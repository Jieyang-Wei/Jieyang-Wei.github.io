<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><title>WebSocket | 魏洁杨</title><link rel="shortcut icon" href="/images/logo.svg"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.4/source/css/font-awesome.min.css"><script id="hexo-configurations">let KEEP=window.KEEP||{};KEEP.hexo_config={hostname:"jieyang-wei.github.io",root:"/",path:"search.json"},KEEP.theme_config={toc:{enable:!0,number:!0,expand_all:!0},style:{primary_color:"#0066CC",avatar:"/images/avatar.jpg",favicon:"/images/logo.svg",img_position:"left",left_side_width:"260px",content_max_width:"900px",hover:{shadow:!0,scale:!0},first_screen:{enable:!0,background_img:"/images/bg.svg",description:"Welcome to Wei jieyang's Blog"}},local_search:{enable:!0,trigger:"auto",unescape:!1,preload:!0},version:"3.0.4"},KEEP.language={search:"Search...",prev:"Prev",next:"Next",prev_posts:"Prev posts",next_posts:"Next posts",page:"Page %d",recent_posts:"Recent Posts",share:"Share",powered_by:"Powered by %s",theme:"Theme",rss_feed:"RSS Feed",category:"Category",categories:"Categories",tag:"Tag",tags:"Tags",tagcloud:"Tag Cloud",comment:"Comment",home:"Home",archive:"Archive",archives:"Archives",about:"About",site_uv:"Visitor Count",site_pv:"Totalview",links:"Links",link:"Link",top:"TOP",read_more:"Read more",wordcount:"Words",min2read:"Mins",changelog:"Changelog",copyright:{author:"Post author",title:"Post title",link:"Post link",create_time:"Create time",license_title:"Copyright Notice",license_content:"All articles in this blog are licensed under %s unless stating additionally."},ago:{second:"%s seconds ago",minute:"%s minutes ago",hour:"%s hours ago",day:"%s days age",week:"%s weeks age",month:"%s months age",year:"%s years age"}}</script><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="WeiJY's blog" type="application/atom+xml"></head><body><div class="page-container"><header class="page-header"><div class="header-progress"></div></header><main class="page-main"><div class="page-main-content"><div class="page-main-content-top"><header class="header-wrapper"><div class="header-content"><a class="logo-title" href="/">魏洁杨</a><ul class="menu-list"><li class="menu-item"><a href="/">HOME</a></li><li class="menu-item"><a href="/categories">CATEGORIES</a></li><li class="menu-item"><a href="/categories/notebook">NOTEBOOK</a></li><li class="menu-item"><a href="/about">ABOUT</a></li><li class="menu-item"><a href="/tags">TAGS</a></li></ul><div class="menu-bar"><div class="menu-bar-middle"></div></div></div><div class="header-drawer"><ul class="drawer-menu-list"><li class="drawer-menu-item flex-center"><a href="/">HOME</a></li><li class="drawer-menu-item flex-center"><a href="/categories">CATEGORIES</a></li><li class="drawer-menu-item flex-center"><a href="/categories/notebook">NOTEBOOK</a></li><li class="drawer-menu-item flex-center"><a href="/about">ABOUT</a></li><li class="drawer-menu-item flex-center"><a href="/tags">TAGS</a></li></ul></div><div class="window-mask"></div></header></div><div class="page-main-content-middle"><main class="main-content normal-code-theme"><div class="fade-in-down-animation"><div class="article-content-container"><div class="article-title"><span class="title-hover-animation">WebSocket</span></div><div class="article-header"><div class="avatar"><img src="/images/avatar.jpg"></div><div class="info"><div class="author"><span>Wei Jieyang</span> <span class="level">Lv3</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fas fa-calendar"></i> 2021-01-25 14:37:08 </span><span class="article-categories article-meta-item"><i class="fas fa-folder"></i><ul><li><a href="/categories/course/">course</a></li><li>&gt; <a href="/categories/course/network/">network</a></li></ul></span><span class="article-tags article-meta-item"><i class="fas fa-tags"></i><ul><li><a href="/tags/socket/">socket</a></li></ul></span><span class="article-wordcount article-meta-item"><i class="fas fa-file-word"></i> <span>3.1k Words</span> </span><span class="article-min2read article-meta-item"><i class="fas fa-clock"></i> <span>13 Mins</span> </span><span class="article-pv article-meta-item"><i class="fas fa-eye"></i> <span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content markdown-body"><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>WebSocket API 是 HTML5 标准的一部分， 但这并不代表 WebSocket 一定要用在 HTML 中，或者只能在基于浏览器的应用程序中使用。</p><p>实际上，许多语言、框架和服务器都提供了 WebSocket 支持：</p><ul><li>基于 <strong>C</strong> 的 libwebsocket.org</li><li>基于 <strong>Node.js</strong> 的 Socket.io</li><li>基于 <strong>Python</strong> 的 ws4py</li><li>基于 <strong>C++</strong> 的 WebSocket++</li><li><strong>Apache</strong> 对 WebSocket 的支持： Apache Module mod_proxy_wstunnel</li><li><strong>Nginx</strong> 对 WebSockets 的支持： NGINX as a WebSockets Proxy 、 NGINX Announces Support for WebSocket Protocol 、WebSocket proxying</li><li><strong>lighttpd</strong> 对 WebSocket 的支持：mod_websocket</li></ul><h2 id="nodejs"><a href="#nodejs" class="headerlink" title="nodejs"></a>nodejs</h2><h2 id="java"><a href="#java" class="headerlink" title="java"></a>java</h2><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><p>c++下没有原生的websocket低矮用，但是可以使用一些开源库实现，如<a class="link" target="_blank" rel="noopener" href="https://download.csdn.net/download/weixin_34196559/10750141">websocketpp<i class="fas fa-external-link-alt"></i></a>等，下面讲解的是socket通信相关的实现</p><h3 id="IOS"><a href="#IOS" class="headerlink" title="IOS"></a>IOS</h3><p><a class="link" target="_blank" rel="noopener" href="https://blog.csdn.net/xuqiang918/article/details/16841343?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-10&spm=1001.2101.3001.4242">IOS网络通信<i class="fas fa-external-link-alt"></i></a></p><p><a class="link" target="_blank" rel="noopener" href="https://github.com/ok-fine/Socket-Cpp.git">代码 - master分支<i class="fas fa-external-link-alt"></i></a></p><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p><code>sockaddr</code>和<code>sockaddr_in</code>在字节长度上都为16个BYTE，可以进行转换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 通用的socket地址 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span>&#123;</span>  </span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> sa_family;    <span class="comment">//2 </span></span><br><span class="line">  <span class="keyword">char</span> sa_data[<span class="number">14</span>];            <span class="comment">//14</span></span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Internet socket */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>&#123;</span></span><br><span class="line">  <span class="keyword">short</span> <span class="keyword">int</span> sin_family;        <span class="comment">//2</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> sin_port; <span class="comment">//2</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>     <span class="comment">//4</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="number">8</span>];   <span class="comment">//8</span></span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 表示32位的IPv4地址 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span> u_char s_b1,s_b2,s_b3,s_b4; &#125; S_un_b;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span> u_short s_w1,s_w2; &#125; S_un_w;</span><br><span class="line">    u_long S_addr; </span><br><span class="line">  &#125; S_un;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> s_addr  S_un.S_addr</span></span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 或者 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>&#123;</span></span><br><span class="line">  <span class="keyword">in_addr_t</span> s_addr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>**inet_addr(“192.168.0.1”)**：将一个点分制的IP地址(如192.168.0.1)转换为上述结构中需要的32位二进制方式的IP地址</li></ul><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line"><span class="keyword">int</span> server_socket = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>domain</strong>（IOS系统使用 <code>AT_</code> ）<ul><li>PF_UNIX Unix IPC通信</li><li>PF_INET IPV4通信（默认）</li><li>PF_INET6 IPV6</li><li>PF_IPX Novell IPX</li><li>PF_NETLINK Kernel用户接口驱动程序</li><li>PF_X25 X.25</li><li>PF_AX25 AX.25</li><li>PF_ATMPVC ATM PVC</li><li>PF_APPLETALK AppleTalk协议</li><li>PF_PACKET 低级包接口</li></ul></li><li><strong>type</strong><ul><li>SOCK_STREAM 使用TCP面向连接的通信包（默认）</li><li>SOCK_DGRAM 使用UDP无连接的通信包</li><li>SOCK_SEQPACKET 使用有固定最大长度的面向连接的通信包</li><li>SOCK_RAW 使用原IP包</li><li>SOCK_RDM 使用不保证次序的可靠数据报</li></ul></li><li><strong>Protocol</strong><ul><li>一般使用与type对应的默认协议，用0表示。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recv</span><span class="params">(SOCKET socket, <span class="keyword">char</span> *buf, <span class="keyword">int</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="keyword">char</span> recv_msg[<span class="number">1024</span>];</span><br><span class="line">bzero(recv_msg, <span class="number">1024</span>);</span><br><span class="line"><span class="keyword">long</span> byte_num = recv(client_socket, recv_msg, <span class="number">1024</span>, <span class="number">0</span>);</span><br><span class="line">recv_msg[byte_num] = <span class="string">&#x27;\0&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>参数：<ul><li><strong>socket</strong>：已建立连接的套接字；</li><li><strong>buf</strong>：存放接收到的数据的缓冲区指针；</li><li><strong>len</strong>：buf的长度</li><li><strong>flags</strong>：调用方式：<ul><li><strong>0</strong>：接收的是正常数据，无特殊行为。</li><li><strong>MSG_PEEK</strong>：系统缓冲区数据复制到提供的接收缓冲区，但是系统缓冲区内容并没有删除。</li><li><strong>MSG_OOB</strong>：表示处理带外数据。</li></ul></li></ul></li><li>返回值：接收成功时返回接收到的数据长度，连接结束时返回0，连接失败时返回SOCKET_ERROR。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">send</span><span class="params">(SOCKET socket, <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> len, <span class="keyword">int</span> flags)</span></span></span><br><span class="line">char send_msg[1024];</span><br><span class="line">bzero(send_msg, <span class="number">1024</span>);</span><br><span class="line">send(client_socket, send_msg, <span class="number">1024</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><ul><li>参数<ul><li><strong>socket</strong>：已建立连接的套接字</li><li><strong>buf</strong>：存放将要发送的数据的缓冲区指针；</li><li><strong>len</strong>：发送缓冲区中的字符数</li><li><strong>flags</strong>：控制数据传输方式：<ul><li><strong>0</strong>：接收的是正常数据，无特殊行为。</li><li><strong>MSG_DONTROUTE</strong>：表示目标主机就在本地网络中，无需路由选择。</li><li><strong>MSG_OOB</strong>：表示处理带外数据。</li></ul></li></ul></li><li>返回值：发送成功时返回发送的数据长度，连接结束时返回0，连接失败时返回SOCKET_ERROR。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">bzero</span><span class="params">(<span class="keyword">void</span> *s, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="keyword">char</span> msg[<span class="number">1024</span>];</span><br><span class="line">bzero(msg, <span class="number">1024</span>);  </span><br><span class="line"><span class="comment">/* 相当于 */</span></span><br><span class="line"><span class="built_in">memset</span>(msg, <span class="number">0</span>, <span class="number">1024</span>);</span><br></pre></td></tr></table></figure><ul><li>头文件：#include &lt;string.h&gt;</li><li>功能：置字节字符串s的前n个字节为零且包括‘\0’</li><li>描述：<ul><li>string.h曾经是posix标准的一部分，但是在POSIX.1-2001标准里面，这些函数被标记为了遗留函数而不推荐使用。在POSIX.1-2008标准里已经没有这些函数了。推荐使用<code>memset</code>替代<code>bzero</code>。</li><li>bzero函数TC和VC中都没有，gcc中提供了</li></ul></li><li>无返回值</li></ul><blockquote><p>使用无阻塞的I/O方法</p><p>什么是阻塞?<br>比如使用recv(),如果函数接受不到数据，就会阻塞程序的继续执行。</p><p>如何防止阻塞?<br>使用fcntl()函数，把套接字设置为无阻塞模式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">int</span> newsocket; </span><br><span class="line">&gt;newsocket = socket(PF_INET, SOCK_STREAM, <span class="number">0</span> ); </span><br><span class="line">&gt;fcntl( newsocket, F_SETEL, O_NONBLOCK ); </span><br></pre></td></tr></table></figure><p>以后使用recv()就不会阻塞了。</p><p>另一种方式是使用多路套接字<code>select()</code></p></blockquote><h5 id="select"><a href="#select" class="headerlink" title="select"></a>select</h5><p>select这个系统调用，是一种多路复用IO方案，可以同时对多个文件描述符进行监控，从而知道哪些<a class="link" target="_blank" rel="noopener" href="https://blog.csdn.net/test1280/article/details/80293294">文件描述符(File Descriptor，FD)<i class="fas fa-external-link-alt"></i></a>可读，可写或者出错，不过select方法是阻塞的，可以设定超时时间。</p><p>select使用的步骤如下:</p><ol><li>创建一个<code>fd_set</code>变量（fd_set实为包含了一个整数数组的结构体），用来存放所有的待检查的文件描述符</li><li>清空<code>fd_set</code>变量，并将需要检查的所有文件描述符加入<code>fd_set</code></li><li>调用select。若返回-1，则说明出错;返回0,则说明超时，返回正数，则为发生状态变化的文件描述符的个数</li><li>若select返回大于0,则依次查看哪些文件描述符变的可读，并对它们进行处理</li><li>返回步骤2，开始新一轮的检测</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfd, fd_set *rdset, fd_set *wrset, fd_set *exset, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>参数：<ul><li>maxfd：需要监视的最大的文件描述符值+1；</li><li>rdset：需要检测的可读文件描述符的集合</li><li>wrset：可写文件描述符的集合</li><li>exset：异常文件描述符的集合</li><li>timeval：用于描述一段时间长度，如果在这个时间内，需要监视的描述符没有事件发生则函数返回，返回值为0。</li></ul></li></ul><p><code>fd_set</code>类型通过下面四个宏来操作：</p><ol><li><code>FD_ZERO(fd_set *fdset);</code>将指定的文件描述符集清空，在对文件描述符集合进行设置前，必须对其进行初始化，如果不清空，由于在系统分配内存空间后，通常并不作清空处理，所以结果是不可知的。</li><li><code>FD_SET(fd_set *fdset);</code>用于在文件描述符集合中增加一个新的文件描述符。</li><li><code>FD_CLR(fd_set *fdset);</code>用于在文件描述符集合中删除一个文件描述符。</li><li><code>FD_ISSET(int fd, fd_set *fdset);</code>用于测试指定的文件描述符是否在该集合中。</li></ol><h5 id="kqueue"><a href="#kqueue" class="headerlink" title="kqueue"></a>kqueue</h5><p>Mac是基于BSD的内核，所使用的是kqueue（kernel event notification mechanism，详细内容可以Mac中 <code>man 2 kqueue</code>）</p><ul><li>kqueue比select先进的地方就在于使用<strong>事件触发</strong>的机制，且其调用无需每次对所有的文件描述符进行遍历，返回的时候只返回需要处理的事件，而不像select中需要自己去一个个通过FD_ISSET检查。</li><li>kqueue默认的触发方式是level 水平触发，可以通过设置event的flag为<code>EV_CLEAR</code> 使得这个事件变为边沿触发,可能epoll的触发方式无法细化到单个event，需要查证。</li><li></li></ul><p>kqueue中涉及两个系统调用，kqueue()和kevent()</p><ul><li><code>kqueue()</code>创建kernel级别的事件队列，并返回队列的文件描述符</li><li><code>kevent()</code>往事件队列中加入订阅事件，或者返回相关的事件数组</li></ul><p>kqueue使用的流程一般如下：</p><ul><li>创建kqueue</li><li>创建<code>struct kevent</code>变量（注意这里的kevent是结构体类型名），可以通过<code>EV_SET</code>这个宏提供的快捷方式进行创建</li><li>通过kevent系统调用将创建好的kevent结构体变量加入到kqueue队列中，完成对指定文件描述符的事件的订阅</li><li>通过kevent系统调用获取满足条件的事件队列，并对每一个事件进行处理</li></ul><h4 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h4><img src="/2021/01/25/WebSocket/1.png" alt="截屏2021-01-31 下午2.57.07" style="zoom:45%"><p><strong>1. sever</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 绑定server socket的ip、端口等信息 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">server_addr.sin_len = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">server_addr.sin_family = AF_INET;<span class="comment">//Address families AF_INET互联网地址簇</span></span><br><span class="line">server_addr.sin_port = htons(<span class="number">11332</span>);</span><br><span class="line">server_addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">bzero(&amp;(server_addr.sin_zero),<span class="number">8</span>);</span><br></pre></td></tr></table></figure><ul><li><p>一般情况下都用<code>server_addr.sin_addr.s_addr = htonl(INADDR_ANY)</code></p><blockquote><p>比如你的机器有三个ip<br>192.168.1.1<br>202.202.202.202<br>61.1.2.3</p><p>如果你serv.sin_addr.s_addr=inet_addr(“192.168.1.1”);</p><p>然后监听100端口</p><p>这时其他机器只有connect 192.168.1.1:100端口才能成功。<br>connect 202.202.202.202:100和connect 61.1.2.3:100都会失败。</p><p>如果serv.sin_addr.s_addr=htonl(INADDR_ANY); 的话，无论连接哪个ip都可以连上的，这就是为什么这样选择的理由</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* server socket工作流程 */</span></span><br><span class="line"><span class="comment">//创建socket</span></span><br><span class="line"><span class="keyword">int</span> server_socket = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);<span class="comment">//SOCK_STREAM 有连接</span></span><br><span class="line"><span class="keyword">if</span> (server_socket == <span class="number">-1</span>) &#123;</span><br><span class="line">  perror(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//绑定socket</span></span><br><span class="line"><span class="comment">//将创建的socket绑定到本地的IP地址和端口，此socket是半相关的，只是负责侦听客户端的连接请求，并不能用于和客户端通信</span></span><br><span class="line"><span class="keyword">int</span> bind_result = bind(server_socket, (struct sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line"><span class="keyword">if</span> (bind_result == <span class="number">-1</span>) &#123;</span><br><span class="line">  perror(<span class="string">&quot;bind error&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//listen侦听</span></span><br><span class="line"><span class="comment">//第一个参数是套接字</span></span><br><span class="line"><span class="comment">//第二个参数为等待接受的连接的队列的大小，在connect请求过来的时候,完成三次握手后先将连接放到这个队列中，直到被accept处理。如果这个队列满了，且有新的连接的时候，对方可能会收到出错信息。</span></span><br><span class="line"><span class="keyword">if</span> (listen(server_socket, <span class="number">5</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">  perror(<span class="string">&quot;listen error&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//accept接收来自客户端的链接请求(使用下面的select不需要这一部分)</span></span><br><span class="line"><span class="comment">//返回的client_socket为一个全相关的socket，其中包含client的地址和端口信息，通过client_socket可以和客户端进行通信。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>;</span></span><br><span class="line"><span class="keyword">socklen_t</span> address_len;</span><br><span class="line"><span class="keyword">int</span> client_socket = accept(server_socket, (struct sockaddr *)&amp;client_address, &amp;address_len);</span><br><span class="line"><span class="keyword">if</span> (client_socket == <span class="number">-1</span>) &#123;</span><br><span class="line">  perror(<span class="string">&quot;accept error&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 信息交流 */</span></span><br><span class="line">fd_set server_fd_set;</span><br><span class="line"><span class="keyword">int</span> max_fd = <span class="number">-1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">tv.tv_sec = <span class="number">20</span>;  <span class="comment">// seconds</span></span><br><span class="line">tv.tv_usec = <span class="number">0</span>;  <span class="comment">// microseconds</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">  FD_ZERO(&amp;server_fd_set);</span><br><span class="line">  <span class="comment">//标准输入</span></span><br><span class="line">  FD_SET(STDIN_FILENO, &amp;server_fd_set);</span><br><span class="line">  <span class="keyword">if</span> (max_fd &lt; STDIN_FILENO) &#123;</span><br><span class="line">    max_fd = STDIN_FILENO;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//服务器端socket</span></span><br><span class="line">  FD_SET(server_sock_fd, &amp;server_fd_set);</span><br><span class="line">  <span class="keyword">if</span> (max_fd &lt; server_sock_fd) &#123;</span><br><span class="line">    max_fd = server_sock_fd;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//客户端连接</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CONCURRENT_MAX; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (client_fds[i]!=<span class="number">0</span>) &#123;</span><br><span class="line">      FD_SET(client_fds[i], &amp;server_fd_set);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (max_fd &lt; client_fds[i]) &#123;</span><br><span class="line">        max_fd = client_fds[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> ret = select(max_fd+<span class="number">1</span>, &amp;server_fd_set, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;tv);</span><br><span class="line">  <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;select 出错\n&quot;</span>);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;select 超时\n&quot;</span>);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//ret为未状态发生变化的文件描述符的个数</span></span><br><span class="line">    <span class="keyword">if</span> (FD_ISSET(STDIN_FILENO, &amp;server_fd_set)) &#123;</span><br><span class="line">      <span class="comment">//标准输入</span></span><br><span class="line">      bzero(input_msg, BUFFER_SIZE);</span><br><span class="line">      fgets(input_msg, BUFFER_SIZE, <span class="built_in">stdin</span>);</span><br><span class="line">      <span class="comment">//输入 &quot;.quit&quot; 则退出服务器</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strcmp</span>(input_msg, QUIT_CMD) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;CONCURRENT_MAX; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (client_fds[i]!=<span class="number">0</span>) &#123;</span><br><span class="line">          send(client_fds[i], input_msg, BUFFER_SIZE, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (FD_ISSET(server_sock_fd, &amp;server_fd_set)) &#123;</span><br><span class="line">      <span class="comment">//有新的连接请求</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>;</span></span><br><span class="line">      <span class="keyword">socklen_t</span> address_len;</span><br><span class="line">      <span class="keyword">int</span> client_socket_fd = accept(server_sock_fd, (struct sockaddr *)&amp;client_address, &amp;address_len);</span><br><span class="line">      <span class="keyword">if</span> (client_socket_fd &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CONCURRENT_MAX; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (client_fds[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            index = i;</span><br><span class="line">            client_fds[i] = client_socket_fd;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;新客户端(%d)加入成功 %s:%d \n&quot;</span>,index,inet_ntoa(client_address.sin_addr),ntohs(client_address.sin_port));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          bzero(input_msg, BUFFER_SIZE);</span><br><span class="line">          <span class="built_in">strcpy</span>(input_msg, <span class="string">&quot;服务器加入的客户端数达到最大值,无法加入!\n&quot;</span>);</span><br><span class="line">          send(client_socket_fd, input_msg, BUFFER_SIZE, <span class="number">0</span>);</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;客户端连接数达到最大值，新客户端加入失败 %s:%d \n&quot;</span>,inet_ntoa(client_address.sin_addr),ntohs(client_address.sin_port));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;CONCURRENT_MAX; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (client_fds[i]!=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(client_fds[i], &amp;server_fd_set)) &#123;</span><br><span class="line">          <span class="comment">//处理某个客户端过来的消息</span></span><br><span class="line">          bzero(recv_msg, BUFFER_SIZE);</span><br><span class="line">          <span class="keyword">long</span> byte_num = recv(client_fds[i],recv_msg,BUFFER_SIZE,<span class="number">0</span>);</span><br><span class="line">          <span class="keyword">if</span> (byte_num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (byte_num &gt; BUFFER_SIZE) &#123;</span><br><span class="line">              byte_num = BUFFER_SIZE;</span><br><span class="line">            &#125;</span><br><span class="line">            recv_msg[byte_num] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端(%d):%s\n&quot;</span>,i,recv_msg);</span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span>(byte_num &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;从客户端(%d)接受消息出错.\n&quot;</span>,i);</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            FD_CLR(client_fds[i], &amp;server_fd_set);</span><br><span class="line">            client_fds[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端(%d)退出了\n&quot;</span>,i);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. client</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建需要通信的server socket的IP、端口等信息 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">server_addr.sin_len = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">server_addr.sin_family = AF_INET;</span><br><span class="line">server_addr.sin_port = htons(<span class="number">11332</span>);</span><br><span class="line">server_addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">bzero(&amp;(server_addr.sin_zero),<span class="number">8</span>);</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建socket通信连接 */</span></span><br><span class="line"><span class="comment">//创建socket</span></span><br><span class="line"><span class="keyword">int</span> client_socket = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (client_socket == <span class="number">-1</span>) &#123;</span><br><span class="line">  perror(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接client和server的通信道路</span></span><br><span class="line"><span class="keyword">int</span> connect_result = connect(client_socket, (struct sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(struct sockaddr_in));</span><br><span class="line"></span><br><span class="line"><span class="comment">//connect 成功之后，其实系统将你创建的socket绑定到一个系统分配的端口上，且其为全相关，包含服务器端的信息，可以用来和服务器端进行通信。</span></span><br><span class="line"><span class="keyword">char</span> recv_msg[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">char</span> reply_msg[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">if</span> (connect_result == <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    bzero(recv_msg, <span class="number">1024</span>);</span><br><span class="line">    bzero(reply_msg, <span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">long</span> byte_num = recv(client_socket, recv_msg, <span class="number">1024</span>, <span class="number">0</span>);</span><br><span class="line">    recv_msg[byte_num] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;server said:%s\n&quot;</span>,recv_msg);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client reply:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,reply_msg);</span><br><span class="line">    <span class="keyword">if</span> (send(client_socket, reply_msg, <span class="number">1024</span>, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">      perror(<span class="string">&quot;send error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="WIN"><a href="#WIN" class="headerlink" title="WIN"></a>WIN</h3><p>模仿Unix Socket技术实现</p><h4 id="操作流程-1"><a href="#操作流程-1" class="headerlink" title="操作流程"></a>操作流程</h4><img src="/2021/01/25/WebSocket/2.png" alt="截屏2021-01-31 下午2.57.07" style="zoom:45%"><h2 id="php"><a href="#php" class="headerlink" title="php"></a>php</h2></div><div class="post-copyright-info"><div class="article-copyright-info-container"><ul><li>Post title：WebSocket</li><li>Post author：Wei Jieyang</li><li>Create time：2021-01-25 14:37:08</li><li>Post link：https://jieyang-wei.github.io/2021/01/25/WebSocket/</li><li>Copyright Notice：All articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> unless stating additionally.</li></ul></div></div><div class="article-nav"><div class="article-prev"><a class="prev" rel="prev" href="/2021/02/23/%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8%E7%A0%B4%E8%A7%A3/"><span class="left arrow-icon flex-center"><i class="fas fa-chevron-left"></i> </span><span class="title flex-center"><span class="post-nav-title-item">植物大战僵尸破解</span> <span class="post-nav-item">Prev posts</span></span></a></div><div class="article-next"><a class="next" rel="next" href="/2021/01/23/C++/"><span class="title flex-center"><span class="post-nav-title-item">C++</span> <span class="post-nav-item">Next posts</span> </span><span class="right arrow-icon flex-center"><i class="fas fa-chevron-right"></i></span></a></div></div></div></div></main></div><div class="page-main-content-bottom"><footer class="footer"><div class="info-container"><div class="copyright-info info-item">&copy; <span>2020</span> - 2021 <i class="fas fa-heart icon-animate"></i> <a href="/">Wei Jieyang</a></div><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="website-count info-item"><span id="busuanzi_container_site_uv">Visitor Count <span id="busuanzi_value_site_uv"></span>&ensp; </span><span id="busuanzi_container_site_pv">Totalview <span id="busuanzi_value_site_pv"></span></span></div><div class="theme-info info-item">Powered by <a target="_blank" href="https://hexo.io">Hexo</a> | Theme <a class="theme-version" target="_blank"></a></div></div></footer></div></div></main><div class="sidebar-tools"><div class="tools-container"><ul class="tools-list"><li class="search popup-trigger"><i class="fas fa-search"></i></li><li class="tools-item page-aside-toggle"><i class="fas fa-outdent"></i></li></ul></div></div><div class="right-bottom-side-tools"><div class="side-tools-container"><ul class="side-tools-list"><li class="tools-item tool-font-adjust-plus flex-center"><i class="fas fa-search-plus"></i></li><li class="tools-item tool-font-adjust-minus flex-center"><i class="fas fa-search-minus"></i></li><li class="tools-item tool-expand-width flex-center"><i class="fas fa-arrows-alt-h"></i></li><li class="tools-item tool-dark-light-toggle flex-center"><i class="fas fa-moon"></i></li><li class="tools-item tool-scroll-to-top flex-center"><i class="fas fa-arrow-up"></i></li><li class="tools-item tool-scroll-to-bottom flex-center"><i class="fas fa-arrow-down"></i></li></ul><ul class="tools-ul-1"><li class="tools-item tool-toggle-show flex-center"><i class="fas fa-cog fa-spin"></i></li></ul></div></div><aside class="page-aside"><div class="post-toc-wrap"><div class="post-toc"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8"><span class="nav-number">2.</span> <span class="nav-text">使用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#nodejs"><span class="nav-number">2.1.</span> <span class="nav-text">nodejs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java"><span class="nav-number">2.2.</span> <span class="nav-text">java</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C"><span class="nav-number">2.3.</span> <span class="nav-text">C++</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#IOS"><span class="nav-number">2.3.1.</span> <span class="nav-text">IOS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">2.3.1.1.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">2.3.1.2.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#select"><span class="nav-number">2.3.1.2.1.</span> <span class="nav-text">select</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#kqueue"><span class="nav-number">2.3.1.2.2.</span> <span class="nav-text">kqueue</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">2.3.1.3.</span> <span class="nav-text">操作流程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WIN"><span class="nav-number">2.3.2.</span> <span class="nav-text">WIN</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B-1"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">操作流程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#php"><span class="nav-number">2.4.</span> <span class="nav-text">php</span></a></li></ol></li></ol></div></div></aside><div class="image-viewer-container"><div class="img-box"><img src=""></div></div></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fas fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fas fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.4/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.4/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.4/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.4/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.4/source/js/dark-light-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.4/source/js/local-search.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.4/source/js/left-side-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.4/source/js/code-copy.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.4/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.4/source/js/toc.js"></script></body></html>