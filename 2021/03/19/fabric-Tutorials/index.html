<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><title>fabric-Tutorials | 魏洁杨</title><link rel="shortcut icon" href="/images/logo.svg"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.4/source/css/font-awesome.min.css"><script id="hexo-configurations">let KEEP=window.KEEP||{};KEEP.hexo_config={hostname:"jieyang-wei.github.io",root:"/",path:"search.json"},KEEP.theme_config={toc:{enable:!0,number:!0,expand_all:!0},style:{primary_color:"#0066CC",avatar:"/images/avatar.jpg",favicon:"/images/logo.svg",img_position:"left",left_side_width:"260px",content_max_width:"900px",hover:{shadow:!0,scale:!0},first_screen:{enable:!0,background_img:"/images/bg.svg",description:"Welcome to Wei jieyang's Blog"}},local_search:{enable:!0,trigger:"auto",unescape:!1,preload:!0},version:"3.0.4"},KEEP.language={search:"Search...",prev:"Prev",next:"Next",prev_posts:"Prev posts",next_posts:"Next posts",page:"Page %d",recent_posts:"Recent Posts",share:"Share",powered_by:"Powered by %s",theme:"Theme",rss_feed:"RSS Feed",category:"Category",categories:"Categories",tag:"Tag",tags:"Tags",tagcloud:"Tag Cloud",comment:"Comment",home:"Home",archive:"Archive",archives:"Archives",about:"About",site_uv:"Visitor Count",site_pv:"Totalview",links:"Links",link:"Link",top:"TOP",read_more:"Read more",wordcount:"Words",min2read:"Mins",changelog:"Changelog",copyright:{author:"Post author",title:"Post title",link:"Post link",create_time:"Create time",license_title:"Copyright Notice",license_content:"All articles in this blog are licensed under %s unless stating additionally."},ago:{second:"%s seconds ago",minute:"%s minutes ago",hour:"%s hours ago",day:"%s days age",week:"%s weeks age",month:"%s months age",year:"%s years age"}}</script><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="WeiJY's blog" type="application/atom+xml"></head><body><div class="page-container"><header class="page-header"><div class="header-progress"></div></header><main class="page-main"><div class="page-main-content"><div class="page-main-content-top"><header class="header-wrapper"><div class="header-content"><a class="logo-title" href="/">魏洁杨</a><ul class="menu-list"><li class="menu-item"><a href="/">HOME</a></li><li class="menu-item"><a href="/categories">CATEGORIES</a></li><li class="menu-item"><a href="/categories/notebook">NOTEBOOK</a></li><li class="menu-item"><a href="/about">ABOUT</a></li><li class="menu-item"><a href="/tags">TAGS</a></li></ul><div class="menu-bar"><div class="menu-bar-middle"></div></div></div><div class="header-drawer"><ul class="drawer-menu-list"><li class="drawer-menu-item flex-center"><a href="/">HOME</a></li><li class="drawer-menu-item flex-center"><a href="/categories">CATEGORIES</a></li><li class="drawer-menu-item flex-center"><a href="/categories/notebook">NOTEBOOK</a></li><li class="drawer-menu-item flex-center"><a href="/about">ABOUT</a></li><li class="drawer-menu-item flex-center"><a href="/tags">TAGS</a></li></ul></div><div class="window-mask"></div></header></div><div class="page-main-content-middle"><main class="main-content normal-code-theme"><div class="fade-in-down-animation"><div class="article-content-container"><div class="article-title"><span class="title-hover-animation">fabric-Tutorials</span></div><div class="article-header"><div class="avatar"><img src="/images/avatar.jpg"></div><div class="info"><div class="author"><span>Wei Jieyang</span> <span class="level">Lv3</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fas fa-calendar"></i> 2021-03-19 11:33:34 </span><span class="article-categories article-meta-item"><i class="fas fa-folder"></i><ul><li><a href="/categories/notebook/">notebook</a></li><li>&gt; <a href="/categories/notebook/blockchain/">blockchain</a></li><li>&gt; <a href="/categories/notebook/blockchain/fabric/">fabric</a></li></ul></span><span class="article-tags article-meta-item"><i class="fas fa-tags"></i><ul><li><a href="/tags/fabric/">fabric</a></li><li>| <a href="/tags/blockchain/">blockchain</a></li></ul></span><span class="article-wordcount article-meta-item"><i class="fas fa-file-word"></i> <span>11.7k Words</span> </span><span class="article-min2read article-meta-item"><i class="fas fa-clock"></i> <span>43 Mins</span> </span><span class="article-pv article-meta-item"><i class="fas fa-eye"></i> <span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content markdown-body"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本部分详细介绍了Hyperledger Fabric中的客户端应用程序和智能合约开发的关键功能。对功能的深入了解将帮助您设计和实施高效的解决方案。</p><h1 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h1><p>智能合约是高级编程抽象的一个示例，可以在链码容器中定义智能合约。将链码安装在对等方上并部署到通道后，其中的所有智能合约都可用于您的应用程序。</p><blockquote><p>一个智能合约只能属于一个chaincode，但一个chaincode中可以包含多个智能合约</p><ul><li><strong>合同名称在链码文件中必须唯一</strong>。某些代码编辑器会在部署之前检测到相同类名的多个定义。如果显式或隐式指定了多个具有相同协定名称的类，则链代码将返回错误。</li><li><strong>不指定链码中的合约将默认使用第一个合约</strong></li><li><strong>单个链码中存放多个相关合约是有意义的</strong>。<ul><li>例如，在不同的货币计价的可能有合同的商业票据<code>EuroPaperContract</code>， <code>DollarPaperContract</code>， <code>YenPaperContract</code>这可能需要保持在它们所部署的通道相互同步。</li></ul></li></ul></blockquote><h2 id="链码"><a href="#链码" class="headerlink" title="链码"></a>链码</h2><p>链码是用于将代码部署到Hyperledger Fabric区块链网络的通用容器</p><p>当写好链码文件后（此例中为 commercialpaper.js），需要经过以下步骤：</p><ul><li>打包：peer chaincode package</li><li>下载到通道：peer chaincode install</li><li>组织管理员批准链码：peer chaincode approveformyorg</li><li>当满足制定策略之后，通道上任一节点均可提交此链码：peer chaincode commit</li></ul><h3 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h3><p>链码的namespace允许它保持其世界状态与其他链码分离。</p><ul><li><p>具体来说，具有相同链码的智能合约共享对同一世界状态的直接访问，而具有不同链码的智能合约不能直接访问彼此的世界状态。</p><ul><li><p>即Chaincode命名空间提供了不同世界状态之间的<strong>隔离</strong></p><blockquote><p>注意：不能选择链码名称空间。它由Hyperledger Fabric分配，并直接映射到链码的名称</p></blockquote></li></ul></li><li><p>如果智能合约需要访问另一个链码世界状态，则可以通过执行链码到链码的调用来做到这一点。</p></li><li><p>最后，区块链可以包含与不同世界状态相关的交易。</p></li></ul><blockquote><p>注意：</p><p>将同一个链码部署到不同peer的channel上时，将创建一个完全独立的区块链，并创建两个新的世界状态数据库。但是，peer和chaincode container不会增加，每个都将连接到多个通道。</p></blockquote><h3 id="同链码访问"><a href="#同链码访问" class="headerlink" title="同链码访问"></a>同链码访问</h3><p><strong>示例图：</strong></p><p>![截屏2021-03-19 下午9.02.21](fabric-Tutorials/截屏2021-03-19 下午9.02.21.png)</p><ul><li>应用程序与对等方进行通信，并且对等方将请求路由到适当的链码容器，然后容器可以访问DBMS。该路由由图中所示的对等<strong>核心</strong>组件完成。</li></ul><p><strong>示例代码：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> euroPaper = network.getContract(papers, euroPaper);</span><br><span class="line">paper1 = euroPaper.submit(issue, PAP11);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> yenPaper = network.getContract(papers, yenPaper);</span><br><span class="line">paper2 = yenPaper.submit(redeem, PAP21);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> euroBond = network.getContract(bonds, euroBond);</span><br><span class="line">bond1 = euroBond.submit(buy, BON31);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> yenBond = network.getContract(bonds, yenBond);</span><br><span class="line">bond2 = yenBond.submit(sell, BON41);</span><br></pre></td></tr></table></figure><ol><li><strong>应用程序</strong><ul><li>使用 <code>getContract()</code> API访问 <code>papers</code>链码中的 <code>euroPaper</code> 和 <code>yenPaper</code> 合约。<ul><li>参见交互点<strong>1a</strong>和<strong>2a</strong>。</li></ul></li><li>使用 <code>getContract()</code>。API访问 <code>bonds</code> 链码中的 <code>euroBond</code> 和 <code>yenBond</code> 合约。<ul><li>参见交互点<strong>3a</strong>和<strong>4a</strong>。</li></ul></li><li>使用 <code>euroPaper</code> 合约将 <code>issue</code> 交易提交到网络以获取商业票据 <code>PAP11</code>。参见相互作用点<strong>1a</strong>。结果在 <code>world state A</code> 中产生了商业票据 <code>PAP11</code>；相互作用点<strong>1b</strong>。该操作在交互点<strong>1c</strong>被捕获为区块链中的交易。</li><li>使用 <code>yenPaper</code> 合约将 <code>redeem</code> 交易提交到网络以获取商业票据 <code>PAP21</code>。参见交互点<strong>2a</strong>。这导致在<code>world state A</code> 中商业票据 <code>PAP21</code> 的状态为赎回中；交互点<strong>2b</strong>。该操作在交互点<strong>2c</strong>被捕获为区块链中的交易。</li><li>使用 <code>euroBond</code> 合约操作 <code>BON41</code> 进行 <code>buy</code> 交易并提交到网络。参见相互作用点<strong>3a</strong>。这导致在 <code>world state B</code> 中 <code>BON31</code> 的状态更新，相互作用点<strong>3b</strong>。该操作在交互点<strong>3c</strong>被捕获为区块链中的交易。</li><li>使用 <code>yenBond</code> 合约操作 <code>BON41</code> 进行 <code>sell</code> 交易并提交到网络。参见相互作用点<strong>4a</strong>。这导致在 <code>world state B</code> 中 <code>BON41</code> 的状态更新，相互作用点 <strong>4b</strong>。该操作在交互点<strong>4c</strong>被捕获为区块链中的交易。</li></ul></li></ol><ol start="2"><li><strong>了解智能合约如何与世界状态交互：</strong></li></ol><ul><li><code>euroPaper</code>和<code>yenPaper</code>合同可以直接访问 <code>world state A</code>，但不能直接访问 <code>world state B</code>。<code>World state A</code> 物理地存储在与链码 <code>papers</code> 相对应的数据库管理系统（DBMS）中的数据库中。</li><li><code>euroBond</code>和<code>yenBond</code>合同可以直接访问 <code>world state B</code>，但不能直接访问 <code>world state A</code>。<code>World state B</code> 物理地存储在与链码 <code>Bonds</code> 相对应的数据库管理系统（DBMS）中的数据库中。</li></ul><ol start="3"><li><strong>了解区块链如何捕获所有世界各州的交易：</strong></li></ol><ul><li>互动<strong>1C</strong>和<strong>2C</strong>对应的交易分别创建和更新商业票据<code>PAP11</code>和<code>PAP21</code>分别。这些都包含在 <code>world state A</code> 中</li><li>互动<strong>3c</strong>和<strong>4c</strong>对应于更新债券 <code>BON31</code> 和 <code>BON41</code> 的交易。这些都包含 <code>world state B</code> 中。</li><li>如果 <code>world state A</code> 或 <code>world state B</code> 由于某种原因被销毁，则可以通过重新执行区块链中的所有交易来重新创建它们。</li></ul><h3 id="跨链码访问"><a href="#跨链码访问" class="headerlink" title="跨链码访问"></a>跨链码访问</h3><p><strong>示例图</strong></p><p><img src="/2021/03/19/fabric-Tutorials/develop.diagram.51.png" alt="develop.diagram.51"></p><ol><li>链码和智能合约如何通过他们的链码间接访问其他世界状态<ul><li>该应用程序在 <code>euroPaper</code> 智能合约中提交 <code>issue</code> 来发行 <code>PAP11</code>。参见互动<strong>1a</strong>。</li><li>智能合约 <code>euroPaper</code> 中的 <code>issue</code> 交易需要调用 <code>euroBond</code> 智能合约中的 <code>query</code> 交易。参见相互作用点<strong>1b</strong>。</li><li>在智能合约 <code>euroBond</code> 中 <code>query</code> 交易能检索 <code>world state B</code> 的信息。参见相互作用点<strong>1c</strong>。</li><li>当控制权返回 <code>issue</code> 交易时，它可以使用响应中的信息对 paper 定价并更新 。<code>world state A</code> 的信息。参见相互作用点<strong>1d</strong>。</li><li>发行以Yen计价的商业票据的控制流程是相同的。参见交互点<strong>2a</strong>，<strong>2b</strong>，<strong>2c</strong>和<strong>2d</strong>。</li></ul></li></ol><blockquote><p>使用<code>invokeChaincode()</code> <a class="link" target="_blank" rel="noopener" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#invokeChaincode__anchor">API<i class="fas fa-external-link-alt"></i></a>在链代码之间传递control。</p><ul><li>该API将control从一个链码传递到另一个链码。</li><li>如果只 <strong>query</strong> 被调用的链码世界状态，调用可以在与调用者的链码不同的通道中进行。</li><li>如果需要 <strong>update</strong> 被调用的链码世界状态，调用必须与调用者链码在同一通道中。</li></ul></blockquote><p>尽管在示例中我们仅讨论了查询交易，但是可以调用智能合约来更新被调用的链码的世界状态</p><h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><p>在commercial paper中，链码papercontract中只包含了一个名为 <code>org.papernet.commercialpaper</code> 的合约</p><ul><li><p>合约构造</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommercialPaperContract</span> <span class="keyword">extends</span> <span class="title">Contract</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// Unique name when multiple contracts per chaincode file</span></span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&#x27;org.papernet.commercialpaper&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果未指定显式合同名称，则将分配默认名称 - 类的名称。<ul><li>在我们的示例中，<strong>默认合同名称</strong>为 <code>CommercialPaperContract</code>。</li></ul></li><li>建议使用显式的<strong>DNS样式</strong>命名约定，以帮助组织清晰且有意义的名称<ul><li><code>org.papernet.commercialpaper</code> 表示PaperNet网络已经定义了标准的商业用纸智能合约</li></ul></li></ul></li></ul><ul><li>合同名称在链码文件中必须唯一。某些代码编辑器会在部署之前检测到相同类名的多个定义。如果显式或隐式指定了多个具有相同协定名称的类，则链代码将返回错误。</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>将链码安装到对等方并部署到通道后，应用程序即可访问其中的智能合约：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> network = <span class="keyword">await</span> gateway.getNetwork(<span class="string">`papernet`</span>);</span><br><span class="line"><span class="keyword">const</span> contract = <span class="keyword">await</span> network.getContract(<span class="string">&#x27;papercontract&#x27;</span>, <span class="string">&#x27;org.papernet.commercialpaper&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> issueResponse = <span class="keyword">await</span> contract.submitTransaction(<span class="string">&#x27;issue&#x27;</span>, <span class="string">&#x27;MagnetoCorp&#x27;</span>, <span class="string">&#x27;00001&#x27;</span>, <span class="string">&#x27;2020-05-31&#x27;</span>, <span class="string">&#x27;2020-11-30&#x27;</span>, <span class="string">&#x27;5000000&#x27;</span>);</span><br></pre></td></tr></table></figure><ul><li>CommercialPaperContract 使用名称 org.papernet.commercialpaper 调用父类Contract来构造实例</li><li>所以network可以通过此名称定为到 CommercialPaperContract 类</li><li>contract 对象再调用CommercialPaperContract 类中定义的方法进行交易</li></ul><h1 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h1><h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><ul><li><p>允许智能合约在交易调用之间定义和维护用户变量</p></li><li><p>可以包含任意数量的用户变量，例如 <code>paperList</code>。</p></li><li><p>注意到一个智能合约的初始化流程：(路径：contract/papercontract.js)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommercialPaperContext</span> <span class="keyword">extends</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="comment">// All papers are held in a list of papers</span></span><br><span class="line">        <span class="built_in">this</span>.paperList = <span class="keyword">new</span> PaperList(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommercialPaperContract</span> <span class="keyword">extends</span> <span class="title">Contract</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// Unique namespace when multiple contracts per chaincode file</span></span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&#x27;org.papernet.commercialpaper&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> 		<span class="function"><span class="title">createContext</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommercialPaperContext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">issue</span>(<span class="params">ctx, issuer, paperNumber, ...</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">await</span> ctx.paperList.addPaper(...);</span><br><span class="line">        <span class="keyword">await</span> ctx.stub.putState(...);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">buy</span>(<span class="params">ctx, issuer, paperNumber, ...</span>)</span>&#123; &#125;</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">redeem</span>(<span class="params">ctx, issuer, paperNumber, ...</span>)</span>&#123; &#125;</span><br><span class="line">    ... ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>构建智能合约时，开发人员可以选择内置的 <code>Context</code> 类 <code>createContext</code> 方法以创建自定义上下文</li><li>本例中，<code>CommercialPaperContext</code>专门用于 <code>CommercialPaperContract</code>。观察指定的 <code>context</code> 如何通过 <code>this</code> 关键字将 <code>PaperList</code> 添加到自己的成员中</li></ul></li></ul><p>transaction context还包含两个内置元素，这些元素提供对范围广泛的Fabric功能的访问，从提交交易的客户端应用程序到分类帐访问。</p><ul><li>**<code>ctx.stub</code>**：用于访问API，这些API从分类账提供各种交易处理操作<ul><li><code>putState()</code> 和 <code>getState()</code> 访问分类账，<code>getTxID()</code> 以检索当前交易ID。</li></ul></li><li>**<code>ctx.clientIdentity</code>**： 用于获取有关提交交易的用户身份的信息。</li></ul><p>一个智能合约通过 <code>stub</code>和 <code>clientIdentity</code> 可以访问一系列的功能：</p><img src="/2021/03/19/fabric-Tutorials/develop.diagram.41.png" alt="develop.diagram.41" style="zoom:45%"><h3 id="Stub"><a href="#Stub" class="headerlink" title="Stub"></a>Stub</h3><p>API分类：</p><ol><li><strong>World state data APIs</strong> - 交互点**(1)**<ul><li>使智能合约能够使用其密钥从世界状态中获取，放置和删除与各个对象相对应的状态<ul><li><a class="link" target="_blank" rel="noopener" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getState__anchor">getState( )<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" target="_blank" rel="noopener" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#putState__anchor">putState( )<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" target="_blank" rel="noopener" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#deleteState__anchor">deleteState( )<i class="fas fa-external-link-alt"></i></a></li></ul></li><li>辅以<strong>query API</strong>：交互点**(2)** - 使合同能够检索一组状态而不是单个状态，该集合可以通过使用完整或部分键的键值范围来定义，也可以根据基础世界状态数据库中的值进行查询 。对于大型查询，可以对结果集进行分页以减少存储需求：<ul><li><a class="link" target="_blank" rel="noopener" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getStateByRange__anchor">getStateByRange( )<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" target="_blank" rel="noopener" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getStateByRangeWithPagination__anchor">getStateByRangeWithPagination( )<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" target="_blank" rel="noopener" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getStateByPartialCompositeKey__anchor">getStateByPartialCompositeKey( )<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" target="_blank" rel="noopener" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getStateByPartialCompositeKeyWithPagination__anchor">getStateByPartialCompositeKeyWithPagination( )<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" target="_blank" rel="noopener" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getQueryResult__anchor">getQueryResult( )<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" target="_blank" rel="noopener" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getQueryResultWithPagination__anchor">getQueryResultWithPagination( )<i class="fas fa-external-link-alt"></i></a></li></ul></li></ul></li></ol><ol start="2"><li><strong>私有数据APIs</strong> - 交互点**(3)**<ul><li>这些API使智能合约能够与私有数据收集进行交互。它们类似于用于世界状态交互的API，但用于私有数据。有一些API可以通过其键获取，放置和删除私有数据状态：<ul><li><a class="link" target="_blank" rel="noopener" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getPrivateData__anchor">getPrivateData( )<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" target="_blank" rel="noopener" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#putPrivateData__anchor">putPrivateData( )<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" target="_blank" rel="noopener" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#deletePrivateData__anchor">deletePrivateData( )<i class="fas fa-external-link-alt"></i></a></li></ul></li><li>辅以<strong>query API</strong>：交互点**(4)** - 这些API允许智能合约根据一系列键值（全部或部分键）从私有数据集合中检索一组状态，或者根据基础<strong>世界状态数据库</strong>中的值进行查询 。当前没有用于私有数据收集的分页API。<ul><li><a class="link" target="_blank" rel="noopener" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getPrivateDataByRange__anchor">getPrivateDataByRange( )<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" target="_blank" rel="noopener" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getPrivateDataByPartialCompositeKey__anchor">getPrivateDataByPartialCompositeKey( )<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" target="_blank" rel="noopener" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getPrivateDataQueryResult__anchor">getPrivateDataQueryResult( )<i class="fas fa-external-link-alt"></i></a></li></ul></li></ul></li></ol><ol start="3"><li><strong>Transaction APIs</strong> - 交互点**(5)**<ul><li>智能合约使用这些API来检索有关智能合约正在处理的当前交易提议的详细信息。这包括交易标识符和创建交易提议的时间。<ul><li><a class="link" target="_blank" rel="noopener" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getTxID__anchor">getTxID( )<i class="fas fa-external-link-alt"></i></a>：返回当前交易建议的id。**(5)**</li><li><a class="link" target="_blank" rel="noopener" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getTxTimestamp__anchor">getTxTimestamp( )<i class="fas fa-external-link-alt"></i></a> ：返回应用程序创建当前交易建议时的时间戳。**(5)**</li><li><a class="link" target="_blank" rel="noopener" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getCreator__anchor">getCreator( )<i class="fas fa-external-link-alt"></i></a> ：返回交易建议创建者的原始身份（X.509或其他）。如果这是X.509证书，则通常更适合使用 <code>ctx.ClientIdentity</code>。</li><li><a class="link" target="_blank" rel="noopener" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getSignedProposal__anchor">getSignedProposal( )<i class="fas fa-external-link-alt"></i></a> ：返回智能合约正在处理的当前交易提议的签名副本。</li><li><a class="link" target="_blank" rel="noopener" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getBinding__anchor">getBinding( )<i class="fas fa-external-link-alt"></i></a> ：用于防止使用随机数恶意或意外重播交易。（出于实际目的，随机数是由客户端应用程序生成并包含在加密哈希中的随机数。）例如，智能合约可以在**(1)<strong>使用此API 来检测交易是否重播</strong>(5)**。</li><li><a class="link" target="_blank" rel="noopener" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getTransient__anchor">getTransient( )<i class="fas fa-external-link-alt"></i></a> ：允许智能合约访问应用程序传递给智能合约的临时数据。请参阅交互点**(9)<strong>和</strong>(10)<strong>。临时数据是应用程序-智能合约交互的私有数据。它没有记录在分类帐中，通常与私人数据收集</strong>(3)**结合使用。</li></ul></li></ul></li></ol><ol start="4"><li><strong>Key APIs</strong> - 交互点**(2)<strong>和</strong>(4)**<ul><li>是智能合约可以操纵世界状态或私有数据收集中的状态密钥</li><li>这些API中最简单的API允许智能合约从其单独的组件中形成和拆分组合密钥。<ul><li><a class="link" target="_blank" rel="noopener" href="https://hyperledger.github.io/fabric-chaincode-node/%7BBRACNH%7D/api/fabric-shim.ChaincodeStub.html#createCompositeKey__anchor">createCompositeKey( )<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" target="_blank" rel="noopener" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#splitCompositeKey__anchor">splitCompositeKey( )<i class="fas fa-external-link-alt"></i></a></li></ul></li><li><code>ValidationParameter()</code> ：稍微先进一些，这些 API可以获取和设置针对世界状态**(2)<strong>和私有数据</strong>(4)**的基于状态的endorsement。<ul><li><a class="link" target="_blank" rel="noopener" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#setStateValidationParameter__anchor">setStateValidationParameter( )<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" target="_blank" rel="noopener" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getStateValidationParameter__anchor">getStateValidationParameter( )<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" target="_blank" rel="noopener" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getPrivateDataValidationParameter__anchor">getPrivateDataValidationParameter( )<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" target="_blank" rel="noopener" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#setPrivateDataValidationParameter__anchor">setPrivateDataValidationParameter( )<i class="fas fa-external-link-alt"></i></a></li></ul></li><li><code>getHistoryForKey()</code>：通过返回存储值的的集合来检索状态的历史记录，该存储值包括执行状态更新的交易得id，从而允许从区块链读取交易**(10)**。<ul><li><a class="link" target="_blank" rel="noopener" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getHistoryForKey__anchor">getHistoryForKey( )<i class="fas fa-external-link-alt"></i></a></li></ul></li></ul></li></ol><ol start="5"><li><strong>Event APIs</strong> - 交互点**(5)**<ul><li>用于在处理智能合约期间设置事件</li><li>智能合约使用此API将事件添加到交易响应中。请注意，在交易中只能创建一个事件，并且当合同通过 <code>invokeChaincode</code> 相互调用时，该事件必须起源于最外面的合同。这些事件最终记录在区块链上，并在交互点**(11)**发送到侦听应用程序 。<ul><li><a class="link" target="_blank" rel="noopener" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#setEvent__anchor">setEvent( )<i class="fas fa-external-link-alt"></i></a></li></ul></li></ul></li></ol><ol start="6"><li><strong>Utility APIs</strong><ul><li>是有用的API的集合，这些API并不容易放入预定义的类别中，因此我们将它们分组在一起！它们包括检索当前通道名称，并将控制权传递给同一对等方上的不同链码。</li><li>任何peer均可使用，来获取应用程序在<strong>哪个通道</strong>上调用了智能合约 - 交互点**(13)**<ul><li><a class="link" target="_blank" rel="noopener" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getChannelID__anchor">getChannelID( )<i class="fas fa-external-link-alt"></i></a></li></ul></li><li>（不懂）MagnetoCorp组织中的Peer3上安装了多个智能合约。这些智能合约可以使用此API相互调用。智能合约必须并置/collocated；无法在其他对等方上调用智能合约。 - 交互点**(14)**<ul><li><a class="link" target="_blank" rel="noopener" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#invokeChaincode__anchor">invokeChaincode( )<i class="fas fa-external-link-alt"></i></a></li></ul></li><li>其中一些API仅在使用低级链码而不是智能合约的情况下使用。这些API主要用于链码输入的详细操作。智能合约 <code>Contract</code> 类会自动为开发人员整理所有的参数。<ul><li><a class="link" target="_blank" rel="noopener" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getFunctionAndParameters__anchor">getFunctionAndParameters( )<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" target="_blank" rel="noopener" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getStringArgs__anchor">getStringArgs( )<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" target="_blank" rel="noopener" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getArgs__anchor">getArgs( )<i class="fas fa-external-link-alt"></i></a></li></ul></li></ul></li></ol><h3 id="ClientIdentity"><a href="#ClientIdentity" class="headerlink" title="ClientIdentity"></a>ClientIdentity</h3><p>在大多数情况下，提交交易的应用程序将使用X.509证书。</p><p>在本示例中，由 <code>CA1</code> <strong>(7)**颁发的X.509证书</strong>(6)**被 <code>Isabella</code> **(8)**在其应用程序中用来在交易 <code>t6</code> **(5)**中签署提案。</p><p><code>ClientIdentity</code> 接收 <code>getCreator()</code> 返回的信息，并将一组X.509实用程序API放在其顶部，以使其更易于在此常见用例中使用。</p><ul><li><a class="link" target="_blank" rel="noopener" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ClientIdentity.html#getX509Certificate__anchor">getX509Certificate( )<i class="fas fa-external-link-alt"></i></a>：返回交易提交者的完整X.509证书，包括其所有属性及其值 - 交互点**(6)**</li><li><a class="link" target="_blank" rel="noopener" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ClientIdentity.html#getAttributeValue__anchor">getAttributeValue( )<i class="fas fa-external-link-alt"></i></a>：返回特定X.509属性的值，例如，组织单位 <code>OU</code> 或专有名称 <code>DN</code> - 交互点**(6)**</li><li><a class="link" target="_blank" rel="noopener" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ClientIdentity.html#assertAttributeValue__anchor">assertAttributeValue( )<i class="fas fa-external-link-alt"></i></a>：返回<code>TRUE</code>，如果X.509属性的指定属性具有指定的值 - 交互点**(6)**</li><li><a class="link" target="_blank" rel="noopener" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ClientIdentity.html#getID__anchor">getID( )<i class="fas fa-external-link-alt"></i></a>：根据交易提交者的专有名称和颁发方CA的专有名称，返回交易提交者的唯一标识id，格式为 <code>x509::&#123;subject DN&#125;::&#123;issuer DN&#125;</code> - 交互点**(6)**。</li><li><a class="link" target="_blank" rel="noopener" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ClientIdentity.html#getMSPID__anchor">getMSPID( )<i class="fas fa-external-link-alt"></i></a>：返回交易提交者的channel MSP。这使智能合约可以根据提交者的组织身份做出处理决策 - 交互点**(15)<strong>或</strong>(16)**</li></ul><h2 id="Transaction-handlers"><a href="#Transaction-handlers" class="headerlink" title="Transaction handlers"></a>Transaction handlers</h2><p>交易处理程序允许智能合约开发人员在应用程序与智能合约之间的交互过程中的关键点定义通用处理。</p><ul><li>交易处理程序是可选的，但如果定义，它们将在调用智能合约中的每个交易之前或之后获得控制。即使没有定义也并不影响智能合约的正常运行。</li><li>还有一个特定的处理程序，该处理程序在发出请求以调用智能合约中未定义的交易时接收控制。</li><li>一个智能合约最多可以定义每种类型的一个handler，如果需要执行多个功能，则需要在功能内进行协调</li></ul><p><strong>1、类型：</strong></p><img src="/2021/03/19/fabric-Tutorials/截屏2021-03-20 下午4.54.53.png" alt="截屏2021-03-20 下午4.54.53" style="zoom:50%"><ul><li><strong>Before handler</strong>：<ul><li>在每个智能合约交易被调用之前触发</li><li>通常用来修改交易的 <code>context</code>。可以访问所有范围的Fabric API；</li><li>例如，它可以issue <code>getState()</code> 和 <code>putState()</code>。</li></ul></li><li><strong>After handler</strong>：<ul><li>在每个智能合约交易被调用之后触发</li><li>通常执行所有交易的后加工。可以访问所有范围的Fabric API；</li></ul></li><li><strong>Unknown handler</strong>：<ul><li>在尝试调用智能合约中没有定义的交易时触发</li><li>通常用来记录故障，以供管理员进行后续处理。可以访问所有范围的Fabric API；</li></ul></li></ul><p><strong>2、定义：</strong></p><p>交易处理程序将作为具有明确定义名称的方法添加到智能合约中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">CommercialPaperContract <span class="keyword">extends</span> Contract &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">beforeTransaction</span>(<span class="params">ctx</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// Write the transaction ID as an informational to the console</span></span><br><span class="line">        <span class="built_in">console</span>.info(ctx.stub.getTxID());</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">afterTransaction</span>(<span class="params">ctx, result</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// This handler interacts with the ledger</span></span><br><span class="line">        ctx.stub.cpList.putState(...);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">unknownTransaction</span>(<span class="params">ctx</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// This handler throws an exception</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Unknown transaction function&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>交易处理程序定义的形式对于所有处理程序类型都是相似的，但是请注意，<code>afterTransaction(ctx, result)</code> 也将接收交易返回的任何结果。</li><li>该<a class="link" target="_blank" rel="noopener" href="https://hyperledger.github.io/fabric-chaincode-node/main/api/fabric-contract-api.Contract.html">API文档<i class="fas fa-external-link-alt"></i></a>您展示了这些处理器的确切形式。</li></ul><p><strong>3、过程</strong></p><p>将处理程序添加到智能合约后，将在交易处理期间将其调用。在处理期间，处理程序接收<code>ctx</code>， 也就是 <code>transaction context</code>，执行一些处理，并在完成时返回控制。处理继续如下：</p><ul><li><p><strong>在处理程序之前</strong>：如果处理程序成功完成，则使用更新的 <code>context</code> 调用交易。如果处理程序引发异常，则不会调用该交易，并且智能合约将失败，显示异常错误消息。</p></li><li><p><strong>处理程序之后</strong>：如果处理程序成功完成，则智能合约将根据所调用的交易确定完成。如果处理程序引发异常，则交易将失败，并显示异常错误消息。</p></li><li><p><strong>未知处理程序</strong>：处理程序应通过引发带有所需错误消息的异常来完成。如果未指定<strong>Unknown处理程序</strong>，或者未引发异常，则存在显式默认处理；智能合约将失败，并显示<strong>未知的交易</strong>错误消息。</p></li></ul><p>当处理程序需要访问函数和参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">beforeTransaction</span>(<span class="params">ctx</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// Retrieve details of the transaction</span></span><br><span class="line">    <span class="keyword">let</span> txnDetails = ctx.stub.getFunctionAndParameters();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.info(<span class="string">`Calling function: <span class="subst">$&#123;txnDetails.fcn&#125;</span> `</span>);</span><br><span class="line">    <span class="built_in">console</span>.info(util.format(<span class="string">`Function arguments : %j <span class="subst">$&#123;stub.getArgs()&#125;</span> `</span><span class="string">`);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>此处理程序通过<a class="link" target="_blank" rel="noopener" href="https://hyperledger-fabric.readthedocs.io/en/latest/developapps/transactioncontext.html#stub">transaction context<i class="fas fa-external-link-alt"></i></a>对象调用 utility API <code>getFunctionAndParameters</code>。</li></ul><h1 id="背书策略"><a href="#背书策略" class="headerlink" title="背书策略"></a>背书策略</h1><p>背书策略定义了认可交易以使其生效所需的最小组织集合。</p><ul><li>要进行背书，组织的背书对等方需要运行与交易关联的智能合约并签署其结果。</li><li>当订购服务将交易发送给 committed 的对等方时，他们将分别检查交易中的背书是否满足背书策略。如果不满足，则该交易将无效，并且对世界状态没有任何影响。</li></ul><p>背书策略以两种不同的粒度起作用：</p><ul><li>可以为<strong>整个命名空间</strong>以及<strong>单个状态键</strong>设置它们。它们使用诸如 <code>AND</code> 和 <code>OR</code> 的基本逻辑表达式来表示。</li><li>例如，在PaperNet中，该方法可以按以下方式使用：从MagnetoCorp出售给DigiBank的paper的背书政策可以设置为 <code>AND(MagnetoCorp.peer, DigiBank.peer)</code>，要求对paper进行任何更改都必须由MagnetoCorp和DigiBank进行背书。</li></ul><h1 id="连接配置"><a href="#连接配置" class="headerlink" title="连接配置"></a>连接配置</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gateway.connect(connectionProfile, connectionOptions);</span><br></pre></td></tr></table></figure><h2 id="Connection-Profile"><a href="#Connection-Profile" class="headerlink" title="Connection Profile"></a>Connection Profile</h2><p>连接配置文件</p><p>应用程序主要使用连接配置文件来配置处理所有网络交互的<strong>网关</strong>，从而使其能够专注于业务逻辑。</p><ul><li><p>连接配置文件主要中来配置网关，通常由了解网络拓扑的<strong>管理员</strong>创建。</p></li><li><p><strong>静态连接配置文件</strong>通常由详细了解网络拓扑的管理员创建。这是因为静态配置文件可以包含很多信息，并且管理员需要在相应的连接配置文件中捕获此信息。相反，<strong>动态配置文件</strong>将所需的定义量减到最少。</p></li><li><p><strong>静态网关</strong>比动态网关需要更多的信息，因为<strong>动态网关</strong>可以使用<a class="link" target="_blank" rel="noopener" href="https://hyperledger-fabric.readthedocs.io/en/latest/discovery-overview.html">服务发现<i class="fas fa-external-link-alt"></i></a>来动态扩展连接配置文件中的信息</p></li><li><p>连接配置文不应该是网络通道的详尽描述，它只需要包含足够的信息即可使用它的网关</p><ul><li>根据需要添加和删除对等方，订购方，证书颁发机构，渠道和组织。</li><li>组件可能会启动和停止，或者发生意外故障（例如断电）。</li><li>服务发现可以在连接配置文件中扩充信息。具体而言，可以使用最少的Fabric拓扑信息来配置动态网关。其余的可以发现。</li></ul></li><li><p><strong>语法</strong>：json或者yaml</p></li></ul><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> yaml = <span class="built_in">require</span>(<span class="string">&#x27;js-yaml&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; Gateway &#125; = <span class="built_in">require</span>(<span class="string">&#x27;fabric-network&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> connectionProfile = yaml.safeLoad(fs.readFileSync(<span class="string">&#x27;../gateway/paperNet.yaml&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>));</span><br><span class="line"><span class="keyword">const</span> gateway = <span class="keyword">new</span> Gateway();</span><br><span class="line"><span class="keyword">await</span> gateway.connect(connectionProfile, connectionOptions);</span><br></pre></td></tr></table></figure><ul><li>通过使用连接配置文件配置网关，<code>issue.js</code> 将为网关提供应用于处理交易的相关网络拓扑</li><li>对于任何给定的组织而言，连接配置文件定义一个以上的对等点都是一种很好的做法 – 它可以防止<strong>单点故障</strong>。这种做法也适用于动态网关。为服务发现提供多个起点。</li><li><code>connectionOptions</code> 传递给网关配合连接配置文件。它们允许应用程序声明网关希望使用连接配置文件的方式。SDK会对它们进行解释，以控制与网络组件的交互模式，例如，选择要与之连接的身份或用于事件通知的对等实体。阅读<a class="link" target="_blank" rel="noopener" href="https://hyperledger-fabric.readthedocs.io/en/latest/developapps/connectionoptions.html">有关<i class="fas fa-external-link-alt"></i></a>可用连接选项的列表以及何时使用它们的信息。</li></ul><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>文件路径</strong>：<code>commercial-paper/organization/magnetocorp/gateway/paperNet.yaml</code></p><p><strong>结构：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="attr">x-type:</span> <span class="string">&quot;hlfv1&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;to descript this connection profile&quot;</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">&quot;1.0.0&quot;</span></span><br><span class="line"><span class="attr">channels:</span></span><br><span class="line">  <span class="attr">channelName:</span></span><br><span class="line">    <span class="attr">orderers:</span></span><br><span class="line">    	<span class="bullet">-</span> <span class="string">orderer1.orgName.example.com</span></span><br><span class="line">    <span class="attr">peers:</span></span><br><span class="line">    	<span class="attr">peer1.orgName.example.com:</span></span><br><span class="line">    	  <span class="attr">endorsingPeer:</span> <span class="literal">true</span></span><br><span class="line">    	  <span class="string">...</span></span><br><span class="line">    	<span class="attr">peer2.orgName.example.com:</span></span><br><span class="line">    	<span class="string">...</span></span><br><span class="line">    	</span><br><span class="line"><span class="attr">organizations:</span></span><br><span class="line">	<span class="attr">org1Name:</span></span><br><span class="line">		<span class="attr">mspid:</span> <span class="string">OrgNameMSP</span></span><br><span class="line">		<span class="attr">peers:</span></span><br><span class="line">	 		<span class="bullet">-</span> <span class="string">peer1.orgName.example.com</span></span><br><span class="line">	  	<span class="bullet">-</span> <span class="string">peer2.orgName.example.com</span></span><br><span class="line">		<span class="attr">certificateAuthorities:</span></span><br><span class="line">			<span class="bullet">-</span> <span class="string">ca-orgname</span></span><br><span class="line">	<span class="attr">org2Name:</span></span><br><span class="line">		<span class="string">...</span></span><br><span class="line"></span><br><span class="line"><span class="attr">orderers:</span></span><br><span class="line">  <span class="attr">orderer1.orgName.example.com:</span></span><br><span class="line">  	<span class="attr">url:</span> <span class="string">grpc://localhost:7050</span></span><br><span class="line">    <span class="attr">grpcOptions:</span></span><br><span class="line">      <span class="attr">ssl-target-name-override:</span> <span class="string">orderer1.magnetocorp.example.com</span></span><br><span class="line"></span><br><span class="line"><span class="attr">peers:</span></span><br><span class="line">	<span class="attr">peer1.orgName.example.com:</span></span><br><span class="line">		<span class="attr">url:</span> <span class="string">grpc://localhost:7251</span></span><br><span class="line">    <span class="attr">grpcOptions:</span></span><br><span class="line">      <span class="attr">ssl-target-name-override:</span> <span class="string">peer2.magnetocorp.example.com</span></span><br><span class="line">      <span class="attr">request-timeout:</span> <span class="number">120001</span></span><br><span class="line">  <span class="attr">peer2.orgName.example.com:</span></span><br><span class="line">  	<span class="string">...</span></span><br><span class="line"></span><br><span class="line"><span class="attr">certificateAuthorities:</span></span><br><span class="line">	<span class="attr">ca1-orgname:</span></span><br><span class="line">		<span class="attr">url:</span> <span class="string">http://localhost:7054</span></span><br><span class="line">    <span class="attr">httpOptions:</span></span><br><span class="line">      <span class="attr">verify:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">registrar:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">enrollId:</span> <span class="string">admin</span></span><br><span class="line">        <span class="attr">enrollSecret:</span> <span class="string">adminpw</span></span><br><span class="line">    <span class="attr">caName:</span> <span class="string">ca-orgname</span></span><br></pre></td></tr></table></figure><p><strong>主要信息：</strong></p><ul><li><p>第9行： <code>name: &quot;papernet.magnetocorp.profile.sample&quot;</code></p><p>这是连接配置文件的名称。尝试使用DNS样式名称；它们是传达意义的一种非常简单的方法。</p></li><li><p>第16行： <code>x-type: &quot;hlfv1&quot;</code></p><p>用户可以添加自己 <code>x-</code> 的“application-specific”的属性，就像使用HTTP标头一样。它们主要是为将来使用而提供的。</p></li><li><p>第20行： <code>description: &quot;Sample connection profile for documentation topic&quot;</code></p><p>连接配置文件的简短描述。尝试使此功能对可能是第一次看到此内容的读者有所帮助！</p></li><li><p>第25行： <code>version: &quot;1.0&quot;</code></p><p>此连接配置文件的架构版本。当前仅支持1.0版，并且没有预见到该架构会经常更改。</p></li><li><p>第32行： <code>channels:</code></p><p>这是第一条真正重要的一行。</p><p><code>channels:</code> 标识此连接配置文件描述的<strong>所有</strong>通道属性。但是，优良作法是将不同的通道保留在不同的连接配置文件中，尤其是当它们彼此独立使用时。</p><ul><li><p>第36行： <code>papernet:</code></p><p>下面是有关 <code>papernet</code> 的详细信息，是此连接配置文件中的第一个channel</p></li><li><p>第41行： <code>orderers:</code></p><p><code>papernet</code> 中所有 orderers 的详细信息。</p><p><code>orderer1.magnetocorp.example.com</code> 为此频道的orderer(45)。这只是一个逻辑名称；稍后在连接配置文件中（第134-147行），将详细介绍如何连接到这个orderer。</p><p><code>orderer2.digibank.example.com</code> 不在此列表中。应用程序将用自己组织的订购者，而不是其他组织的订购者</p></li><li><p>第49行： <code>peers:</code></p><p><code>papernet</code> 中所有 peers 的详细信息</p><p>你可以看到从MagnetoCorp列出了三个同行： <code>peer1.magnetocorp.example.com</code>，<code>peer2.magnetocorp.example.com</code> 和 <code>peer3.magnetocorp.example.com</code>。</p><ul><li>无需像在此处列出的那样列出在MagnetoCorp的所有peer。比如DigiBank中只列出了一个peer：<code>peer9.digibank.example.com</code>; 现在我们将确认，包括该对等点开始意味着背书策略要求MagnetoCorp和DigiBank背书交易。</li></ul><blockquote><p>使用时最好有多个peer，以<strong>避免单点故障。</strong></p><p>每个peer下面，你可以看到四个非排他性的角色设置：<strong>endorsingPeer</strong>， <strong>chaincodeQuery</strong>，<strong>ledgerQuery</strong>和<strong>EventSource的</strong>。</p><ul><li>了解<code>peer1</code>以及 <code>peer2</code>如何在担任<code>papercontract</code>主人时扮演所有角色。</li><li>相比之下，<code>peer3</code> 只能用于通知或访问分类账的区块链组件而不是世界状态的分类账查询，因此不需要安装智能合约。</li><li>请注意<code>peer9</code>，除了背书之外，不应将其用于其他任何用途，因为MagnetoCorp的其他peer可以更好地担当这些角色。</li></ul><p>以上信息是通过peer的逻辑名称和角色来描述的，在配置文件的后面，我们将看到这些peer的物理信息。</p></blockquote></li></ul></li><li><p>第97行： <code>organizations:</code></p><p>配置<strong>所有通道</strong>上某组织的属性。请注意，尽管<code>papernet</code>目前是唯一列出的通道，但这些组织适用于所有通道。这是因为组织可以位于多个通道中，并且通道可以具有多个组织。而且，某些应用程序操作与组织有关，而不是与通道有关。</p><ul><li><p>例如，应用程序可以使用<a class="link" target="_blank" rel="noopener" href="https://hyperledger-fabric.readthedocs.io/en/latest/developapps/connectionoptions.html">连接选项<i class="fas fa-external-link-alt"></i></a>从其组织内的一个或所有对等方或网络内的所有组织请求通知。为此，需要有一个组织到对等方的映射</p></li><li><p>第101行： <code>MagnetoCorp:</code></p><ul><li><p>第109 / 116行：<code>peers:</code> / <code>certificateAuthorities:</code></p><p>列出的所有peer都被认为MagnetoCorp的一部分：<code>peer1</code>， <code>peer2</code>和<code>peer3</code>。</p><p>证书颁发机构也是如此。</p><blockquote><p>请注意此处仍使用逻辑名称，与本<code>channels:</code>节相同；物理信息将在配置文件的后面列出。</p></blockquote></li></ul></li><li><p>第121行： <code>DigiBank:</code></p><p>仅列出了DigiBank的一部分peer：<code>peer9</code></p><p>没有列出证书颁发机构。这是因为DigiBank其他的peer和DigiBank CA均与本连接配置文件的用户无关。</p></li></ul></li></ul><blockquote><p>以下是之前相关逻辑名称对应的物理信息</p></blockquote><ul><li><p>第134行： <code>orderers:</code></p><p>现在列出了 orderers 的物理信息。由于此连接配置文件仅提及 <code>papernet</code> 的一个订购者，所以只列出了 <code>orderer1.magnetocorp.example.com</code> 的详细信息。</p><p>其中包括其<strong>IP地址</strong>和<strong>端口</strong>，以及<strong>gRPC选项</strong> <code>ssl-target-name-override</code>，可以在需要时覆盖与订购者进行通信时使用的默认值。</p><p>与一样<code>peers:</code>，对于高可用性，指定多个订购者是一个好主意。</p></li><li><p>第152行： <code>peers:</code></p><p>现在列出了先前所有对等方的物理信息。此连接配置文件有MagnetoCorp的三个对等方： ，<code>peer1</code>，<code>peer2</code>和 <code>peer3</code>; 对于DigiBank，列出了单个对等方 <code>peer9</code>的信息。</p><p>对于每个对等方，如orderer一样，将列出其<strong>IP地址</strong>和<strong>端口</strong>，并列出<strong>gRPC选项</strong>，这些选项可以覆盖与特定对等方进行通信时使用的默认值（如有必要）。</p></li><li><p>194行： <code>certificateAuthorities:</code></p><p>现在列出了证书颁发机构的物理信息。连接配置文件为MagnetoCorp列出了一个CA <code>ca1-magnetocorp</code>，其物理信息如下。</p><p>除了IP地址 <code>url:</code> 之外，<code>resigter:</code> 表示还允许将此CA用于证书签名请求（CSR）。这些用于请求本地生成的公用/专用密钥对的新证书。</p></li></ul><h2 id="Connection-Options"><a href="#Connection-Options" class="headerlink" title="Connection Options"></a>Connection Options</h2><p>配置选项：允许应用程序声明网关希望与连接配置文件交互的方式</p><p>连接选项与连接配置文件一起使用，以<strong>精确</strong>控制网关与网络的交互方式。使用网关可以使应用程序专注于<strong>业务逻辑</strong>，而不是网络拓扑。</p><blockquote><p>网络由<strong>连接配置文件</strong>标识，<strong>配置选项</strong>精确指定网关应如何与之交互。</p></blockquote><h3 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h3><p>以MagnetoCorp的 <code>issue.js</code>为示例 ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userName = <span class="string">&#x27;User1@org1.example.com&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> wallet = <span class="keyword">new</span> FileSystemWallet(<span class="string">&#x27;../identity/user/isabella/wallet&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> connectionOptions = &#123;</span><br><span class="line">  identity: userName,</span><br><span class="line">  wallet: wallet,</span><br><span class="line">  eventHandlerOptions: &#123;</span><br><span class="line">    commitTimeout: <span class="number">100</span>,</span><br><span class="line">    strategy: EventStrategies.MSPID_SCOPE_ANYFORTX</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> gateway.connect(connectionProfile, connectionOptions);</span><br></pre></td></tr></table></figure><ul><li><code>identity</code> 和 <code>wallet</code> 选项为 <code>connectionOptions</code> 对象的简单属性 。它们分别具有值 <code>userName</code> 和 <code>wallet</code>，这些值在代码的前面设置。</li><li><code>eventHandlerOptions</code> 本身就是对象的选项。它具有两个属性：<ul><li><code>commitTimeout: 100</code>:（以秒为单位）</li><li><code>strategy: EventStrategies.MSPID_SCOPE_ANYFORTX</code></li></ul></li></ul><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><img src="/2021/03/19/fabric-Tutorials/develop.diagram.35.png" alt="develop.diagram.35" style="zoom:45%"><ul><li><p><code>wallet</code>：标识代表应用程序使用网关的钱包。**(1)** ;</p><ul><li>钱包是由应用程序指定的，但实际上是从中检索身份的网关。</li><li>必须指定一个钱包；决定使用的钱包<a class="link" target="_blank" rel="noopener" href="https://hyperledger-fabric.readthedocs.io/en/latest/developapps/wallet.html#type">类型<i class="fas fa-external-link-alt"></i></a>是最重要的 - 文件系统，内存，HSM还是数据库。</li></ul></li><li><p><code>identity</code>：是应用程序将使用的来自 <code>wallet</code> 的用户身份。**(2a)** ;</p><ul><li><strong>用户身份由应用程序指定</strong>，并代表应用程序的用户Isabella**(2b)**。但身份实际上是由网关检索的。<ul><li>在我们的示例中，不同MSP**(2c)**， **(2d)**将使用Isabella的身份来标识她来自MagnetoCorp，并且在其中具有特定角色。这两个事实将相应地确定她对资源的许可，例如能够读取和写入分类帐。</li></ul></li><li><strong>必须指定用户身份</strong>。如您所见，此身份对于Hyperledger Fabric是一个<strong>permissioned</strong>网络 - 所有参与者都具有一个身份，包括应用程序，peers 和 oderers，这些身份决定了他们对资源的控制。您可以在会员服务<a class="link" target="_blank" rel="noopener" href="https://hyperledger-fabric.readthedocs.io/en/latest/membership/membership.html">主题中<i class="fas fa-external-link-alt"></i></a>阅读有关此想法的更多信息。</li></ul></li><li><p><code>clientTlsIdentity</code>：是从钱包**(3a)<strong>检索并用于网关和不同通道组件（例如peers和orderers）之间的安全通信</strong>(3b)<strong>的</strong>identity**。</p><ul><li>请注意，此<strong>identity</strong>不同于用户身份。尽管 <code>clientTlsIdentity</code> 对于安全通信很重要，但它不如用户身份那么基础，因为它的范围不会扩展到安全网络通信之外。</li><li><code>clientTlsIdentity</code>是可选的。建议您在生产环境中进行设置。您应该始终使用跟 <code>identity</code>不同的 <code>clientTlsIdentity</code>，因为这些身份具有不同的含义和生命周期。<ul><li>例如，如果你的 <code>clientTlsIdentity</code> 受到了损害，那么你的 <code>identity</code> 也会受到损害。将它们分开是更安全的。</li></ul></li></ul></li><li><p><code>eventHandlerOptions</code></p><ul><li><p><code>commitTimeout</code>：是可选的。它以秒为单位指定在将控制权返回给应用程序之前，网关应等待对等方**(4a)**提交交易的最长时间（默认为300s）。</p></li><li><p><code>strategy</code>：是可选的。它标识网关应用于侦听交易已提交的通知的对等体的集合。例如，是侦听组织中的单个对等方还是所有对等方。它可以采用以下值之一：</p><ul><li><p><code>EventStrategies.MSPID_SCOPE_ANYFORTX</code>：侦听用户<strong>组织内</strong>的<strong>任何</strong>对等方**(4b)**。MagnetoCorp的对等体1，对等体2或对等体3中的任何一个都可以通知网关。</p></li><li><p><code>EventStrategies.MSPID_SCOPE_ALLFORTX</code>： 这是<strong>默认值</strong>。监听用户<strong>组织内</strong>的<strong>所有</strong>对等方**(4b)<strong>。MagnetoCorp的所有对等方</strong>都必须**已通知网关。不包括<code>stopped</code>或<code>falied</code>的对等方。</p></li><li><p><code>EventStrategies.NETWORK_SCOPE_ANYFORTX</code>：侦听整个<strong>网络通道</strong>中的<strong>任何</strong>对等方**(4b)<strong>和</strong>(4c)**。MagnetoCorp的对等方1-3或DigiBank的对等方7-9中的任何一个都可以通知网关。</p></li><li><p><code>EventStrategies.NETWORK_SCOPE_ALLFORTX</code>：侦听整个<strong>网络通道</strong>中的<strong>所有</strong>对等方**(4b)<strong>和</strong>(4c)<strong>。MagnetoCorp和DigiBank的所有对等方</strong>都必须**通知网关；对等1-3和对等7-9。不包括<code>stopped</code>或<code>falied</code>的对等方。</p></li><li><p>&lt; <code>PluginEventHandlerFunction</code>&gt;：用户定义的事件处理程序的名称。这允许用户定义自己的事件处理逻辑。了解如何<a class="link" target="_blank" rel="noopener" href="https://hyperledger.github.io/fabric-sdk-node/main/tutorial-transaction-commit-events.html">定义<i class="fas fa-external-link-alt"></i></a>事件处理程序插件，并检查<a class="link" target="_blank" rel="noopener" href="https://github.com/hyperledger/fabric-sdk-node/blob/main/test/integration/network-e2e/sample-transaction-event-handler.js">样本程序<i class="fas fa-external-link-alt"></i></a>。</p><blockquote><p>仅当有非常特定的事件处理要求时，才需要用户定义的事件处理程序。通常，使用内置事件策略之一就足够了。用户定义的事件处理程序的一个示例可能是等待组织中超过一半的对等方来确认交易已提交。</p><p>如果确实指定了用户定义的事件处理程序，则它不会影响您的应用程序逻辑。它与这完全不同。SDK在处理过程中会调用处理程序；它决定何时调用它，并使用其结果选择要用于事件通知的对等方。SDK完成处理后，应用程序将收到控制权。</p><p>如果未指定用户定义的事件处理程序，则使用<code>EventStrategies</code>的默认值</p></blockquote></li></ul></li></ul></li><li><p><code>discovery</code></p><ul><li><code>enabled</code>：是可选的，并且可能具有<code>true</code>或值<code>false</code>。默认值为<code>true</code>。它确定网关是否使用<a class="link" target="_blank" rel="noopener" href="https://hyperledger-fabric.readthedocs.io/en/latest/discovery-overview.html">服务发现<i class="fas fa-external-link-alt"></i></a>来扩展连接配置文件中指定的网络拓扑。**(6)** ; 网关使用的对等方gossip information。<ul><li>该值会被 <code>INITIALIIZE-WITH-DISCOVERY</code> 环境变量覆盖</li></ul></li><li><code>asLocalhost</code>：是可选的，并且可能具有<code>true</code>或值<code>false</code>。默认值为<code>true</code>。它确定是否把在服务发现期间找到的IP地址从docker网络转换为本地主机。<ul><li>通常，开发人员会编写使用docker容器作为其网络组件（例如peer，orderer和CA）的应用程序，但这些应用程序本身不会在docker容器中运行。这就是 <code>true</code> 默认设置的原因；</li><li>在生产环境中，应用程序可能会以与网络组件相同的方式在docker容器中运行，因此不需要地址转换。在这种情况下，应用程序应显式指定 <code>false</code> 或使用环境变量替代。</li><li>该值将被 <code>DISCOVERY-AS-LOCALHOST</code> 环境变量覆盖</li></ul></li></ul></li></ul><p><strong>注意事项：</strong></p><p>下面的注意事项列表在决定如何选择连接选项时会很有帮助。</p><ul><li><p><code>eventHandlerOptions.commitTimeout</code> 和 <code>eventHandlerOptions.strategy</code>一起工作。</p><ul><li>例如，<code>commitTimeout: 100</code> 和 <code>strategy: EventStrategies.MSPID_SCOPE_ANYFORTX</code>表示网关将等待多达100秒，以便<strong>任何一个</strong>对等方确认交易已提交。相反，<code>strategy: EventStrategies.NETWORK_SCOPE_ALLFORTX</code> 意味着网关将对<strong>所有</strong>组织中的<strong>所有</strong>对等方最多等待100秒。</li></ul></li><li><p>默认值 <code>eventHandlerOptions.strategy: EventStrategies.MSPID_SCOPE_ALLFORTX</code> 将等待应用程序组织中的所有对等方提交交易。</p><ul><li>这是一个很好的默认设置，因为应用程序可以确保所有对等方都拥有分类账的最新副本，从而最大程度地减少了并发问题</li><li>但是，随着组织中对等方数目的增加，等待所有对等方变得有点不必要，在这种情况下，使用**&lt;可插入事件处理程序&gt;**可以提供更有效的策略。例如，在共识将使所有分类帐保持同步的安全假设下，可以使用相同的一组对等方来提交交易和侦听通知。</li></ul></li><li><p>需要 <code>clientTlsIdentity</code> 来设置服务发现。</p><ul><li>这是因为与应用程序交换信息的对等方需要确信他们正在与自己信任的实体交换信息。如果 <code>clientTlsIdentity</code>未设置，则无论 <code>discovery</code> 是否设置，都将不服从。</li></ul></li><li><p>尽管应用程序可以在连接到网关时设置连接选项，但是管理员可能有必要覆盖这些选项。</p><ul><li>这是因为选项与网络交互有关，该交互可能随时间而变化。例如，管理员试图了解使用服务发现对网络性能的影响。</li><li>一种好的方法是在一个配置文件中定义应用程序的重写，当应用程序配置其与网关的连接时，该配置文件将由应用程序读取。</li><li>因为发现选项<code>enabled</code>和<code>asLocalHost</code>是管理员最经常需要覆盖的选项，所以提供了环境变量 <code>INITIALIIZE-WITH-DISCOVERY</code>和<code>DISCOVERY-AS-LOCALHOST</code>以便于使用。管理员应在应用程序的生产运行时环境中设置这些设置，该环境很可能是docker容器。</li></ul></li></ul><h1 id="wallet"><a href="#wallet" class="headerlink" title="wallet"></a>wallet</h1><p>钱包包含一组用户身份。用户运行的应用程序在连接到通道时会选择这些身份之一。结合MSP使用此身份确定对诸如分类帐之类的信道资源的访问权限。</p><p><strong>过程：</strong></p><img src="/2021/03/19/fabric-Tutorials/develop.diagram.10.png" alt="develop.diagram.10" style="zoom:45%"><ul><li>当应用程序连接到诸如PaperNet之类的网络通道时，它会选择一个用户身份进行连接<code>ID1</code>。通道MSP将<code>ID1</code>与特定组织内的角色相关联，并且该角色最终将确定应用程序对通道资源的权利。例如，<code>ID1</code>可能将某个用户标识为可以读写账本的MagnetoCorp组织成员，而<code>ID2</code>可能会标识MagnetoCorp中可以向联盟添加新组织的管理员。</li></ul><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>钱包存储的三种不同类型：文件系统，内存和CouchDB。</p><ul><li><strong>文件系统</strong>：这是最常见的存放钱包的地方；文件系统无处不在，易于理解，并且可以通过网络安装。对于钱包来说，它们是一个很好的默认选择。</li><li><strong>内存中</strong>：应用程序存储中的钱包。当您的应用程序在受限环境中运行而无法访问文件系统时，请使用这种钱包。通常是网络浏览器。值得记住的是，这种钱包是易变的。应用程序正常结束或崩溃后，身份将丢失。</li><li><strong>CouchDB</strong>：存储在CouchDB中的钱包。这是最罕见的钱包存储形式，但是对于那些想要使用数据库备份和还原机制的用户，CouchDB钱包可以提供一个有用的选项来简化灾难恢复。</li></ul><blockquote><p>使用wallet类的工厂函数创建钱包</p></blockquote><h3 id="HSM"><a href="#HSM" class="headerlink" title="HSM"></a>HSM</h3><p>硬件安全模块（HSM）是一种超安全的防篡改设备，用于存储数字身份信息，尤其是私钥。HSM可以本地连接到您的计算机或可通过网络访问。大多数HSM提供了使用私钥执行机载加密的功能，这样私钥就永远不会离开HSM。</p><ul><li><p>HSM可以与任何钱包类型一起使用。在这种情况下，身份证书将存储在钱包中，私钥将存储在HSM中。</p></li><li><p>要启用使用HSM管理的身份，<code>IdentityProvider</code> 必须使用HSM连接信息配置并在钱包中注册。有关更多详细信息，请参阅《<a class="link" target="_blank" rel="noopener" href="https://hyperledger.github.io/fabric-sdk-node/main/tutorial-wallet.html">使用钱包管理身份<i class="fas fa-external-link-alt"></i></a>》教程。</p></li></ul><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>单个钱包可以保存多个身份，每个身份由特定的证书颁发机构颁发。每个身份具有一个标准结构，该标准结构包括<strong>描述性标签</strong>，<strong>公钥</strong>，<strong>私钥</strong>和某些特定于Fabric的<strong>metadata的X.509证书</strong>。不同的<a class="link" target="_blank" rel="noopener" href="https://hyperledger-fabric.readthedocs.io/en/latest/developapps/wallet.html#types">钱包类型<i class="fas fa-external-link-alt"></i></a>将此结构适当地映射到其存储机制。</p><p><img src="/2021/03/19/fabric-Tutorials/develop.diagram.11.png" alt="develop.diagram.11"></p><ul><li>Fabric钱包可以使用由不同证书颁发机构颁发的证书来保存多个身份。<ul><li>身份包括<strong>证书</strong>，<strong>私钥</strong>和<strong>结构元数据</strong>。</li></ul></li></ul><p>生成钱包：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> identity: X509Identity = &#123;</span><br><span class="line">    credentials: &#123;</span><br><span class="line">        certificate: certificatePEM,</span><br><span class="line">        privateKey: privateKeyPEM,</span><br><span class="line">    &#125;,</span><br><span class="line">    mspId: <span class="string">&#x27;Org1MSP&#x27;</span>,</span><br><span class="line">    type: <span class="string">&#x27;X.509&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// const identityLabel = &#x27;isabella&#x27;;</span></span><br><span class="line"><span class="keyword">await</span> wallet.put(identityLabel, identity);</span><br></pre></td></tr></table></figure><p>获取身份：</p><ul><li><code>Gateway</code> 类只需要 <code>mspId</code> 和 <code>type</code> 来标识一个身份，它使用MSP ID在连接配置文件中识别一个对等方</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">organizations:</span></span><br><span class="line">  <span class="attr">Org1:</span></span><br><span class="line">    <span class="attr">mspid:</span> <span class="string">Org1MSP</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">peers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">peer0.org1.example.com</span></span><br></pre></td></tr></table></figure><ul><li>通过 <code>get()</code> 方法获得身份 <code>fabric-network.Identit</code>，没有则返回 <code>undefined</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// const identityLabel = &#x27;isabella&#x27;;</span></span><br><span class="line"><span class="keyword">const</span> userExists = <span class="keyword">await</span> wallet.get(<span class="string">&#x27;identityLabel&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="运行方式"><a href="#运行方式" class="headerlink" title="运行方式"></a>运行方式</h2><p>不同的钱包类型都实现了一个通用的<a class="link" target="_blank" rel="noopener" href="https://hyperledger.github.io/fabric-sdk-node/main/module-fabric-network.Wallet.html">电子钱包<i class="fas fa-external-link-alt"></i></a>接口，该接口提供了一组标准的API来管理身份。</p><p><strong>生命周期</strong>：可以创建或打开钱包，并且可以读取，添加和删除身份。</p><p><strong>示例代码</strong>：<code>commercial-paper/organization/magnetocorp/application/addToWallet.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wallet = <span class="keyword">await</span> Wallets.newFileSystemWallet(<span class="string">&#x27;../identity/user/isabella/wallet&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cert = fs.readFileSync(path.join(credPath, <span class="string">&#x27;.../User1@org1.example.com-cert.pem&#x27;</span>)).toString();</span><br><span class="line"><span class="keyword">const</span> key = fs.readFileSync(path.join(credPath, <span class="string">&#x27;.../_sk&#x27;</span>)).toString();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> identityLabel = <span class="string">&#x27;User1@org1.example.com&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> identity = &#123;</span><br><span class="line">    credentials: &#123;</span><br><span class="line">        certificate: cert,</span><br><span class="line">        privateKey: key,</span><br><span class="line">    &#125;,</span><br><span class="line">    mspId: <span class="string">&#x27;Org1MSP&#x27;</span>,</span><br><span class="line">    type: <span class="string">&#x27;X.509&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> wallet.put(identityLabel, identity);</span><br></pre></td></tr></table></figure><ul><li>首次运行该程序时，会在本地文件系统上创建一个钱包 <code>.../isabella/wallet</code>。</li><li>证书<code>cert</code>和私有<code>key</code>文件是从文件系统加载的。</li><li>新的X.509身份使用 <code>cert</code>，<code>key</code> 和 <code>Org1MSP</code> 来创建。</li><li>使用 <code>wallet.put()</code> 将带有标签 <code>User1@org1.example.com</code> 的新身份添加到钱包中</li></ul><h1 id="Gateway"><a href="#Gateway" class="headerlink" title="Gateway"></a>Gateway</h1><p>网关代表应用程序管理网络交互，使其专注于业务逻辑。应用程序连接到网关，然后使用该网关的配置管理所有后续交互。</p><p><strong>使用方式：</strong></p><ol><li><strong>静态</strong>：网关配置完全在<a class="link" target="_blank" rel="noopener" href="https://hyperledger-fabric.readthedocs.io/en/latest/developapps/connectionprofile.html">连接配置文件中<i class="fas fa-external-link-alt"></i></a>定义。<ul><li>应用程序可用的所有<strong>对等方</strong>，<strong>订购者</strong>和<strong>CA</strong>在用于配置网关的连接配置文件中静态定义。例如，对于对等方来说，包括其作为 endorsing peer 或event notification hub的角色。</li><li>SDK将结合网关<a class="link" target="_blank" rel="noopener" href="https://hyperledger-fabric.readthedocs.io/en/latest/developapps/connectionoptions">连接选项<i class="fas fa-external-link-alt"></i></a>来使用此静态拓扑来管理交易的提交和通知过程。连接配置文件必须包含足够的网络拓扑，以允许网关代表应用程序与网络交互；这包括网络渠道，组织，订购者，对等方及其角色。</li></ul></li></ol><ol start="2"><li><strong>动态</strong>：网关配置只在连接配置文件中最少定义。<ul><li>通常，指定来自应用程序组织的一个或两个对等方，并且它们使用<a class="link" target="_blank" rel="noopener" href="https://hyperledger-fabric.readthedocs.io/en/latest/discovery-overview.html">服务发现<i class="fas fa-external-link-alt"></i></a>来发现可用的网络拓扑。这包括对等方，订购者，渠道，已部署的智能合约及其认可策略。（在生产环境中，网关配置应至少指定两个对等方以确保可用性。）</li><li>SDK将使用文件中所有的静态定义部分和发现的拓扑信息以及网关连接选项来管理交易的提交和通知过程。作为其一部分，它还将智能地使用发现的拓扑。例如，它将使用发现的智能合约背书策略计算所需的最少背书对等体。</li></ul></li></ol><blockquote><p>静态或动态网关是否更好？权衡是在可预测性和响应性之间。静态网络始终会以相同的方式运行，因为它们将网络视为不变的。从这种意义上讲，它们是可预测的–如果可用，它们将始终使用相同的对等方和订购方。当动态网络了解网络的变化时，它们的响应速度更快–它们可以使用新添加的对等点和订购者，从而带来额外的弹性和可扩展性，但可能会在可预测性方面付出一些代价。通常，使用动态网络是可以的，实际上，这是网关的默认模式。</p><ul><li>请注意，可以静态或动态使用同一连接配置文件。显然，如果要静态使用配置文件，则它必须是全面的，而动态使用仅需要稀疏的填充即可。</li><li>两种样式的网关对应用程序都是透明的。无论使用静态还是动态网关，应用程序设计都不会改变。这也意味着某些应用程序可以使用服务发现，而其他应用程序则可以不使用。通常，使用动态发现意味着SDK的定义更少，情报更多。这是默认值。</li></ul></blockquote><p><strong>连接：</strong>（前面有详细的）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> gateway.connect(connectionProfile, connectionOptions);</span><br></pre></td></tr></table></figure><ul><li><p><strong>连接配置文件</strong>：<code>connectionProfile</code> 是网关配置，它将用于SDK的静态或动态交易处理。尽管可以在传递给网关时将其转换为JSON对象，但是可以使用<strong>YAML</strong>或<strong>JSON</strong>指定它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> connectionProfile = yaml.safeLoad(fs.readFileSync(<span class="string">&#x27;../gateway/paperNet.yaml&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>));</span><br></pre></td></tr></table></figure></li></ul><ul><li><strong>连接选项</strong>：<code>connectionOptions</code> 允许应用程序<strong>声明</strong>而不是实现所需的事务处理行为。SDK会解释连接选项，以控制与网络组件的交互模式，例如，选择要与之连接的身份或用于事件通知的对等对象。这些选项可在不影响功能的情况下显着降低应用程序的复杂性。这是可能的，因为SDK已实现了许多应用程序原本需要的低层逻辑。连接选项控制此逻辑流。</li></ul><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>静态网关定义网络的<strong>固定视图</strong>。</p><p>在MagnetoCorp <a class="link" target="_blank" rel="noopener" href="https://hyperledger-fabric.readthedocs.io/en/latest/developapps/gateway.html#scenario">方案中<i class="fas fa-external-link-alt"></i></a>，网关可能会标识MagnetoCorp的单个对等方，DigiBank的单个对等方和MagentoCorp订购者。或者，网关可以定义MagnetCorp和DigiBank的 <em>所有</em> 对等方和订购方。在这两种情况下，网关都必须定义足以使商业票据交易获得认可和分发的网络视图。</p><ul><li>通过在API <code>gateway.connect()</code> 上显式指定connect选项 <code>discovery: &#123; enabled:false &#125;</code>，应用程序可以静态使用网关。或者，环境变量设置 <code>FABRIC_SDK_DISCOVERY=false</code> 将始终覆盖应用程序选择。</li><li>检查 MagnetoCorp的 <code>issue.js</code> 应用程序使用的<a class="link" target="_blank" rel="noopener" href="https://github.com/hyperledger/fabric-samples/blob/main/commercial-paper/organization/magnetocorp/gateway/networkConnection.yaml">连接配置文件<i class="fas fa-external-link-alt"></i></a>。查看如何在此文件中指定所有对等方，订购者甚至CA，包括它们的角色。</li></ul><blockquote><p>注意：静态网关代表某个<strong>时刻</strong>的网络视图。随着网络的变化，将其反映在网关文件的变化中可能很重要。当应用程序重新加载网关文件时，它们将自动获取这些更改。</p></blockquote><h2 id="dynamic"><a href="#dynamic" class="headerlink" title="dynamic"></a>dynamic</h2><p>动态网关为网络定义了一个最小的<strong>固定起点</strong>。</p><p>在MagnetoCorp<a class="link" target="_blank" rel="noopener" href="https://hyperledger-fabric.readthedocs.io/en/latest/developapps/gateway.html#scenario">方案中<i class="fas fa-external-link-alt"></i></a>，动态网关可能仅识别MagnetoCorp中的单个对等方。一切都会被发现！（为了预防单点故障，最好定义两个这样的引导对等点）</p><ul><li>如果应用程序选择了<a class="link" target="_blank" rel="noopener" href="https://hyperledger-fabric.readthedocs.io/en/latest/discovery-overview.html">服务发现<i class="fas fa-external-link-alt"></i></a>，则网关文件中定义的拓扑将使用此过程生成的拓扑进行扩充。<ul><li>服务发现从网关定义开始，并使用<a class="link" target="_blank" rel="noopener" href="https://hyperledger-fabric.readthedocs.io/en/latest/gossip.html"> gossip 协议<i class="fas fa-external-link-alt"></i></a>在MagnetoCorp组织中找到所有连接的对等方和订购方。</li><li>如果已为通道定义了<a class="link" target="_blank" rel="noopener" href="https://hyperledger-fabric.readthedocs.io/en/latest/glossary.html#anchor-peer">anchor peer<i class="fas fa-external-link-alt"></i></a>，则服务发现将使用跨组织的 gossip 协议来发现连接的组织内的组件。此过程还将发现在对等方安装的智能合约及其在渠道级别定义的认可策略。</li><li>与静态网关一样，发现的网络必须足以批准和分发商业票据交易。</li></ul></li><li>动态网关是Fabric应用程序的默认设置。可以使用API <code>gateway.connect()</code> 上的连接选项 <code>discovery: &#123; enabled:true &#125;</code> 明确指定它们。或者，环境变量设置 <code>FABRIC_SDK_DISCOVERY=true</code> 将始终覆盖应用程序选择。</li></ul><blockquote><p>注意：动态网关代表网络的最新视图。随着网络的变化，服务发现将确保网络视图正确反映了应用程序可见的拓扑。应用程序将自动获取这些更改；他们甚至不需要重新加载网关文件。</p></blockquote><h2 id="multiple"><a href="#multiple" class="headerlink" title="multiple"></a>multiple</h2><p>对于应用程序而言，定义相同或不同网络的多个网关非常简单。此外，应用程序可以静态和动态使用名称网关。</p><p>拥有多个网关可能会有所帮助。原因如下：</p><ul><li>代表不同用户处理请求。</li><li>同时连接到不同的网络。</li><li>通过同时比较其行为与现有配置来测试网络配置。</li></ul></div><div class="post-copyright-info"><div class="article-copyright-info-container"><ul><li>Post title：fabric-Tutorials</li><li>Post author：Wei Jieyang</li><li>Create time：2021-03-19 11:33:34</li><li>Post link：https://jieyang-wei.github.io/2021/03/19/fabric-Tutorials/</li><li>Copyright Notice：All articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> unless stating additionally.</li></ul></div></div><div class="article-nav"><div class="article-prev"><a class="prev" rel="prev" href="/2021/03/20/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"><span class="left arrow-icon flex-center"><i class="fas fa-chevron-left"></i> </span><span class="title flex-center"><span class="post-nav-title-item">网络爬虫</span> <span class="post-nav-item">Prev posts</span></span></a></div><div class="article-next"><a class="next" rel="next" href="/2021/03/16/fabric-Developing%20Application/"><span class="title flex-center"><span class="post-nav-title-item">fabric-Developing Application</span> <span class="post-nav-item">Next posts</span> </span><span class="right arrow-icon flex-center"><i class="fas fa-chevron-right"></i></span></a></div></div></div></div></main></div><div class="page-main-content-bottom"><footer class="footer"><div class="info-container"><div class="copyright-info info-item">&copy; <span>2020</span> - 2021 <i class="fas fa-heart icon-animate"></i> <a href="/">Wei Jieyang</a></div><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="website-count info-item"><span id="busuanzi_container_site_uv">Visitor Count <span id="busuanzi_value_site_uv"></span>&ensp; </span><span id="busuanzi_container_site_pv">Totalview <span id="busuanzi_value_site_pv"></span></span></div><div class="theme-info info-item">Powered by <a target="_blank" href="https://hexo.io">Hexo</a> | Theme <a class="theme-version" target="_blank"></a></div></div></footer></div></div></main><div class="sidebar-tools"><div class="tools-container"><ul class="tools-list"><li class="search popup-trigger"><i class="fas fa-search"></i></li><li class="tools-item page-aside-toggle"><i class="fas fa-outdent"></i></li></ul></div></div><div class="right-bottom-side-tools"><div class="side-tools-container"><ul class="side-tools-list"><li class="tools-item tool-font-adjust-plus flex-center"><i class="fas fa-search-plus"></i></li><li class="tools-item tool-font-adjust-minus flex-center"><i class="fas fa-search-minus"></i></li><li class="tools-item tool-expand-width flex-center"><i class="fas fa-arrows-alt-h"></i></li><li class="tools-item tool-dark-light-toggle flex-center"><i class="fas fa-moon"></i></li><li class="tools-item tool-scroll-to-top flex-center"><i class="fas fa-arrow-up"></i></li><li class="tools-item tool-scroll-to-bottom flex-center"><i class="fas fa-arrow-down"></i></li></ul><ul class="tools-ul-1"><li class="tools-item tool-toggle-show flex-center"><i class="fas fa-cog fa-spin"></i></li></ul></div></div><aside class="page-aside"><div class="post-toc-wrap"><div class="post-toc"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6"><span class="nav-number">2.</span> <span class="nav-text">智能合约</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E7%A0%81"><span class="nav-number">2.1.</span> <span class="nav-text">链码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#namespace"><span class="nav-number">2.1.1.</span> <span class="nav-text">namespace</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E9%93%BE%E7%A0%81%E8%AE%BF%E9%97%AE"><span class="nav-number">2.1.2.</span> <span class="nav-text">同链码访问</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%A8%E9%93%BE%E7%A0%81%E8%AE%BF%E9%97%AE"><span class="nav-number">2.1.3.</span> <span class="nav-text">跨链码访问</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%91%BD%E5%90%8D"><span class="nav-number">2.2.</span> <span class="nav-text">命名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8"><span class="nav-number">2.3.</span> <span class="nav-text">使用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%A4%E6%98%93"><span class="nav-number">3.</span> <span class="nav-text">交易</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Context"><span class="nav-number">3.1.</span> <span class="nav-text">Context</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Stub"><span class="nav-number">3.1.1.</span> <span class="nav-text">Stub</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ClientIdentity"><span class="nav-number">3.1.2.</span> <span class="nav-text">ClientIdentity</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Transaction-handlers"><span class="nav-number">3.2.</span> <span class="nav-text">Transaction handlers</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%83%8C%E4%B9%A6%E7%AD%96%E7%95%A5"><span class="nav-number">4.</span> <span class="nav-text">背书策略</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E9%85%8D%E7%BD%AE"><span class="nav-number">5.</span> <span class="nav-text">连接配置</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Connection-Profile"><span class="nav-number">5.1.</span> <span class="nav-text">Connection Profile</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-1"><span class="nav-number">5.1.1.</span> <span class="nav-text">使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89"><span class="nav-number">5.1.2.</span> <span class="nav-text">定义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Connection-Options"><span class="nav-number">5.2.</span> <span class="nav-text">Connection Options</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-2"><span class="nav-number">5.2.1.</span> <span class="nav-text">使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%89%E9%A1%B9"><span class="nav-number">5.2.2.</span> <span class="nav-text">选项</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#wallet"><span class="nav-number">6.</span> <span class="nav-text">wallet</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B"><span class="nav-number">6.1.</span> <span class="nav-text">类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HSM"><span class="nav-number">6.1.1.</span> <span class="nav-text">HSM</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9E%84"><span class="nav-number">6.2.</span> <span class="nav-text">结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%96%B9%E5%BC%8F"><span class="nav-number">6.3.</span> <span class="nav-text">运行方式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Gateway"><span class="nav-number">7.</span> <span class="nav-text">Gateway</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#static"><span class="nav-number">7.1.</span> <span class="nav-text">static</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dynamic"><span class="nav-number">7.2.</span> <span class="nav-text">dynamic</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#multiple"><span class="nav-number">7.3.</span> <span class="nav-text">multiple</span></a></li></ol></li></ol></div></div></aside><div class="image-viewer-container"><div class="img-box"><img src=""></div></div></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fas fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fas fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.4/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.4/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.4/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.4/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.4/source/js/dark-light-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.4/source/js/local-search.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.4/source/js/left-side-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.4/source/js/code-copy.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.4/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.4/source/js/toc.js"></script></body></html>