<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><title>fabric | 魏洁杨</title><link rel="shortcut icon" href="/images/logo.svg"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.4/source/css/font-awesome.min.css"><script id="hexo-configurations">let KEEP=window.KEEP||{};KEEP.hexo_config={hostname:"jieyang-wei.github.io",root:"/",path:"search.json"},KEEP.theme_config={toc:{enable:!0,number:!0,expand_all:!0},style:{primary_color:"#0066CC",avatar:"/images/avatar.jpg",favicon:"/images/logo.svg",img_position:"left",left_side_width:"260px",content_max_width:"900px",hover:{shadow:!0,scale:!0},first_screen:{enable:!0,background_img:"/images/bg.svg",description:"Welcome to Wei jieyang's Blog"}},local_search:{enable:!0,trigger:"auto",unescape:!1,preload:!0},version:"3.0.4"},KEEP.language={search:"Search...",prev:"Prev",next:"Next",prev_posts:"Prev posts",next_posts:"Next posts",page:"Page %d",recent_posts:"Recent Posts",share:"Share",powered_by:"Powered by %s",theme:"Theme",rss_feed:"RSS Feed",category:"Category",categories:"Categories",tag:"Tag",tags:"Tags",tagcloud:"Tag Cloud",comment:"Comment",home:"Home",archive:"Archive",archives:"Archives",about:"About",site_uv:"Visitor Count",site_pv:"Totalview",links:"Links",link:"Link",top:"TOP",read_more:"Read more",wordcount:"Words",min2read:"Mins",changelog:"Changelog",copyright:{author:"Post author",title:"Post title",link:"Post link",create_time:"Create time",license_title:"Copyright Notice",license_content:"All articles in this blog are licensed under %s unless stating additionally."},ago:{second:"%s seconds ago",minute:"%s minutes ago",hour:"%s hours ago",day:"%s days age",week:"%s weeks age",month:"%s months age",year:"%s years age"}}</script><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="WeiJY's blog" type="application/atom+xml"></head><body><div class="page-container"><header class="page-header"><div class="header-progress"></div></header><main class="page-main"><div class="page-main-content"><div class="page-main-content-top"><header class="header-wrapper"><div class="header-content"><a class="logo-title" href="/">魏洁杨</a><ul class="menu-list"><li class="menu-item"><a href="/">HOME</a></li><li class="menu-item"><a href="/categories">CATEGORIES</a></li><li class="menu-item"><a href="/categories/notebook">NOTEBOOK</a></li><li class="menu-item"><a href="/about">ABOUT</a></li><li class="menu-item"><a href="/tags">TAGS</a></li></ul><div class="menu-bar"><div class="menu-bar-middle"></div></div></div><div class="header-drawer"><ul class="drawer-menu-list"><li class="drawer-menu-item flex-center"><a href="/">HOME</a></li><li class="drawer-menu-item flex-center"><a href="/categories">CATEGORIES</a></li><li class="drawer-menu-item flex-center"><a href="/categories/notebook">NOTEBOOK</a></li><li class="drawer-menu-item flex-center"><a href="/about">ABOUT</a></li><li class="drawer-menu-item flex-center"><a href="/tags">TAGS</a></li></ul></div><div class="window-mask"></div></header></div><div class="page-main-content-middle"><main class="main-content normal-code-theme"><div class="fade-in-down-animation"><div class="article-content-container"><div class="article-title"><span class="title-hover-animation">fabric</span></div><div class="article-header"><div class="avatar"><img src="/images/avatar.jpg"></div><div class="info"><div class="author"><span>Wei Jieyang</span> <span class="level">Lv2</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fas fa-calendar"></i> 2021-03-07 22:12:46 </span><span class="article-categories article-meta-item"><i class="fas fa-folder"></i><ul><li><a href="/categories/notebook/">notebook</a></li><li>&gt; <a href="/categories/notebook/blockchain/">blockchain</a></li><li>&gt; <a href="/categories/notebook/blockchain/fabric/">fabric</a></li></ul></span><span class="article-tags article-meta-item"><i class="fas fa-tags"></i><ul><li><a href="/tags/blockchain/">blockchain</a></li><li>| <a href="/tags/fabric/">fabric</a></li></ul></span><span class="article-wordcount article-meta-item"><i class="fas fa-file-word"></i> <span>6.9k Words</span> </span><span class="article-min2read article-meta-item"><i class="fas fa-clock"></i> <span>23 Mins</span> </span><span class="article-pv article-meta-item"><i class="fas fa-eye"></i> <span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content markdown-body"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>由IBM贡献的超级账本框架。它是一个利用现有成熟的技术来组合而成的一个区块链技术的实现。它是一种允许可插拔实现各种功能的的模块化架构。它具有强大的容器技术，来承载各种主流语言来编写的智能合约。</li><li>Fabric 是一个 Python (2.5-2.7) 的库和命令行工具，用来提高基于 SSH 的应用部署和系统管理效率<ul><li>一个让你通过 <strong>命令行</strong> 执行 <strong>无参数 Python 函数</strong> 的工具；</li><li>一个让通过 SSH 执行 Shell 命令更加<strong>容易</strong> 、 <strong>更符合 Python 风格</strong> 的命令库（建立于一个更低层次的库）。</li></ul></li></ul><ul><li>fabric和比特币与以太坊的最大的区别在于其身份识别能力，<strong>fabric是权限区块链</strong>，而后两者是匿名的非权限区块链</li></ul><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><strong>基本结构</strong>：</p><ul><li><img src="/2021/03/07/fabric/截屏2021-03-04 下午4.52.42-4848273.png" alt="截屏2021-03-04 下午4.52.42" style="zoom:35%"></li></ul><p><strong>资产 Assets</strong></p><ul><li>理解为任何具有货币价值的东西，它们都可以通过网络进行交易，无论是有形资产还是无形资产都属于资产，Hyperledger Fabric提供了使用链码交易修改资产的功能。</li><li>资产在Fabric中以<code>键-值对集合</code>的形式存在，在通道（Channel）中各本地账本可以对其状态提交变更</li><li>资产可以用<strong>二进制</strong>或<strong>JSON</strong>形式表示</li><li></li></ul><p><strong>账本 ledger</strong></p><ul><li>Hyperledger Fabric具有一个账本子系统，该子系统包括两个组件：<strong>世界状态</strong>和<strong>事务日志</strong>。</li><li>每个参与者都有一份账本到他们所属的每个Hyperledger Fabric网络的副本。</li><li>分类帐是世界状态数据库和事务日志历史记录的组合。</li></ul><p><strong>世界状态</strong></p><ul><li>版本号：从0开始，每当状态更新时版本号就递增。状态更新时会首先检查版本号，以确保当前状态的版本与背书时的版本一致（避免并发更新）</li><li>描述分类帐在给定时间点的状态。这是分类帐的<strong>数据库</strong>。</li></ul><p><strong>事务日志</strong></p><ul><li>记录所有导致当前世界状态值的事务；这是世界状态的<strong>更新历史</strong>。</li></ul><p><strong>分类账功能</strong></p><ul><li><p>分类帐是结构中<strong>所有状态转换</strong>的有序，防篡改记录。状态转换是参与方提交的链码调用（“交易”）的结果。每笔交易都会产生一组资产键值对，这些键值对会在创建，更新或删除时提交到分类账。</p></li><li><p>分类帐由一个<strong>区块链</strong>（“ chain”）和一个<strong>状态数据库</strong>组成，该区块链将不可变的顺序记录存储在块中，该状态数据库用于维护当前的结构状态。每个频道有一个分类帐。每个对等方都为其所属的每个通道维护一个分类帐的副本。</p></li></ul><p>Fabric分类帐的一些功能：</p><ul><li>使用基于键的查找，范围查询和组合键查询来查询和更新分类帐</li><li>使用丰富查询语言的只读查询（如果使用CouchDB作为状态数据库）</li><li>只读历史记录查询—查询密钥的分类帐历史记录，从而启用数据出处场景</li><li>事务包括以链码（读集）读取的键/值的版本和以链码（写集）写入的键/值的版本。</li><li>交易包含每个背书对等方的签名，并提交给订购服务</li><li>交易被分为几大块，并从订购服务“交付”到渠道上的对等方</li><li>对等方根据背书政策验证交易并执行政策</li><li>在附加块之前，执行版本检查，以确保自链码执行以来，已读取资产的状态未发生变化。</li><li>交易一旦经过验证并提交，便具有不变性</li><li>通道的分类帐包含一个配置块，用于定义策略，访问控制列表和其他相关信息</li><li>通道包含<a class="link" target="_blank" rel="noopener" href="https://hyperledger-fabric.readthedocs.io/en/latest/glossary.html#msp">成员资格服务提供程序<i class="fas fa-external-link-alt"></i></a>实例，允许从不同的证书颁发机构派生加密材料</li></ul><h2 id="区块结构"><a href="#区块结构" class="headerlink" title="区块结构"></a>区块结构</h2><ol><li><p><strong>区块头</strong>：包含三个属性（<strong>区块号</strong>、<strong>当前区块哈希</strong>、<strong>前一个区块的哈希</strong>），当一个区块被创建时写入。</p></li><li><p><strong>区块数据</strong>：包含的是<strong>排序后的交易列表</strong>。当区块被ordering service创建时写入。</p></li><li><p><strong>区块元数据</strong>：包括区块的<strong>写入时间</strong>，以及<strong>区块写入者的证书</strong>、<strong>公钥</strong>和<strong>签名。</strong></p></li></ol><p><strong>状态</strong></p><ul><li>整个区块链的状态可以看作是一个 versioned KVS（带有版本的 key-value store，类似于git仓库），这些kv通过chaincode（智能合约）进行更新，它只提供了put和get方法，所有的状态变更都有日志记录。</li></ul><h2 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h2><p>在fabric中指的就是对<strong>链代码（即智能合约）的操作</strong>，交易分为两种</p><ol><li><p><strong>部署交易（deploy transaction）</strong>：</p><ul><li>指的是<strong>创建新的链代码</strong>（chaincode），并且用一个程序作为参数，当一个部署交易成功执行时，链代码就被安装到区块链上了。</li></ul></li><li><p><strong>调用交易（invoke transaction）</strong>：</p><ul><li><p>指的是<strong>运行链代码</strong>，链代码执行时可能会修改相应的状态并返回输出。下图是一个交易的详细结构：</p><img src="/2021/03/07/fabric/15873283-087e0d4d80b57ca1.png" alt="15873283-087e0d4d80b57ca1" style="zoom:70%"><ul><li><strong>交易头 H4</strong>：包含交易的元数据，如<strong>链码名称、版本</strong>等</li><li><strong>交易签名 S4</strong>：包含由客户端应用程序创建的<strong>加密签名</strong>，作用是判断交易是否被篡改</li><li><strong>交易提案 P4</strong>：作用是对由应用程序提供给智能合约的输入参数进行编码。当智能合约运行时，提案<strong>负责将参数传递过去</strong></li><li><strong>交易响应 R4</strong>：是<strong>智能合约的输出</strong>，包含的是世界状态在交易前后的值，以读写集的形式展示。</li></ul></li></ul></li><li><p>其实还可能存在query transaction（v1版本加入）和cross-chaincode transaction（v1之后的版本会加入），此处不做讨论</p></li></ol><h3 id="交易流程"><a href="#交易流程" class="headerlink" title="交易流程"></a>交易流程</h3><p>前提假设是各节点已经提前颁发好证书，且已正常启动，并加入已经创建好的通道。此流程介绍的是在<strong>已经实例化了</strong>的链码通道上从发起一个<strong>调用交易到最终结账的全过程</strong>。</p><img src="/2021/03/07/fabric/截屏2021-03-14 上午10.43.57.png" alt="截屏2021-03-14 上午10.43.57" style="zoom:45%"><ol><li><strong>提交交易提案</strong><ul><li>应用程序（客户端节点）构造好<strong>交易提案</strong>（交易提案中包含本次交易要调用的<strong>合约标识</strong>、<strong>合约方法</strong>和<strong>参数信息</strong>以及<strong>客户端签名</strong>等）请求后，根据背书策略选择背书节点（多个）执行交易提案并进行背书签名。</li><li>背书节点是链代码中背书策略指定的节点。正常情况下背书节点执行后的结果是一致的，只有背书节点对结果的签名不一样。</li></ul></li><li><strong>模拟执行提案并进行背书</strong><ul><li>背书节点在收到交易提案后会进行一些验证，验证通过后，<strong>背书节点会根据当前账本数据模拟执行链码中的业务逻辑并生成读写集（RwSet）。</strong></li><li>模拟执行时不会更新账本数据。<strong>然后背书节点对这些读写集进行签名生成提案响应（proposal response）</strong>，然后返回给应用程序。</li></ul></li><li><strong>收集交易的背书</strong>（返回模拟执行结果）<ul><li>应用程序收到proposal response后会对背书节点的签名进行验证<strong>（所有节点接收到任何消息时都需要先验证消息的合法性）。</strong>如果链码只进行账本查询操作，应用程序只需要检查查询响应，并不会将交易提交给排序服务节点。如果链码对账本进行了invoke操作，则需要提交交易给排序服务进行账本更新（提交前会判断背书策略是否满足）。</li></ul></li><li><strong>构造交易请求并发送给排序服务节点</strong><ul><li>应用程序接收到所有背书节点的签名后，<strong>根据背书签名调用SDK生成交易，并广播给排序服务节点。</strong>其中生成交易的过程很简单，只需要确认所有背书节点的执行结果完全一致，再将<strong>交易提案</strong>、<strong>提案响应</strong>和<strong>背书签名</strong>打包生成交易即可。</li></ul></li><li><strong>排序服务节点对交易进行排序并生成区块</strong><ul><li>排序服务节点接收到网络中所有通道发出的交易信息，读取交易信封获取通道名称，按各个通道上交易的接收<strong>时间顺序</strong>对交易信息进行排序（多通道隔离），生成区块。（在这个过程中，排序服务节点不会关心交易是否正确，只是负责排序和打包。交易的有效性在第7步进行验证）</li></ul></li><li><strong>排序服务节点广播区块给主节点</strong><ul><li>排序服务节点生成区块后会广播给通道上不同组织的<strong>主节点</strong>。</li></ul></li><li><strong>记账节点验证区块内容并写入到账本</strong><ul><li>所有的peer节点都是记账节点，记录的是节点已加入通道的账本数据。记账节点接收到的排序服务节点生成的区块后，会<strong>验证区块交易的有效性</strong>，然后提交到本地账本并产生一个生成区块的事件，监听区块事件的应用程序会进行后续的处理。（如果接收的是配置区块，则会更新缓存的配置信息）</li></ul></li><li><strong>主节点在组织内部同步最新的区块</strong><ul><li>如果交易是无效的，也会更新区块，但不会更新世界状态。（<strong>区块存储的是操作语句，而世界状态存储的是被处理的数据</strong>）</li></ul></li></ol><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>区块链的通信实体，是一个逻辑概念，不同类型的多个节点可以运行在同一个物理服务器上。</p><ol><li><p><strong>客户端节点 client</strong></p><ul><li>客户端必须连接到某一个<strong>peer节点</strong>或<strong>排序服务节点</strong>上才能与区块链网络进行通信。</li></ul><ul><li>客户端<strong>向背书节点</strong>（endorser）<strong>提交交易提案</strong>（transaction proposal），当收集到足够背书后，<strong>向排序服务节点广播交易提案</strong>，进行排序，生成区块。</li></ul></li><li><p><strong>排序服务节点 orderer</strong></p><ul><li>接收包含背书签名的交易，对未打包的交易进行排序生成区块，广播给peer节点。</li></ul><ul><li>排序服务提供的是<strong>原子广播</strong>，保证同一个链上的节点接收到相同的信息，并且有相同的逻辑顺序。</li></ul><hr><p>orderer特性：</p><ol><li><strong>一致性</strong>：经过orderer deliver的交易，seqno一定时，blob和prevhash都一样</li><li><strong>hash链的完整性</strong>：对于deliver(seqno, hash0, blob0)和deliver(seqno-1, hash1, blob1)，HASH(seqno-1, hash1, blob1) == hash0</li><li><strong>不会凭空创造交易</strong>：每一次deliver，都是由于一次boardcast产生的。</li><li><strong>不会缺失交易</strong>：如果一个deliver(seqno, hash, blob)已经发生，那么一定有deliver(seqno-1, hash0, blob0) … deliver(0, default-hash, blob)</li><li><strong>不会重复交易</strong>：如果产生了两次 boardcast(blob)，boardcast(blob1)，则deliver(seqno1, hash, blob1)和deliver(seqno, hash0, blob)中，seqno1==seqno，<br>hash==hash0，blob==blob1</li></ol><hr></li><li><p><strong>CA节点：</strong></p><ul><li>fabric1.0的证书颁发机构，由服务器和客户端组成。</li></ul><ul><li>CA节点接收客户端的注册申请，返回注册密码用于用户登录，以便获取身份证书。</li><li>区块链上的所有操作都需要验证用户身份。</li></ul></li><li><p><strong>普通节点 peer</strong>：peer节点根据所承担的角色又可以分为记账节点（committer）、背书节点（endorser）、主节点（leader）和锚节点（anchor）。</p><hr><ul><li><strong>记账节点 Committer</strong><ul><li>所有的peer节点都是记账节点（committer）</li><li>负责<strong>验证排序服务节点区块里的交易</strong>，<strong>维护状态和总账（Ledger）的副本。</strong></li><li>该节点会定期从<strong>orderer节点</strong>获取包含交易的区块，在对这些区块进行核发验证之后，会把这些区块加入到区块链中。</li><li>记账节点无法通过配置文件配置，<strong>需要在当前客户端或者命令行发起交易请求的时候手动指定相关的committer节点</strong>。</li><li>记账节点可以有多个。</li></ul></li><li><strong>背书节点 endorser</strong><ul><li>部分节点还会<strong>执行交易并对结果进行签名背书</strong>，充当背书节点（endorser）的角色。</li><li>背书节点是<strong>动态</strong>的角色，是与具体链码绑定的。每个链码在实例化的时候都会设置<strong>背书策略</strong>，指定哪些节点对交易背书后交易才是有效的。</li><li>并且<strong>只有应用程序向它发起交易背书请求的时候才是背书节点</strong>，其他时候都是普通的记账节点，只负责验证交易并记账。</li><li>背书节点也无法通过配置文件指定，而是<strong>由发起交易请求的客户端指定</strong>。</li><li>背书节点可以有多个。</li></ul></li><li><strong>锚节点 anchor</strong><ul><li>锚节点主要<strong>负责代表组织和其他组织进行信息交换。</strong>每个组织都有一个锚节点，锚节点对于组织来说非常重要，如果锚节点出现问题，当前组织就会与其他组织失去联系。</li><li>锚节点的配置信息是<strong>在configtxgen模块的配置文件configtx.yaml中配置</strong>的。</li><li>锚节点只能有一个。</li></ul></li><li><strong>主节点 leader</strong><ul><li>能<strong>与排序服务节点通信</strong>，<strong>负责从排序服务节点获取最新的区块并在组织内部同步。</strong></li><li>主节点在整个组织中只能有一个。</li></ul></li></ul><hr></li></ol><h2 id="系统逻辑结构"><a href="#系统逻辑结构" class="headerlink" title="系统逻辑结构"></a>系统逻辑结构</h2><img src="/2021/03/07/fabric/15873283-70ae13534abcc893.png" alt="15873283-70ae13534abcc893" style="zoom:80%"><h4 id="org"><a href="#org" class="headerlink" title="org"></a>org</h4><ul><li>fabric系统是通过组织来划分的<strong>，每个组织内都有承担不同功能的peer节点，同时每个组织都有自己对应的fabric-ca服务器，fabric系统中所有的组织共用一个orderer集群。</strong></li><li>fabric中的组织在现实世界中可以是一个公司、一个企业，或者一个协会。在fabric中，组织是承担着数据信用责任的区块链系统参与方。</li><li>在设计一个fabric系统时，第一步就是要确定系统的参与方，然后从这些参与者中选出组织（生成对应的组织编号、域名、证书等），然后再确认组织的管理方式。组织的管理方式是指组织在遇到问题时的协作方式（如新组织的加入）。</li></ul><h4 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h4><ul><li>fabric的数据存储结构被设计成<strong>多账本体系</strong>，每个账本在fabric中被称为channel。每个channel中都有一个完全独立的账本。同一个channel中的所有peer节点都保存一份相同的数据。</li><li>通道由成员（组织）、每个成员的锚节点、账本、链码应用程序和排序服务节点定义。<ul><li>基本上，一个链由1个通道+ 1个账本+ N个成员组成</li></ul></li><li>网络上的每个交易都是在一个通道上执行的，在该通道上，每一方都必须经过身份验证和授权才能在该通道上进行交易。加入通道的每一个peer都有其自己的身份，由成员服务提供者（MSP）提供。</li></ul><h4 id="chaincode"><a href="#chaincode" class="headerlink" title="chaincode"></a>chaincode</h4><ul><li>链代码是一个按照一定规范实现的应用程序，运行于容器中，chaincode可以被安装到peer上，应用程序（客户端）通过发起交易请求，endsorer peer执行chaincode并进行签名，经过orderer的验证后，下发到对应的channel中，对账本进行更新。</li></ul><h4 id="PKI"><a href="#PKI" class="headerlink" title="PKI"></a>PKI</h4><p>Public Key Infrastructure，公钥基础结构</p><ul><li><p>Internet技术的集合，这些技术在网络中提供安全的通信。注意是PKI将 <strong>s</strong> 放入 <strong>https</strong> 中的</p></li><li><p>一种遵循标准的利用公钥加密技术为电子商务的开展提供一套安全基础平台的技术和规范。</p></li><li><p>底层采用P2P网络和gRPC协议实现对<strong>分布式账本结构的连通</strong>。通过Gossip协议<strong>进行状态同步、数据分发和成员探测。</strong></p></li></ul><p>公钥基础结构（PKI）的元素。PKI由证书颁发机构组成，证书颁发机构向各方（例如，服务的用户，服务提供商）颁发数字证书，然后由他们使用它们在环境中交换的消息中对自己进行身份验证。CA的证书吊销列表（CRL）构成了不再有效的证书的参考。吊销证书的原因有很多。例如，由于与证书关联的加密专用材料已被暴露，因此证书可能被吊销。</p><p>尽管区块链网络不只是通信网络，但它依赖于PKI标准来确保各种网络参与者之间的<strong>安全通信</strong>，并确保对发布在区块链上的消息进行正确的身份验证。因此，重要的是要了解PKI的基础知识，然后理解MSP为何如此重要。</p><p>PKI有四个关键要素：</p><ul><li><strong>数字证书</strong>：最常见的证书类型是符合<a class="link" target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/X.509">X.509标准<i class="fas fa-external-link-alt"></i></a>的证书，该证书允许在其结构中对参与方的标识详细信息进行编码。<ul><li>只要CA安全地保存某些密码信息（即其自己的<strong>专用签名密钥</strong>），任何阅读证书的人都可以确保有关证书所有人的信息未被篡改 - 它始终具有证书所有人的那些特定属性。</li><li>即可视证书为无法更改的数字身份证</li></ul></li><li><strong>公钥和私钥</strong>：份验证和消息完整性是安全通信中的重要概念</li><li><strong>证书颁发机构</strong>：为组织的参与者提供了可验证的数字身份提供了基础。<ul><li>CA的有两种形式：<strong>根CA</strong>和<strong>中间CA</strong>。</li><li>由于<strong>根CA</strong>（赛门铁克，Geotrust等）必须<strong>安全地</strong>向互联网用户<strong>分发</strong>数亿个证书，因此有必要将此过程<strong>分散到</strong>所谓的<strong>中间CA中</strong>。这些中间CA的证书由根CA或其他中间机构颁发，从而可以为链中任何CA颁发的任何证书建立“信任链”。</li><li>追溯到根CA的能力不仅可以扩展CA的功能，同时仍提供安全性-允许使用证书的组织放心地使用中间CA-它限制了根CA的暴露，如果受到损害，这将使根CA暴露危害整个信任链。另一方面，如果中级CA受到威胁，则风险会小得多。</li></ul></li><li><strong>证书吊销列表</strong>：只是CA已知由于某种原因而吊销的证书引用列表。CRL就像一张被盗信用卡的清单。</li></ul><h4 id="MSP"><a href="#MSP" class="headerlink" title="MSP"></a>MSP</h4><p>Membership Service Provider</p><ul><li>负责联盟链成员的证书管理，<strong>它定义了哪些RCA以及ICA在链里是可信任的</strong>，包括<strong>定义了channel上的合作者。</strong></li><li>每个组织都有自己的证书管理（CA）及MSP，CA给每个peer颁发证书，MSP授权，赋予相应权限策略。</li><li>对于peer和client来说，对于交易的结果和交易本身，都需要进行授权</li><li>Peer ，applications，end users, administrators orders 必须拥有CA和MSP才能访问链网。</li></ul><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p>Hyperledger Fabric 项目中，目前可以支持的状态数据库有两种：</p><ol><li><p>LevelDB：LevelDB 是嵌入在 Peer 中的默认键值对（key-value）状态数据库。</p></li><li><p>CouchDB：CouchDB 是一种可选的替代 levelDB 的状态数据库。与 LevelDB 键值存储一样，CouchDB 不仅可以根据 key 进行相应的查询，<strong>还可以根据不同的应用场景需求实现复杂查询。</strong></p></li></ol><h1 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h1><p>fabric的底层主要由四种服务构成，分别是：身份服务、策略服务、区块链服务、智能合约服务。在这些基础服务之上，通过一些API、SDK、CLI为上层业务应用提供一些可以编程的接口服务。</p><p><img src="/2021/03/07/fabric/20180523213138295.png" alt="20180523213138295"></p><h2 id="身份服务"><a href="#身份服务" class="headerlink" title="身份服务"></a>身份服务</h2><p>首先明确一点，fabric和比特币与以太坊的最大的区别在于其身份识别能力，<strong>fabric是权限区块链</strong>，而后两者是匿名的非权限区块链。明确这一点后，fabric的身份识别主要表现在fabric的账本中的各类事件个交易中，参与者和对象都具有明确的身份信息。这些信息主要包括参与者的组织、验证者、交易者，账本中的资产和智能合约，以及系统组件包括网络和服务器、运行环境等等这些信息。验证者在fabric网络建立的时候就可以确定参加交易的权限级别。</p><h2 id="策略服务"><a href="#策略服务" class="headerlink" title="策略服务"></a>策略服务</h2><h2 id="区块链服务"><a href="#区块链服务" class="headerlink" title="区块链服务"></a>区块链服务</h2><h2 id="智能合约服务"><a href="#智能合约服务" class="headerlink" title="智能合约服务"></a>智能合约服务</h2><h1 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h1><ul><li><strong>chaincode：</strong> 链码，Fabric的<strong>智能合约</strong>写在链码里并在区块链外部应用程序要和账本发生交易的时候被外部应用程序调用。<ul><li>在大多数情况下，链码只和账本的数据库组件（<strong>世界状态</strong>）交互，而不和交易日志交互。</li></ul></li></ul><ul><li><strong>账本</strong>：Fabric有一个账本子系统包含两个组件：<strong>世界状态和交易日志</strong>。每一个参与者有一份他们参与的每个Fabric网络的账本的副本。<ul><li>世界状态组件描述了一个给定时间点的账本状态。它是账本的数据库，存储的是<strong>账本当前值</strong>。</li><li>交易日志组件记录所有导致世界状态当前值的交易。<strong>它是世界状态的更新历史</strong>。这样，账本就是世界状态数据库和交易日志历史的组合体。</li></ul></li></ul><h1 id="共识机制"><a href="#共识机制" class="headerlink" title="共识机制"></a>共识机制</h1><p>Fabric区块链的网络节点本质上是<strong>互相复制的状态机</strong>，节点之间需要保持相同的账本状态。为了实现分布式节点的一致性，各个节点需要<strong>通过共识过程，对账本状态的变化达成一致性的认同。</strong></p><p><strong>共识过程</strong></p><img src="/2021/03/07/fabric/15873283-02a9f2f1bb4d0bfd.png" alt="15873283-02a9f2f1bb4d0bfd" style="zoom:55%"><ol><li><strong>背书（endorsement）阶段</strong><ul><li><strong>背书节点</strong>对客户端发来的交易提案进行<strong>合法性校验</strong>，然后模拟执行链码得到交易结果，最后根据设定的背书逻辑判断是否支持该交易提案。如果背书逻辑决定支持交易提案，会把交易提案签名后发回给客户端。</li><li>客户端通常需要根据链码的<strong>背书策略</strong>，向一个或者多个成员的背书节点发出背书请求。背书策略会定义需要哪些节点背书交易才有效，例如需要5个成员的背书节点中至少3个同意；或者某个特殊身份的成员支持等。</li><li>客户端只有在收集<strong>足够多</strong>的背书节点的交易提案签名，交易才能被视为有效。</li></ul></li><li><strong>排序（ordering）阶段</strong><ul><li>由<strong>排序服务节点对</strong>交易进行排序，确定交易之间的时序关系。排序服务把一段时间内收到的交易进行排序，然后把排序后的批量交易<strong>打包成数据块</strong>（区块），再把区块<strong>广播</strong>给通道中的成员。</li><li>采用<strong>排序共识</strong>方式，各个成员收到的是一组发生顺序相同的交易，从而保证了所有节点的<strong>数据一致性。</strong>目前，Hyperledger Fabric有三种交易排序算法：Solo、Kafka、SBFT。<ol><li><strong>Solo</strong>：只有一个排序服务节点负责接收交易信息并排序，是最简单的一种排序算法，一般用于开发测试环境中。Solo共识模式属于<strong>中心化的处理</strong>方式，<strong>不支持</strong>拜占庭容错。</li><li><strong>Kafka</strong>：Kafka是Apache的一个开源项目，主要提供分布式的消息处理／分发服务，每个Kafka集群由多个服务节点组成。Hyperledger Fabric利用Kafka对交易信息进行排序处理，提供高吞吐、低延时的处理能力，并且在集群内部<strong>支持节点故障容错，但不支持拜占庭容错。</strong></li><li><strong>SBFT</strong>：简单拜占庭算法，<strong>支持拜占庭容错的可靠排序算法，包括容忍节点故障以及一定数量的恶意节点。</strong></li><li>排序服务是共识机制中重要的一环，所有交易都要通过排序服务的排序才可以达成全网共识，因此排序服务要避免成为网络上的性能瓶颈。</li></ol></li></ul></li><li><strong>校验（Validation）阶段</strong><ul><li>节点对排序后的交易进行一系列的检验，包括<strong>交易数据的完整性</strong>检查、是否<strong>重复交易</strong>、背书签名<strong>是否符合背书策略</strong>的要求、交易的<strong>读写集是否符合MVCC</strong>（Multiversion Concurrency Control，多版本并发控制）的校验等。</li><li>当交易通过了所有校验后，将被标注为合法并写入账本中。因为所有的确认节点都按照相同的顺序检验交易，并且把合法的交易依次写入账本中，因此不同确认节点的状态能够始终保持一致。</li></ul></li></ol><h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><p>Kafka共识模块是可以用于生产环境的，它可以支持崩溃容错， 但无法对抗恶意攻击。</p><ul><li>多个排序节点通过Kafka实现<strong>同步</strong>， 而Kafka本身并不是排序节点，它只是将排序节点通过流连接起来</li></ul><p>Kafka本质上是一个消息处理系统，它使用的是经典的<strong>发布-订阅模型</strong>。消息的消费者订阅特定的主题，以便收到新消息的通知，生产者则负责消息的发布。</p><p>在fabric中的<strong>运行逻辑</strong>：</p><ul><li>对于每一条链，都有一个对应的分区</li><li>每个链对应一个单一的分区主题</li><li>排序节点负责将来自特定链的交易（通过广播RPC接收）中继到对应的分区</li><li>排序节点可以读取分区并获得在所有排序节点间达成一致的排序交易列表</li><li>一个链中的交易是定时分批处理的，也就是说当一个新的批次的第一个交易进来时，开始计时</li><li>当交易达到最大数量时或超时后进行批次切分，生成新的区块</li><li>定时交易是另一个交易，由上面描述的定时器生成</li><li>每个排序节点为每个链维护一个本地日志，生成的区块保存在本地账本中</li><li>交易区块通过分发RPC返回客户端</li><li>当发生崩溃时，可以利用不同的排序节点分发区块，因为所有的排序节点都维护有本地日志</li></ul><h3 id="崩溃容错"><a href="#崩溃容错" class="headerlink" title="崩溃容错"></a>崩溃容错</h3><p><strong>崩溃容错机制</strong>：通过在多个Kafka代理之间<strong>复制分区</strong>来实现的。因此如果一个代理由于软件或硬件故障挂掉，数据也不会丢失。</p><p><strong>领导-跟随机制</strong>：领导者持有分区， 跟随者则进行分区的复制。当领导者挂掉后，会有某个跟随者转变为新的领导者。</p><p><strong>注意</strong>：虽然在Hyperledger Fabric中Kafka被称为共识（Consensus），但是其核心是交易排序服务以及额外的崩溃容错能力。</p><h3 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h3><p>zookeeper是一个分布式key-value存储库，通常用于存储元数据及集群机制的实现。</p><p>zookeeper 允许服务（Kafka代理）的客户端订阅变化并获得实时通知。这就是代理如何确定应当使用哪个分区领导者的原因。</p><p>zookeeper有超强的故障容错能力，因此Kafka的运行严重依赖于它。</p><p>在zookeeper中存储的元数据包括：</p><ul><li>消费者分组在每个分区的读取偏移量</li><li>访问控制清单，用于访问授权与限制</li><li>生产者及消费者配额，每秒最多消息数量</li><li>分区领导者及健康信息</li></ul></div><div class="post-copyright-info"><div class="article-copyright-info-container"><ul><li>Post title：fabric</li><li>Post author：Wei Jieyang</li><li>Create time：2021-03-07 22:12:46</li><li>Post link：https://jieyang-wei.github.io/2021/03/07/fabric/</li><li>Copyright Notice：All articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> unless stating additionally.</li></ul></div></div><div class="article-nav"><div class="article-prev"><a class="prev" rel="prev" href="/2021/03/08/ssh%E8%AF%81%E4%B9%A6%E7%99%BB%E9%99%86/"><span class="left arrow-icon flex-center"><i class="fas fa-chevron-left"></i> </span><span class="title flex-center"><span class="post-nav-title-item">ssh证书登陆</span> <span class="post-nav-item">Prev posts</span></span></a></div><div class="article-next"><a class="next" rel="next" href="/2021/03/04/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8/"><span class="title flex-center"><span class="post-nav-title-item">区块链应用</span> <span class="post-nav-item">Next posts</span> </span><span class="right arrow-icon flex-center"><i class="fas fa-chevron-right"></i></span></a></div></div></div></div></main></div><div class="page-main-content-bottom"><footer class="footer"><div class="info-container"><div class="copyright-info info-item">&copy; <span>2020</span> - 2021 <i class="fas fa-heart icon-animate"></i> <a href="/">Wei Jieyang</a></div><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="website-count info-item"><span id="busuanzi_container_site_uv">Visitor Count <span id="busuanzi_value_site_uv"></span>&ensp; </span><span id="busuanzi_container_site_pv">Totalview <span id="busuanzi_value_site_pv"></span></span></div><div class="theme-info info-item">Powered by <a target="_blank" href="https://hexo.io">Hexo</a> | Theme <a class="theme-version" target="_blank"></a></div></div></footer></div></div></main><div class="sidebar-tools"><div class="tools-container"><ul class="tools-list"><li class="search popup-trigger"><i class="fas fa-search"></i></li><li class="tools-item page-aside-toggle"><i class="fas fa-outdent"></i></li></ul></div></div><div class="right-bottom-side-tools"><div class="side-tools-container"><ul class="side-tools-list"><li class="tools-item tool-font-adjust-plus flex-center"><i class="fas fa-search-plus"></i></li><li class="tools-item tool-font-adjust-minus flex-center"><i class="fas fa-search-minus"></i></li><li class="tools-item tool-expand-width flex-center"><i class="fas fa-arrows-alt-h"></i></li><li class="tools-item tool-dark-light-toggle flex-center"><i class="fas fa-moon"></i></li><li class="tools-item tool-scroll-to-top flex-center"><i class="fas fa-arrow-up"></i></li><li class="tools-item tool-scroll-to-bottom flex-center"><i class="fas fa-arrow-down"></i></li></ul><ul class="tools-ul-1"><li class="tools-item tool-toggle-show flex-center"><i class="fas fa-cog fa-spin"></i></li></ul></div></div><aside class="page-aside"><div class="post-toc-wrap"><div class="post-toc"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">2.</span> <span class="nav-text">基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%BA%E5%9D%97%E7%BB%93%E6%9E%84"><span class="nav-number">2.1.</span> <span class="nav-text">区块结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%A4%E6%98%93"><span class="nav-number">2.2.</span> <span class="nav-text">交易</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%A4%E6%98%93%E6%B5%81%E7%A8%8B"><span class="nav-number">2.2.1.</span> <span class="nav-text">交易流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8A%82%E7%82%B9"><span class="nav-number">2.3.</span> <span class="nav-text">节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="nav-number">2.4.</span> <span class="nav-text">系统逻辑结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#org"><span class="nav-number">2.4.0.1.</span> <span class="nav-text">org</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#channel"><span class="nav-number">2.4.0.2.</span> <span class="nav-text">channel</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#chaincode"><span class="nav-number">2.4.0.3.</span> <span class="nav-text">chaincode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PKI"><span class="nav-number">2.4.0.4.</span> <span class="nav-text">PKI</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MSP"><span class="nav-number">2.4.0.5.</span> <span class="nav-text">MSP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">2.4.0.6.</span> <span class="nav-text">数据库</span></a></li></ol></li></ol></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1"><span class="nav-number">3.</span> <span class="nav-text">服务</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BA%AB%E4%BB%BD%E6%9C%8D%E5%8A%A1"><span class="nav-number">3.1.</span> <span class="nav-text">身份服务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AD%96%E7%95%A5%E6%9C%8D%E5%8A%A1"><span class="nav-number">3.2.</span> <span class="nav-text">策略服务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E6%9C%8D%E5%8A%A1"><span class="nav-number">3.3.</span> <span class="nav-text">区块链服务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E6%9C%8D%E5%8A%A1"><span class="nav-number">3.4.</span> <span class="nav-text">智能合约服务</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6"><span class="nav-number">4.</span> <span class="nav-text">智能合约</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6"><span class="nav-number">5.</span> <span class="nav-text">共识机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Kafka"><span class="nav-number">5.1.</span> <span class="nav-text">Kafka</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B4%A9%E6%BA%83%E5%AE%B9%E9%94%99"><span class="nav-number">5.1.1.</span> <span class="nav-text">崩溃容错</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#zookeeper"><span class="nav-number">5.1.2.</span> <span class="nav-text">zookeeper</span></a></li></ol></li></ol></li></div></div></aside><div class="image-viewer-container"><div class="img-box"><img src=""></div></div></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fas fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fas fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.4/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.4/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.4/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.4/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.4/source/js/dark-light-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.4/source/js/local-search.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.4/source/js/left-side-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.4/source/js/code-copy.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.4/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.4/source/js/toc.js"></script></body></html>