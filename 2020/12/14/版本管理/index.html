<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><title>版本管理 | 魏洁杨</title><link rel="shortcut icon" href="/images/logo.svg"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.4/source/css/font-awesome.min.css"><script id="hexo-configurations">let KEEP=window.KEEP||{};KEEP.hexo_config={hostname:"jieyang-wei.github.io",root:"/",path:"search.json"},KEEP.theme_config={toc:{enable:!0,number:!0,expand_all:!0},style:{primary_color:"#0066CC",avatar:"/images/avatar.jpg",favicon:"/images/logo.svg",img_position:"left",left_side_width:"260px",content_max_width:"900px",hover:{shadow:!0,scale:!0},first_screen:{enable:!0,background_img:"/images/bg.svg",description:"Welcome to Wei jieyang's Blog"}},local_search:{enable:!0,trigger:"auto",unescape:!1,preload:!0},version:"3.0.4"},KEEP.language={search:"Search...",prev:"Prev",next:"Next",prev_posts:"Prev posts",next_posts:"Next posts",page:"Page %d",recent_posts:"Recent Posts",share:"Share",powered_by:"Powered by %s",theme:"Theme",rss_feed:"RSS Feed",category:"Category",categories:"Categories",tag:"Tag",tags:"Tags",tagcloud:"Tag Cloud",comment:"Comment",home:"Home",archive:"Archive",archives:"Archives",about:"About",site_uv:"Visitor Count",site_pv:"Totalview",links:"Links",link:"Link",top:"TOP",read_more:"Read more",wordcount:"Words",min2read:"Mins",changelog:"Changelog",copyright:{author:"Post author",title:"Post title",link:"Post link",create_time:"Create time",license_title:"Copyright Notice",license_content:"All articles in this blog are licensed under %s unless stating additionally."},ago:{second:"%s seconds ago",minute:"%s minutes ago",hour:"%s hours ago",day:"%s days age",week:"%s weeks age",month:"%s months age",year:"%s years age"}}</script><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="WeiJY's blog" type="application/atom+xml"></head><body><div class="page-container"><header class="page-header"><div class="header-progress"></div></header><main class="page-main"><div class="page-main-content"><div class="page-main-content-top"><header class="header-wrapper"><div class="header-content"><a class="logo-title" href="/">魏洁杨</a><ul class="menu-list"><li class="menu-item"><a href="/">HOME</a></li><li class="menu-item"><a href="/categories">CATEGORIES</a></li><li class="menu-item"><a href="/categories/notebook">NOTEBOOK</a></li><li class="menu-item"><a href="/about">ABOUT</a></li><li class="menu-item"><a href="/tags">TAGS</a></li></ul><div class="menu-bar"><div class="menu-bar-middle"></div></div></div><div class="header-drawer"><ul class="drawer-menu-list"><li class="drawer-menu-item flex-center"><a href="/">HOME</a></li><li class="drawer-menu-item flex-center"><a href="/categories">CATEGORIES</a></li><li class="drawer-menu-item flex-center"><a href="/categories/notebook">NOTEBOOK</a></li><li class="drawer-menu-item flex-center"><a href="/about">ABOUT</a></li><li class="drawer-menu-item flex-center"><a href="/tags">TAGS</a></li></ul></div><div class="window-mask"></div></header></div><div class="page-main-content-middle"><main class="main-content normal-code-theme"><div class="fade-in-down-animation"><div class="article-content-container"><div class="article-title"><span class="title-hover-animation">版本管理</span></div><div class="article-header"><div class="avatar"><img src="/images/avatar.jpg"></div><div class="info"><div class="author"><span>Wei Jieyang</span> <span class="level">Lv2</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fas fa-calendar"></i> 2020-12-14 15:55:40 </span><span class="article-categories article-meta-item"><i class="fas fa-folder"></i><ul><li><a href="/categories/notebook/">notebook</a></li></ul></span><span class="article-tags article-meta-item"><i class="fas fa-tags"></i><ul><li><a href="/tags/linux/">linux</a></li><li>| <a href="/tags/git/">git</a></li></ul></span><span class="article-wordcount article-meta-item"><i class="fas fa-file-word"></i> <span>4.9k Words</span> </span><span class="article-min2read article-meta-item"><i class="fas fa-clock"></i> <span>18 Mins</span> </span><span class="article-pv article-meta-item"><i class="fas fa-eye"></i> <span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content markdown-body"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h3 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h3><ol><li><p><strong>本地版本控制系统</strong>（Version Control Systems，简称VCS）</p><ul><li><p>大多都是采用某种简单的数据库来记录文件的历次更新差异</p></li><li><p>最流行的：<code>RCS</code></p><ul><li>工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，可以重新计算出各个版本的文件内容。”</li></ul></li></ul></li><li><p><strong>集中化版本控制系统</strong>（Centralized Version Control Systems，简称 CVCS ）</p><ul><li>诸如CVS、Subversion以及perforce等</li><li>容易单点故障、丢失所有历史更新记录的风险</li></ul></li><li><p><strong>分布式版本控制系统</strong>（Distributed Version Control System，简称 DVCS）</p><ul><li>像Git、Mercurial、Bazaar以及Darcs</li><li>客户端并不只提取最新版本的文件快照， 而是把代码仓库完整地镜像下来，包括完整的历史记录</li></ul></li></ol><ul><li>大部分系统以文件变更列表的方式存储信息，这类系统（CVS、Subversion、Perforce、Bazaar等）将他们存储的信息看作是一组基本文件和每个文件随时间逐步累积的差异（**基于差异[delta-based]**的版本控制）</li><li>Git 更像是把数据看作是对<strong>小型文件系统</strong>的一系列快照。 在 Git 中，每当你提交更新或保存项目状态时，它基本上就会对当时的全部文件创建一个快照并保存这个快照的索引。 为了效率，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 <strong>快照流</strong></li></ul><p><strong>git</strong>：分布式版本控制系统，c语言开发</p><p><strong>免费集中式版本控制</strong>：CVS、SVN — 速度慢，且需要联网</p><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p><a class="link" target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">廖雪峰<i class="fas fa-external-link-alt"></i></a></p><p>电子书：progit_v2.1.54</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>git校验和机制</strong>：<strong>SHA-1散列</strong>，这是一个由 40 个十六进制字符（0-9 和 a-f）组成的字符串，基于 Git 中文件的内容或目录结构计算出来</p><h4 id="三种状态"><a href="#三种状态" class="headerlink" title="三种状态"></a>三种状态</h4><ul><li><strong>已提交（committed）</strong>：表示数据已经安全地保存在本地数据库中</li><li><strong>已修改（modified）</strong>：表示修改了文件，但还没保存到数据库中</li><li><strong>已暂存（staged）</strong>：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中</li></ul><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/截屏2020-12-09 下午2.58.04.png" alt="截屏2020-12-07 下午3.29.20"><ul><li>工作区：对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改</li><li>暂存区：是一个文件，保存了下次将要提交的文件列表信息，一般在 Git 仓库目录中。 按照 Git 的术语叫做“索引”，不过一般说法还是叫“暂存区</li><li>git目录：Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，复制的就是这里的数据</li></ul><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><ol><li>在工作区中修改文件。</li><li>将你想要下次提交的更改选择性地暂存，这样只会将更改的部分添加到暂存区。</li><li>提交更新，找到暂存区的文件，将快照永久性存储到 Git 目录。</li></ol><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install git-all</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看版本</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git --version</span></span><br></pre></td></tr></table></figure><p>工具目录结构</p><ul><li>git自带一个<code>git config</code>的工具来帮助设置，这些变量存储在三个不同的位置</li></ul><ol><li>/etc/gitconfig 文件：包含系统上每一个用户及他们仓库的通用配置。 如果在执行 git config 时带上 –system 选项，那么它就会读写该文件中的配置变量。 （由于它是系统配置文件，因此你需要管理员或超级用户权限来修改它。）</li><li>~/.gitconfig 或 ~/.config/git/config 文件：只针对当前用户。 你可以传递 –global 选项让 Git 读写此文件，这会对你系统上所有的仓库生效</li><li>当前使用仓库的 Git 目录中的 config 文件（即 .git/config）：针对该仓库。 你可以传递 –local 选项让 Git 强制读写此文件，虽然默认情况下用的就是它。。 （当然，你需要进入某个 Git 仓库中才能让该选项生效。）<ul><li>每一个级别会覆盖上一级别的配置，所以 .git/config 的配置变量会覆盖 /etc/gitconfig 中的配置变量</li></ul></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --list --show-origin  <span class="comment"># 查看所有配置以及他们所在文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置用户信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.name <span class="string">&quot;Weijieyang&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.email <span class="string">&quot;name@mail.com&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> git config 选项列表</span></span><br><span class="line"> * --list 列出所有 Git 当时能找到的配置</span><br><span class="line"> * --global 配置所有的项目</span><br></pre></td></tr></table></figure><ul><li>git工作目录下每一个文件只有两种状态<ol><li><strong>已跟踪</strong>：指那些被纳入了版本控制的文件，在上一次快照中有它们的记录。即git已经知道的文件</li><li><strong>未跟踪</strong>：其他文件</li></ol></li></ul><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="版本库（Repository）"><a href="#版本库（Repository）" class="headerlink" title="版本库（Repository）"></a>版本库（Repository）</h3><p>工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。</p><p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</p><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/截屏2020-12-07 下午3.29.20.png" alt="截屏2020-12-07 下午3.29.20" style="zoom:50%"><ol><li><strong>创建版本库</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br></pre></td></tr></table></figure><ul><li>到需要版本管理的目录下</li><li>初始化后会在目录下形成一个<code>.git</code>文件，此文件为隐藏文件，需要使用命令<code>ls -a</code>查看</li></ul><ol start="2"><li><strong>使用步骤</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add file</span> </span><br></pre></td></tr></table></figure><ul><li>添加本地修改后的文件到暂存区</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"> * -s/--short 更为紧凑的输出展示效果</span><br></pre></td></tr></table></figure><ul><li>时刻掌握仓库当前情况，查看未被提交的修改，包括工作区和暂存区</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&#x27;注释&#x27;</span></span></span><br></pre></td></tr></table></figure><ul><li>将暂存区的修改提交到版本库中</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&#x27;注释&#x27;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add filemore</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend</span></span><br></pre></td></tr></table></figure><ul><li>第一次提交后发现漏了几个文件，可以使用<code>--amend</code>添加，此次提交将会替代上一次的提交，上一次的提交将不会出现在版本历史中ß</li></ul><ol start="3"><li><strong>版本管理</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line"> * —-pretty=onelines pretty可以指定不同于默认格式的方式展示历史</span><br><span class="line"> 		* onelines 输出消息更简洁，最前面是每个版本的commit id（用SHA1计算）</span><br><span class="line"> 		* format:&quot;%h - %an, %ar : %s&quot; 定制记录的显示格式</span><br><span class="line"> 		* 还有short、full和fuller</span><br><span class="line"> 		</span><br><span class="line"> * -p/--patch 显示每次提交所引入的差异（按 补丁 的格式输出）</span><br><span class="line"> * --stat 每次提交的简略统计信息</span><br><span class="line"> * --shortstat 只显示 --stat 中最后的行数修改添加移除统计</span><br><span class="line"> * --name-only 仅在提交信息后显示已修改的文件清单</span><br><span class="line"> * --name-status 显示新增、修改、删除的文件清单</span><br><span class="line"> * --graph 查看分支合并图，在日志旁以 ASCII 图形显示分支与合并历</span><br><span class="line"> * --abbrev-commit 查看详细的合并信息，仅显示 SHA-1 校验和所有 40 个字符中的前几个字符</span><br><span class="line"> * --relative-data 使用较短的相对时间而不是完整格式显示日期（比如“2 weeks ago”）</span><br></pre></td></tr></table></figure><ul><li>显示从最近到最远的提交日志</li><li><strong>format</strong>格式设置：<ul><li><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/截屏2020-12-09 下午3.39.00.png" alt="截屏2020-12-09 下午3.39.00" style="zoom:33%"></li><li><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/截屏2020-12-09 下午3.39.17.png" alt="截屏2020-12-09 下午3.39.17" style="zoom:33%"></li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git last</span></span><br></pre></td></tr></table></figure><ul><li>查看最后一次提交</li></ul><p><strong>取消暂存 reset</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard HEAD^</span> </span><br></pre></td></tr></table></figure><ul><li>回退到前一个版本<ul><li><code>HEAD</code>：相当于一个指针，指向<code>master</code>，而<code>master</code>指向提交</li><li><code>^</code>：是上一个版本，<code>^^</code>：前两个的版本，<code>HEAD～100</code>：往上100个版本</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard commitId</span></span><br></pre></td></tr></table></figure><ul><li>回退到版本号为<code>commitId</code>的版本</li><li><strong>注意</strong>：<code>--hard</code> 是一个危险的选项</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rerset HEAD &lt;file&gt;</span></span><br></pre></td></tr></table></figure><ul><li>撤销暂存区(unstage)的修改回退到工作区</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reflog</span></span><br><span class="line">e475afc HEAD@&#123;1&#125;: reset: moving to HEAD^</span><br><span class="line">1094adb (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: append GPL</span><br><span class="line">e475afc HEAD@&#123;3&#125;: commit: add distributed</span><br><span class="line">eaadf4e HEAD@&#123;4&#125;: commit (initial): wrote a readme file</span><br></pre></td></tr></table></figure><ul><li>记录了你的每一次命令，可以用来找已经撤销掉的版本id</li></ul><ol start="4"><li><strong>其他操作</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff file</span></span><br></pre></td></tr></table></figure><ul><li>查看修改内容，<code>diff</code>均是未提交的内容</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff --staged</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看已暂存文件和最后一次提交的文件差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff --cached</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看已经暂存起来的变化（--staged和--cached是同义词）</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff HEAD -- file</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看工作区和版本库里面最新版本的区别</span></span><br></pre></td></tr></table></figure><p><strong>撤销操作 checkout</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -- &lt;file&gt;</span></span><br></pre></td></tr></table></figure><ul><li>撤销上一次修改，回到最近一次git commit或者git add状态，不管是在工作区还是在暂存区<ul><li>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</li><li>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</li><li>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考<a class="link" target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192">版本回退<i class="fas fa-external-link-alt"></i></a>一节，不过前提是没有推送到远程库。</li></ul></li></ul><p><strong>删除文件 rm</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rm file</span></span><br></pre></td></tr></table></figure><ul><li>通过rm删除了文件之后，status会告诉删除信息，因为删除也算是修改操作（deleted： file）</li><li>在本地目录中删除文件之后可以选择彻底删除或者使用git恢复<ol><li>彻底删除：<code>$ git rm file</code>— 在暂存区中删除，<code>$ git commit</code> — 确定要在版本库中删除<ul><li>(如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失<strong>最近一次提交后你修改的内容</strong>。)</li></ul></li><li>恢复：<code>$ git checkout --file</code><ul><li>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</li></ul></li></ol></li></ul><p><strong>改名操作 mv</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git mv old new</span></span><br><span class="line">---- 相当于 ----</span><br><span class="line"><span class="meta">$</span><span class="bash"> mv old new</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm old</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add new</span></span><br></pre></td></tr></table></figure><p><strong>忽略文件</strong></p><p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。在这种情况下，我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件的模式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat .gitignore</span></span><br><span class="line">*～      # 忽略所有名字以～结尾的文件（通常是副本文件）</span><br><span class="line">*.[oa]   # 忽略以.o .a 结尾的文件</span><br><span class="line">!lib.a.  # 忽略.a文件，但跟踪所有 lib.a 文件</span><br><span class="line">/TODO    # 只忽略当前目录下的 TODO 文件</span><br><span class="line">build/   # 忽略任何目录下名为 build 的文件夹</span><br><span class="line">doc/*.txt    #忽略doc下的txt，但不忽略doc/server/a.txt</span><br><span class="line">doc/**/*.pdf #忽略doc及其子目录下的所有pdf文件</span><br></pre></td></tr></table></figure><p>格式规范：</p><ul><li>所有空行或者以 # 开头的行都会被 Git 忽略。</li><li>可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。</li><li>匹配模式可以以（/）开头防止递归。</li><li>匹配模式可以以（/）结尾指定目录。</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上叹号（!）取反。</li></ul><h3 id="远程仓库（github）"><a href="#远程仓库（github）" class="headerlink" title="远程仓库（github）"></a>远程仓库（github）</h3><ol><li><strong>创建电脑用户自己的密钥</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen -t rsa -C <span class="string">&quot;youremail@example.com&quot;</span></span></span><br><span class="line"> * -t 指定密钥类型，默认是 rsa ，可以省略。</span><br><span class="line"> * -C 设置注释文字，比如邮箱。</span><br><span class="line"> * -f 指定密钥文件存储文件名.</span><br></pre></td></tr></table></figure><ul><li>在用户主目录<code>/home/username</code>下创建密钥</li><li>生成<code>id_rsa</code>和<code>id_rsa.pub</code></li></ul><ol start="2"><li><strong>绑定电脑用户和github用户</strong></li></ol><ul><li>将公钥<code>id_rsa.pub</code>加载到github网站上<code>Add SSH Key</code></li></ul><ol start="3"><li><strong>添加远程仓库</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote add origin git@github-link</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote -v</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote show &lt;remote&gt;    <span class="comment"># 查看摸一个远程仓库的更多信息</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote rename old new   <span class="comment"># 给远程仓库改名</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote remove name      <span class="comment"># 删除远程仓库，及所有跟踪分支和配置信息</span></span></span><br></pre></td></tr></table></figure><ul><li>链接本地仓库和github上创建的远程仓库</li><li><code>origin</code>为远程仓库的默认名字，可自行更改</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push -u origin mymaster:master</span></span><br></pre></td></tr></table></figure><ul><li>将本地仓库的内容推送到远程仓库上，实际上是把当前分支master推送到远程</li><li><code>-u</code>：如果当前分支与多个主机存在追踪关系，则可以使用 -u 参数指定一个默认主机，这样后面就可以不加任何参数使用<code>git push</code><ul><li>不指定<code>mymaster</code>：将会删除远程的<code>master</code>分支，这相当于是push了一个空分支到<code>master</code></li><li>不指定<code>:master</code>：默认推送到与<code>mymaster</code>有追踪关系的分支，一般为同名分支，没有的话会在远程建一个（<code>git remote show &lt;origin&gt;</code>查看各个分支的追踪关系）</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull origin master:mymaster</span></span><br></pre></td></tr></table></figure><ul><li>提交远程之前，最好先将远程仓库的文件拉取下来，再<code>push</code>，以免造成冲突</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git fetch &lt;remote&gt; &lt;remote branchname&gt;:&lt;your branchname&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 不指定远程分支将会默认为‘default’分支（一般为master）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 不给本地分支命名的话，会自动默认指针 FETCH_HEAD</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者使用远程分支名 origin/master 指定fetch的分支</span></span><br></pre></td></tr></table></figure><ul><li>他与pull一样，就拉取远程仓库中有但你没有的文件（不要拉取到当前所在分支）</li><li>不同的是，fetch并不会自动合并或修改你当前的工作，更安全。 当准备好时你必须手动将其合并入你的工作。</li><li><strong>pull = fetch + merge (FETCH_HEAD)</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git fetch origin</span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge origin/<span class="string">&#x27;default&#x27;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 拉取远程默认分支到本地当前分支上，再与远程的默认分支合并</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git fetch origin master:mymaster-tmp</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge mymaster-tmp</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 建议建一个专用存放fetch的分支tmp，拉去下来文件后，再与myaster来merge</span></span><br></pre></td></tr></table></figure><p><strong><code>FETCH_HEAD</code></strong></p><ul><li>某个branch在服务器上的最新状态.</li><li>每一个执行过fetch操作的项目都会存在一个FETCH_HEAD列表,这个列表保存在 <code>.git/FETCH_HEAD</code> 文件中, 其中每一行对应于远程服务器的一个分支.当前分支指向的FETCH_HEAD, 就是这个文件第一行对应的那个分支</li><li>一般来说, 存在两种情况:<ul><li>如果没有显式的指定<code>远程分支</code>, 则远程分支的<code>master</code>将作为默认的<code>FETCH_HEAD</code>.</li><li>如果指定了<code>远程分支</code>, 就将这个远程分支作为<code>FETCH_HEAD</code>.</li></ul></li></ul><p><strong><code>–rebase</code></strong></p><ul><li>作用是取消掉本地库中刚刚的commit，并把他们接到更新后的版本库之中。</li></ul><ol start="4"><li><strong>克隆远程仓库</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> git@github-link</span></span><br></pre></td></tr></table></figure><ul><li>如果远程仓库已有文件，可以将其克隆到本地的空仓库中</li></ul><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p><code>master</code>：主分支</p><p><code>HEAD</code>：指向当前分支，即指向<code>master</code></p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul><li><strong>新建<code>dev</code>分支</strong>：现在修改东西就是<code>dev</code>指针移动了，而<code>HEAD</code>指向当前的<code>dev</code>分支<ul><li>此时修改<code>dev</code>分支，<code>master</code>分支将不会改变</li></ul></li></ul><p><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/3DEC42CC-E46F-4939-ACAA-33BD4B3F88B2.png" alt="3DEC42CC-E46F-4939-ACAA-33BD4B3F88B2" style="zoom:67%"><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/截屏2020-12-07 下午4.12.29.png" alt="截屏2020-12-07 下午4.12.29" style="zoom:33%"></p><ul><li><strong>合并分支</strong>：改改指针的问题<ul><li>将<code>dev</code>分支合并到<code>master</code>上，右图为不使用<code>Fast-Forward</code>快进模式时（–no-ff）</li></ul></li></ul><p><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/69B01EAC-0670-4DED-85A9-A41465FCBF3C.png" alt="69B01EAC-0670-4DED-85A9-A41465FCBF3C" style="zoom:67%"><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/B0212A11-D318-457F-9943-E5FCD27820B4.png" alt="B0212A11-D318-457F-9943-E5FCD27820B4" style="zoom:67%"></p><ul><li><strong>删除分支</strong>：将dev指针给删掉就行了</li></ul><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/9CA8FECF-51AB-438D-86D7-59846BF675C9.png" alt="9CA8FECF-51AB-438D-86D7-59846BF675C9" style="zoom:80%"><h4 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h4><ul><li>创建分支：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout (-b) dev</span></span><br><span class="line"> * -b 创建并切换分支</span><br><span class="line">-------------------------</span><br><span class="line"><span class="meta">$</span><span class="bash"> git switch (-c) dev</span></span><br><span class="line"> * -c 创建并切换分支</span><br></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch dev     //创建分支(会创建一个和当前分支有一样内容的分支)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout/switch dev   //切换分支</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br><span class="line">* dev</span><br><span class="line">  master</span><br></pre></td></tr></table></figure><ul><li>查看当前分支，当前分支上会加上<code>*</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -d dev</span></span><br></pre></td></tr></table></figure><ul><li>删除分支dev</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br><span class="line"> * -vv 将所有的本地分支列出来并且包含更多的信息</span><br><span class="line"> * -r 查看远程所有分支</span><br><span class="line"> * -a 查看本地和远程的所有分支</span><br><span class="line"> * &lt;branchname&gt; 新建分支</span><br><span class="line"> * -d -r &lt;branchname&gt; 删除远程分支，删除后还需要推送到服务器</span><br><span class="line"> * -m old new 重命名分支</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch --set-upstream-to origin/branchname</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch --set-upstream-to=origin/branchname  branchname</span></span><br></pre></td></tr></table></figure><ul><li>修改<code>pull</code>时的远程分支关联<ul><li>upstream：将当前分支推送到其上游分支（ tracking &gt;是不推荐的同义词对于上游）</li><li>current：将当前分支推送到同名分支</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git merge dev</span>   </span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge --no-ff -m <span class="string">&quot;merge with no-ff” dev</span></span> </span><br></pre></td></tr></table></figure><ul><li>合并分支到当前分支（如：将<code>dev</code>上的工作结果合并到<code>master</code>上）</li><li>注：两个分支分别都修改了文件的冲突情况下，需要进行手动更改冲突<ul><li>一般合并分支会在<code>Fast Forward</code>模式，但此模式下删除分支，会丢失掉分支信息；</li><li>如果要强制禁用<code>Fast Forward</code>模式，Git就会在<code>merge</code>时生成一个新的<code>commit</code>，这样，从分支历史上就可以看出分支信息。</li><li><code>--no-ff</code>方式的git merge：看的出原来发生过合并，而merge看不出</li></ul></li></ul><ul><li><strong>分支策略</strong>：<ul><li>master：最稳定的，用来发布版本；</li><li>dev：不稳定，所有人将自己的修改合并到这个分支上</li></ul></li></ul><p><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/FD4949A7-CB58-4BD1-B887-3A833E23A7DD.png" alt="FD4949A7-CB58-4BD1-B887-3A833E23A7DD"></p><p>修改bug：创建新的分支进行修改，修改后合并到dev上，但是因为commit是一次提交所有的暂存区，所以需要将现在在写的，不需要提交的先用stash指令存储起来</p><p>git stash：将当前工作现场存储起来，等以后恢复现场工作后继续使用，此时git status非常的干净</p><p>查看：git stash list</p><p>恢复：git stash apply - 恢复后不删除stash中的内容，需要用 git stash drop 来删除</p><p>​ git stash pop - 恢复的同时删除</p><p>​ git stash apply stash@{0}：恢复指令的stash</p><p>feature分支</p><p>每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分</p><p>强行删除未合并的分支：git branch -D<file></file></p><h3 id="标签设置"><a href="#标签设置" class="headerlink" title="标签设置"></a>标签设置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出标签</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag -l <span class="string">&quot;v1.8.5&quot;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -l/-list 指定需要某些标签，如上只输出 v1.8.5 系列的</span></span><br></pre></td></tr></table></figure><h4 id="标签类型"><a href="#标签类型" class="headerlink" title="标签类型"></a><strong>标签类型</strong></h4><ol><li><strong>轻量标签（lightweight）</strong>：像一个不会改变的分支，它只是某个提交的引用</li><li><strong>附注标签（annotated）</strong>：是存储在git数据库的一个完整对象，它可以被校验，其中包含打标签者的名字、电子邮件、地址、日期时间，此外还有一个标签信息，并且可以使用GNU Privacy Guard（GPG）签名并验证</li></ol><h4 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a><strong>创建标签</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag -a v1.4 -m <span class="string">&quot;指定一条标签信息&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 轻量只用指定标签名字</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag v1.4</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 给历史版本打标签</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag -a v1.4 commitId</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git show v1.4</span></span><br></pre></td></tr></table></figure><ul><li>查看标签信息和与之对应的提交信息，如果是轻量标签则只会有提交信息</li></ul><h4 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a><strong>删除标签</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag -d v1.4</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin :refs/tags/v1.4</span></span><br></pre></td></tr></table></figure><ul><li>本地删除标签后并不会在远程仓库移除，需要执行第二条指令</li><li>将冒号前面的空值推送到远程标签名，从而高效地删除它</li><li>或者使用下面的方式更直观的删除</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin --delete &lt;tagname&gt;</span></span><br></pre></td></tr></table></figure><h4 id="共享标签"><a href="#共享标签" class="headerlink" title="共享标签"></a><strong>共享标签</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin v1.4</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin --tags</span></span><br></pre></td></tr></table></figure><ul><li><p>在创建完标签后你必须显式地推送标签到共享服务器上</p></li><li><p>–tags：这将会把所有不在远程仓库服务器上的标签全部传送到那里</p></li></ul><h4 id="检出标签"><a href="#检出标签" class="headerlink" title="检出标签"></a><strong>检出标签</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout 2.0.0</span></span><br></pre></td></tr></table></figure><ul><li>查看某个标签所指向的文件版本，但这会是你的仓库处于“分离头指针（detached HEAD）”的状态<ul><li>此状态如果你做了某些更改然后提交它们，标签不会发生变化， 但你的新提交将不属于任何分支，并且将无法访问，除非通过确切的提交哈希才能访问。 因此，如果你需要进行更改，比如你要修复旧版本中的错误，那么通常需要创建一个新分支<code>$ git checkout -b version2 v2.0.0</code></li></ul></li></ul><h3 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h3><h1 id="SVM"><a href="#SVM" class="headerlink" title="SVM"></a>SVM</h1><p>阿斯顿</p></div><div class="post-copyright-info"><div class="article-copyright-info-container"><ul><li>Post title：版本管理</li><li>Post author：Wei Jieyang</li><li>Create time：2020-12-14 15:55:40</li><li>Post link：https://jieyang-wei.github.io/2020/12/14/版本管理/</li><li>Copyright Notice：All articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> unless stating additionally.</li></ul></div></div><div class="article-nav"><div class="article-prev"><a class="prev" rel="prev" href="/2020/12/14/%E5%8C%BA%E5%9D%97%E9%93%BE/"><span class="left arrow-icon flex-center"><i class="fas fa-chevron-left"></i> </span><span class="title flex-center"><span class="post-nav-title-item">区块链</span> <span class="post-nav-item">Prev posts</span></span></a></div><div class="article-next"><a class="next" rel="next" href="/2020/12/12/hello-world/"><span class="title flex-center"><span class="post-nav-title-item">Hello World</span> <span class="post-nav-item">Next posts</span> </span><span class="right arrow-icon flex-center"><i class="fas fa-chevron-right"></i></span></a></div></div></div></div></main></div><div class="page-main-content-bottom"><footer class="footer"><div class="info-container"><div class="copyright-info info-item">&copy; <span>2020</span> - 2021 <i class="fas fa-heart icon-animate"></i> <a href="/">Wei Jieyang</a></div><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="website-count info-item"><span id="busuanzi_container_site_uv">Visitor Count <span id="busuanzi_value_site_uv"></span>&ensp; </span><span id="busuanzi_container_site_pv">Totalview <span id="busuanzi_value_site_pv"></span></span></div><div class="theme-info info-item">Powered by <a target="_blank" href="https://hexo.io">Hexo</a> | Theme <a class="theme-version" target="_blank"></a></div></div></footer></div></div></main><div class="sidebar-tools"><div class="tools-container"><ul class="tools-list"><li class="search popup-trigger"><i class="fas fa-search"></i></li><li class="tools-item page-aside-toggle"><i class="fas fa-outdent"></i></li></ul></div></div><div class="right-bottom-side-tools"><div class="side-tools-container"><ul class="side-tools-list"><li class="tools-item tool-font-adjust-plus flex-center"><i class="fas fa-search-plus"></i></li><li class="tools-item tool-font-adjust-minus flex-center"><i class="fas fa-search-minus"></i></li><li class="tools-item tool-expand-width flex-center"><i class="fas fa-arrows-alt-h"></i></li><li class="tools-item tool-dark-light-toggle flex-center"><i class="fas fa-moon"></i></li><li class="tools-item tool-scroll-to-top flex-center"><i class="fas fa-arrow-up"></i></li><li class="tools-item tool-scroll-to-bottom flex-center"><i class="fas fa-arrow-down"></i></li></ul><ul class="tools-ul-1"><li class="tools-item tool-toggle-show flex-center"><i class="fas fa-cog fa-spin"></i></li></ul></div></div><aside class="page-aside"><div class="post-toc-wrap"><div class="post-toc"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2"><span class="nav-number">1.0.1.</span> <span class="nav-text">发展历史</span></a></li></ol></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#Git"><span class="nav-number">2.</span> <span class="nav-text">Git</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">2.1.</span> <span class="nav-text">简介</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="nav-number">2.1.0.1.</span> <span class="nav-text">三种状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">2.1.0.2.</span> <span class="nav-text">工作流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%89%E8%A3%85"><span class="nav-number">2.1.0.3.</span> <span class="nav-text">安装</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C"><span class="nav-number">2.2.</span> <span class="nav-text">操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%88%E6%9C%AC%E5%BA%93%EF%BC%88Repository%EF%BC%89"><span class="nav-number">2.2.1.</span> <span class="nav-text">版本库（Repository）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%EF%BC%88github%EF%BC%89"><span class="nav-number">2.2.2.</span> <span class="nav-text">远程仓库（github）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86"><span class="nav-number">2.2.3.</span> <span class="nav-text">分支管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%90%86"><span class="nav-number">2.2.3.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C-1"><span class="nav-number">2.2.3.2.</span> <span class="nav-text">操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E7%AD%BE%E8%AE%BE%E7%BD%AE"><span class="nav-number">2.2.4.</span> <span class="nav-text">标签设置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E7%AD%BE%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.2.4.1.</span> <span class="nav-text">标签类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%A0%87%E7%AD%BE"><span class="nav-number">2.2.4.2.</span> <span class="nav-text">创建标签</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E6%A0%87%E7%AD%BE"><span class="nav-number">2.2.4.3.</span> <span class="nav-text">删除标签</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E6%A0%87%E7%AD%BE"><span class="nav-number">2.2.4.4.</span> <span class="nav-text">共享标签</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A3%80%E5%87%BA%E6%A0%87%E7%AD%BE"><span class="nav-number">2.2.4.5.</span> <span class="nav-text">检出标签</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E5%9F%BA"><span class="nav-number">2.2.5.</span> <span class="nav-text">变基</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SVM"><span class="nav-number">3.</span> <span class="nav-text">SVM</span></a></li></div></div></aside><div class="image-viewer-container"><div class="img-box"><img src=""></div></div></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fas fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fas fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.4/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.4/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.4/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.4/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.4/source/js/dark-light-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.4/source/js/local-search.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.4/source/js/left-side-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.4/source/js/code-copy.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.4/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.4/source/js/toc.js"></script></body></html>