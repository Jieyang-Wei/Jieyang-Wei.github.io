<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WeiJY&#39;s blog</title>
  
  
  <link href="https://jieyang-wei.github.io/atom.xml" rel="self"/>
  
  <link href="https://jieyang-wei.github.io/"/>
  <updated>2021-02-02T07:11:33.903Z</updated>
  <id>https://jieyang-wei.github.io/</id>
  
  <author>
    <name>Wei Jieyang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>WebSocket</title>
    <link href="https://jieyang-wei.github.io/2021/01/25/WebSocket/"/>
    <id>https://jieyang-wei.github.io/2021/01/25/WebSocket/</id>
    <published>2021-01-25T06:37:08.000Z</published>
    <updated>2021-02-02T07:11:33.903Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>WebSocket API 是 HTML5 标准的一部分， 但这并不代表 WebSocket 一定要用在 HTML 中，或者只能在基于浏览器的应用程序中使用。</p><p>实际上，许多语言、框架和服务器都提供了 WebSocket 支持：</p><ul><li>基于 <strong>C</strong> 的 libwebsocket.org</li><li>基于 <strong>Node.js</strong> 的 Socket.io</li><li>基于 <strong>Python</strong> 的 ws4py</li><li>基于 <strong>C++</strong> 的 WebSocket++</li><li><strong>Apache</strong> 对 WebSocket 的支持： Apache Module mod_proxy_wstunnel</li><li><strong>Nginx</strong> 对 WebSockets 的支持： NGINX as a WebSockets Proxy 、 NGINX Announces Support for WebSocket Protocol 、WebSocket proxying</li><li><strong>lighttpd</strong> 对 WebSocket 的支持：mod_websocket</li></ul><h2 id="nodejs"><a href="#nodejs" class="headerlink" title="nodejs"></a>nodejs</h2><h2 id="java"><a href="#java" class="headerlink" title="java"></a>java</h2><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><p>c++下没有原生的websocket低矮用，但是可以使用一些开源库实现，如<a class="link" href="https://download.csdn.net/download/weixin_34196559/10750141">websocketpp<i class="fas fa-external-link-alt"></i></a>等，下面讲解的是socket通信相关的实现</p><h3 id="IOS"><a href="#IOS" class="headerlink" title="IOS"></a>IOS</h3><p><a class="link" href="https://blog.csdn.net/xuqiang918/article/details/16841343?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-10&spm=1001.2101.3001.4242">IOS网络通信<i class="fas fa-external-link-alt"></i></a></p><p><a class="link" href="https://github.com/ok-fine/Socket-Cpp.git">代码 - master分支<i class="fas fa-external-link-alt"></i></a></p><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p><code>sockaddr</code>和<code>sockaddr_in</code>在字节长度上都为16个BYTE，可以进行转换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 通用的socket地址 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span>&#123;</span>  </span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> sa_family;    <span class="comment">//2 </span></span><br><span class="line">  <span class="keyword">char</span> sa_data[<span class="number">14</span>];            <span class="comment">//14</span></span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Internet socket */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>&#123;</span></span><br><span class="line">  <span class="keyword">short</span> <span class="keyword">int</span> sin_family;        <span class="comment">//2</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> sin_port; <span class="comment">//2</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>     <span class="comment">//4</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="number">8</span>];   <span class="comment">//8</span></span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 表示32位的IPv4地址 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span> u_char s_b1,s_b2,s_b3,s_b4; &#125; S_un_b;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span> u_short s_w1,s_w2; &#125; S_un_w;</span><br><span class="line">    u_long S_addr; </span><br><span class="line">  &#125; S_un;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> s_addr  S_un.S_addr</span></span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 或者 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>&#123;</span></span><br><span class="line">  <span class="keyword">in_addr_t</span> s_addr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>**inet_addr(“192.168.0.1”)**：将一个点分制的IP地址(如192.168.0.1)转换为上述结构中需要的32位二进制方式的IP地址</li></ul><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line"><span class="keyword">int</span> server_socket = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>domain</strong>（IOS系统使用 <code>AT_</code> ）<ul><li>PF_UNIX          Unix IPC通信 </li><li>PF_INET           IPV4通信（默认）</li><li>PF_INET6         IPV6 </li><li>PF_IPX              Novell IPX </li><li>PF_NETLINK    Kernel用户接口驱动程序 </li><li>PF_X25             X.25 </li><li>PF_AX25          AX.25 </li><li>PF_ATMPVC    ATM PVC </li><li>PF_APPLETALK    AppleTalk协议 </li><li>PF_PACKET     低级包接口 </li></ul></li><li><strong>type</strong><ul><li>SOCK_STREAM          使用TCP面向连接的通信包（默认）</li><li>SOCK_DGRAM           使用UDP无连接的通信包</li><li>SOCK_SEQPACKET    使用有固定最大长度的面向连接的通信包 </li><li>SOCK_RAW                 使用原IP包 </li><li>SOCK_RDM                 使用不保证次序的可靠数据报 </li></ul></li><li><strong>Protocol</strong><ul><li>一般使用与type对应的默认协议，用0表示。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recv</span><span class="params">(SOCKET socket, <span class="keyword">char</span> *buf, <span class="keyword">int</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="keyword">char</span> recv_msg[<span class="number">1024</span>];</span><br><span class="line">bzero(recv_msg, <span class="number">1024</span>);</span><br><span class="line"><span class="keyword">long</span> byte_num = recv(client_socket, recv_msg, <span class="number">1024</span>, <span class="number">0</span>);</span><br><span class="line">recv_msg[byte_num] = <span class="string">&#x27;\0&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>参数：<ul><li><strong>socket</strong>：已建立连接的套接字；</li><li><strong>buf</strong>：存放接收到的数据的缓冲区指针；</li><li><strong>len</strong>：buf的长度</li><li><strong>flags</strong>：调用方式： <ul><li><strong>0</strong>：接收的是正常数据，无特殊行为。 </li><li><strong>MSG_PEEK</strong>：系统缓冲区数据复制到提供的接收缓冲区，但是系统缓冲区内容并没有删除。 </li><li><strong>MSG_OOB</strong>：表示处理带外数据。 </li></ul></li></ul></li><li>返回值：接收成功时返回接收到的数据长度，连接结束时返回0，连接失败时返回SOCKET_ERROR。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">send</span><span class="params">(SOCKET socket, <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> len, <span class="keyword">int</span> flags)</span></span></span><br><span class="line">char send_msg[1024];</span><br><span class="line">bzero(send_msg, <span class="number">1024</span>);</span><br><span class="line">send(client_socket, send_msg, <span class="number">1024</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><ul><li>参数<ul><li><strong>socket</strong>：已建立连接的套接字</li><li><strong>buf</strong>：存放将要发送的数据的缓冲区指针；</li><li><strong>len</strong>：发送缓冲区中的字符数</li><li><strong>flags</strong>：控制数据传输方式： <ul><li><strong>0</strong>：接收的是正常数据，无特殊行为。 </li><li><strong>MSG_DONTROUTE</strong>：表示目标主机就在本地网络中，无需路由选择。 </li><li><strong>MSG_OOB</strong>：表示处理带外数据。 </li></ul></li></ul></li><li>返回值：发送成功时返回发送的数据长度，连接结束时返回0，连接失败时返回SOCKET_ERROR。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">bzero</span><span class="params">(<span class="keyword">void</span> *s, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="keyword">char</span> msg[<span class="number">1024</span>];</span><br><span class="line">bzero(msg, <span class="number">1024</span>);  </span><br><span class="line"><span class="comment">/* 相当于 */</span></span><br><span class="line"><span class="built_in">memset</span>(msg, <span class="number">0</span>, <span class="number">1024</span>);</span><br></pre></td></tr></table></figure><ul><li>头文件：#include &lt;string.h&gt;</li><li>功能：置字节字符串s的前n个字节为零且包括‘\0’</li><li>描述：<ul><li>string.h曾经是posix标准的一部分，但是在POSIX.1-2001标准里面，这些函数被标记为了遗留函数而不推荐使用。在POSIX.1-2008标准里已经没有这些函数了。推荐使用<code>memset</code>替代<code>bzero</code>。</li><li>bzero函数TC和VC中都没有，gcc中提供了</li></ul></li><li>无返回值</li></ul><blockquote><p>使用无阻塞的I/O方法 </p><p>什么是阻塞?<br>比如使用recv(),如果函数接受不到数据，就会阻塞程序的继续执行。 </p><p>如何防止阻塞?<br>使用fcntl()函数，把套接字设置为无阻塞模式。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">int</span> newsocket; </span><br><span class="line">&gt;newsocket = socket(PF_INET, SOCK_STREAM, <span class="number">0</span> ); </span><br><span class="line">&gt;fcntl( newsocket, F_SETEL, O_NONBLOCK ); </span><br></pre></td></tr></table></figure><p>以后使用recv()就不会阻塞了。 </p><p>另一种方式是使用多路套接字<code>select()</code> </p></blockquote><h5 id="select"><a href="#select" class="headerlink" title="select"></a>select</h5><p>select这个系统调用，是一种多路复用IO方案，可以同时对多个文件描述符进行监控，从而知道哪些<a class="link" href="https://blog.csdn.net/test1280/article/details/80293294">文件描述符(File Descriptor，FD)<i class="fas fa-external-link-alt"></i></a>可读，可写或者出错，不过select方法是阻塞的，可以设定超时时间。 </p><p>select使用的步骤如下:</p><ol><li>创建一个<code>fd_set</code>变量（fd_set实为包含了一个整数数组的结构体），用来存放所有的待检查的文件描述符</li><li>清空<code>fd_set</code>变量，并将需要检查的所有文件描述符加入<code>fd_set</code></li><li>调用select。若返回-1，则说明出错;返回0,则说明超时，返回正数，则为发生状态变化的文件描述符的个数</li><li>若select返回大于0,则依次查看哪些文件描述符变的可读，并对它们进行处理</li><li>返回步骤2，开始新一轮的检测</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfd, fd_set *rdset, fd_set *wrset, fd_set *exset, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>参数：<ul><li>maxfd：需要监视的最大的文件描述符值+1；</li><li>rdset：需要检测的可读文件描述符的集合</li><li>wrset：可写文件描述符的集合</li><li>exset：异常文件描述符的集合</li><li>timeval：用于描述一段时间长度，如果在这个时间内，需要监视的描述符没有事件发生则函数返回，返回值为0。</li></ul></li></ul><p><code>fd_set</code>类型通过下面四个宏来操作：</p><ol><li><code>FD_ZERO(fd_set *fdset);</code>将指定的文件描述符集清空，在对文件描述符集合进行设置前，必须对其进行初始化，如果不清空，由于在系统分配内存空间后，通常并不作清空处理，所以结果是不可知的。</li><li><code>FD_SET(fd_set *fdset);</code>用于在文件描述符集合中增加一个新的文件描述符。</li><li><code>FD_CLR(fd_set *fdset);</code>用于在文件描述符集合中删除一个文件描述符。 </li><li><code>FD_ISSET(int fd, fd_set *fdset);</code>用于测试指定的文件描述符是否在该集合中。</li></ol><h5 id="kqueue"><a href="#kqueue" class="headerlink" title="kqueue"></a>kqueue</h5><p>Mac是基于BSD的内核，所使用的是kqueue（kernel event notification mechanism，详细内容可以Mac中 <code>man 2 kqueue</code>）</p><ul><li>kqueue比select先进的地方就在于使用<strong>事件触发</strong>的机制，且其调用无需每次对所有的文件描述符进行遍历，返回的时候只返回需要处理的事件，而不像select中需要自己去一个个通过FD_ISSET检查。</li><li>kqueue默认的触发方式是level 水平触发，可以通过设置event的flag为<code>EV_CLEAR</code> 使得这个事件变为边沿触发,可能epoll的触发方式无法细化到单个event，需要查证。</li><li></li></ul><p>kqueue中涉及两个系统调用，kqueue()和kevent()</p><ul><li><code>kqueue()</code>创建kernel级别的事件队列，并返回队列的文件描述符</li><li><code>kevent()</code>往事件队列中加入订阅事件，或者返回相关的事件数组</li></ul><p>kqueue使用的流程一般如下：</p><ul><li>创建kqueue</li><li>创建<code>struct kevent</code>变量（注意这里的kevent是结构体类型名），可以通过<code>EV_SET</code>这个宏提供的快捷方式进行创建</li><li>通过kevent系统调用将创建好的kevent结构体变量加入到kqueue队列中，完成对指定文件描述符的事件的订阅</li><li>通过kevent系统调用获取满足条件的事件队列，并对每一个事件进行处理</li></ul><h4 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h4><img src="/2021/01/25/WebSocket/1.png" alt="截屏2021-01-31 下午2.57.07" style="zoom:45%;"> <p><strong>1. sever</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 绑定server socket的ip、端口等信息 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">server_addr.sin_len = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">server_addr.sin_family = AF_INET;<span class="comment">//Address families AF_INET互联网地址簇</span></span><br><span class="line">server_addr.sin_port = htons(<span class="number">11332</span>);</span><br><span class="line">server_addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">bzero(&amp;(server_addr.sin_zero),<span class="number">8</span>);</span><br></pre></td></tr></table></figure><ul><li><p>一般情况下都用<code>server_addr.sin_addr.s_addr = htonl(INADDR_ANY)</code></p><blockquote><p>比如你的机器有三个ip<br> 192.168.1.1<br> 202.202.202.202<br> 61.1.2.3  </p><p> 如果你serv.sin_addr.s_addr=inet_addr(“192.168.1.1”);  </p><p> 然后监听100端口  </p><p> 这时其他机器只有connect  192.168.1.1:100端口才能成功。<br> connect  202.202.202.202:100和connect  61.1.2.3:100都会失败。  </p><p> 如果serv.sin_addr.s_addr=htonl(INADDR_ANY);  的话，无论连接哪个ip都可以连上的，这就是为什么这样选择的理由</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* server socket工作流程 */</span></span><br><span class="line"><span class="comment">//创建socket</span></span><br><span class="line"><span class="keyword">int</span> server_socket = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);<span class="comment">//SOCK_STREAM 有连接</span></span><br><span class="line"><span class="keyword">if</span> (server_socket == <span class="number">-1</span>) &#123;</span><br><span class="line">  perror(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//绑定socket</span></span><br><span class="line"><span class="comment">//将创建的socket绑定到本地的IP地址和端口，此socket是半相关的，只是负责侦听客户端的连接请求，并不能用于和客户端通信</span></span><br><span class="line"><span class="keyword">int</span> bind_result = bind(server_socket, (struct sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line"><span class="keyword">if</span> (bind_result == <span class="number">-1</span>) &#123;</span><br><span class="line">  perror(<span class="string">&quot;bind error&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//listen侦听</span></span><br><span class="line"><span class="comment">//第一个参数是套接字</span></span><br><span class="line"><span class="comment">//第二个参数为等待接受的连接的队列的大小，在connect请求过来的时候,完成三次握手后先将连接放到这个队列中，直到被accept处理。如果这个队列满了，且有新的连接的时候，对方可能会收到出错信息。</span></span><br><span class="line"><span class="keyword">if</span> (listen(server_socket, <span class="number">5</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">  perror(<span class="string">&quot;listen error&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//accept接收来自客户端的链接请求(使用下面的select不需要这一部分)</span></span><br><span class="line"><span class="comment">//返回的client_socket为一个全相关的socket，其中包含client的地址和端口信息，通过client_socket可以和客户端进行通信。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>;</span></span><br><span class="line"><span class="keyword">socklen_t</span> address_len;</span><br><span class="line"><span class="keyword">int</span> client_socket = accept(server_socket, (struct sockaddr *)&amp;client_address, &amp;address_len);</span><br><span class="line"><span class="keyword">if</span> (client_socket == <span class="number">-1</span>) &#123;</span><br><span class="line">  perror(<span class="string">&quot;accept error&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 信息交流 */</span></span><br><span class="line">fd_set server_fd_set;</span><br><span class="line"><span class="keyword">int</span> max_fd = <span class="number">-1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">tv.tv_sec = <span class="number">20</span>;  <span class="comment">// seconds</span></span><br><span class="line">tv.tv_usec = <span class="number">0</span>;  <span class="comment">// microseconds</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">  FD_ZERO(&amp;server_fd_set);</span><br><span class="line">  <span class="comment">//标准输入</span></span><br><span class="line">  FD_SET(STDIN_FILENO, &amp;server_fd_set);</span><br><span class="line">  <span class="keyword">if</span> (max_fd &lt; STDIN_FILENO) &#123;</span><br><span class="line">    max_fd = STDIN_FILENO;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//服务器端socket</span></span><br><span class="line">  FD_SET(server_sock_fd, &amp;server_fd_set);</span><br><span class="line">  <span class="keyword">if</span> (max_fd &lt; server_sock_fd) &#123;</span><br><span class="line">    max_fd = server_sock_fd;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//客户端连接</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CONCURRENT_MAX; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (client_fds[i]!=<span class="number">0</span>) &#123;</span><br><span class="line">      FD_SET(client_fds[i], &amp;server_fd_set);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (max_fd &lt; client_fds[i]) &#123;</span><br><span class="line">        max_fd = client_fds[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> ret = select(max_fd+<span class="number">1</span>, &amp;server_fd_set, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;tv);</span><br><span class="line">  <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;select 出错\n&quot;</span>);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;select 超时\n&quot;</span>);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//ret为未状态发生变化的文件描述符的个数</span></span><br><span class="line">    <span class="keyword">if</span> (FD_ISSET(STDIN_FILENO, &amp;server_fd_set)) &#123;</span><br><span class="line">      <span class="comment">//标准输入</span></span><br><span class="line">      bzero(input_msg, BUFFER_SIZE);</span><br><span class="line">      fgets(input_msg, BUFFER_SIZE, <span class="built_in">stdin</span>);</span><br><span class="line">      <span class="comment">//输入 &quot;.quit&quot; 则退出服务器</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strcmp</span>(input_msg, QUIT_CMD) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;CONCURRENT_MAX; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (client_fds[i]!=<span class="number">0</span>) &#123;</span><br><span class="line">          send(client_fds[i], input_msg, BUFFER_SIZE, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (FD_ISSET(server_sock_fd, &amp;server_fd_set)) &#123;</span><br><span class="line">      <span class="comment">//有新的连接请求</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>;</span></span><br><span class="line">      <span class="keyword">socklen_t</span> address_len;</span><br><span class="line">      <span class="keyword">int</span> client_socket_fd = accept(server_sock_fd, (struct sockaddr *)&amp;client_address, &amp;address_len);</span><br><span class="line">      <span class="keyword">if</span> (client_socket_fd &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CONCURRENT_MAX; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (client_fds[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            index = i;</span><br><span class="line">            client_fds[i] = client_socket_fd;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;新客户端(%d)加入成功 %s:%d \n&quot;</span>,index,inet_ntoa(client_address.sin_addr),ntohs(client_address.sin_port));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          bzero(input_msg, BUFFER_SIZE);</span><br><span class="line">          <span class="built_in">strcpy</span>(input_msg, <span class="string">&quot;服务器加入的客户端数达到最大值,无法加入!\n&quot;</span>);</span><br><span class="line">          send(client_socket_fd, input_msg, BUFFER_SIZE, <span class="number">0</span>);</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;客户端连接数达到最大值，新客户端加入失败 %s:%d \n&quot;</span>,inet_ntoa(client_address.sin_addr),ntohs(client_address.sin_port));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;CONCURRENT_MAX; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (client_fds[i]!=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(client_fds[i], &amp;server_fd_set)) &#123;</span><br><span class="line">          <span class="comment">//处理某个客户端过来的消息</span></span><br><span class="line">          bzero(recv_msg, BUFFER_SIZE);</span><br><span class="line">          <span class="keyword">long</span> byte_num = recv(client_fds[i],recv_msg,BUFFER_SIZE,<span class="number">0</span>);</span><br><span class="line">          <span class="keyword">if</span> (byte_num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (byte_num &gt; BUFFER_SIZE) &#123;</span><br><span class="line">              byte_num = BUFFER_SIZE;</span><br><span class="line">            &#125;</span><br><span class="line">            recv_msg[byte_num] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端(%d):%s\n&quot;</span>,i,recv_msg);</span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span>(byte_num &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;从客户端(%d)接受消息出错.\n&quot;</span>,i);</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            FD_CLR(client_fds[i], &amp;server_fd_set);</span><br><span class="line">            client_fds[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端(%d)退出了\n&quot;</span>,i);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. client</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建需要通信的server socket的IP、端口等信息 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">server_addr.sin_len = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">server_addr.sin_family = AF_INET;</span><br><span class="line">server_addr.sin_port = htons(<span class="number">11332</span>);</span><br><span class="line">server_addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">bzero(&amp;(server_addr.sin_zero),<span class="number">8</span>);</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建socket通信连接 */</span></span><br><span class="line"><span class="comment">//创建socket</span></span><br><span class="line"><span class="keyword">int</span> client_socket = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (client_socket == <span class="number">-1</span>) &#123;</span><br><span class="line">  perror(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接client和server的通信道路</span></span><br><span class="line"><span class="keyword">int</span> connect_result = connect(client_socket, (struct sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(struct sockaddr_in));</span><br><span class="line"></span><br><span class="line"><span class="comment">//connect 成功之后，其实系统将你创建的socket绑定到一个系统分配的端口上，且其为全相关，包含服务器端的信息，可以用来和服务器端进行通信。</span></span><br><span class="line"><span class="keyword">char</span> recv_msg[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">char</span> reply_msg[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">if</span> (connect_result == <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    bzero(recv_msg, <span class="number">1024</span>);</span><br><span class="line">    bzero(reply_msg, <span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">long</span> byte_num = recv(client_socket, recv_msg, <span class="number">1024</span>, <span class="number">0</span>);</span><br><span class="line">    recv_msg[byte_num] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;server said:%s\n&quot;</span>,recv_msg);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client reply:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,reply_msg);</span><br><span class="line">    <span class="keyword">if</span> (send(client_socket, reply_msg, <span class="number">1024</span>, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">      perror(<span class="string">&quot;send error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="WIN"><a href="#WIN" class="headerlink" title="WIN"></a>WIN</h3><p>模仿Unix Socket技术实现</p><h4 id="操作流程-1"><a href="#操作流程-1" class="headerlink" title="操作流程"></a>操作流程</h4><img src="/2021/01/25/WebSocket/2.png" alt="截屏2021-01-31 下午2.57.07" style="zoom:45%;"> <h2 id="php"><a href="#php" class="headerlink" title="php"></a>php</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;h1 id=&quot;使用&quot;&gt;&lt;a href=&quot;#使用&quot; class=&quot;headerlink&quot; title=&quot;使用&quot;&gt;&lt;/a&gt;使用&lt;/h1&gt;&lt;p&gt;Web</summary>
      
    
    
    
    <category term="course" scheme="https://jieyang-wei.github.io/categories/course/"/>
    
    
    <category term="socket" scheme="https://jieyang-wei.github.io/tags/socket/"/>
    
  </entry>
  
  <entry>
    <title>C++</title>
    <link href="https://jieyang-wei.github.io/2021/01/23/C++/"/>
    <id>https://jieyang-wei.github.io/2021/01/23/C++/</id>
    <published>2021-01-23T10:13:55.000Z</published>
    <updated>2021-01-31T08:04:13.687Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h1 id="语法教程"><a href="#语法教程" class="headerlink" title="语法教程"></a>语法教程</h1><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><h3 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h3><p><strong>bool</strong></p><p><strong>char</strong></p><p><strong>int</strong></p><p><strong>float</strong></p><p><strong>double</strong></p><p><strong>void</strong></p><p><strong>wchar_t</strong></p><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p><a class="link" href="https://www.cnblogs.com/wuruofeng/p/10412559.html">char,char*,string转换<i class="fas fa-external-link-alt"></i></a></p><h3 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h3><p>枚举类型</p><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ofstream outfile;</span><br><span class="line"><span class="comment">/* 打开文件 */</span></span><br><span class="line">outfile.open(<span class="string">&quot;file.txt&quot;</span>, ios::out | ios::trunc ); <span class="comment">//模式结合</span></span><br><span class="line"><span class="comment">/* 关闭文件*/</span></span><br><span class="line">outfile.close();</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, ios::openmode mode)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>filename：要打开的文件的名称和位置（绝对路径）</p><blockquote><p>相对路径的位置取得是可执行文件的位置，而不是代码文件所在位置</p><ul><li><strong>xcode</strong>：<code>/Users/username/Library/Developer/Xcode/DerivedData/区块链-cwiqijiormracofndmvocmukooxi/Build/Products/Debug</code></li></ul></blockquote></li><li><p>mode：文件的打开模式（早期c++用ios代替ios_base）</p><ul><li><strong>ios::app</strong>      追加模式。所有写入都追加到文件末尾。</li><li><strong>ios::ate</strong>       文件打开后定位到文件末尾</li><li><strong>ios::in</strong>          打开文件用于读取（ifstream默认）</li><li><strong>ios::out</strong>       打开文件用于写入（ofstream默认）</li><li><strong>ios::trunc</strong>   如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0</li></ul><blockquote><p>ios是C++的一个类，ios_base是有关输入输出流的类的公共基类，<strong>ios</strong>继承了basic_ios类，而basic_ios又继承了<strong>ios_base</strong>，所以说ios_base也是ios类的间接基类。</p><ul><li>其中ios_base类具有静态常量in、out、binary等（在VS中ios_base类还有一个叫_Iosb的基类，这些静态成员在_Iosb中，但是C++标准没有这种说法），</li><li>ios_base类也是basic_ostream、basic_istream等多个类的直接或间接基类。从这个意义上，写ostream::binary什么的可能也没什么问题，但是习惯上都用ios::in、ios::binary，或者ios_base::in、ios_base::binary之类的。</li><li>所以，综上，ios类继承了ios_base类的静态成员变量in、out、binary等，所以既可以用ios，也可以用ios_base。望采纳。</li></ul></blockquote></li></ul><h3 id="ostream"><a href="#ostream" class="headerlink" title="ostream"></a>ostream</h3><p>该数据类型表示输出文件流，用于创建文件并向文件写入信息。</p><h3 id="istream"><a href="#istream" class="headerlink" title="istream"></a>istream</h3><p>该数据类型表示输入文件流，用于从文件读取信息。</p><h3 id="fstream"><a href="#fstream" class="headerlink" title="fstream"></a>fstream</h3><p>该数据类型通常表示文件流，且同时具有 ofstream 和 ifstream 两种功能</p><h3 id="文件夹"><a href="#文件夹" class="headerlink" title="文件夹"></a>文件夹</h3><p><a class="link" href="https://blog.csdn.net/nuptwanglei/article/details/43051643">函数说明<i class="fas fa-external-link-alt"></i></a></p><p><strong>opendir</strong>（打开目录）</p><ul><li>相关函数：open，readdir，closedir，rewinddir，seekdir，telldir，scandir </li><li>表头文件：<code>#include&lt;dirent.h&gt; </code></li><li>定义函数：<code>DIR * opendir(const char * name); </code></li><li>函数说明：<ul><li>opendir()用来打开参数name指定的目录，并返回DIR*形态的目录流，和open()类似，接下来对目录的读取和搜索都要使用此返回值。 </li></ul></li><li>返回值：成功则返回 *<em>DIR**</em> 型态的目录流，打开失败则返回NULL。 </li><li>错误代码<ul><li>EACCESS   权限不足</li><li>EMFILE      已达到进程可同时打开的文件数上限</li><li>ENFILE       已达到系统可同时打开的文件数上限</li><li>ENOTDIR   参数name非真正的目录 </li><li>ENOENT    参数name 指定的目录不存在，或是参数name 为一空字符串</li><li>ENOMEM  核心内存不足。</li></ul></li></ul><p><strong>readdir（读取目录）</strong></p><ul><li><p>相关函数：open，opendir，closedir，rewinddir，seekdir，telldir，scandir </p></li><li><p>表头文件：<code>#include&lt;dirent.h&gt; </code></p></li><li><p>定义函数：<code>struct dirent * readdir(DIR * dir); </code></p></li><li><p>函数说明：</p><ul><li><p>readdir()返回参数dir目录流的下个目录进入点。 </p></li><li><pre><code class="c++">struct dirent&#123;  ino_t d_ino;   //此目录进入点的inode  ff_t d_off;    //目录文件开头至此目录进入点的位移，当前目录下为0  signed short int d_reclen;  //d_name的长度，不包含NULL字符  unsigned char d_type;       //d_name 所指的文件类型  //DT_REG 文件    DT_DIR 文件夹  har d_name[256];  //文件名&#125;;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>返回值：成功则返回下个目录进入点。有错误发生或读取到目录文件尾则返回NULL。</p></li><li><p>错误代码</p><ul><li>EBADF   参数dir为无效的目录流</li></ul></li></ul><p><strong>closedir（关闭目录）</strong></p><ul><li>相关函数：opendir</li><li>表头文件：<code>#include&lt;dirent.h&gt; </code></li><li>定义函数：<code>int closedir(DIR *dir);</code></li><li>函数说明：closedir()关闭参数dir所指的目录流。</li><li>返回值：关闭成功则返回0，失败返回-1，错误原因存于errno 中</li><li>错误代码<ul><li>EBADF   参数dir为无效的目录流</li></ul></li></ul><p><strong>示例</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getFiles</span><span class="params">(<span class="keyword">char</span> *path, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; files)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dirp</span>;</span></span><br><span class="line">    DIR* dir = opendir(path);</span><br><span class="line">    <span class="keyword">while</span> ((dirp = readdir(dir)) != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dirp-&gt;d_type == DT_REG) &#123;</span><br><span class="line">            <span class="comment">// 文件</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, dirp-&gt;d_name);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dirp-&gt;d_type == DT_DIR) &#123;</span><br><span class="line">            <span class="comment">// 文件夹</span></span><br><span class="line">            <span class="comment">// getFiles(dirp-&gt;d_name, files);  //迭代</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    closedir(dir);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p><a class="link" href="https://blog.csdn.net/touzani/article/details/1637776">教程<i class="fas fa-external-link-alt"></i></a></p><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h1 id="资源库"><a href="#资源库" class="headerlink" title="资源库"></a>资源库</h1><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><h2 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h2><h3 id="lt-time-h-gt"><a href="#lt-time-h-gt" class="headerlink" title="&lt;time.h&gt;"></a>&lt;time.h&gt;</h3><p><strong>struct timespec</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">time_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _TIMESPEC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _TIMESPEC</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span></span><br><span class="line"><span class="keyword">time_t</span> tv_sec;  <span class="comment">// seconds </span></span><br><span class="line"><span class="keyword">long</span> tv_nsec;   <span class="comment">// nanoseconds, 纳秒</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>一般由函数<code>int clock_gettime(clock id_t, struct timespec*)</code>获取特定时钟的时间</p><ul><li><p>常用clock有如下4种：</p><ul><li><strong>CLOCK_REALTIME</strong>   统当前时间，从1970年1.1日算起</li><li><strong>CLOCK_MONOTONIC</strong>   系统的启动时间，不能被设置</li><li><strong>CLOCK_PROCESS_CPUTIME_ID</strong>   本进程运行时间</li><li><strong>CLOCK_THREAD_CPUTIME_ID</strong>     本线程运行时间</li></ul></li><li><p>函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct tm* <span class="title">localtime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">time_t</span>* clock)</span></span>;  <span class="comment">//线程不安全</span></span><br><span class="line"><span class="function">struct tm* <span class="title">localtime_r</span><span class="params">(<span class="keyword">const</span> <span class="keyword">time_t</span>* timer, struct tm* result )</span></span>;<span class="comment">//线程安全</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">strftime</span><span class="params">(<span class="keyword">char</span>* ptr, <span class="keyword">size_t</span> maxsize, <span class="keyword">const</span> <span class="keyword">char</span>* format, <span class="keyword">const</span> struct tm* timeptr )</span></span>;</span><br></pre></td></tr></table></figure></li></ul><p><strong>struct timeval</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line"><span class="keyword">time_t</span> tv_sec;  <span class="comment">// seconds </span></span><br><span class="line"><span class="keyword">long</span> tv_usec;   <span class="comment">// microseconds </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timezone</span>&#123;</span> </span><br><span class="line"><span class="keyword">int</span> tz_minuteswest; <span class="comment">//miniutes west of Greenwich </span></span><br><span class="line"><span class="keyword">int</span> tz_dsttime; <span class="comment">//type of DST correction </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一般由函数<code>int gettimeofday(struct timeval* tv, struct timezone* tz)</code>获取系统的时间 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;h1 id=&quot;语法教程&quot;&gt;&lt;a href=&quot;#语法教程&quot; class=&quot;headerlink&quot; title=&quot;语法教程&quot;&gt;&lt;/a&gt;语法教程&lt;/h</summary>
      
    
    
    
    <category term="notebook" scheme="https://jieyang-wei.github.io/categories/notebook/"/>
    
    
    <category term="C++" scheme="https://jieyang-wei.github.io/tags/C/"/>
    
    <category term="编程语言" scheme="https://jieyang-wei.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>比特币+以太坊</title>
    <link href="https://jieyang-wei.github.io/2021/01/09/%E6%AF%94%E7%89%B9%E5%B8%81-%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    <id>https://jieyang-wei.github.io/2021/01/09/%E6%AF%94%E7%89%B9%E5%B8%81-%E4%BB%A5%E5%A4%AA%E5%9D%8A/</id>
    <published>2021-01-09T04:47:31.000Z</published>
    <updated>2021-01-14T09:10:55.605Z</updated>
    
    <content type="html"><![CDATA[<h1 id="crypto-currency，加密货币"><a href="#crypto-currency，加密货币" class="headerlink" title="crypto-currency，加密货币"></a>crypto-currency，加密货币</h1><ul><li><p>区块链是一种数据结构，而比特币和以太坊都是使用区块链这种数据结构实现的应用</p></li><li><p><a class="link" href="https://bitcoin.org/bitcoin.pdf">比特币白皮书<i class="fas fa-external-link-alt"></i></a></p></li><li><p><a class="link" href="https://www.cnblogs.com/coderzjz/p/13788649.html">别人好的笔记<i class="fas fa-external-link-alt"></i></a></p></li></ul><h1 id="比特币-BTC"><a href="#比特币-BTC" class="headerlink" title="比特币 BTC"></a>比特币 BTC</h1><p><strong>前提：</strong>大部分算力掌握在诚实的矿工手里</p><h2 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h2><h3 id="1-crypto-graphic-hash-function"><a href="#1-crypto-graphic-hash-function" class="headerlink" title="1. crypto graphic hash function"></a>1. crypto graphic hash function</h3><p>特性：</p><ol><li><p>collision resistance：抗碰撞性</p></li><li><p>hiding：x可以算出H(x)，但H(x)不能反推出x，即这个hash函数不会泄露x</p><ul><li><p>需要满足，不然可以通过蛮力求解</p><ol><li><p>输入空间大</p></li><li><p>均匀分布</p></li></ol></li><li><p>digital commitment / digital equivalent of a sealed envelope：密封预测结果</p></li></ul></li><li><p>puzzle friendly：H(x)是事先不可预测的</p></li></ol><p>H(block header) &lt;= target 目标域值（nBits：目标域值编码）</p><p>proof of work POW，工作证明</p><p>difficult to solve, but easy to verify</p><h3 id="2-签名"><a href="#2-签名" class="headerlink" title="2. 签名"></a><strong>2. 签名</strong></h3><p>账户 - public key, private key</p><ul><li>来源于非对称加密：asymmetric encryption algorithm</li><li>最早期是对称加密，symmetric encryption algorithm，但这样密钥分发是一个问题，所以有了公私钥</li></ul><p>a good source of randomness：使得生成的公钥相同的几率微乎其微</p><p><strong>SHA-256</strong>（Secure Hash Algorithm）</p><ul><li><a class="link" href="https://blog.csdn.net/u011583927/article/details/80905740">原理简介<i class="fas fa-external-link-alt"></i></a></li><li>和md5加密的效果一样，但是SHA-256更加的安全</li><li>都只能算是签名，加密算法是既能加密也能解密的算法，而签名就仅仅是起到校验和的作用</li></ul><hr><p>Mac, Linux hash命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> md5 file.txt    <span class="comment"># md5校验和</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> shasum -a 1 /tmp/hello.txt      <span class="comment"># SHA-1校验和</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> shasum -a 256 /tmp/hello.txt    <span class="comment"># SHA-256校验和</span></span></span><br><span class="line"><span class="meta"> #</span><span class="bash"> -a --algorithm</span></span><br></pre></td></tr></table></figure><img src="/2021/01/09/%E6%AF%94%E7%89%B9%E5%B8%81-%E4%BB%A5%E5%A4%AA%E5%9D%8A/截屏2020-12-27 上午10.44.14.png" alt="截屏2020-12-27 上午10.44.png" style="zoom:60%;"> <hr><h2 id="BTC-数据结构"><a href="#BTC-数据结构" class="headerlink" title="BTC 数据结构"></a>BTC 数据结构</h2><blockquote><p>区块链仅仅是一个<strong>数据结构</strong>，BTC是使用区块链这种数据结构实现的应用</p></blockquote><h3 id="hash-point"><a href="#hash-point" class="headerlink" title="hash point"></a>hash point</h3><ul><li>无环链表都可以用 hash point 代替普通的point</li></ul><ol><li>区块链</li></ol><p><img src="/2021/01/09/%E6%AF%94%E7%89%B9%E5%B8%81-%E4%BB%A5%E5%A4%AA%E5%9D%8A/IMG_0230-7744726.jpg" alt="IMG_0230"></p><ul><li><p>block chain is a linked list using hash pointers：用hash point 代替普通的指针</p><ul><li><p>genesis block：创世区块            most recent blcok：最近产生的区块      </p><p>H( )：hash point</p></li><li><p>tamper-evident log：最后一个hash值就能检查整个链表是否被修改过</p></li></ul></li></ul><blockquote><p>Merkle tree 不是区块链的信息存储结构，而是BTC使用过程中用到的数据结构，在节点验证交易正确性时，使用到的一个结构而已</p></blockquote><ol start="2"><li>Merkle tree<ul><li>与binary tree的区别<ol><li>用hash point代替普通的指针</li><li>只要记录<code>root hash</code>，就能检测对整棵树的修改</li></ol></li><li>block header：只保存<code>root hash</code>，</li><li>block body：保存所有的交易信息<code>tx</code>等</li><li>作用：<ul><li>提供<code>merkle proof</code></li></ul></li></ul></li></ol><blockquote><p><img src="/2021/01/09/%E6%AF%94%E7%89%B9%E5%B8%81-%E4%BB%A5%E5%A4%AA%E5%9D%8A/IMG_231E499E57D8-1.jpeg" alt="IMG_231E499E57D8-1"></p><ul><li><strong>proof of membership</strong>：轻节点想知道黄色交易是否在<code>merkle tree</code>上，只有一个<code>root hash</code>(在<code>block header</code>里面)</li></ul><ol><li>轻节点向某个全节点发出证明请求，请求一个能证明黄色交易包括在<code>merkle tree</code>里面的一个<code>merkle proof</code></li><li>全节点收到请求，会将图中红色的三个<code>hash值</code>发送给这个轻节点</li><li><strong>从下往上</strong>：轻节点会算出黄色交易的hash值绿1，绿1和红1一起算出hash值绿2，绿2和红2算出绿3，绿3和红3一起算出<code>root hash</code></li><li>轻节点比较这个算出来的<code>root hash</code>和<code>block header</code>的hash值</li></ol><blockquote><p><strong>注意</strong>：我们只能验证绿色的部分，不能验证红色部分的hash值</p></blockquote><blockquote><ul><li>如果考虑通过调整红色的部分，使得被篡改后的绿色的部分算出来hash不变，是不实际的</li><li>因为<code>Collision resistance</code>性质，这样的操作相当于人为的制造hash碰撞</li></ul></blockquote><ul><li><strong>proof of non-memership</strong>：轻节点想证明某个交易不存在</li></ul><ol><li></li></ol></blockquote><h2 id="数字货币"><a href="#数字货币" class="headerlink" title="数字货币"></a>数字货币</h2><ul><li>使用公私钥，非对成加密算法<ol><li>Double spending attack，双花攻击 - 花两次攻击：数字货币本质上是一个文件，带签名的数字货币可以复制</li></ol></li><li>每个数字货币上带编号（防范DSA，但是是中心化的）<ul><li>bank维护一个数据库，每个编号的数字货币在谁手里</li><li>每次验证数字货币的签名和编号，这个货币有没有发过，被谁花过</li></ul></li></ul><p><strong>BTC安全性</strong></p><ol><li><strong>密码学</strong>：别人没有私钥，不能伪造签名<ul><li>前提：系统中拥有大多数算力的矿工是好的，是遵守协议的，不会接受没有合法签名的交易</li></ul></li><li><strong>共识机制</strong>：</li></ol><h3 id="BTC解决去中心化的数字货币发行问题"><a href="#BTC解决去中心化的数字货币发行问题" class="headerlink" title="BTC解决去中心化的数字货币发行问题"></a>BTC解决去中心化的数字货币发行问题</h3><ul><li><img src="/2021/01/09/%E6%AF%94%E7%89%B9%E5%B8%81-%E4%BB%A5%E5%A4%AA%E5%9D%8A/IMG_9CCCEC7F3445-1.jpeg" alt="IMG_9CCCEC7F3445-1"><ul><li>交易中A的公钥表明是钱是哪儿来的，但是要将A和他的公钥联系在一起，不然E可以用自己的公钥冒充A的，再用自己的私钥签名<ul><li><strong>coinbase tx</strong>：需要验证A-&gt;B的钱的前一个交易（金币来源）中A的公钥，即金币来源的输出脚本，和交易中提供的A的公钥，即交易的输入脚本拼在一起合成一个程序，看能不能顺利执行</li></ul></li></ul></li></ul><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><h5 id="区块结构"><a href="#区块结构" class="headerlink" title="区块结构"></a>区块结构</h5><img src="/2021/01/09/%E6%AF%94%E7%89%B9%E5%B8%81-%E4%BB%A5%E5%A4%AA%E5%9D%8A/IMG_9EF94BC347FE-1.jpeg" alt="IMG_9EF94BC347FE-1" style="zoom:70%;"> <ul><li><strong>Block Header</strong><ul><li>区块信息：<ul><li>version：比特币版本</li><li>时间戳等</li></ul></li><li>hash of previous block header：指向前一个区块的指针（只算header的hash）<ul><li>创世区块的<code>previous hash</code>为0</li></ul></li><li>merkle root hash：整棵merkle tree的根hash值<ul><li>保证了<code>transaction list</code>是无法被篡改的</li></ul></li><li>nonce：随机数，256bits<ul><li>target：挖矿难度目标域值</li></ul></li></ul></li><li><strong>Block Body</strong><ul><li>transaction list</li><li>只存交易信息</li></ul></li></ul><h5 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h5><ul><li>full node（fully validating node，全节点）：</li><li>light node（light weight node，轻节点）：<ul><li>一般无法验证交易的合法性，只是利用区块链的信息做一个查询</li></ul></li></ul><h4 id="Consensus-in-BitCoin，比特币共识"><a href="#Consensus-in-BitCoin，比特币共识" class="headerlink" title="Consensus in BitCoin，比特币共识"></a>Consensus in BitCoin，比特币共识</h4><p>distributed consensus，分布式共识</p><ul><li>impossibility result：<ul><li>FLP：在一个异步的系统里（asynchronous），网络时延没有上线，哪怕系统中只要有一个用户是faulty的，都没有办法达成共识</li><li>CAP Theorem：以下三个性质中，最多满足两种<ul><li>一致性Consistency、可用性Availability、分区容错性Partition tolerance</li></ul></li></ul></li></ul><p>membership</p><p>hyperledger</p><p>联盟链 - fabric</p><p>sybil attacl，女巫攻击：找一个超级计算机，不停的产生用户节点，当总数超过一半时，就得到了这个链的控制权</p><ul><li>coinbase transaction：<ul><li>coinbase域：可以在里面写东西，永久保存，但只有获得记账权的节点才能使用</li><li>通过算例投票 puzzle friendly</li><li>hash rate</li><li>nonce</li></ul></li></ul><p>mining - 挖矿：比特币争夺记账权</p><ul><li>digital gold</li><li>miner</li></ul><h4 id="BTC系统实现"><a href="#BTC系统实现" class="headerlink" title="BTC系统实现"></a>BTC系统实现</h4><h5 id="transaction-based-ledger，基于交易的账本模式"><a href="#transaction-based-ledger，基于交易的账本模式" class="headerlink" title="transaction-based ledger，基于交易的账本模式"></a>transaction-based ledger，基于交易的账本模式</h5><ul><li>每个交易需要说清楚，币是从哪儿来的，它没有账户的概念</li></ul><p>全节点维护一个数据结构：</p><ul><li><p>UTXO，unspent Transaction Output：还没有被花掉的交易的输出集合</p><img src="/2021/01/09/%E6%AF%94%E7%89%B9%E5%B8%81-%E4%BB%A5%E5%A4%AA%E5%9D%8A/IMG_1019233284AC-1 .jpeg" alt="IMG_1019233284AC-1" style="zoom:50%;"><ul><li><strong>包括</strong> 2个数据就能定位UTXO的输出：<ol><li>产生这个输出的交易的hash 值</li><li>这个输出是交易中的第几个输出</li></ol></li><li><strong>作用</strong>：检测Double Spending<ul><li>total inputs = total outputs：i可以略大于o，中间的<code>transaction fee</code>可能给了拥有记账权的区块</li><li>transaction fee：大约只有零点零几个币</li></ul></li></ul></li></ul><p>account-based ledger，基于账户的模式</p><ul><li>系统需要显示的记录每个账户有多少个币，如以太坊ß</li></ul><h5 id="Bernoulli-trial"><a href="#Bernoulli-trial" class="headerlink" title="Bernoulli trial"></a>Bernoulli trial</h5><ul><li><p>a random experiment with binary outcome</p></li><li><p>每次求解nonce可以看作是Bernoulli trial</p></li></ul><p><strong>Bernoulli process</strong>：a sequence of independent Bernoulli</p><ul><li>大量实践的Bernoulli trial就组成了</li><li>性质：<ul><li>memoryless，无记忆的：实验结果和之前的实验结果是没有关系的</li></ul></li></ul><p>Poisson process：</p><p>exponential distribution，出块时间：服从指数分布</p><img src="/2021/01/09/%E6%AF%94%E7%89%B9%E5%B8%81-%E4%BB%A5%E5%A4%AA%E5%9D%8A/IMG_9A528FE35443-1.jpeg" alt="IMG_9A528FE35443-1" style="zoom:40%;"><ul><li>无记忆性：<ul><li>memory less：将来挖多少时间与之前已经挖了多少时间没有关系，即使等了10mins，下一挖到矿的时间仍然指数分布，平均是10mins</li><li>process free：过去的process是没用的，对挖矿公平性的保证</li></ul></li></ul><p>出块奖励</p><p>geometric series 几何级数</p><ul><li>BTC总数：21万 * 50 + 21万 * 25 + 21万 * 12.5 + ····<ul><li>= 21万 * 50 *（1 + 1/2 + 1/4 + ····）[等比求和，逐年减半]</li><li>= 2100万 [过去到未来的BTC总数]</li></ul></li></ul><p>Bitcoin is secured by mining</p><p>分岔攻击</p><p>回滚交易 - Double Spending Attack</p><ul><li>多等几个区块/确认 confirmation</li></ul><p>irrevocable ledger，不可篡改的账本</p><ul><li>不可篡改是该旅行的保证</li></ul><p>zero confirmation</p><ul><li>交易刚发出去，没有写进区块</li></ul><p>selfish mining</p><ul><li>我先不发布，等到挖到足够多的区块了，再一起发布，盖过其他的 - 分岔攻击</li><li>自己挖到两个的时候，不发布，等别人挖到一个，再一起发布，别人的那个就白发了</li><li>风险：<ul><li>不一定抢的赢别人</li></ul></li></ul><h4 id="BTC网络"><a href="#BTC网络" class="headerlink" title="BTC网络"></a>BTC网络</h4><p>BTC所有节点平等，没有super/master node</p><p>协议：</p><ul><li>application layer：BitCoin Block chain</li><li>network layer：P2P Overlay Network</li></ul><p>设计原则：simple简单，robot鲁棒，but not efficient不是高效</p><ul><li><p>消息节点：flooding方式</p></li><li><p>邻居节点：选取是随机的，不考虑底层的拓扑结构</p><ul><li>增强了鲁棒性，但是牺牲了效率</li></ul></li><li><p>每个节点维护一个等待上链的消息集合</p><ul><li>冲突交易</li></ul></li></ul><p>best effort，</p><blockquote><p>区块链是一种数据结构，而节点是在基于网络应用时，每一个连入区块的设备，比如手机就是轻节点，而矿池(后面有讲)就是一个全节点，保存所有的信息 - 现在BTC大约有100多G</p></blockquote><p><strong>全节点</strong>：保存所有的信息</p><ul><li>一直在线</li><li>在本地硬盘上维护完整的区块链信息</li><li>在内存里维护UTXO集合，以便快速检验交易的正确性</li><li>监听比特币网络上的交易信息，验证每个交易的合法性</li><li>决定哪些交易会被打包到区块里</li><li>监听别的矿工挖出来的区块，验证其合法性</li><li>挖矿：<ul><li>决定沿着那条链挖下去<ul><li>缺省情况下选择最长的链</li></ul></li><li>当出现等长的分岔的时候，选择哪一个分岔<ul><li>缺省情况下选择第一个发现的</li></ul></li></ul></li></ul><p><strong>轻节点</strong>：只保存block header（如手机上）</p><ul><li>不是一直在线</li><li>不用保存整个区块链，只要保存每个区块的块头</li><li>不用保存全部交易，只保存与自己相关的交易</li><li>无法检测大多数交易的合法性，只能检验与自己相关的那些交易的合法性</li><li>无法检测网上发布的区块的正确性<ul><li>因为无法知道区块里的交易是不是合法的</li></ul></li><li>可以验证挖矿的难度<ul><li>挖矿时计算hash值只需要用到块头的信息</li></ul></li><li>只能检测那个是最长的链，不知道哪个是最长的合法链<ul><li>只能知道这个链上的区块挖矿难度时符合要求的，但是无法验证每个区块里交易的合法性</li></ul></li></ul><h2 id="挖矿"><a href="#挖矿" class="headerlink" title="挖矿"></a>挖矿</h2><p>H(block header) &lt;= target</p><ul><li>target越小，难度越大</li><li>需要调整target值，使得出块时间保持稳定（BTC大约为10mins）</li></ul><p>hash算法：SHA-256</p><ul><li>取值空间：2^256</li><li>block header里面存nBits，只有4字节<ul><li>target有256位，32字节</li></ul></li></ul><h3 id="挖矿难度"><a href="#挖矿难度" class="headerlink" title="挖矿难度"></a>挖矿难度</h3><img src="/2021/01/09/%E6%AF%94%E7%89%B9%E5%B8%81-%E4%BB%A5%E5%A4%AA%E5%9D%8A/IMG_3A7CCA25FE75-1.jpeg" alt="IMG_3A7CCA25FE75-1" style="zoom:50%;"><ul><li>difficulty_1_target：挖矿难度等于1时的目标域值</li><li>1是最低难度</li><li>不调整target的话，出块时间会越来越短<ul><li>分岔，几个用户同时出块</li><li>系统不容易统一</li><li>51% attack：将大部分算力用来放在攻击的回滚区块的链上</li></ul></li></ul><p>orphan block</p><p>uncle reward</p><h3 id="难度调整"><a href="#难度调整" class="headerlink" title="难度调整"></a>难度调整</h3><p>每2016个区块调整目标域值，大约为2周（2016 * 10 / 60 * 24 = 14）</p><ul><li>调整公式：<img src="/2021/01/09/%E6%AF%94%E7%89%B9%E5%B8%81-%E4%BB%A5%E5%A4%AA%E5%9D%8A/IMG_E4D6502FBD91-1.jpeg" alt="IMG_E4D6502FBD91-1" style="zoom:40%;"><ul><li>如果实际时间超过了2周，那么平均出块时间超过了10mins，这个时候出块难度需要调整的低一点（右边分式大于1，target变大）</li></ul></li><li><img src="/2021/01/09/%E6%AF%94%E7%89%B9%E5%B8%81-%E4%BB%A5%E5%A4%AA%E5%9D%8A/IMG_D3AE8A16D3B4-1.jpeg" alt="IMG_D3AE8A16D3B4-1" style="zoom:80%;"></li></ul><h3 id="设备"><a href="#设备" class="headerlink" title="设备"></a>设备</h3><p><strong>早期1代 - CPU</strong>：</p><ul><li>随着挖矿难度增加，性价比极低</li><li>计算机中大部分内存都是闲置的，挖矿只用到了其中很少一部分内存</li><li>大部分不见也是闲置的，挖矿中hash值的计算只用到了通用计算机cpu中很少一部分指令</li><li>硬盘和其他资源也是闲置的</li></ul><blockquote><p> GPU主要用于大规模的并行计算，如深度学习</p></blockquote><p><strong>2代 - GPU</strong>：</p><ul><li>效率得到了很大的提高</li><li>但gpu主要是为了并行计算设计的，其中仍然有很多部件是闲置的，所以也不划算<ul><li>如用于浮点数运算的部件</li></ul></li><li>对于现在的挖矿的难度，GPU的算力已经不够了</li></ul><blockquote><p>ASIC：Application Specific Integrated  Circuit</p></blockquote><p><strong>现在 - ASIC芯片</strong></p><ul><li>专门为了BTC挖矿<strong>计算hash值</strong>所设计的，生产周期长（不能做全节点其他工作）</li><li>为某种加密货币设计的芯片，只能挖着一种货币（除非两种货币用同一个mining puzzle）<ul><li>merge mining：一个新的货币发行时，为了解决冷启动问题，吸引更多的用户，故意用一个已有的mining puzzle</li></ul></li><li><strong>Alternative mining puzzle</strong><ul><li>有的货币会设计这种puzzle，达到下面的效果</li><li>ASIC resistance：抗ASIC芯片化，为了让通用CPU也能参与挖矿</li></ul></li></ul><h3 id="矿池"><a href="#矿池" class="headerlink" title="矿池"></a>矿池</h3><ul><li>一个全节点去驱动很多的矿机（一个矿工负责全部的工作比较累）</li></ul><img src="/2021/01/09/%E6%AF%94%E7%89%B9%E5%B8%81-%E4%BB%A5%E5%A4%AA%E5%9D%8A/IMG_FFBC17D6F168-1.jpeg" alt="IMG_FFBC17D6F168-1" style="zoom:60%;"><ul><li><p>矿主：其他全节点的指责</p><ul><li>监听网上的交易，将这些交易组织打包成候选区块</li><li>同时关注是否有其他节点抢先发布了区块，如果有就需要作出调整等</li></ul></li><li><p>矿工：只负责计算hash值</p></li><li><p><strong>好处</strong>：</p><ul><li><p>减轻了矿工的工作量</p></li><li><p>解决单个矿工收入不稳定问题，以下两种方式</p><ol><li>像大型数据中心一样，矿池下有成千上万的矿机，属于一个机构，好分配</li><li>分布式，矿机来自不用的厂商，需要通过通讯协议与矿主联系，之后一起分红</li></ol><blockquote><p>如何解决矿工分红问题 - 工作量证明：</p><ul><li>降低挖矿难度，矿工提交 - share，almost valid block - 只能用来证明做了多少工作</li></ul></blockquote></li></ul></li><li><p>大型矿池的<strong>弊病</strong>：使得51%的攻击更加容易了</p><ul><li><strong>分叉攻击</strong>：对已经经过6次确认的交易分叉，利用51%算力将交易记录回滚。<ul><li>矿工只能计算哈希值，并不知道区块包含哪些交易，区块链状况是什么。所以，这些“群众”是无知的，容易被利用（《乌合之众》当中提出的观点，大多数人真的就能掌握真理吗？）。</li><li>此外，51%攻击只是一个概率问题，并非达到51%算力就能发动攻击，不能达到就无法发动攻击。此外，矿池本身算力也是在不断变化的。</li></ul></li><li><strong>封锁交易（Boycott）</strong>：<ul><li>假如攻击者不喜欢某个账户A，不想让A的交易上区块链，在监听到有其他人将A的交易发布到区块链上时，立刻发动分叉攻击，使A所在链无法成为”最长合法链“。这样，便实现了对A账户的封锁。</li><li>像不像即当裁判又当运动员？”堂下何人状告本官“？</li></ul></li><li><strong>盗币</strong>（将他人账户BTC转走）<ul><li>这个是<strong>不可能</strong>的，因为其并没有他人账户私钥。如果依仗算力强，强行将没有签名的转账发布到区块链，正常节点不会认为其合法，这样，即使这条链再长，其他人也不会认为其是最长合法链。</li></ul></li><li>on demand computing  -&gt;  on demand mining（潜在危害）</li></ul></li></ul><h2 id="BTC-使用的脚本语言"><a href="#BTC-使用的脚本语言" class="headerlink" title="BTC 使用的脚本语言"></a>BTC 使用的脚本语言</h2><ul><li>基于栈的编程语言：很简单，只有一个堆栈</li></ul><h3 id="交易结构"><a href="#交易结构" class="headerlink" title="交易结构"></a>交易结构</h3><img src="/2021/01/09/%E6%AF%94%E7%89%B9%E5%B8%81-%E4%BB%A5%E5%A4%AA%E5%9D%8A/IMG_0280.jpg" alt="IMG_0280" style="zoom:35%;"> <p><strong>交易的输入</strong></p><img src="/2021/01/09/%E6%AF%94%E7%89%B9%E5%B8%81-%E4%BB%A5%E5%A4%AA%E5%9D%8A/IMG_0281-9908278.jpg" alt="IMG_0281" style="zoom:38%;"> <p><strong>交易的输出</strong></p><img src="/2021/01/09/%E6%AF%94%E7%89%B9%E5%B8%81-%E4%BB%A5%E5%A4%AA%E5%9D%8A/IMG_0282.jpg" alt="IMG_0282" style="zoom:55%;"> <h3 id="交易验证"><a href="#交易验证" class="headerlink" title="交易验证"></a>交易验证</h3><img src="/2021/01/09/%E6%AF%94%E7%89%B9%E5%B8%81-%E4%BB%A5%E5%A4%AA%E5%9D%8A/IMG_0262.jpg" alt="IMG_0262" style="zoom:36%;"> <ul><li>早期是将输入输出脚本拼接到一起执行</li><li>后面处于安全考虑，输入输出两者分别执行，都为非0(True)则成功</li></ul><h4 id="脚本形式"><a href="#脚本形式" class="headerlink" title="脚本形式"></a>脚本形式</h4><blockquote><p>注：下面的脚本中，省略了<code>OP_</code>前缀</p><ul><li>如CHECKSIG -&gt; OP_CHECKSIG；DUP -&gt; OP_DUP；</li></ul></blockquote><ol><li><p><strong>P2PK ，Pay to Public Key</strong></p><ul><li>input script<ol><li><strong>PUSHDATA(SIG)**：将输入里提供的</strong><code>签名</code>**压入栈</li></ol></li><li>output script<ol start="2"><li><strong>PUSHDATA(PubKey)**：将输出里提供的</strong><code>公钥</code>**压入栈</li><li><strong>CHECKSIG</strong>：将栈顶的两个元素弹出来，用公钥检查签名是否正确<ul><li>正确则返回True，验证通过，否则执行出错，交易是非法的</li></ul></li></ol></li></ul></li><li><p><strong>P2PKH，Pay to Public Key Hash</strong></p><ul><li>input script<ol><li><strong>PUSHDATA(SIG)**：将输入里提供的</strong><code>签名</code>**压入栈</li><li><strong>PUSHDATA(PubKey)**：将</strong><code>公钥</code>**压入栈</li></ol></li><li>output script<ol start="3"><li><strong>DUP</strong>：将栈顶的元素复制一遍<ul><li>栈顶多了一个**<code>公钥</code>**</li></ul></li><li><strong>HASH160</strong>：将栈顶元素弹出，取hash，再将此hash值压入栈<ul><li>此时栈顶是**<code>公钥的hash-1</code>**</li></ul></li><li><strong>PUSHDATA(PubKeyHash)**：将输出中提供的</strong><code>公钥的hash-2</code>**值压入栈<ul><li>此时栈顶有两个公钥的hash</li></ul></li><li><strong>EQUALVERIFY</strong>：弹出栈顶的两个元素，比较是否相等<ul><li>防止有人冒名顶替，用自己的公钥冒充收款人的公钥</li><li>相等的话栈顶的两个**<code>PubKeyHash</code>**就消失了</li></ul></li><li><strong>CHECKSIG</strong>：将栈顶的两个元素弹出来，用公钥检查签名是否正确<ul><li>正确则返回True，验证通过，否则执行出错，交易是非法的</li></ul></li></ol></li></ul><blockquote><p>区别：第二种没有在输出中直接给出收款人的公钥，而是给出公钥的hash。公钥则是在输入脚本中给出的，其他的操作都是为了验证正确性。</p><p>第二种更常用</p></blockquote></li><li><p><strong>P2SH，Pay to Script Hash</strong></p><blockquote><p><strong>采用BIP16的方案</strong></p><p>输出脚本不提供收款人公钥的hash，而是收款人提供的脚本的hash</p><ul><li>redeemScript：赎回脚本</li><li>常见应用场景：对多重签名的支持-防止私钥的泄露</li></ul></blockquote><p><strong>验证分两步：</strong></p><ul><li>input script要给出一些签名（数目不定）及一段序列化的redeemScript<ol><li>验证序列化的<strong>redeemScript</strong>是否与<strong>output script</strong>中的hash值匹配</li><li>将输入脚本中给出的序列化的<strong>redeemScript</strong>反序列化并执行<strong>redeemScript</strong>，验证<strong>input script</strong>中给出的签名是否正确</li></ol></li></ul><blockquote><p>此处脚本中redeemScript内容采用<strong>P2PK形式</strong></p></blockquote><ul><li><p><strong>第一阶段</strong></p><ul><li><p>input script</p><ol><li><p><strong>PUSHDATA(Sig)**：将输入的</strong><code>签名</code>**压入栈</p></li><li><p><strong>PUSHDATA(serialized redeemScript)**：将赎回脚本</strong><code>seriRS</code>**压入栈</p></li></ol></li><li><p>output script</p><ol start="3"><li><strong>HASH160</strong>：将栈顶元素**<code>seriRS</code>**弹出，取hash，再将此hash值压入栈<ul><li>此时栈顶为**<code>RSH-1</code>**</li></ul></li><li><strong>PUSHDATA(redeemScriptHash)**：将输出脚本中给出的hash值</strong><code>RSH-2</code>**压入栈<ul><li>栈顶为两个<strong>RSH</strong></li></ul></li><li><strong>EQUAL</strong>：比较栈顶的两个RSH是否相等<ul><li>相等的话栈顶的两个**<code>RSH</code><strong>就消失了，栈中只剩一个</strong><code>Sig</code>**</li></ul></li></ol></li></ul></li><li><p><strong>第二阶段</strong></p><ul><li>执行反序列化之后的redeemScript<ol><li><strong>PUSHDATA(PubKey)**：将</strong><code>公钥</code>**压入栈</li><li><strong>CHECKSIG</strong>：检查输入给出的**<code>签名</code>**的正确性</li></ol></li></ul></li></ul></li></ol><h4 id="redeemScript"><a href="#redeemScript" class="headerlink" title="redeemScript"></a>redeemScript</h4><ol><li><p>P2PK形式</p><ul><li>PUSHDATA(PubKey)：将**<code>公钥</code>**压入栈</li><li>CHECKSIG：验证栈顶的**<code>公钥</code><strong>和</strong><code>签名</code>**是否匹配</li></ul></li><li><p>P2PKH形式</p></li><li><p>多重签名形式 - 下面的P2SH实现多重签名</p><blockquote><p><img src="/2021/01/09/%E6%AF%94%E7%89%B9%E5%B8%81-%E4%BB%A5%E5%A4%AA%E5%9D%8A/IMG_C6B93A3357A1-1.jpeg" alt="IMG_C6B93A3357A1-1" style="zoom:45%;">   <img src="/2021/01/09/%E6%AF%94%E7%89%B9%E5%B8%81-%E4%BB%A5%E5%A4%AA%E5%9D%8A/IMG_56F89D5B4A1F-1-9752549.jpeg" alt="IMG_56F89D5B4A1F-1" style="zoom:45%;"></p><ul><li>输出脚本提供N个公钥和一个域值M，输入脚本只需要提供这N个签名中任意M个合法的签名就能通过验证<ul><li>**<code>CHECKMULTISIG</code>**：验证堆栈中是否有N个签名中的M个</li></ul></li></ul></blockquote></li></ol><p>1、<strong>P2SH实现多重签名</strong> - 现在普遍采用的形式</p><ul><li><img src="/2021/01/09/%E6%AF%94%E7%89%B9%E5%B8%81-%E4%BB%A5%E5%A4%AA%E5%9D%8A/IMG_0272.jpg" alt="IMG_0272" style="zoom:30%;"> </li><li><strong>本质</strong>：将复杂度从输出脚本转移到了输入脚本 -&gt; 赎回脚本里面</li><li>赎回脚本在输入里面，由<strong>收款人</strong>提供，输出脚本只需要提供赎回脚本的hash值即可<ul><li>实际应用中，收款人不需要公布多重签名的公钥hash值，直接提供赎回脚本的hash值就可以了。则收款人采用什么形式的多重签名就可以隐藏起来</li></ul></li></ul><p>2、<strong>Proof of Burn</strong></p><ul><li>特殊的输出脚本形式，是销毁比特币的方法</li><li>output script，被称为<code>provably Unspendable/Prunable Outputs</code><ul><li><img src="/2021/01/09/%E6%AF%94%E7%89%B9%E5%B8%81-%E4%BB%A5%E5%A4%AA%E5%9D%8A/IMG_0279.jpg" alt="IMG_0279" style="zoom: 25%;"> </li><li>假如一个交易的input指向这个output，不论这个input里的input script如何设计，执行到<code>RETUEN</code>命令之后会直接返回false，不会执行后面的其他指令，所以这个output无法再被花出去，其对应的UTXO也就可以被剪枝了，无需保存</li></ul></li><li>应用场景<ol><li>一些小的币种(AltCoin，Alternative Coin)需要销毁一定数量的比特币来实现</li><li>向其中添加一些无法篡改的内容<ul><li>example - digital commitment，证明在某个时间知道某些事情：如将知识产权取hash之后存在<code>RETUEN</code>之后，之后可以证明你在这个时间知道某些事</li></ul></li></ol></li></ul><h2 id="fork-分岔"><a href="#fork-分岔" class="headerlink" title="fork, 分岔"></a>fork, 分岔</h2><p>state fork</p><p>forking attack</p><h1 id="以太坊-ETC"><a href="#以太坊-ETC" class="headerlink" title="以太坊 ETC"></a>以太坊 ETC</h1><h1 id="Conflux"><a href="#Conflux" class="headerlink" title="Conflux"></a>Conflux</h1><p>Conflux共识机制是在比特币源代码基础上实现的。</p><p>Conflux的框架和比特币的矿机类似</p><ul><li>GossipNetwork：实现P2P网络交互</li><li>节点：维护TxPool，生成区块（Block Generator），以及维护区块状态</li></ul><h1 id="fabric"><a href="#fabric" class="headerlink" title="fabric"></a>fabric</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;crypto-currency，加密货币&quot;&gt;&lt;a href=&quot;#crypto-currency，加密货币&quot; class=&quot;headerlink&quot; title=&quot;crypto-currency，加密货币&quot;&gt;&lt;/a&gt;crypto-currency，加密货币&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="notebook" scheme="https://jieyang-wei.github.io/categories/notebook/"/>
    
    
    <category term="blockchain" scheme="https://jieyang-wei.github.io/tags/blockchain/"/>
    
    <category term="BTC" scheme="https://jieyang-wei.github.io/tags/BTC/"/>
    
    <category term="Ethereum" scheme="https://jieyang-wei.github.io/tags/Ethereum/"/>
    
  </entry>
  
  <entry>
    <title>毕业设计</title>
    <link href="https://jieyang-wei.github.io/2021/01/04/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    <id>https://jieyang-wei.github.io/2021/01/04/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/</id>
    <published>2021-01-04T11:03:58.000Z</published>
    <updated>2021-01-14T08:05:55.106Z</updated>
    
    <content type="html"><![CDATA[<h1 id="例会"><a href="#例会" class="headerlink" title="例会"></a>例会</h1><h2 id="2021-1-4-A"><a href="#2021-1-4-A" class="headerlink" title="2021.1.4 - A"></a>2021.1.4 - A</h2><h3 id="A-Mixing-Scheme-Using-a-Decentralized-Signature-Protocol-for-Privacy-Protection-in-Bitcoin-Blockchain"><a href="#A-Mixing-Scheme-Using-a-Decentralized-Signature-Protocol-for-Privacy-Protection-in-Bitcoin-Blockchain" class="headerlink" title="A Mixing Scheme Using a Decentralized Signature Protocol for Privacy Protection in Bitcoin Blockchain"></a>A Mixing Scheme Using a Decentralized Signature Protocol for Privacy Protection in Bitcoin Blockchain</h3><p>BTC的匿名性保证 - 混币服务器</p><p>现有</p><ul><li><p><strong>Coinjoin</strong></p></li><li><p><strong>Coin Shuffle</strong>：Cut the connection between input address and output address</p></li><li><p><strong>Altcoin</strong></p></li><li><p><strong>Blind token</strong></p></li></ul><blockquote><p>现在的BTC系统，因为服务器节点远近问题，一个交易发布后会先被距离近的节点捕捉到，此时可以通过交易的时间未知等细节信息，定位到交易的ip地址，最后根据ip地址可以在线下找出交易双方的真实身份信息</p></blockquote><p>通过协商实现交易</p><h3 id="Differential-Privacy-Based-Blockchain-for-Industrial-Internet-of-Things"><a href="#Differential-Privacy-Based-Blockchain-for-Industrial-Internet-of-Things" class="headerlink" title="Differential Privacy-Based Blockchain for Industrial Internet-of-Things"></a>Differential Privacy-Based Blockchain for Industrial Internet-of-Things</h3><p>区块链边缘计算应用在物联网上的隐私保护</p><ul><li>边缘节点</li><li>拆分隐私处理</li></ul><h2 id="2021-1-11-A-B"><a href="#2021-1-11-A-B" class="headerlink" title="2021.1.11 - A + B"></a>2021.1.11 - A + B</h2><h3 id="自主可控区块链关键技术"><a href="#自主可控区块链关键技术" class="headerlink" title="自主可控区块链关键技术"></a>自主可控区块链关键技术</h3><p>区块链上升国家战略</p><p><strong>挑战</strong></p><ul><li>如何解决高效自主共识协议的一致性问题，缩短区块链网络中共识时间延时</li><li>数据自主存储的空间问题，在公有链环境下，比特币2019年已达到240G的存储空间，每年以50GB的增长</li><li>多链的跨链的自主交互问题，各种不同类型的区块链平台产生数据孤岛和价值孤岛问题</li></ul><p><strong>三大技术</strong></p><ol><li>数据保全 - 密码算法</li><li>共识算法<ol><li>PoW</li><li>新型共识机制 - 易构共识</li></ol></li><li>智能合约</li></ol><h3 id="预言机"><a href="#预言机" class="headerlink" title="预言机"></a>预言机</h3><p>4种推拉方式</p><h1 id="研读论文"><a href="#研读论文" class="headerlink" title="研读论文"></a>研读论文</h1><h2 id="1、Conflux共识机制"><a href="#1、Conflux共识机制" class="headerlink" title="1、Conflux共识机制"></a>1、Conflux共识机制</h2><p>Scaling Nakamoto Consensus to Thousands of Transactions per Second</p><p>最近arXiv上发现一篇论文（2018/8/2发表，”Scaling Nakamoto Consensus to Thousands of Transactions per Second”），作者来自清华大学，卡内基梅隆大学，以及多伦多大学，提出了<strong>Conflux共识机制</strong></p><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>本文提出了一个快速、可扩展和去中心化的区块链系统Conflux，它乐观地处理并发块而不丢弃任何as叉。conflux共识协议将块之间的关系表示为一个直接的非循环图，并在块的总顺序上达成共识。然后，Conflux从区块顺序确定地推导出transactiontotal顺序作为区块链分类帐。我们在Amazon EC2集群上评估了高达20k的全节点的Con-flux。Conflux在4.5-7.4分钟内实现了5.76GB/h的事务吞吐量。对于典型的比特币交易来说，其吞吐量相当于每秒6400笔交易。我们的结果还表明，<strong>当运行Conflux时，共识协议不再是吞吐量的瓶颈。相反，瓶颈在于单个节点的处理能力</strong></p><h2 id="2、区块链共识算法效能优化研究进展"><a href="#2、区块链共识算法效能优化研究进展" class="headerlink" title="2、区块链共识算法效能优化研究进展"></a>2、区块链共识算法效能优化研究进展</h2><h3 id="摘要-1"><a href="#摘要-1" class="headerlink" title="摘要"></a>摘要</h3><p>近年来，区块链及其相关技术发展迅速，区块链也迅速成为了学术界的热门领域。然而，<strong>区块链的共识算法在资源花销、能源耗费和性能上都饱受诟病，因此需要制定一个能衡量其执行效率的指标，以评价其设计是否优良</strong>。由于共识算法的资源花销、能源耗费以及性能之间相互关联且关系复杂，因此有必要从“效能”的角度对现有区块链的共识算法加以分析，并总结 研究思路。文中总结了区块链共识算法的效能优化研究进展。首先定义区块链共识算法的效能为“在正确性和有效性的前提 下计算的共识算法<strong>性能、所需资源和能源消耗</strong>”，并分析这3个影响因素的关联;然后从公有链与联盟链两方面对共识算法的效 能优化进行整理与总结;最后从多链区块链、多个区块链与 BaS这3个方面提出关于共识算法的资源共享问题，以供研究人员 参考。</p><h2 id="3、区块链共识机制综述"><a href="#3、区块链共识机制综述" class="headerlink" title="3、区块链共识机制综述"></a>3、区块链共识机制综述</h2><h3 id="摘要-2"><a href="#摘要-2" class="headerlink" title="摘要"></a>摘要</h3><p>区块链能够有效融合物联网、5G、大数据和人工智能等技术，在新型基础设施建设中具有重要作用。共识机制作为区块链的核心技术，能够保障区块链数据库的一致性和正确性，从而决定区块链的安全性、扩展性、吞吐量等相关性能。根据区块链共识机制的技术路线，将其细分为 3 类单一共识机制和 6 类混合共识机制。从原理实现角度，系 统描述共识机制的理论技术，归纳节点达成一致所需的运算操作并评价共识机制的优缺点。从工程应用角度，具体分 析共识机制的应用情况，介绍区块链项目并对比共识机制的关键性能。针对现有共识机制研究中存在的能耗与效率 问题给出相应的解决方案，并对其奖惩制度、网络分片与存储分片技术等下一步研究方向进行展望</p><h2 id="4、-区块链技术及应用研究综述"><a href="#4、-区块链技术及应用研究综述" class="headerlink" title="4、 区块链技术及应用研究综述"></a>4、 区块链技术及应用研究综述</h2><h3 id="摘要-3"><a href="#摘要-3" class="headerlink" title="摘要"></a>摘要</h3><p>针对区块链可构建信任和传递价值特性，从数据层面、财务层面、应用层面、体制 层面等多角度研究区块链技术及应用价值重构，对利用区块链技术在数字资产存证、保护 用户隐私、 数字资源流通、 <strong>跨部门信息系统互联与数据可信共享</strong>等应用场景研究进行综述，形成基于区块链的安全可信、稳定可靠、高效便捷的应用场景和模式，为区块链技术与各领域深度融合的技术路径创新与数据价值重构提供一定的借鉴参考。</p><p>共识机制解决全网节点之间数据验证同步和激励相融问题。 目前主流的共识机制有四种:PoW、 PoS，DPoS、PBFT。</p><ol><li>PoW 机制<ul><li>PoW 是最经典的共识机制. 基于给定难度值在 最快时间通过迭代计算得到一个随机数 Nonce 以 争夺记账权， 对获得优先记账权的节点给予一定激 励。 PoW 共识流程如图 4 所示。</li></ul></li><li>PoS 机制<ul><li>PoS 通过计算全网节点的持有币量和持币时间 来决定投票权和打包权。 拥有打包权的节点打包交 易后对全网广播， 拥有投票权的节点投票决定最终上链的区块， 根据每个节点持有币量和持币时间等 比例降低计算随机数的难度。</li></ul></li><li>DPoS 机制<ul><li>DPoS 是 PoS 的升级版， 由全网普通节点投票 选出一些代理节点进行交易验证和记账， 代理节点 完成共识后会获得一定数量的激励， 不合格的代理 节点会被投票替换。</li></ul></li><li>PBFT 算法<ul><li>PBFT 广泛使用于联盟链，是一种能容忍全网 1 / 3 节点出现错误或异常的分布式系统共识算法， 该算法依赖节点对同一信息的多次重复确认， 从而 达到全网共识。</li></ul></li></ol><p><strong>电子政务领域</strong>：</p><p>通过区块链技术将数据、信息上链，实现对数据的记录和追踪， 能缩短行政办公周期， 加快资金流动， 对于提升政府公共服务管理水平和政府办公效率具有重要的意义。 目前基于区块链的电子政务场 景主要集中在政务服务、综合监管、智慧法院、数字 身份等领域。</p><h2 id="5、物联网中区块链的轻量级共识机制"><a href="#5、物联网中区块链的轻量级共识机制" class="headerlink" title="5、物联网中区块链的轻量级共识机制"></a>5、物联网中区块链的轻量级共识机制</h2><p>A lightweight consensus mechanism for blockchain in IoT</p><h3 id="摘要-4"><a href="#摘要-4" class="headerlink" title="摘要"></a>摘要</h3><p>在物联网应用中，区块链消除了对单一可信权威的依赖，增强了潜在的可伸缩性和可靠性。区块链中使用的现有共识方法需要较高的能量消耗、具有可信权威的巨大计算能力或挖掘区块的证据。资源受限的物联网设备需要一种轻量级和低延迟的共识机制。与绝对共识方法相比，无信任概率共识方法允许每个节点都参与共识，增强了事务的鲁棒性和可靠性。对于物联网环境中的非合作区块链，我们提出了一种轻量级的耗时工作和运气(PoEWAL)一致性证明方法。PoEWAL消耗更少的能量，需要更少的计算能力和低延迟。我们利用康智奇库雅模拟器分析了PoEWAL在资源受限设备中的适用性。实验结果表明，在不同的难度水平下，能量消耗都很低，证明了PoEWAL的可行性。将PoEWAL与现有的概率共识方法如工作证明、权益证明、活动证明、algorand、权威证明等在能量、共识时间、网络延迟等方面进行比较，确认PoEWAL是适用于物联网区块链的共识方法。</p><h2 id="6、一种基于改进遗传算法的共识机制"><a href="#6、一种基于改进遗传算法的共识机制" class="headerlink" title="6、一种基于改进遗传算法的共识机制"></a>6、一种基于改进遗传算法的共识机制</h2><p>A Consensus Mechanism Based on an Improved Genetic Algorithm</p><h3 id="摘要-5"><a href="#摘要-5" class="headerlink" title="摘要"></a>摘要</h3><p><strong>区块链技术的一个重要特点是所有参与者共同维护事务数据，无需集成控制就可以实现相互信任关系，这依赖于分布式共识算法</strong>。实用拜占庭容错算法(PBFT)是一种基于状态机复制的容错算法，它解决了拜占庭错误，即节点的恶意行为。在PBFT中，所有参与节点分为主节点和备份节点。当这个主节点提交错误或失败时，它将再次选择一个主节点进行消息通信。遗传算法(GA)是受自然生物遗传进化准则“自然选择，生存拟合检验”启发而提出的一种计算机模拟研究方法。遗传算法实际上是一种寻找最优解的方法。据此，在PBFT算法中选择最佳主节点，以提高一致性效率。<strong>共识算法是区块链技术中去中心化特性的保证</strong>。PBFT算法是一种常用的共识算法。但该算法存在如下问题:当主节点发生故障时，必须重新选择该节点，导致协商效率降低。提出了一种基于改进遗传算法的一致性机制，利用改进的遗传算法来选择主节点。根据遗传算法选择最佳的主节点，使其与其他备份节点的交易效率达到最高。改进的一致性算法可以有效地减少系统延迟，提高一致性效率。</p><h2 id="7、pbft启发的区块链共识和Neo-dBFT增强的挑战"><a href="#7、pbft启发的区块链共识和Neo-dBFT增强的挑战" class="headerlink" title="7、pbft启发的区块链共识和Neo dBFT增强的挑战"></a>7、pbft启发的区块链共识和Neo dBFT增强的挑战</h2><p>Challenges of PBFT-Inspired Consensus for Blockchain and Enhancements over Neo dBFT</p><h3 id="摘要-6"><a href="#摘要-6" class="headerlink" title="摘要"></a>摘要</h3><p><strong>共识机制是处理谈判和协议的核心特征</strong>。区块链技术已经引入了不同类型的共识机制，从繁重的计算任务到错综复杂的数学证明协议。本文从实际的拜占庭容错(PBFT)中得到启发，提出了Neo区块链的先驱代理拜占庭容错(dBFT)协议。除了介绍它的历史，本研究描述了证明和说教的例子，以及新颖的设计和扩展Neo dBFT与多个区块的建议。最后，我们讨论了在处理强大的拜占庭对手时所面临的挑战，并针对当前的弱同步问题和增强系统抗攻击的鲁棒性提出了PBFT启发的解决方案。<strong>主要贡献</strong>:概述了pbft启发的区块链共识的历史，强调了其目前在文献、挑战和假设方面的重要性。在分布式共识领域做出贡献，提出了Neo dBFT (dBFT 2.0+、dBFT 3.0和dBFT 3.0+)的新扩展，对创新共识机制有新的见解。</p><h2 id="8、区块链原理及关键技术"><a href="#8、区块链原理及关键技术" class="headerlink" title="8、区块链原理及关键技术"></a>8、区块链原理及关键技术</h2><h3 id="摘要-7"><a href="#摘要-7" class="headerlink" title="摘要"></a>摘要</h3><p>区块链是综合运用密码学、分布式数据库、P2P 通信、智能合约等的技术，在一个去中心化、去信任网络中，利用加密算法在链式数据结构中验证和存储数据。区块链技术是一项具有普适性的底层技术架构，它通过共识机制在分布式节点上生成和同步数据，借助可编程脚本实现合约条款的自动执行和数据操作。对区块链进行系统梳理并对其关键技术元素进行解构，在此前提下，从体系结构和实现协议入手分析了区块链系统的基础架构，以区块链技术的应用发展为脉络，主要结合比特币、以太坊和超级账本应用场景，对其技术原理、 实现路径、应用现状和存在的挑战进行了阐述。力求为读者在系统学习区块链技术的基础上致力于更深入的 研究提供帮助和借鉴。</p><h2 id="9、区块链技术发展综述及其政务领域应用研究"><a href="#9、区块链技术发展综述及其政务领域应用研究" class="headerlink" title="9、区块链技术发展综述及其政务领域应用研究"></a>9、区块链技术发展综述及其政务领域应用研究</h2><h3 id="摘要-8"><a href="#摘要-8" class="headerlink" title="摘要"></a>摘要</h3><p>区块链是密码技术应用发展的重要里程碑,其技术特点及优势颠覆了传统管理思维与治理模式,有助于推动信任模式与管理机制的重构与优化,为建立新型的政府数据治理体系提供经验与启示.全面评述了区块链技术的起源、演进、发展和兴起历程,审视其核心思想与设计理念,对其核心技术、要素规则、基础架构分别作了比较与概括;从用例设计角度阐述了区块链技术在机关公文运转、信息资源目录、网上政务服务等政务领域典型场景的应用;总结了区块链技术在政务领域应用的愿景、问题与原因,并提出一些方向性的思考与展望</p><h1 id="政务链上交易共识算法研究与应用"><a href="#政务链上交易共识算法研究与应用" class="headerlink" title="政务链上交易共识算法研究与应用"></a>政务链上交易共识算法研究与应用</h1><h2 id="开题"><a href="#开题" class="headerlink" title="开题"></a>开题</h2><h3 id="1、任务书"><a href="#1、任务书" class="headerlink" title="1、任务书"></a>1、任务书</h3><h4 id="进度安排"><a href="#进度安排" class="headerlink" title="进度安排"></a>进度安排</h4><h4 id="任务目的与要求"><a href="#任务目的与要求" class="headerlink" title="任务目的与要求"></a>任务目的与要求</h4><h3 id="2、开题报告"><a href="#2、开题报告" class="headerlink" title="2、开题报告"></a>2、开题报告</h3><p>选择近五年的论文，或者是学术史上经典的论文参考</p><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>随着新基建技术的发展，区块链技术也得到日益广泛的应用。在现如今的网络大环境下，区块链凭着自己的去中心化、不可篡改等特点，在政务领域中逐步开始应用，而其中节点之间的共识算法成为政务链体系研究中的热门议题。<br>在政务链体系中各节点之间达成共识的特殊性，一个节点项目的产生，往往需要经过链上多方节点核实，各个独立的而有相互不可分割的部门都需要自动、高效地处理这一过程，从而达到共识。本课题的主要任务是针对政务链上节点共识的要求，设计出一款安全，可靠，高效的共识算法。</p><p>针对政务领域中节点之间的达成共识往往需要经过链上多方节点核实，但实时性要求较高，达成分歧较大的痛点问题；如何根据政务链应用的业务求，设计一款安全、高效的共识算法，使得各个独立而又相互不可分割的部门能自动、高效地处理这一过程，从而实现业务应用的有效执行</p><h4 id="现状和发展趋势"><a href="#现状和发展趋势" class="headerlink" title="现状和发展趋势"></a>现状和发展趋势</h4><p>共识机制是特殊节点的投票，在很短的时间内完成对交易的验证和确认；对一笔交易，如果利益不相干的若干个节点能够达成共识，我们就可以认为全网对此也能够达成共识。再通俗一点来讲，如果中国一名微博大V、美国一名虚拟币玩家、一名非洲留学生和一名欧洲旅行者互不相识，但他们都一致认为你是个好人，那么基本上就可以断定你这人还不坏。（摘自百度百科）</p><p>从本质上讲，公有、私有和联盟链并不矛盾，它们只是使用了不同的技术：</p><ul><li>精心设计的公有链在防审计性方面往往更具优势，但代价是速度和吞吐量较低。这些是对交易结算（或智能合约）提供安全性保证的最佳选择。</li><li>私有链可以优先考虑系统的速度，因为它无需像公共区块链那样担心核心故障。理想情况下，将私有链部署在个人或组织可控且信息保密的情况下。</li><li>联盟链可减轻私有链中交易对手的风险（通过消除集中控制），并且较少的节点数通常可使它们能够比公共链更有效率的运行。联盟链适合于彼此之间需要相互沟通的单位组织。</li></ul><h4 id="重难点和拟采用途径"><a href="#重难点和拟采用途径" class="headerlink" title="重难点和拟采用途径"></a>重难点和拟采用途径</h4><p>数图公链 -&gt; 政务联盟链</p><p>节点机</p><p>两个指针</p><p>交易所-效率高</p><p>达成共识-</p><p>服务于应用</p><p>模版</p><p>政务场景下达成共识设计</p><p><strong>项目招标：</strong></p><ul><li><p><strong>区块链底层基础平台</strong></p><ul><li>共识系统</li></ul></li><li><p><strong>区块链能力增强系统</strong></p><ul><li>高性能共识算法：针对现有共识系统吞吐量低下、交易确认时间长、应用场景受限等问题，突破区块链在交易共识过程中的性能瓶颈，提高全网交易吞吐量</li></ul></li></ul><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><h2 id="论文撰写"><a href="#论文撰写" class="headerlink" title="论文撰写"></a>论文撰写</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;例会&quot;&gt;&lt;a href=&quot;#例会&quot; class=&quot;headerlink&quot; title=&quot;例会&quot;&gt;&lt;/a&gt;例会&lt;/h1&gt;&lt;h2 id=&quot;2021-1-4-A&quot;&gt;&lt;a href=&quot;#2021-1-4-A&quot; class=&quot;headerlink&quot; title=&quot;2021.</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>计算机基础</title>
    <link href="https://jieyang-wei.github.io/2020/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    <id>https://jieyang-wei.github.io/2020/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/</id>
    <published>2020-12-23T01:18:40.000Z</published>
    <updated>2021-02-01T09:05:34.358Z</updated>
    
    <content type="html"><![CDATA[<p>专用计算机：凯撒密码徽章，算盘</p><p>1946：宾夕法尼亚研究的第一台电子计算机</p><p>求 pai</p><p>密码学：</p><p>二进制编辑器：file info</p><p>Bmp：位图文件，没有压缩的原始文件</p><ul><li>jpg：是压缩之后的</li><li>文件前缀是BM(424d)，可以用二进编辑器打开</li><li>格式：（找到文档规范就能找到）<ul><li>源信息：BM 文件大小 空字节 … 宽 高 … </li><li>数据信息</li></ul></li></ul><p>文件类型：</p><ul><li>私有文件，不能对外交换信息</li><li>通用数据格式文件<ul><li>找到数据规范，就可以解析这个文件</li><li>去掉文件头，别人就打不开了</li><li>bmp，jpg，mp3等</li></ul></li></ul><p>vim -b  filename</p><p>:!xxde</p><p>dapp：完全分布式的</p><p>中心服务器，单点故障</p><p>混合架构：查询/目录服务器</p><p><strong>完全分布式的</strong>：种子</p><ul><li>共享文件</li><li>种子会记录那些人的电脑里会有这些文件，<ul><li>雷达：主动搜索资源</li><li>种子：定向下载资源</li></ul></li><li>发布种子的人的网络地址，和发布的人对文件分片的每一篇的uri</li><li>唯一的uri标示一个唯一的资源，但可能很多个机器里都有<ul><li>bt://202.103.5.8:8909/asdas:00</li><li>bt://202.103.5.8:8909/asdas:01</li></ul></li><li>种子主要解决第一次连接的问题，一旦第一个连接了，就能知道还有其他那些可以连了</li><li>BT很特殊，不仅有ip等还有文件资源</li></ul><p> 广播：树/图/线/双向链/交叉链等</p><ul><li>线性：<strong>可控性</strong>强，效率低</li><li>非结构化的：可控性差</li><li><strong>结构化</strong>：基于hash，树的之类的</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;专用计算机：凯撒密码徽章，算盘&lt;/p&gt;
&lt;p&gt;1946：宾夕法尼亚研究的第一台电子计算机&lt;/p&gt;
&lt;p&gt;求 pai&lt;/p&gt;
&lt;p&gt;密码学：&lt;/p&gt;
&lt;p&gt;二进制编辑器：file info&lt;/p&gt;
&lt;p&gt;Bmp：位图文件，没有压缩的原始文件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;jpg：</summary>
      
    
    
    
    <category term="notebook" scheme="https://jieyang-wei.github.io/categories/notebook/"/>
    
    
    <category term="理论知识" scheme="https://jieyang-wei.github.io/tags/%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>nodejs</title>
    <link href="https://jieyang-wei.github.io/2020/12/18/nodejs/"/>
    <id>https://jieyang-wei.github.io/2020/12/18/nodejs/</id>
    <published>2020-12-18T09:56:37.000Z</published>
    <updated>2021-02-02T09:35:24.830Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h2><ul><li>nodejs的包管理工具</li></ul><p><strong><a class="link" href="https://www.cnblogs.com/datiangou/p/10172994.html">package.json<i class="fas fa-external-link-alt"></i></a></strong></p><ul><li><a class="link" href="https://docs.npmjs.com/cli/v6/configuring-npm/package-json">官方文档<i class="fas fa-external-link-alt"></i></a></li></ul><p><code>npm init</code></p><ul><li>可以初始化一个package.json文件。在初始化的过程中，会叫用户输入name, version等等信息，当然，你都可以忽略。一路点回车，就生成了下面这样一个初始化的package.json。</li></ul><p><code>package.json</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;test&quot;</span>, <span class="comment">// 假如项目叫做test</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;this is my test&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;index.js&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;amp;&amp;amp; exit 1&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;author&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;license&quot;</span>: <span class="string">&quot;ISC&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>name</strong>: 这个很好理解，就是package的名称。不过需要注意的是，name有长度限制(虽然一般都不会超)，而且name不能以 【点】 或者 【下划线】开头，name中不能有大写字母。这个是每一个package必须的。在业务代码中，通过<code>require($&#123;name&#125;)</code>就可以引入对应的程序包了。</li><li><strong>version</strong>: package的版本。对于业务项目来说，这个往往不太重要，但是如果你要发布自己的项目，这个就显得十分重要了。name和version共同决定了唯一一份代码。npm是用[<a class="link" href="https://docs.npmjs.com/misc/semver.html">npm-semver]<i class="fas fa-external-link-alt"></i></a>来解析版本号的。我们一般见到的都是<code>大版本.次要版本.小版本</code>这种版本号，比如<code>16.1.0</code>。版本号的规则、含义其实蛮多的，可以参考<a class="link" href="https://segmentfault.com/a/1190000011368506">这篇文章<i class="fas fa-external-link-alt"></i></a>。</li><li><strong>desription</strong>：包的描述。开发组件库时必需，简明的向库的使用者介绍这个库是干嘛的。对于公司的业务项目，这个配置项一般无所谓。</li><li><strong>keywords</strong>：关键词。一个字符串数组，对这个npm包的介绍。组件库必需，便于使用者在npm中搜索。对于公司业务项目，这个配置一般无所谓。</li><li>homepage： 项目主页。对于开发组件库来说挺有用的。</li><li>bugs：开发者的联系方式，代码库的issues地址等。如果代码使用者发现了bug，可以通过这个配置项找到提bug的地方。</li><li><strong>license</strong>：开源协议。对于开源组件库，这个十分重要。之前react还因为这事儿没少被社区嫌弃。开源协议略微复杂，用<a class="link" href="http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html">阮一峰<i class="fas fa-external-link-alt"></i></a>前辈的一张图来说明一下吧。注：图里少了ISC, ISC和BSD差不多</li></ul><img src="/2020/12/18/nodejs/截屏2020-12-22 下午7.11.30.png" alt="截屏2020-12-22 下午7.11.30" style="zoom: 33%;"><ul><li><p>author：项目的作者。可以为字符串，对象。</p></li><li><p>contributors：项目的贡献者。author的数组。</p></li><li><p><strong>main</strong>：代码入口。这个十分重要，特别是对于组件库。当你想在node_modules中修改你使用的某个组件库的代码时，首先在node_modules中找到这个组件库，第一眼就是要看这个main，找到组件库的入口文件。在这个入口文件中再去修改代码吧。</p></li><li><p><strong>scripts</strong>：指定了运行脚本命令的npm命令行缩写。十分重要。</p><ul><li>在命令行输入：<code>npm run dev</code> , 对应的命令就会被执行。这里有一个地方需要注意，当执行<code>npm run xxx </code>的时候，<code>node_modules/.bin/</code>目录会在运行时被加入系统的PATH变量。</li><li>上面的例子，当我们在命令行输入：<code>npm run build</code>时，其实真正执行的命令是<code>node_modules/.bin/webpack</code>而不是<code>webpack</code>。所以，当你的webpack并未全局安装时，直接在命令行输入：<code>webpack</code>是会报错的。因为你的webapck是安装在<code>node_modules/.bin/</code>下面的。</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;dev&quot;: &quot;NODE_ENV=dev webpack-dev-server --progress --hot --host 0.0.0.0 --port 8089&quot;,</span><br><span class="line">    &quot;test&quot;: &quot;NODE_ENV=test webpack --config webpack.test.config.js --progress&quot;,</span><br><span class="line">    &quot;online&quot;: &quot;NODE_ENV=production webpack --config webpack.online.config.js --progress&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;webpack&quot;,</span><br><span class="line">    &quot;node&quot;: &quot;node server.js&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>directories：对整个代码结构的描述。告诉代码包使用者可以在哪里找到对应的文件。</p></li><li><p>files：数组。表示代码包下载安装完成时包括的所有文件。</p></li><li><p><strong>repository</strong>：对于组件库很有用。让组件库使用者找到你的代码库地址。这个配置项会直接在组件库的npm首页生效。例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;repository&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;git&quot;,</span><br><span class="line">    &quot;url&quot;: &quot;git+https:&#x2F;&#x2F;github.com&#x2F;CoyPan&#x2F;react-scroll-to-show-cb.git&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><p>config：用于添加命令行的环境变量。具体用法见<a class="link" href="https://docs.npmjs.com/misc/config">这里<i class="fas fa-external-link-alt"></i></a>。</p></li><li><p><strong>dependencies</strong>：项目的依赖。通过<code>npm install --save</code>安装的包会出现在这里。</p><ul><li>注意，<strong>不要把测试工具、代码转换器或者打包工具</strong>等放在这里。当你在命令行里面使用<code>npm install react --save</code>时，react就会出现在dependencies。默认是安装最新的版本。如果想安装某个特定的版本，可以<code>npm install react@15.6.2</code>。</li></ul></li></ul><hr><p>以下的dependencies，格式都是合法的，</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&quot;dependencies&quot; : &#123; </span><br><span class="line">    &quot;foo&quot; : &quot;1.0.0 - 2.9999.9999&quot;,</span><br><span class="line">    &quot;bar&quot; : &quot;&amp;gt;=1.0.2 &amp;lt;2.1.2&quot;,</span><br><span class="line">    &quot;baz&quot; : &quot;&amp;gt;1.0.2 &amp;lt;=2.3.4&quot;,</span><br><span class="line">    &quot;boo&quot; : &quot;2.0.1&quot;,    // 指定了就是2.0.1版本</span><br><span class="line">    &quot;qux&quot; : &quot;&amp;lt;1.0.0 || &amp;gt;=2.3.1 &amp;lt;2.4.5 || &amp;gt;=2.5.2 &amp;lt;3.0.0&quot;,</span><br><span class="line">    &quot;asd&quot; : &quot;http://asdf.com/asdf.tar.gz&quot;,</span><br><span class="line">    &quot;til&quot; : &quot;~1.2.2&quot;,   // 安装版本号不低于1.2.2的1.2.x的最新版本</span><br><span class="line">  <span class="comment">// 例如:1.2.3， 1.2.4等等。1.2.1 ，1.3.x 等就不行了</span></span><br><span class="line">    &quot;elf&quot; : &quot;^1.2.3&quot;,   // 安装版本号不低于1.2.2的1.x.x的最新版本</span><br><span class="line">  <span class="comment">// 例如: 1.2.7，1.7.8等,1.2.1 ，2.0.0 等就不行了。</span></span><br><span class="line">    <span class="comment">// 注意，如果配置是^0.x.x，则和~0.x.x的效果一样。  </span></span><br><span class="line">    &quot;two&quot; : &quot;2.x&quot;,</span><br><span class="line">    &quot;thr&quot; : &quot;3.3.x&quot;,</span><br><span class="line">    &quot;lat&quot; : &quot;latest&quot;,   // 安装最新版本</span><br><span class="line">    &quot;dyl&quot; : &quot;file:../dyl&quot;,</span><br><span class="line">  <span class="comment">//&quot;foo&quot;: &quot;git+ssh://git@github.com:foo/foo.git#v1.0.1&quot;   // 还可以这样</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>foo组件的地址为<code>git+ssh://&#123;foo代码库的ssh地址&#125;#v&#123;foo的版本号&#125;</code><ul><li>好处：组内的许多项目都有同一个功能，把这个功能抽出来做成组件是很自然的想法。但是每个项目都有自己的代码库，公司也没有内部的npm库，组件应该放在哪里呢？可以专门为组件新建一个代码仓库，将组件放在这里开发、迭代。这样，各个项目都可以引用该组件：只需要在dependencies中将组件配置成上述的形式。至于组件的版本，可以通过<code>git tag</code>来控制。</li></ul></li><li>dependencies还有其他的配置方式，具体在<a class="link" href="https://docs.npmjs.com/files/package.json.html#dependencies">这里<i class="fas fa-external-link-alt"></i></a>查看。</li></ul><hr><ul><li><strong>devDependencies</strong>：项目的依赖。通过<code>npm run install --save-dev</code>安装的包会出现在这里。主要是在<strong>开发过程</strong>中依赖的一些工具。用法与dependencies相似。</li><li>bundledDependencies：数组，打包时的依赖。如果配置了bundledDependencies，在项目中执行 <code>npm pack</code>将项目打包时，最后生成的<code>.tgz</code>包中，会包含bundledDependencies中配置的依赖。bundledDependencies中的依赖必须在devDependencies或者dependencies中声明过。</li><li>peerDependencies: 指定当前组件的依赖以其版本。如果组件使用者在项目中安装了其他版本的同一依赖，会提示报错。</li><li>engines：指定项目所依赖的node环境、npm版本等。</li><li>private：如果设为true，无法通过<code>npm publish</code>发布代码。</li><li>bin：用来指定各个内部命令对应的可执行文件的路径。具体用法这里不多讲了。详情可以点击<a class="link" href="https://docs.npmjs.com/files/package.json.html#bin">这里<i class="fas fa-external-link-alt"></i></a>。</li></ul><p><code>npm install</code></p><ul><li>根据配置文件<code>package.json</code>来安装环境</li><li>会在当前路径下自动创建文件夹<code>node_modules</code>，里面放所有下载的依赖包</li></ul><p><code>npm install name --save</code></p><ul><li>下载包name，同时加载到配置文件<code>package.json</code>的依赖<code>&quot;dependencies&quot;</code>里面</li></ul><h1 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123</span>; <span class="comment">// 整数123</span></span><br><span class="line"><span class="number">0.456</span>; <span class="comment">// 浮点数0.456</span></span><br><span class="line"><span class="number">1.2345e3</span>; <span class="comment">// 科学计数法表示1.2345x1000，等同于1234.5</span></span><br><span class="line">-<span class="number">99</span>; <span class="comment">// 负数</span></span><br><span class="line"><span class="literal">NaN</span>; <span class="comment">// NaN表示Not a Number，当无法计算结果时用NaN表示</span></span><br><span class="line"><span class="literal">Infinity</span>; <span class="comment">// Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity</span></span><br></pre></td></tr></table></figure><ul><li>JavaScript不区分整数和浮点数，统一用Number表示，以上都是合法的Number类型</li><li>Number的四则运算同数学</li><li><strong>注意</strong>：<ul><li><code>NaN</code>这个特殊的Number与所有其他值都不相等，包括它自己：<ul><li>NaN === NaN        //false</li><li>isNaN(NaN);          //true</li></ul></li></ul></li></ul><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p><strong>比较运算符</strong></p><ul><li><code>==</code>：它会<strong>自动转换数据类型</strong>再比较，很多时候，会得到非常诡异的结果；</li><li><code>===</code>：它<strong>不会</strong>自动转换数据类型，如果数据类型不一致，返回<code>false</code>，如果一致，再比较。<ul><li>由于JavaScript这个设计缺陷，<em>不要</em>使用<code>==</code>比较，始终坚持使用<code>===</code>比较。</li></ul></li></ul><p><strong>null和undefined：</strong></p><ul><li><code>null</code>表示一个“空”的值，它和<code>0</code>以及空字符串<code>&#39;&#39;</code>不同，<code>0</code>是一个数值，<code>&#39;&#39;</code>表示长度为0的字符串，而<code>null</code>表示“空”。</li><li>在其他语言中，也有类似JavaScript的<code>null</code>的表示，例如Java也用<code>null</code>，Swift用<code>nil</code>，Python用<code>None</code>表示。但是，在JavaScript中，还有一个和<code>null</code>类似的<code>undefined</code>，它表示“未定义”。</li><li>JavaScript的设计者希望用<code>null</code>表示一个空的值，而<code>undefined</code>表示值未定义。事实证明，这并没有什么卵用，区分两者的意义不大。</li><li>大多数情况下，我们都应该用<code>null</code>。<code>undefined</code>仅仅在判断函数参数是否传递的情况下有用。</li></ul><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p><strong>strict模式</strong></p><ul><li>JavaScript在设计之初，为了方便初学者学习，并不强制要求用<code>var</code>申明变量。这个设计错误带来了严重的后果：如果一个变量没有通过<code>var</code>申明就被使用，那么该变量就自动被申明为全局变量</li><li>为了修补JavaScript这一严重设计缺陷，ECMA在后续规范中推出了<code>strict模式</code>，在<code>strict模式</code>下运行的JavaScript代码，强制通过<code>var</code>申明变量，未使用<code>var</code>申明变量就使用的，将导致运行错误。</li></ul><h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><h5 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h5><h5 id="Iterable"><a href="#Iterable" class="headerlink" title="Iterable"></a>Iterable</h5><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul><li>变量名是大小写英文、数字、<code>$</code>和<code>_</code>的组合，且不能用数字开头。</li><li>变量名也不能是JavaScript的关键字，如<code>if</code>、<code>while</code>等。</li><li>申明一个变量用<code>var</code>语句</li></ul><p><strong>变量输出</strong></p><ul><li>console.log(x)</li><li>alert(x) –html弹窗</li></ul><p><strong>环境变量 process.env</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http_port = process.env.HTTP_PORT || <span class="number">3001</span>   <span class="comment">//默认设置为3001</span></span><br><span class="line"><span class="keyword">var</span> p2p_port = process.env.P2P_PORT || <span class="number">6001</span></span><br><span class="line"><span class="keyword">var</span> initialPeers = process.env.PEERS ? process.env.PEERS.split(<span class="string">&#x27;,&#x27;</span>) : []</span><br></pre></td></tr></table></figure><ul><li><p><strong>process</strong>：是一个 global （全局变量），提供有关信息，控制当前 Node.js 进程。<br>作为一个对象，它对于 Node.js 应用程序始终是可用的，故无需使用 require()。</p><ul><li>process（进程）其实就是存在nodejs中的一个全局变量，所有模块都可以调用。</li></ul></li><li><p>终端设置变量值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//win</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">set</span> HTTP_PORT=3002</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">set</span> P2P_PORT=6002</span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">set</span> PEERS=ws://localhost:6001</span></span><br><span class="line"></span><br><span class="line">//ios</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> HTTP_PORT=3002</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> P2P_PORT=6002</span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> PEERS=ws://localhost:6001</span></span><br><span class="line"></span><br><span class="line">//启动</span><br><span class="line"><span class="meta">$</span><span class="bash"> node file.js</span> </span><br></pre></td></tr></table></figure><ul><li>ios</li></ul></li></ul><h2 id="标准对象"><a href="#标准对象" class="headerlink" title="标准对象"></a>标准对象</h2><ul><li>在JavaScript的世界里，一切都是对象。</li><li>但是某些对象还是和其他对象不太一样。为了区分对象的类型，我们用<code>typeof</code>操作符获取对象的类型，它总是返回一个字符串</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">123</span>; <span class="comment">// &#x27;number&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span>; <span class="comment">// &#x27;number&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;str&#x27;</span>; <span class="comment">// &#x27;string&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>; <span class="comment">// &#x27;boolean&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>; <span class="comment">// &#x27;undefined&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Math</span>.abs; <span class="comment">// &#x27;function&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>; <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> []; <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;; <span class="comment">// &#x27;object&#x27;</span></span><br></pre></td></tr></table></figure><ul><li><code>number</code>、<code>string</code>、<code>boolean</code>、<code>function</code>和<code>undefined</code>有别于其他类型。</li><li><strong>特别注意</strong>：<code>null</code>的类型是<code>object</code>，<code>Array</code>的类型也是<code>object</code>，如果我们用<code>typeof</code>将无法区分出<code>null</code>、<code>Array</code>和通常意义上的object——<code>&#123;&#125;</code>。</li></ul><p><strong>包装对象</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>); <span class="comment">// 123,生成了新的包装类型</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>); <span class="comment">// true,生成了新的包装类型</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;str&#x27;</span>); <span class="comment">// &#x27;str&#x27;,生成了新的包装类型</span></span><br></pre></td></tr></table></figure><ul><li>类型为<code>object</code></li></ul><p>总结一下，有这么几条规则需要遵守：</p><ul><li><p>不要使用<code>new Number()</code>、<code>new Boolean()</code>、<code>new String()</code>创建包装对象；</p><ul><li>如果没写<code>new</code>，<code>Number()</code>、<code>Boolean</code>和<code>String()</code>被当做普通函数，把任何类型的数据转换为<code>number</code>、<code>boolean</code>和<code>string</code>类型（注意不是其包装类型）</li></ul></li><li><p>用<code>parseInt()</code>或<code>parseFloat()</code>来转换任意类型到<code>number</code>；</p></li><li><p>用<code>String()</code>来转换任意类型到<code>string</code>，或者直接调用某个对象的<code>toString()</code>方法；</p><ul><li><p><code>null</code>和<code>undefined</code>就没有<code>toString()</code>方法；Object一些情况下也不能使用</p></li><li><p><code>number</code>对象调用<code>toString()</code>报<strong>SyntaxError：</strong></p></li><li><pre><code class="javascript">123.toString();    // SyntaxError123..toString();   // &#39;123&#39;, 注意是两个点！(123).toString();  // &#39;123&#39;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 通常不必把任意类型转换为&#96;boolean&#96;再判断，因为可以直接写&#96;if (myVar) &#123;...&#125;&#96;；</span><br><span class="line"></span><br><span class="line">- &#96;typeof&#96;操作符可以判断出&#96;number&#96;、&#96;boolean&#96;、&#96;string&#96;、&#96;function&#96;和&#96;undefined&#96;；</span><br><span class="line"></span><br><span class="line">- 判断&#96;Array&#96;要使用&#96;Array.isArray(arr)&#96;；</span><br><span class="line"></span><br><span class="line">- 判断&#96;null&#96;请使用&#96;myVar &#x3D;&#x3D;&#x3D; null&#96;；</span><br><span class="line"></span><br><span class="line">- 判断某个全局变量是否存在用&#96;typeof window.myVar &#x3D;&#x3D;&#x3D; &#39;undefined&#39;&#96;；</span><br><span class="line"></span><br><span class="line">- 函数内部判断某个变量是否存在用&#96;typeof myVar &#x3D;&#x3D;&#x3D; &#39;undefined&#39;&#96;。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### Date</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### RegExp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### JSON</span><br><span class="line"></span><br><span class="line">* JSON实际上是JavaScript的一个子集。</span><br><span class="line">* JSON字符集必须是UTF-8</span><br><span class="line">* 为了统一解析JSON的字符串规定必须用双引号&#96;&quot;&quot;&#96;，Object的键也必须用双引号&#96;&quot;&quot;&#96;。</span><br><span class="line">* 在JSON中，一共就这么几种数据类型：</span><br><span class="line">  1. **number**：和JavaScript的&#96;number&#96;完全一致；</span><br><span class="line">  2. **boolean**：就是JavaScript的&#96;true&#96;或&#96;false&#96;；</span><br><span class="line">  3. **string**：就是JavaScript的&#96;string&#96;；</span><br><span class="line">  4. **nul**l：就是JavaScript的&#96;null&#96;；</span><br><span class="line">  5. **array**：就是JavaScript的&#96;Array&#96;表示方式——&#96;[]&#96;；</span><br><span class="line">  6. **object**：就是JavaScript的&#96;&#123; ... &#125;&#96;表示方式。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**序列化:** 对象 -&gt; JSON</span><br><span class="line"></span><br><span class="line">* &#96;JSON.stringfy(var, null, &#39; &#39;)&#96;：将nodejs对象输出成标准JSON格式</span><br><span class="line"></span><br><span class="line">  * 第二个参数用于控制如何筛选对象的键值，如果我们只想输出指定的属性，可以传入&#96;Array&#96;</span><br><span class="line"></span><br><span class="line">    * &#96;JSON.stringify(xiaoming, [&#39;name&#39;, &#39;skills&#39;], &#39;&#39;);  &#96;</span><br><span class="line">    * 只输出对象 xiaoming 的 name 和 skills 属性</span><br><span class="line"></span><br><span class="line">  * 第二个参数还能是一个函数，这样对象的每个键值对都会被函数先处理，</span><br><span class="line"></span><br><span class="line">    * &#96;&#96;&#96;javascript</span><br><span class="line">      function convert(key, value) &#123;</span><br><span class="line">          if (typeof value &#x3D;&#x3D;&#x3D; &#39;string&#39;) &#123;</span><br><span class="line">              return value.toUpperCase();</span><br><span class="line">          &#125;</span><br><span class="line">          return value;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      JSON.stringfy(xiaoming, convert, &#39;  &#39;);</span><br></pre></td></tr></table></figure></code></pre></li></ul><ul><li>第三个参数控制按缩进输出</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    age: <span class="number">14</span>,</span><br><span class="line">    gender: <span class="literal">true</span>,</span><br><span class="line">    height: <span class="number">1.65</span>,</span><br><span class="line">    grade: <span class="literal">null</span>,</span><br><span class="line">    <span class="string">&#x27;middle-school&#x27;</span>: <span class="string">&#x27;\&quot;W3C\&quot; Middle School&#x27;</span>,</span><br><span class="line">    skills: [<span class="string">&#x27;JavaScript&#x27;</span>, <span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;Lisp&#x27;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="built_in">JSON</span>.stringify(xiaoming);</span><br><span class="line"><span class="built_in">console</span>.log(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;小明&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">14</span>,<span class="string">&quot;gender&quot;</span>:<span class="literal">true</span>,<span class="string">&quot;height&quot;</span>:<span class="number">1.65</span>,<span class="string">&quot;grade&quot;</span>:<span class="literal">null</span>,<span class="string">&quot;middle-school&quot;</span>:<span class="string">&quot;\&quot;W3C\&quot; Middle School&quot;</span>,<span class="string">&quot;skills&quot;</span>:[<span class="string">&quot;JavaScript&quot;</span>,<span class="string">&quot;Java&quot;</span>,<span class="string">&quot;Python&quot;</span>,<span class="string">&quot;Lisp&quot;</span>]&#125;</span><br></pre></td></tr></table></figure><ul><li>如果我们还想要精确控制如何序列化小明，可以给<code>xiaoming</code>定义一个<code>toJSON()</code>的方法，直接返回JSON应该序列化的数据：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    age: <span class="number">14</span>,</span><br><span class="line">    gender: <span class="literal">true</span>,</span><br><span class="line">    height: <span class="number">1.65</span>,</span><br><span class="line">    grade: <span class="literal">null</span>,</span><br><span class="line">    <span class="string">&#x27;middle-school&#x27;</span>: <span class="string">&#x27;\&quot;W3C\&quot; Middle School&#x27;</span>,</span><br><span class="line">    skills: [<span class="string">&#x27;JavaScript&#x27;</span>, <span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;Lisp&#x27;</span>],</span><br><span class="line">    toJSON: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="comment">// 只输出name和age，并且改变了key：</span></span><br><span class="line">            <span class="string">&#x27;Name&#x27;</span>: <span class="built_in">this</span>.name,</span><br><span class="line">            <span class="string">&#x27;Age&#x27;</span>: <span class="built_in">this</span>.age</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify(xiaoming); <span class="comment">// &#x27;&#123;&quot;Name&quot;:&quot;小明&quot;,&quot;Age&quot;:14&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>反序列化:</strong> JSON -&gt; 对象</p><ul><li><code>JSON.parse()</code>：把JSON变成一个JavaScript对象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;[1,2,3,true]&#x27;</span>); <span class="comment">// [1, 2, 3, true]</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;&#123;&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:14&#125;&#x27;</span>); <span class="comment">// Object &#123;name: &#x27;小明&#x27;, age: 14&#125;</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;true&#x27;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;123.45&#x27;</span>); <span class="comment">// 123.45</span></span><br></pre></td></tr></table></figure><ul><li><code>JSON.parse()</code>还可以接收一个函数，用来转换解析出的属性：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">JSON</span>.parse(<span class="string">&#x27;&#123;&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:14&#125;&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key === <span class="string">&#x27;name&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value + <span class="string">&#x27;同学&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj)); <span class="comment">// &#123;name: &#x27;小明同学&#x27;, age: 14&#125;</span></span><br></pre></td></tr></table></figure><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><h3 id="fs"><a href="#fs" class="headerlink" title="fs"></a>fs</h3><ul><li>文件系统模块，负责读写文件</li><li>和所有其它JavaScript模块不同的是，<code>fs</code>模块同时提供了异步和同步的方法。、</li></ul><p><strong>异步读文件</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">&#x27;sample.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>异步读取时，传入的回调函数接收两个参数，当正常读取时，<code>err</code>参数为<code>null</code>，<code>data</code>参数为读取到的String。当读取发生错误时，<code>err</code>参数代表一个错误对象，<code>data</code>为<code>undefined</code>。</li><li>这也是Node.js<strong>标准的</strong>回调函数：第一个参数代表错误信息，第二个参数代表结果。后面我们还会经常编写这种回调函数。</li></ul><p>读取图片</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">&#x27;sample.png&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">        <span class="built_in">console</span>.log(data.length + <span class="string">&#x27; bytes&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>当读取二进制文件时，不传入文件编码时，回调函数的<code>data</code>参数将返回一个<code>Buffer</code>对象。在Node.js中，<code>Buffer</code>对象就是一个包含零个或任意个字节的数组（注意和Array不同）。<ul><li><code>Buffer</code>对象可以和String作转换，例如，把一个<code>Buffer</code>对象转换成String：</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Buffer -&gt; String</span></span><br><span class="line"><span class="keyword">var</span> text = data.toString(<span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(text);</span><br></pre></td></tr></table></figure><ul><li>或者把一个String转换成<code>Buffer</code>：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String -&gt; Buffer</span></span><br><span class="line"><span class="keyword">var</span> buf = Buffer.from(text, <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(buf);</span><br></pre></td></tr></table></figure><p><strong>同步读文件</strong></p><ul><li>同步读取的函数和异步函数相比，多了一个<code>Sync</code>后缀，并且不接收回调函数，函数直接返回结果。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data = fs.readFileSync(<span class="string">&#x27;sample.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(data);</span><br></pre></td></tr></table></figure><ul><li>如果同步读取文件发生错误，则需要用<code>try...catch</code>捕获该错误：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data = fs.readFileSync(<span class="string">&#x27;sample.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="comment">// 出错了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h3><h3 id="http"><a href="#http" class="headerlink" title="http"></a>http</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入http模块:</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建http server，并传入回调函数:</span></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(req.method == <span class="string">&quot;GET&quot;</span>)&#123;</span><br><span class="line">        doGet(req, res)</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(req.method == <span class="string">&quot;POST&quot;</span>)&#123;</span><br><span class="line">        doPost(req, res)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        res.end();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 让服务器监听8080端口:</span></span><br><span class="line">server.listen(<span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doGet</span>(<span class="params">request, response</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 回调函数接收request和response对象,</span></span><br><span class="line">    <span class="comment">// 获得HTTP请求的method和url:</span></span><br><span class="line">    <span class="built_in">console</span>.log(request.method + <span class="string">&#x27;: &#x27;</span> + request.url);</span><br><span class="line">    <span class="comment">// 解析请求的Url，返回一个标准的对象</span></span><br><span class="line">    <span class="keyword">var</span> params = url.parse(request.url, <span class="literal">true</span>);   </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 向http请求返回一个表单</span></span><br><span class="line">    <span class="comment">// 协议头，将HTTP响应200写入response, 同时设置Content-Type: text/html:</span></span><br><span class="line">    response.writeHead(<span class="number">200</span>, &#123;<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/html&#x27;</span>&#125;);</span><br><span class="line">    response.write(<span class="string">&#x27;&lt;html&gt;&#x27;</span>);</span><br><span class="line">    response.write(<span class="string">&#x27;&lt;head&gt;&#x27;</span>);</span><br><span class="line">    response.write(<span class="string">&#x27;&lt;meta charset=&quot;utf-8&quot;&gt;&#x27;</span>);</span><br><span class="line">    response.write(<span class="string">&#x27;&lt;title&gt;&#x27;</span>);</span><br><span class="line">    response.write(<span class="string">&#x27;&lt;/title&gt;&#x27;</span>);</span><br><span class="line">    response.write(<span class="string">&#x27;&lt;/head&gt;&#x27;</span>);</span><br><span class="line">    response.write(<span class="string">&#x27;&lt;body&gt;&#x27;</span>);</span><br><span class="line">    response.write(<span class="string">&#x27;&lt;form method=&quot;post&quot;&gt;&#x27;</span>);  <span class="comment">//表单post输出传入下面的函数</span></span><br><span class="line">    response.write(<span class="string">&#x27;username:&lt;input name=&quot;username&quot;&gt;&#x27;</span>);</span><br><span class="line">    response.write(<span class="string">&#x27;password:&lt;input name=&quot;password&quot;&gt;&lt;input type=&quot;submit&quot;&gt;&#x27;</span>);</span><br><span class="line">    response.write(<span class="string">&#x27;&lt;/form&gt;&#x27;</span>);</span><br><span class="line">    response.write(<span class="string">&#x27;&lt;/body&gt;&#x27;</span>);</span><br><span class="line">    response.write(<span class="string">&#x27;&lt;/html&gt;&#x27;</span>);</span><br><span class="line">    <span class="comment">// 将HTTP响应的HTML内容写入response:</span></span><br><span class="line">    response.end()</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doPost</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> formDate = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 通过req的data事件监听函数，每当接受到请求体的数据，就累加到formDate变量中</span></span><br><span class="line">    req.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        formDate += data;</span><br><span class="line">        <span class="built_in">console</span>.log(data); </span><br><span class="line"><span class="comment">//&lt;Buffer 75 73 65 72 6e 61 6d 65 3d 25 45 39 25 41 44 25 38 46 25 45 36 25 42 34 25 38 31 25 45 36 25 39 44 25 41 38 26 70 61 73 73 77 6f 72 64 3d 34 35 36 37&gt;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 在end事件触发后，通过querystring.parse将formDate解析为真正的POST请求格式，然后向客户端返回。</span></span><br><span class="line">    req.on(<span class="string">&#x27;end&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> body = querystring.parse(formDate);</span><br><span class="line">    res.end(util.inspect(body));</span><br><span class="line">      <span class="comment">// [Object: null prototype] &#123; username: &#x27;wjy&#x27;, password: &#x27;456&#x27; &#125;</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Server is running at http://127.0.0.1:8080/&#x27;</span>);</span><br></pre></td></tr></table></figure><ul><li><code>request</code>：封装了HTTP请求，我们调用<code>request</code>对象的属性和方法就可以拿到所有HTTP请求的信息；<ul><li>{‘Content-Type’: ‘text/html’}：设置类型为html页面</li><li><strong>方法</strong><ul><li><code>req.on(&#39;data&#39;, function(data)&#123;&#125;)</code>：data为一个buffer数据，需要将所有数据包的字节都存储起来，再来分析</li><li><code>req.on(&#39;end&#39;, function(data)&#123;  res.end();  &#125;)</code>：在出发结束的函数后，再在他的function里面结束相应<code>res.end();</code></li></ul></li></ul></li><li><code>response</code>：封装了HTTP响应，我们操作<code>response</code>对象的方法，就可以把HTTP响应返回给浏览器。<ul><li><strong>方法</strong><ul><li><code>response.writeHead()</code>：设置http协议头，给浏览器看的</li><li><code>response.write()</code>：仅发送数据</li><li><code>response.end()</code>：发送并结束请求，必须有，可以发送空</li></ul></li></ul></li></ul><p><strong>编码模式</strong></p><ul><li>浏览器默认<code>urlencode</code>字符集编码，不支持中文<ul><li>接收浏览器的请求数据res，在nodejs中输出是中文适配的</li><li>但是如果直接将中文传到浏览器输出将会出现乱码，所以设置html页面属性meta为<code>utf-8</code></li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">res.write(<span class="string">&#x27;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;/&gt;&lt;/head&gt;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">------ urlcode 加解码 ------</span><br><span class="line"><span class="built_in">encodeURI</span>(<span class="string">&quot;魏洁杨&quot;</span>);    <span class="comment">// %E9%AD%8F%E6%B4%81%E6%9D%A8</span></span><br><span class="line"><span class="built_in">decodeURI</span>(<span class="string">&quot;%E9%AD%8F%E6%B4%81%E6%9D%A8&quot;</span>)   <span class="comment">//魏洁杨</span></span><br></pre></td></tr></table></figure><p><strong>请求内容</strong></p><ul><li>GET：<ul><li>由于GET请求直接被嵌入在路径中，URL是完整的请求路径，包括了?后面的部分，因此你可以手动解析后面的内容作为GET请求的参数。</li><li>下面 url 模块中的 <code>parse</code>函数提供了这个功能。</li></ul></li><li>POST：<ul><li>POST 请求的内容全部的都在请求体中，http.ServerRequest 并没有一个属性内容为请求体，原因是等待请求体传输可能是一件耗时的工作。</li><li>比如上传文件，而很多时候我们可能并不需要理会请求体的内容，恶意的POST请求会大大消耗服务器的资源，所以 node.js 默认是不会解析请求体的，当你需要的时候，需要手动来做。</li><li>下面的querystring和util模块提供了相应的处理</li></ul></li></ul><h4 id="url"><a href="#url" class="headerlink" title="url"></a>url</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(url.parse(<span class="string">&#x27;http://user:pass@host.com:8080/path/to/file?query=string#hash&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出 */</span></span><br><span class="line">Url &#123;</span><br><span class="line">  protocol: <span class="string">&#x27;http:&#x27;</span>,</span><br><span class="line">  slashes: <span class="literal">true</span>,</span><br><span class="line">  auth: <span class="string">&#x27;user:pass&#x27;</span>,</span><br><span class="line">  host: <span class="string">&#x27;host.com:8080&#x27;</span>,</span><br><span class="line">  port: <span class="string">&#x27;8080&#x27;</span>,</span><br><span class="line">  hostname: <span class="string">&#x27;host.com&#x27;</span>,</span><br><span class="line">  hash: <span class="string">&#x27;#hash&#x27;</span>,</span><br><span class="line">  search: <span class="string">&#x27;?query=string&#x27;</span>,</span><br><span class="line">  query: <span class="string">&#x27;query=string&#x27;</span>,</span><br><span class="line">  pathname: <span class="string">&#x27;/path/to/file&#x27;</span>,</span><br><span class="line">  path: <span class="string">&#x27;/path/to/file?query=string&#x27;</span>,</span><br><span class="line">  href: <span class="string">&#x27;http://user:pass@host.com:8080/path/to/file?query=string#hash&#x27;</span> &#125;</span><br></pre></td></tr></table></figure><h4 id="querystring"><a href="#querystring" class="headerlink" title="querystring"></a>querystring</h4><p>模块提供用于解析和格式化 URL 查询字符串的实用工具</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123; unescapeBuffer: [Function],</span></span><br><span class="line"><span class="comment">  unescape: [Function: qsUnescape],</span></span><br><span class="line"><span class="comment">  escape: [Function],</span></span><br><span class="line"><span class="comment">  encode: [Function],</span></span><br><span class="line"><span class="comment">  stringify: [Function],</span></span><br><span class="line"><span class="comment">  decode: [Function],</span></span><br><span class="line"><span class="comment">  parse: [Function] &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">console</span>.log(querystring);</span><br></pre></td></tr></table></figure><p><strong>序列化：url -&gt; 对象</strong></p><p><code>querystring.parse(str[, sep[, eq[, options]]])</code></p><ul><li><p>把一个URL查询字符串(str)解析成一个<strong>键值对的集合</strong></p></li><li><p>参数</p><ul><li><p><strong>str</strong>：要解析的 URL 查询字符串</p></li><li><p><strong>sep</strong>：用于在查询字符串中分隔键值对的子字符串。<strong>默认值:</strong> <code>&#39;&amp;&#39;</code></p></li><li><p><strong>eq</strong>：用于在查询字符串中分隔键和值的子字符串。<strong>默认值:</strong> <code>&#39;=&#39;</code>。</p></li><li><p><strong>Options</strong>：</p><ul><li><code>decodeURIComponent</code> <a href="http://url.nodejs.cn/ceTQa6"><Function></Function></a> 当解码查询字符串中的百分比编码字符时使用的函数。<strong>默认值:</strong> <code>querystring.unescape()</code>。</li><li><code>maxKeys</code> <a href="http://url.nodejs.cn/SXbo1v"><number></number></a> 指定要解析的键的最大数量。指定 <code>0</code> 可移除键的计数限制。<strong>默认值:</strong> <code>1000</code>。</li><li>注：默认情况下，会假定查询字符串中的百分比编码字符使用 UTF-8 编码。 如果使用其他的字符编码，则需要指定其他的 <code>decodeURIComponent</code> 选项</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;foo=bar&amp;abc=xyz&amp;abc=123&quot;</span></span><br><span class="line"><span class="keyword">var</span> body = querystring.parse(str)</span><br><span class="line"><span class="comment">//body = &#x27;&#123; foo: &#x27;bar&#x27;, abc: [ &#x27;xyz&#x27;, &#x27;123&#x27; ] &#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">querystring.parse(<span class="string">&#x27;w=%D6%D0%CE%C4&amp;foo=bar&#x27;</span>, <span class="literal">null</span>, <span class="literal">null</span>,</span><br><span class="line">                  &#123; <span class="attr">decodeURIComponent</span>: gbkDecodeURIComponent &#125;);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>注意：本方法返回的对象不继承自 JavaScript 的 Object。 这意味着典型的 Object 方法如 <code>obj.toString()</code>、<code>obj.hasOwnProperty()</code>等没有被定义且无法使用</p></li></ul><p><strong>反序列化：对象 -&gt; url</strong></p><p><code>querystring.stringify(obj[, sep][, eq][, options])</code></p><ul><li><p>通过遍历对象的自有属性，从一个给定的obj产生一个URL查询字符串</p></li><li><p>参数：</p><ul><li><p><strong>obj</strong>：要序列化为 URL 查询字符串的对象。</p></li><li><p><strong>sep</strong>：用于在查询字符串中分隔键值对的子字符串。<strong>默认值:</strong> <code>&#39;&amp;&#39;</code></p></li><li><p><strong>eq</strong>：用于在查询字符串中分隔键和值的子字符串。<strong>默认值:</strong> <code>&#39;=&#39;</code></p></li><li><p><strong>options</strong>：</p><ul><li><code>decodeURIComponent</code> <a href="http://url.nodejs.cn/ceTQa6"><Function></Function></a> 当解码查询字符串中的百分比编码字符时使用的函数。<strong>默认值:</strong> <code>querystring.unescape()</code>。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">querystring.stringify(&#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>: [<span class="string">&#x27;qux&#x27;</span>, <span class="string">&#x27;quux&#x27;</span>], <span class="attr">corge</span>: <span class="string">&#x27;&#x27;</span> &#125;);</span><br><span class="line"><span class="comment">// 返回 &#x27;foo=bar&amp;baz=qux&amp;baz=quux&amp;corge=&#x27;</span></span><br><span class="line"></span><br><span class="line">querystring.stringify(&#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>: <span class="string">&#x27;qux&#x27;</span> &#125;, <span class="string">&#x27;;&#x27;</span>, <span class="string">&#x27;:&#x27;</span>);</span><br><span class="line"><span class="comment">// 返回 &#x27;foo:bar;baz:qux&#x27;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>编码</strong></p><p><code>querystring.escape(str)</code></p><p><code>querystring.unescape(str)</code></p><ul><li><p>给定的 <code>str</code> 上执行 URL 百分比编码字符的解码</p></li><li><p><code>querystring.unescape()</code> 方法由 <code>querystring.parse()</code> 使用，通常不会被直接地使用。 它的导出主要是为了允许应用程序代码在需要时通过将 <code>querystring.unescape</code> 赋值给替代函数来提供替换的解码实现。</p><p>默认情况下， <code>querystring.unescape()</code> 方法将会尝试使用 JavaScript 内置的 <code>decodeURIComponent()</code> 方法进行解码。 如果失败，则将会使用更保险的不会因格式错误的 URL 而抛出异常的同类方法。</p></li></ul><h4 id="body-parser"><a href="#body-parser" class="headerlink" title="body-parser"></a>body-parser</h4><h4 id="util"><a href="#util" class="headerlink" title="util"></a>util</h4><h4 id="path"><a href="#path" class="headerlink" title="path"></a>path</h4><h3 id="socket-io"><a href="#socket-io" class="headerlink" title="socket.io"></a>socket.io</h3><h3 id="module-exports"><a href="#module-exports" class="headerlink" title="module  exports"></a>module  exports</h3><p><strong>模块规范</strong></p><ul><li><code>CommonJS</code>模块规范和<code>ES6</code>模块规范完全是两种不同的概念。</li><li><a class="link" href="http://javascript.ruanyifeng.com/nodejs/module.html">CommonJS规范<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" href="http://es6.ruanyifeng.com/#docs/module">ES6 Module 的语法<i class="fas fa-external-link-alt"></i></a></li></ul><p><strong>CommonJS</strong></p><ul><li><strong>Node</strong>应用由模块组成，采用CommonJS模块规范。</li><li>根据这个规范，每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。</li><li>CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。</li></ul><ul><li>下面代码通过module.exports输出变量x和函数addX。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> addX = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value + x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports.x = x;</span><br><span class="line"><span class="built_in">module</span>.exports.addX = addX;</span><br></pre></td></tr></table></figure><ul><li>require方法用于加载模块。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> example = <span class="built_in">require</span>(<span class="string">&#x27;./example.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(example.x); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(example.addX(<span class="number">1</span>)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><ul><li><strong>exports 与 module.exports</strong><ul><li>为了方便，Node为每个模块提供一个exports变量，指向module.exports。这等同在每个模块头部，有一行这样的命令。</li><li><code>var exports = module.exports;</code></li><li>于是我们可以直接在 exports 对象上添加方法，表示对外输出的接口，如同在module.exports 上添加一样。注意，不能直接将exports变量指向一个值，因为这样等于切断了exports与module.exports的联系。</li></ul></li></ul><p><strong>ES6</strong></p><ul><li>不同于CommonJS，ES6使用 export 和 import 来导出、导入模块。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// profile.js</span></span><br><span class="line"><span class="keyword">var</span> firstName = <span class="string">&#x27;Michael&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> lastName = <span class="string">&#x27;Jackson&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> year = <span class="number">1958</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;firstName, lastName, year&#125;;</span><br></pre></td></tr></table></figure><ul><li>需要特别注意的是，export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;m&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法三</span></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;n <span class="keyword">as</span> m&#125;;</span><br></pre></td></tr></table></figure><p><strong>export default</strong></p><ul><li>使用export default命令，为模块指定默认输出。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// export-default.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="crypto"><a href="#crypto" class="headerlink" title="crypto"></a>crypto</h3><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><h3 id="express"><a href="#express" class="headerlink" title="express"></a>express</h3><h1 id="多人实时聊天服务器"><a href="#多人实时聊天服务器" class="headerlink" title="多人实时聊天服务器"></a>多人实时聊天服务器</h1><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p><code>npm install socket.io --save</code>    </p><ul><li><p>网络上的程序实现双向的数据链接，这个链接的一端成为socket。</p><p> 1.Socket是一个持久链接。</p><p> 2.Socket是双向通信的。</p></li></ul><p><strong>Socket VS ajax轮询</strong></p><ul><li>ajax轮询 ， 是利用客户端来发送请求，每隔几秒发送一个http请求，服务器压力大。</li><li>Socket不会，一旦链接不会断开，可以实现实时通信。 比如微信的朋友圈更新提示。即时聊天通讯。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;h2 id=&quot;NPM&quot;&gt;&lt;a href=&quot;#NPM&quot; class=&quot;headerlink&quot; title=&quot;NPM&quot;&gt;&lt;/a&gt;NPM&lt;/h2&gt;&lt;u</summary>
      
    
    
    
    <category term="notebook" scheme="https://jieyang-wei.github.io/categories/notebook/"/>
    
    
    <category term="编程语言" scheme="https://jieyang-wei.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="nodejs" scheme="https://jieyang-wei.github.io/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>ruby</title>
    <link href="https://jieyang-wei.github.io/2020/12/17/ruby/"/>
    <id>https://jieyang-wei.github.io/2020/12/17/ruby/</id>
    <published>2020-12-17T02:12:34.000Z</published>
    <updated>2020-12-18T07:59:53.447Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Ruby是一种纯粹的面向对象编程语言。它由日本的松本行弘（まつもとゆきひろ/Yukihiro Matsumoto）创建于1993年。</p><p>您可以在 <a class="link" href="http://www.ruby-lang.org/">www.ruby-lang.org<i class="fas fa-external-link-alt"></i></a> 的 Ruby 邮件列表上找到松本行弘（まつもとゆきひろ/Yukihiro Matsumoto）的名字。在 Ruby 社区，松本也被称为马茨（Matz）。</p><p><strong>Ruby 是”程序员的最佳朋友”。</strong></p><p>Ruby 的特性与 Smalltalk、Perl 和 Python 类似。Perl、Python 和 Smalltalk 是脚本语言。Smalltalk 是一个真正的面向对象语言。Ruby，与 Smalltalk 一样，是一个完美的面向对象语言。使用 Ruby 的语法比使用 Smalltalk 的语法要容易得多。</p><p><strong>Ruby历史</strong></p><p>Ruby明显比其他类似的编程语言（如Perl或Python）年轻，又因为Ruby是日本人发明的，所以早期的非日文资料和程序都比较贫乏，所以在网上仍然可以找到类似“Ruby的资料太少”之类的批评。约于2000年，Ruby开始进入美国，英文的资料开始发展。Ruby归根结底源于Perl和Python两类语言，与C，C++，C#，java是不同大类。</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>Ruby 是开源的，在 Web 上免费提供，但需要一个许可证。</li><li>Ruby 是一种通用的、解释的编程语言。</li><li>Ruby 是一种真正的面向对象编程语言。</li><li>Ruby 是一种类似于 Python 和 Perl 的服务器端脚本语言。</li><li>Ruby 可以用来编写通用网关接口（CGI）脚本。</li><li>Ruby 可以被嵌入到超文本标记语言（HTML）。</li><li>Ruby 语法简单，这使得新的开发人员能够快速轻松地学习 Ruby。</li><li>Ruby 与 C++ 和 Perl 等许多编程语言有着类似的语法。</li><li>Ruby 可扩展性强，用 Ruby 编写的大程序易于维护。</li><li>Ruby 可用于开发的 Internet 和 Intranet 应用程序。</li><li>Ruby 可以安装在 Windows 和 POSIX 环境中。</li><li>Ruby 支持许多 GUI 工具，比如 Tcl/Tk、GTK 和 OpenGL。</li><li>Ruby 可以很容易地连接到 DB2、MySQL、Oracle 和 Sybase。</li><li>Ruby 有丰富的内置函数，可以直接在 Ruby 脚本中使用。</li></ul><p><strong>语言特点</strong></p><ul><li>完全面向对象<ul><li>在Ruby语言中，任何东西都是对象，包括其他语言中的基本数据类型，比如整数</li></ul></li><li>变量没有类型</li><li>Ruby的变量可以保存任何类型的数据。</li><li>任何东西都有值</li><li>不管是数学或者逻辑表达式还是一个语句，都会有值。</li><li>ruby语言很优雅，可以做到不需要注释就可以读懂。</li></ul><p>Ruby是动态语言，你可以在程序中修改先前定义过的类。 也可以在某个类的实例中定义该实例特有的方法，这叫做单例方法。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">the_method</span></span></span><br><span class="line">        <span class="string">&quot;generalmethod&quot;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">mc=MyClass.new</span><br><span class="line">def mc.the_method</span><br><span class="line">    <span class="string">&quot;special for this instance.&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><strong>Homebrew:</strong></p><ul><li><a class="link" href="https://brew.sh/index_zh-cn">官网链接<i class="fas fa-external-link-alt"></i></a></li><li>Homebrew是一款Mac OS平台下的软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能。简单的一条指令，就可以实现包管理，而不用你关心各种依赖和文件路径的情况，十分方便快捷。</li><li>援引<a class="link" href="https://link.jianshu.com/?t=http://brew.sh/">官方<i class="fas fa-external-link-alt"></i></a>的一句话：又提示缺少套件啦？别担心，Homebrew 随时守候。Homebrew —— OS X 不可或缺的套件管理器。</li></ul><ul><li>安装路径：<code>/usr/local/Homebrew</code></li><li>大部分情况下，它把软件包安装到 <code>/usr/local/Cellar/程序名/版本号</code>目录 下，然后在 <code>/usr/local/bin</code> 下建立符号链接，没有其他的操作了。</li></ul><ul><li><strong>指令</strong><ul><li>brew –version：查看版本</li><li>brew –repo：查看路径</li></ul></li></ul><p><strong>Ruby:</strong></p><ul><li><a class="link" href="http://www.ruby-lang.org/zh_cn/">官网链接<i class="fas fa-external-link-alt"></i></a></li><li>Ruby，一种简单快捷的面向对象（面向对象程序设计）脚本语言</li><li>Mac OS X 或 Linux，别在 Windows 上面搞，那是在浪费时间，两个原因：<ol><li>Ruby 对 Unix 环境的需求非常高，这点 Mac OS X 和 Linux 系列的系统才能很好的满足；</li><li>Ruby 在 Windows 环境下面执行效率低。</li></ol></li><li>CocoaPods是用Ruby构建的，它可以使用macOS上的默认Ruby进行安装。您可以使用Ruby版本管理器(RVM)，但建议使用macOS上提供的标准Ruby。</li></ul><hr><p><strong>注意：</strong>Mac OS X 或 Linux，别在 Windows 上面搞，那是在浪费时间，两个原因</p><ol><li>Ruby 对 Unix 环境的需求非常高，这点 Mac OS X 和 Linux 系列的系统才能很好的满足；</li><li>Ruby 在 Windows 环境下面执行效率低。</li></ol><hr><p><strong>RubyGem:</strong></p><ul><li><a class="link" href="https://www.runoob.com/ruby/ruby-rubygems.html">菜鸟教程<i class="fas fa-external-link-alt"></i></a></li><li>RubyGems 是 Ruby 的一个包管理器，它提供一个分发 Ruby 程序和库的标准格式，还提供一个管理程序包安装的工具。</li><li>RubyGems 旨在方便地管理 gem 安装的工具，以及用于分发 gem 的服务器。这类似于 Ubuntu 下的apt-get, Centos 的 yum，Python 的 pip。</li><li>RubyGems大约创建于2003年11月，从Ruby 1.9版起成为Ruby标准库的一部分。</li><li>Gem 是 Ruby 模块 (叫做 Gems) 的包管理器。其包含包信息，以及用于安装的文件。</li><li>Gem通常是依照”.gemspec”文件构建的，包含了有关Gem信息的YAML文件。Ruby代码也可以直接建立Gem，这种情况下通常利用Rake来进行。</li><li>gem命令用于构建、上传、下载以及安装Gem包。</li></ul><ul><li><strong>指令</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ruby -v          <span class="comment"># 查看安装版本</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rvm -v</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gem sources -l   <span class="comment"># 查看默认镜像源</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> uby的默认源使用的是cocoapods.org，国内访问这个网址有时候会有问题，网上的一种解决方案是将远替换成淘宝的，替换方式如下</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gem <span class="built_in">source</span> -r https://rubygems.org/               <span class="comment"># 移除次镜像源</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gem <span class="built_in">source</span> -a/--add https://gems.ruby-china.org   <span class="comment"># 添加新的镜像源</span></span></span><br></pre></td></tr></table></figure><img src="/2020/12/17/ruby/截屏2020-12-18 上午9.17.40.png" alt="截屏2020-12-18 上午9.17.40" style="zoom:50%;"><p><strong>RVM:</strong></p><ul><li><a class="link" href="https://rvm.io/">官网链接<i class="fas fa-external-link-alt"></i></a></li><li>(Ruby Version Manager)Ruby的版本管理工具。</li><li>RVM 是一个命令行工具，可以让你简单的管理多种版本的Ruby，并在这些版本中切换。</li><li><a class="link" href="https://www.jianshu.com/p/c44ef74d99f9">简书教程<i class="fas fa-external-link-alt"></i></a></li></ul><ul><li><strong>指令</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rvm install 版本      <span class="comment"># 安装指定版本</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rvm install ruby --head  <span class="comment"># 安装最新版本</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> RVM其他常用命令</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rvm info                   <span class="comment"># rvm信息</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rvm list known             <span class="comment"># 列出已知的ruby版本</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rvm list                   <span class="comment"># 查询已经安装的 ruby</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rvm use [版本号] --default  <span class="comment"># 配置ruby使用版本</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rvm get head               <span class="comment"># 升级</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rvm remove 版本号           <span class="comment"># 移除ruby版本</span></span></span><br></pre></td></tr></table></figure><h2 id="Linux-Unix"><a href="#Linux-Unix" class="headerlink" title="Linux / Unix"></a>Linux / Unix</h2><p><strong>Mac</strong></p><ul><li>默认情况下，mac系统已经安装了Ruby, 安装在 <code>/System/Library/Frameworks/Ruby.framework/Versions/Current </code> 目录下。</li><li>但是，由于默认的 Ruby 安装在 <code>/System</code> 目录下，过深的、与 *nix 约定不同的目录结构对日常的开发、维护都带来许多不便。</li></ul><p><strong>Linux/Unix</strong></p><p><a class="link" href="https://www.runoob.com/ruby/ruby-installation-unix.html">Linux/Unix 上的 Ruby 安装<i class="fas fa-external-link-alt"></i></a></p><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p><a class="link" href="https://www.runoob.com/ruby/ruby-installation-windows.html">Windows 上的 Ruby 安装<i class="fas fa-external-link-alt"></i></a></p><p><a class="link" href="https://www.runoob.com/ruby/ruby-command-line-options.html">Ruby 命令行选项<i class="fas fa-external-link-alt"></i></a></p><p><a class="link" href="https://www.runoob.com/ruby/ruby-environment-variables.html">Ruby 环境变量<i class="fas fa-external-link-alt"></i></a></p><ul><li>Ruby 解释器使用下列环境变量来控制它的行为。</li><li>ENV 对象包含了所有当前设置的环境变量列表。</li></ul><table><thead><tr><th align="left">变量</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><strong>DLN_LIBRARY_PATH</strong></td><td align="left">动态加载模块搜索的路径。</td></tr><tr><td align="left"><strong>HOME</strong></td><td align="left">当没有参数传递给 Dir::chdir 时，要移动到的目录。也用于 File::expand_path 来扩展 “~”。</td></tr><tr><td align="left"><strong>LOGDIR</strong></td><td align="left">当没有参数传递给 Dir::chdir 且未设置环境变量 HOME 时，要移动到的目录。</td></tr><tr><td align="left"><strong>PATH</strong></td><td align="left">执行子进程的搜索路径，以及在指定 -S 选项后，Ruby 程序的搜索路径。每个路径用冒号分隔（在 DOS 和 Windows 中用分号分隔）。</td></tr><tr><td align="left"><strong>RUBYLIB</strong></td><td align="left">库的搜索路径。每个路径用冒号分隔（在 DOS 和 Windows 中用分号分隔）。</td></tr><tr><td align="left"><strong>RUBYLIB_PREFIX</strong></td><td align="left">用于修改 RUBYLIB 搜索路径，通过使用格式 path1;path2 或 path1path2，把库的前缀 path1 替换为 path2。</td></tr><tr><td align="left"><strong>RUBYOPT</strong></td><td align="left">传给 Ruby 解释器的命令行选项。在 taint 模式时被忽略（其中，$SAFE 大于 0）。</td></tr><tr><td align="left"><strong>RUBYPATH</strong></td><td align="left">指定 -S 选项后，Ruby 程序的搜索路径。优先级高于 PATH。在 taint 模式时被忽略（其中，$SAFE 大于 0）。</td></tr><tr><td align="left"><strong>RUBYSHELL</strong></td><td align="left">指定执行命令时所使用的 shell。如果未设置该环境变量，则使用 SHELL 或 COMSPEC。</td></tr></tbody></table><h2 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h2><p>Ruby 不需要 IDE，一个简单的文本编辑器就足够了，作为 Ruby 开发者，这个必须习惯。</p><ul><li><p>Mac 平台</p><ul><li><a class="link" href="https://github.com/textmate/textmate/releases">TextMate 2<i class="fas fa-external-link-alt"></i></a></li></ul></li><li><p>Linux / Mac / Windows</p><ul><li><p><a class="link" href="https://code.visualstudio.com/">Visual Studio Code<i class="fas fa-external-link-alt"></i></a></p></li><li><p><a class="link" href="https://atom.io/">Atom<i class="fas fa-external-link-alt"></i></a></p></li><li><p><a class="link" href="http://www.vim.org/">Vim<i class="fas fa-external-link-alt"></i></a> 或 <a class="link" href="http://emacs.org/">Emacs<i class="fas fa-external-link-alt"></i></a></p></li><li><p>如果用 Vim 的话也可以尝试用 <a class="link" href="https://github.com/carlhuda/janus">janus<i class="fas fa-external-link-alt"></i></a></p></li><li><p>Vim 的 Rails 插件 <a class="link" href="http://www.vim.org/scripts/script.php?script_id=1567">rails.vim<i class="fas fa-external-link-alt"></i></a></p></li><li><p><strong><a class="link" href="http://www.sublimetext.com/">Sublime Text<i class="fas fa-external-link-alt"></i></a></strong></p><ul><li>Sublime文件默认存储编码为UTF8，我们几乎不用修改这个选项。</li><li>在按快捷键<code>Control + B</code>执行代码的时候，所有输出都会被Python（Sublime是用Python开发的）接收，然后输出到控制台，输出的字符串编码必须是UTF8编码。</li></ul></li></ul></li></ul><hr><p><strong>设置编译环境</strong></p><p>Tool -&gt; Build System</p><p><strong>编译</strong></p><p>Tool -&gt; build</p><hr><h1 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><strong>空白</strong></p><p><strong>行尾</strong></p><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><h3 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h3><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="语言标准"><a href="#语言标准" class="headerlink" title="语言标准"></a>语言标准</h3><ul><li><p>$ 开头的一定是全局变量</p></li><li><p>@ 开头的都是实例变量</p></li><li><p>@@ 开头的是类变量</p></li><li><p>常数则以大写字母开头</p><ul><li>这种方法，对文本编辑器的命令补全很有帮助，如在vim下先键入$及开头字母，再敲击Ctrl+p，则可专门补全本文件以及关联文件中的全局变量，perl与php亦有此优点。</li></ul></li><li><p>已经定义的类可以在运行时修改</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;Ruby是一种纯粹的面向对象编程语言。它由日本的松本行弘（まつもとゆきひろ/Yukihiro Matsumoto）创建于1993年。&lt;/p&gt;</summary>
      
    
    
    
    <category term="notebook" scheme="https://jieyang-wei.github.io/categories/notebook/"/>
    
    
    <category term="编程语言" scheme="https://jieyang-wei.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="rugy" scheme="https://jieyang-wei.github.io/tags/rugy/"/>
    
  </entry>
  
  <entry>
    <title>编程语言学习</title>
    <link href="https://jieyang-wei.github.io/2020/12/16/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    <id>https://jieyang-wei.github.io/2020/12/16/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-12-16T08:18:33.000Z</published>
    <updated>2021-02-02T06:57:08.480Z</updated>
    
    <content type="html"><![CDATA[<p>最快掌握编程语言</p><ul><li><p>coder：</p><ul><li><strong>图灵完备</strong>：相互之间可以替代的，c的能做，java也能，bat不是</li></ul><blockquote></blockquote><ul><li>标记语言，不是编程语言，没有逻辑</li></ul></li></ul><ol><li><p>语言背景</p></li><li><p>程序逻辑</p><ul><li>编程语言环境<ul><li>强类型：<ul><li>定义a = “string”，就知道a是一个字符串类型</li><li>Java，python</li></ul></li><li>弱类型：<ul><li>需要定义 String a = “String”，才知道类型，像C需要程序猿去判定类型</li><li>C，PHP，js</li></ul></li></ul></li></ul></li><li><p>变量</p><ul><li>变量定义<ul><li>动态类型<ul><li>js</li></ul></li><li>静态类型<ul><li>java</li></ul></li></ul></li><li>变量类型<ul><li>值类型（基本类型）<ul><li>变量在栈里面声明，</li><li>C，C++，引用类型通过指针来实现</li></ul></li><li>引用类型（封装类型）<ul><li>变量是指针，指向了内存地址中变量的地址</li><li>python，js</li></ul></li><li>java - 即保留值类型，也保留引用类型</li><li>应用在比较变量中，引用类型需要重写equal方法，不然比较的是地址</li></ul></li></ul></li><li><p>容器对象</p><ul><li>简单操作</li><li>浅复制，深复制、序列化</li></ul></li><li><p>类接口、抽象类</p></li><li><p>函数</p></li><li><p>生态、依赖</p><ul><li>框架，包管理工具</li></ul></li><li><p>高级特性</p><ul><li>java - 并发、高性能处理</li><li>是否支持携程</li></ul></li></ol><p>训练任务：</p><ol><li>支持消息循环的交互程序，一个文字版RPG小游戏</li><li>比较机械的控制，比如二进制位控制，</li></ol><p>【python game】</p><p>fixupdate</p><p>显卡不给力：一帧一帧的出来</p><p>update</p><p>window.setAnimation</p><p>2D技术跟3D完全不一样</p><p>3D - 显卡实时渲染</p><p>nodejs</p><p>ECMAScript，ES标准：</p><ul><li>最早浏览器支持的是ES2的标准</li></ul><p>WebKit</p><p>alert():bomapi</p><p>nodejs、unity这种是js运行的环境</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最快掌握编程语言&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;coder：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;图灵完备&lt;/strong&gt;：相互之间可以替代的，c的能做，java也能，bat不是&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;ul&gt;</summary>
      
    
    
    
    <category term="notebook" scheme="https://jieyang-wei.github.io/categories/notebook/"/>
    
    
    <category term="编程语言" scheme="https://jieyang-wei.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>python</title>
    <link href="https://jieyang-wei.github.io/2020/12/15/python/"/>
    <id>https://jieyang-wei.github.io/2020/12/15/python/</id>
    <published>2020-12-15T06:32:10.000Z</published>
    <updated>2020-12-25T15:13:39.014Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a>Anaconda</h1><ul><li><a class="link" href="https://www.jianshu.com/p/62f155eb6ac5">Anaconda部分原博客<i class="fas fa-external-link-alt"></i></a></li><li>Anaconda（<a class="link" href="https://link.jianshu.com/?t=https://www.anaconda.com/download/%23macos">官方网站<i class="fas fa-external-link-alt"></i></a>）就是可以便捷获取包且对包能够进行管理，同时对环境可以统一管理的发行版本。</li><li>Anaconda包含了conda、Python在内的超过180个科学包及其依赖项。</li><li>其特点的实现是因为包含：<ul><li> conda包</li><li>环境管理器</li><li>1000+开源库</li></ul></li></ul><p>特点：</p><ul><li>开源</li><li>安装过程简单</li><li>高性能使用python和R语言</li><li>免费的社区支持</li></ul><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><h3 id="1-Anaconda"><a href="#1-Anaconda" class="headerlink" title="1. Anaconda"></a>1. Anaconda</h3><ul><li>Anaconda是一个包含180+的科学包及其依赖项的发行版本。</li><li>其包含的科学包包括：<ul><li>conda, numpy, scipy, ipython notebook等。</li></ul></li></ul><h3 id="2-conda"><a href="#2-conda" class="headerlink" title="2. conda"></a>2. conda</h3><ul><li><p>conda是包及其依赖项和环境的管理工具。</p></li><li><p>适用语言：</p><ul><li>Python, R, Ruby, Lua, Scala, Java, JavaScript, C/C++, FORTRAN。</li></ul></li><li><p>适用平台：</p><ul><li>Windows, macOS, Linux</li></ul></li></ul><p><strong>用途</strong>：</p><ol><li>快速安装、运行和升级包及其依赖项。</li><li>在计算机中便捷地创建、保存、加载和切换环境。</li></ol><blockquote><p>如果你需要的包要求不同版本的Python，你无需切换到不同的环境，因为conda同样是一个环境管理器。仅需要几条命令，你可以创建一个完全独立的环境来运行不同的Python版本，同时继续在你常规的环境中使用你常用的Python版本。——<a class="link" href="https://link.jianshu.com/?t=https://conda.io/docs/">conda官方网站<i class="fas fa-external-link-alt"></i></a></p></blockquote><ul><li>onda为Python项目而创造，但可适用于上述的多种语言。</li><li>conda包和环境管理器包含于Anaconda的所有版本当中。</li></ul><h3 id="3-pip"><a href="#3-pip" class="headerlink" title="3. pip"></a>3. pip</h3><ul><li><p>pip是用于安装和管理软件包的包管理器。</p></li><li><p>pip编写语言：Python。</p></li><li><p>Python中默认安装的版本：</p><ul><li>Python 2.7.9及后续版本：默认安装，命令为<code>pip</code></li><li>Python 3.4及后续版本：默认安装，命令为<code>pip3</code></li></ul></li><li><p>pip名称的由来：pip采用的是<strong>递归缩写</strong>进行命名的。其名字被普遍认为来源于2处：</p><ul><li>“Pip installs Packages”（“pip安装包”）</li><li>“Pip installs Python”（“pip安装Python”）</li></ul></li></ul><h3 id="4-virtualenv"><a href="#4-virtualenv" class="headerlink" title="4.virtualenv"></a>4.virtualenv</h3><ul><li><p>virtualenv：用于创建一个<strong>独立的</strong>Python环境的工具。</p></li><li><p>解决问题：</p><ol><li>当一个程序需要使用Python 2.7版本，而另一个程序需要使用Python 3.6版本，如何同时使用这两个程序？</li><li>如果将所有程序都安装在系统下的默认路径，如：<code>/usr/lib/python2.7/site-packages</code>，当不小心升级了本不该升级的程序时，将会对其他的程序造成影响。</li><li>如果想要安装程序并在程序运行时对其库或库的版本进行修改，都会导致程序的中断。</li><li>在共享主机时，无法在全局<code>site-packages</code>目录中安装包。</li></ol></li><li><p>virtualenv将会为它自己的安装目录创建一个环境，这并<strong>不与</strong>其他virtualenv环境共享库；同时也可以<strong>选择性</strong>地不连接已安装的全局库。</p></li></ul><hr><p><strong>pip与conda比较</strong>：</p><ol><li><p><strong>依赖项检查</strong></p><ul><li>pip：<ul><li><strong>不一定</strong>会展示所需其他依赖包。</li><li>安装包时<strong>或许</strong>会直接忽略依赖项而安装，仅在结果中提示错误。</li></ul></li><li>conda：<ul><li>列出所需其他依赖包。</li><li>安装包时自动安装其依赖项。</li><li>可以便捷地在包的不同版本中自由切换。</li></ul></li></ul></li><li><p><strong>环境管理</strong></p><ul><li>pip：维护多个环境难度较大。</li><li>conda：比较方便地在不同环境之间进行切换，环境管理较为简单。</li></ul></li><li><p><strong>对系统自带Python的影响</strong></p><ul><li>pip：在系统自带Python中包的**更新/回退版本/卸载将影响其他程序。</li><li>conda：不会影响系统自带Python。</li></ul></li><li><p><strong>适用语言</strong></p><ul><li>pip：仅适用于Python。</li><li>conda：适用于Python, R, Ruby, Lua, Scala, Java, JavaScript, C/C++, FORTRAN。</li></ul></li></ol><p> <strong>conda与pip、virtualenv的关系</strong></p><ul><li>conda<strong>结合</strong>了pip和virtualenv的功能。</li></ul><hr><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>查看是否安装了python和anaconda：</p><img src="/2020/12/15/python/DF8274195F82F3A1713FE9FAB66C46B5.png" alt="DF8274195F82F3A1713FE9FAB66C46B5" style="zoom: 50%;">    <ol><li><p><code>$ conda list</code>：如果Anaconda被成功安装，则会显示已经安装的包名和版本号。</p></li><li><p><code>$ python</code>：进入python终端的命令行</p><ul><li>如果同时安装了Anaconda，则会显示上图红色的部分</li><li>exit() / quit()：退出</li></ul></li><li><p>终端输入<code>$ anaconda-navigator</code>将会打开anaconda-navigator图形界面</p></li></ol><p><strong>安装教程</strong>：自行百度，或者<a class="link" href="https://www.jianshu.com/p/62f155eb6ac5">原博客<i class="fas fa-external-link-alt"></i></a>有</p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="管理conda和环境"><a href="#管理conda和环境" class="headerlink" title="管理conda和环境"></a>管理conda和环境</h3><ul><li>验证conda已被安装</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda list              <span class="comment"># 显示已经安装的包名和版本号</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> conda --version         <span class="comment"># 查看conda版本号码</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> conda update conda      <span class="comment"># 更新conda至最新版本</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> conda --<span class="built_in">help</span>            <span class="comment"># 查看帮助信息</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rm -rf anaconda安装路径   <span class="comment"># 删除只需要删除安装目录即可（mac os）</span></span> </span><br></pre></td></tr></table></figure><p><strong>创建新环境</strong> </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda create --name &lt;env_name&gt; &lt;package_names&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;env_name&gt;</code>：即创建的环境名。建议以英文命名，且不加空格，名称两边不加尖括号“&lt;&gt;”。</li><li><code>&lt;package_names&gt;</code>：即安装在环境中的包名。名称两边不加尖括号“&lt;&gt;”。<ol><li>如果要安装指定的版本号，则只需要在包名后面以<code>=</code>和版本号的形式执行。如：<code>conda create --name python2 python=2.7</code>，即创建一个名为“python2”的环境，环境中安装版本为2.7的python。</li><li>如果要在新创建的环境中创建多个包，则直接在<code>&lt;package_names&gt;</code>后以<strong>空格</strong>隔开，添加多个包名即可。如：<code>conda create -n python3 python=3.5 numpy pandas</code>，即创建一个名为“python3”的环境，环境中安装版本为3.5的python，同时也安装了numpy和pandas。</li></ol></li><li>默认情况下，新创建的环境将会被保存在<code>/Users/&lt;user_name&gt;/anaconda3/env</code>目录下，其中，<code>&lt;user_name&gt;</code>为当前用户的用户名。</li></ul><p><strong>切换环境</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Linux 或macOS</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> activate &lt;env_name&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Windows</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> activate &lt;env_name&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>如果创建环境后安装Python时没有指定Python的版本，那么将会安装与Anaconda版本相同的Python版本，即如果安装Anaconda第2版，则会自动安装Python 2.x；如果安装Anaconda第3版，则会自动安装Python 3.x。</p></li><li><p>当成功切换环境之后，在该行行首将以“(env_name)”或“[env_name]”开头。其中，“env_name”为切换到的环境名。如：在macOS系统中执行<code>source active python2</code>，即切换至名为“python2”的环境，则行首将会以(python2)开头。</p></li></ul><p><strong>退出环境至root</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Linux 或macOS</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> deactivate</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Windows</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> deactivate</span></span><br></pre></td></tr></table></figure><ul><li>当执行退出当前环境，回到root环境命令后，原本行首以 “(env_name)” 或 “[env_name]” 开头的字符将不再显示。</li></ul><p><strong>显示已创建的环境</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda info -envs</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> conda info -e</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> conda env list</span></span><br></pre></td></tr></table></figure><img src="/2020/12/15/python/6349AECA-85FB-4EBA-82CE-CCBE8F84A59B.png" alt="6349AECA-85FB-4EBA-82CE-CCBE8F84A59B" style="zoom:50%;">    <ul><li>结果中星号<code>*</code>所在行即为当前所在环境。macOS系统中默认创建的环境名为<code>base</code>。</li></ul><p><strong>复制环境</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda create --name &lt;new_env_name&gt; --<span class="built_in">clone</span> &lt;copied_env_name&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;copied_env_name&gt;</code>即为被复制/克隆环境名。环境名两边不加尖括号“&lt;&gt;”</li><li><code>&lt;new_env_name&gt;</code>即为复制之后新环境的名称。环境名两边不加尖括号“&lt;&gt;”。<ul><li>如：<code>$ conda create --name py2 --clone python2</code>，即为克隆名为“python2”的环境，克隆后的新环境名为“py2”。此时，环境中将同时存在“python2”和“py2”环境，且两个环境的配置相同。</li></ul></li></ul><p><strong>删除环境</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda remove --name &lt;env_name&gt; --all</span></span><br></pre></td></tr></table></figure><p><strong>复制环境</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda create --name &lt;new_env_name&gt; --<span class="built_in">clone</span> &lt;copied_env_name&gt;</span></span><br></pre></td></tr></table></figure><h3 id="管理包"><a href="#管理包" class="headerlink" title="管理包"></a>管理包</h3><h4 id="1-查找可供安装的包版本"><a href="#1-查找可供安装的包版本" class="headerlink" title="1. 查找可供安装的包版本"></a>1. 查找可供安装的包版本</h4><ol><li>精确查找</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ conda search --full-name &lt;package_full_name&gt;</span><br></pre></td></tr></table></figure><ul><li><code>--full-name</code>：精确查找的参数。</li><li><code>&lt;package_full_name&gt;</code>：是被查找包的<strong>全名</strong>。包名两边不加尖括号“&lt;&gt;”。<ul><li>例如：<code>conda search --full-name python</code>即查找全名为“python”的包有哪些版本可供安装。</li></ul></li></ul><ol start="2"><li>模糊查找</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda search &lt;text&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;text&gt;</code>：查找含有<strong>此字段</strong>的包名。此字段两边不加尖括号“&lt;&gt;”。<ul><li>例如：<code>conda search py</code>即查找含有“py”字段的包，有哪些版本可供安装。</li></ul></li></ul><h4 id="2-获取当前环境中已安装的包信息"><a href="#2-获取当前环境中已安装的包信息" class="headerlink" title="2. 获取当前环境中已安装的包信息"></a>2. 获取当前环境中已安装的包信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda list</span></span><br></pre></td></tr></table></figure><ul><li>执行上述命令后将在终端显示当前环境已安装包的包名及其版本号。</li></ul><h4 id="3-安装包"><a href="#3-安装包" class="headerlink" title="3. 安装包"></a>3. 安装包</h4><ol><li><strong>在指定环境中安装包</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda install --name &lt;env_name&gt; &lt;package_name&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;env_name&gt;</code>：将包安装的指定环境名。环境名两边不加尖括号“&lt;&gt;”。</li><li><code>&lt;package_name&gt;</code>：要安装的包名。包名两边不加尖括号“&lt;&gt;”。<ul><li>例如：<code>conda install --name python2 pandas</code>即在名为“python2”的环境中安装pandas包。</li></ul></li></ul><ol start="2"><li><strong>在当前环境中安装包</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda install &lt;package_name&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;package_name&gt;</code>：要安装的包名。包名两边不加尖括号“&lt;&gt;”。</li><li>执行命令后在当前环境中安装包。<ul><li>例如：<code>conda install pandas</code>即在当前环境中安装pandas包。</li></ul></li></ul><ol start="3"><li><strong>使用pip安装包</strong></li></ol><p><strong>使用场景</strong>：</p><ul><li>当使用<code>conda install</code>无法进行安装时，可以使用pip进行安装。例如：see包。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> pip install &lt;package_name&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;pacage_name&gt;</code>：指定安装包的名称。包名两边不加尖括号“&lt;&gt;”。<ul><li>如：<code>pip install see</code>即安装see包。</li></ul></li></ul><p><strong>注意：</strong></p><ul><li>pip只是包管理器，无法对环境进行管理。因此如果想在指定环境中使用pip进行安装包，则需要先切换到指定环境中，再使用pip命令安装包。</li><li>pip无法更新python，因为pip并不将python视为包。</li><li>pip可以安装一些conda无法安装的包；conda也可以安装一些pip无法安装的包。因此当使用一种命令无法安装包时，可以尝试用另一种命令。</li></ul><ol start="4"><li><strong>从Anaconda.org安装包</strong></li></ol><p><strong>使用场景</strong></p><ul><li>当使用<code>conda install</code>无法进行安装时，可以考虑从Anaconda.org中获取安装包的命令，并进行安装。</li></ul><p><strong>注意</strong></p><ol><li>从Anaconda.org安装包时，无需注册。</li><li>在<strong>当前环境</strong>中安装来自于Anaconda.org的包时，需要通过输入要安装的包在Anaconda.org中的路径作为获取途径（channel）</li></ol><h4 id="4-卸载包"><a href="#4-卸载包" class="headerlink" title="4. 卸载包"></a>4. 卸载包</h4><ol><li>卸载指定环境中的包</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda remove --name &lt;env_name&gt; &lt;package_name&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;env_name&gt;</code>：卸载包所在指定环境的名称。环境名两边不加尖括号“&lt;&gt;”</li><li><code>&lt;package_name&gt;</code>：要卸载包的名称。包名两边不加尖括号“&lt;&gt;”。<ul><li>例如：<code>conda remove --name python2 pandas</code>即卸载名为“python2”中的pandas包。</li></ul></li></ul><ol start="2"><li>卸载当前环境中的包</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda remove &lt;package_name&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;package_name&gt;</code>：要卸载包的名称。包名两边不加尖括号“&lt;&gt;”。</li><li>执行命令后即在当前环境中卸载指定包。<ul><li>例如：<code>conda remove pandas</code>即在当前环境中卸载pandas包。</li></ul></li></ul><h4 id="5-更新包"><a href="#5-更新包" class="headerlink" title="5. 更新包"></a>5. 更新包</h4><ol><li>更新所有包</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda update --all</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> conda upgrade --all</span></span><br></pre></td></tr></table></figure><ul><li>建议：在安装Anaconda之后执行上述命令更新Anaconda中的所有包至最新版本，便于使用。</li></ul><ol start="2"><li>更新指定包</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda update &lt;package_name&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> conda upgrade &lt;package_name&gt;</span></span><br></pre></td></tr></table></figure><ul><li>注意：<ol><li><code>&lt;package_name&gt;</code>为指定更新的包名。包名两边不加尖括号“&lt;&gt;”。</li><li>更新多个指定包，则包名以<strong>空格</strong>隔开，向后排列。如：<code>conda update pandas numpy matplotlib</code>即更新pandas、numpy、matplotlib包。</li></ol></li></ul><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><p><a class="link" href="https://www.runoob.com/python/python-tutorial.html">菜鸟教程<i class="fas fa-external-link-alt"></i></a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>Python 是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言</li><li>Python 的设计具有很强的可读性，相比其他语言经常使用英文关键字，其他语言的一些标点符号，它具有比其他语言更有特色语法结构。<ul><li><strong>Python 是一种解释型语言：</strong>这意味着开发过程中没有了编译这个环节。类似于PHP和Perl语言。</li><li><strong>Python 是交互式语言：</strong>这意味着，您可以在一个 Python 提示符 <strong>&gt;&gt;&gt;</strong> 后直接执行代码。</li><li><strong>Python 是面向对象语言：</strong> 这意味着Python支持面向对象的风格或代码封装在对象的编程技术。</li><li><strong>Python 是初学者的语言：</strong>Python 对初级程序员而言，是一种伟大的语言，它支持广泛的应用程序开发，从简单的文字处理到 WWW 浏览器再到游戏。</li></ul></li></ul><p>特点：</p><ol><li><strong>易于学习：</strong>Python有相对较少的关键字，结构简单，和一个明确定义的语法，学习起来更加简单。</li><li><strong>易于阅读：</strong>Python代码定义的更清晰。</li><li><strong>易于维护：</strong>Python的成功在于它的源代码是相当容易维护的。</li><li><strong>一个广泛的标准库：</strong>Python的最大的优势之一是丰富的库，跨平台的，在UNIX，Windows和Macintosh兼容很好。</li><li><strong>互动模式：</strong>互动模式的支持，您可以从终端输入执行代码并获得结果的语言，互动的测试和调试代码片断。</li><li><strong>可移植：</strong>基于其开放源代码的特性，Python已经被移植（也就是使其工作）到许多平台。</li><li><strong>可扩展：</strong>如果你需要一段运行很快的关键代码，或者是想要编写一些不愿开放的算法，你可以使用C或C++完成那部分程序，然后从你的Python程序中调用。</li><li><strong>数据库：</strong>Python提供所有主要的商业数据库的接口。</li><li><strong>GUI编程：</strong>Python支持GUI可以创建和移植到许多系统调用。</li><li><strong>可嵌入：</strong>你可以将Python嵌入到C/C++程序，让你的程序的用户获得”脚本化”的能力。</li></ol><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><p>安装过程：自行百度云</p><p><strong>环境变量</strong></p><table><thead><tr><th>PYTHONPATH</th><th>PYTHONPATH是Python搜索路径，默认我们import的模块都会从PYTHONPATH里面寻找。</th></tr></thead><tbody><tr><td>PYTHONSTARTUP</td><td>Python启动后，先寻找PYTHONSTARTUP环境变量，然后执行此变量指定的文件中的代码。</td></tr><tr><td>PYTHONCASEOK</td><td>加入PYTHONCASEOK的环境变量, 就会使python导入模块的时候不区分大小写.</td></tr><tr><td>PYTHONHOME</td><td>另一种模块搜索路径。它通常内嵌于的PYTHONSTARTUP或PYTHONPATH目录中，使得两个模块库更容易切换。</td></tr></tbody></table><p><strong>集成开发环境（IDE, Integrated Development Environment）</strong>：PyCharm</p><ul><li>PyCharm 是由 JetBrains 打造的一款 Python IDE，支持 macOS、 Windows、 Linux 系统。</li><li>功能 : <ul><li>调试、语法高亮、Project管理、代码跳转、智能提示、自动完成、单元测试、版本控制……</li></ul></li><li><a class="link" href="https://www.jetbrains.com/pycharm/download/">下载地址<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" href="http://www.runoob.com/w3cnote/pycharm-windows-install.html](https://www.runoob.com/w3cnote/pycharm-windows-install.html)">安装地址<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="基础教程"><a href="#基础教程" class="headerlink" title="基础教程"></a>基础教程</h2><p><strong>中文编码</strong></p><img src="/2020/12/15/python/截屏2020-12-15 下午4.13.19.png" alt="截屏2020-12-15 下午4.13.19" style="zoom:60%;"><ul><li>python3.x源文件默认支持中文编码，无需制定</li><li>如果你使用编辑器，同时需要设置 py 文件存储的格式为 UTF-8，否则会出现错误信息<ul><li>进入 <strong>file &gt; Settings</strong>，在输入框搜索 <strong>encoding</strong>。</li><li>找到 <strong>Editor &gt; File encodings</strong>，将 <strong>IDE Encoding</strong> 和 <strong>Project Encoding</strong> 设置为utf-8。</li></ul></li></ul><h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> num     <span class="comment"># python2.x</span></span><br><span class="line"><span class="built_in">print</span> (num)   <span class="comment"># python3.x</span></span><br></pre></td></tr></table></figure><ul><li>默认换行输出，如果不需要换行，在末尾加入逗号<code>print x,</code>这样的话只会空格</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]: <span class="built_in">print</span> (x, end=<span class="string">&quot;。&quot;</span>)   <span class="comment"># 1。2。3。</span></span><br></pre></td></tr></table></figure><ul><li>指定以”。”为末尾输出，默认是”\n”换行</li></ul><p><strong>等待用户输入：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">str</span> = <span class="built_in">input</span>(<span class="string">&quot;\n\n按下 enter 键后退出。&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>两种输出值的方式：</strong></p><ol><li>表达式</li><li>print()</li><li>文件使用文件对象write()方法，标准输出文件可以用 sys.stdout 引用。</li></ol><ul><li>如果你希望输出的形式更加多样，可以使用 str.format() 函数来格式化输出值。</li><li>如果你希望将输出的值转成字符串，可以使用 repr() 或 str() 函数来实现。<ul><li><strong>str()：</strong> 函数返回一个用户易读的表达形式。 </li><li><strong>repr()：</strong> 产生一个解释器易读的表达形式。</li></ul></li></ul><p><strong>python2.x中使用python2.x的print函数</strong>：</p><ul><li><code>from __future__ import print_function</code></li><li>可以导入 <code>__future__</code>包，该包禁用 Python2.x 的 print 语句，采用 Python3.x 的 print 函数</li><li>Python3.x 与 Python2.x 的许多兼容性设计的功能可以通过  <code>__future__</code>这个包来导入</li></ul><p><strong>输出格式</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&quot;&#123;0:&lt;10&#125;&#123;1:&lt;10&#125;&#123;2:&gt;5&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&#x27;word&#x27;</span>, <span class="string">&#x27;len&#x27;</span>, <span class="string">&#x27;num&#x27;</span>))</span><br><span class="line"><span class="comment"># word      len         num</span></span><br></pre></td></tr></table></figure><ul><li>以标准格式输出</li></ul><h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h4><ul><li><p>标识符由字母、数字、下划线组成。</p></li><li><p>所有标识符可以包括英文、数字以及下划线(_)，但不能以数字开头。</p></li><li><p>Python 中的标识符是区分大小写的。</p></li><li><p>以<strong>下划线开头</strong>的标识符是有特殊意义的。</p><ul><li>以单下划线开头<code> _foo</code>的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用<code>from xxx import *</code>而导入。</li><li>以双下划线开头的<code>__foo</code>代表类的私有成员，以双下划线开头和结尾的 <code>__foo__</code>代表 Python 里特殊方法专用的标识<ul><li>如<code>__init__()</code>代表类的构造函数。</li></ul></li></ul></li><li><p>Python 可以同一行显示多条语句，方法是用分号 <strong>;</strong> 分开</p><ul><li><code>print (&#39;hello&#39;); print (&#39;world&#39;)</code></li></ul></li></ul><h4 id="保留字符"><a href="#保留字符" class="headerlink" title="保留字符"></a>保留字符</h4><ul><li>不能用作常数或变数，或任何其他标识符名称</li><li>所有 Python 的关键字只包含小写字母</li></ul><table><thead><tr><th>and</th><th>exec</th><th>not</th></tr></thead><tbody><tr><td>assert</td><td>finally</td><td>or</td></tr><tr><td>break</td><td>for</td><td>pass</td></tr><tr><td>class</td><td>from</td><td>print</td></tr><tr><td>continue</td><td>global</td><td>raise</td></tr><tr><td>def</td><td>if</td><td>return</td></tr><tr><td>del</td><td>import</td><td>try</td></tr><tr><td>elif</td><td>in</td><td>while</td></tr><tr><td>else</td><td>is</td><td>with</td></tr><tr><td>except</td><td>lambda</td><td>yield</td></tr></tbody></table><h4 id="行和缩进"><a href="#行和缩进" class="headerlink" title="行和缩进"></a>行和缩进</h4><ul><li>学习 Python 与其他语言最大的区别就是，Python 的代码块不使用大括号 <strong>{}</strong> 来控制类，函数以及其他逻辑判断。python 最具特色的就是用缩进来写模块。</li><li>缩进的空白数量是可变的，但是所有代码块语句必须包含相同的缩进空白数量，这个必须严格执行。<ul><li><img src="/2020/12/15/python/截屏2020-12-15 下午4.27.30.png" alt="截屏2020-12-15 下午4.27.30" style="zoom:50%;">    </li></ul></li></ul><p><strong>多行语句：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">total = item_one + \</span><br><span class="line">        item_two + \</span><br><span class="line">        item_three</span><br><span class="line"><span class="comment"># 和</span></span><br><span class="line">days = [<span class="string">&#x27;Monday&#x27;</span>, <span class="string">&#x27;Tuesday&#x27;</span>, <span class="string">&#x27;Wednesday&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Thursday&#x27;</span>, <span class="string">&#x27;Friday&#x27;</span>]</span><br></pre></td></tr></table></figure><p><strong>引号：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">word = <span class="string">&#x27;word&#x27;</span></span><br><span class="line">sentence = <span class="string">&quot;这是一个句子。&quot;</span></span><br><span class="line">paragraph = <span class="string">&quot;&quot;&quot;这是一个段落</span></span><br><span class="line"><span class="string">包含了多个语句&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">多行注释1</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">多行注释2</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><ul><li>三引号可以由多行组成，编写多行文本的快捷语法，常用于文档字符串，在文件的特定地点，被当做注释。</li></ul><p><strong>空行：</strong></p><ul><li>函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。</li><li>空行与代码缩进不同，空行并不是Python语法的一部分。书写时不插入空行，Python解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。</li><li>记住：空行也是程序代码的一部分。</li></ul><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><h4 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = b = c = <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>以上实例，创建一个整型对象，值为1，三个变量被分配到相同的内存空间上。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b, c = <span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;john&quot;</span></span><br></pre></td></tr></table></figure><ul><li>为多个对象指定多个变量</li></ul><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><ol><li><p>算术运算符</p><ul><li>a = 10，b = 21</li></ul><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">+</td><td align="left">加 - 两个对象相加</td><td align="left">a + b 输出结果 31</td></tr><tr><td align="left">-</td><td align="left">减 - 得到负数或是一个数减去另一个数</td><td align="left">a - b 输出结果 -11</td></tr><tr><td align="left">*</td><td align="left">乘 - 两个数相乘或是返回一个被重复若干次的字符串</td><td align="left">a * b 输出结果 210</td></tr><tr><td align="left">/</td><td align="left">除 - x 除以 y</td><td align="left">b / a 输出结果 2.1</td></tr><tr><td align="left">%</td><td align="left">取模 - 返回除法的余数</td><td align="left">b % a 输出结果 1</td></tr><tr><td align="left">**</td><td align="left">幂 - 返回x的y次幂</td><td align="left">a**b 为10的21次方</td></tr><tr><td align="left">//</td><td align="left">取整除 - 向下取接近商的整数</td><td align="left"><code>&gt;&gt;&gt; 9//2 4 &gt;&gt;&gt; -9//2 -5</code></td></tr></tbody></table></li><li><p>比较（关系）运算符</p><ul><li>a = 10，b = 20</li></ul><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">==</td><td align="left">等于 - 比较对象是否相等</td><td align="left">(a == b) 返回 False。</td></tr><tr><td align="left">!=</td><td align="left">不等于 - 比较两个对象是否不相等</td><td align="left">(a != b) 返回 True。</td></tr><tr><td align="left">&gt;</td><td align="left">大于 - 返回x是否大于y</td><td align="left">(a &gt; b) 返回 False。</td></tr><tr><td align="left">&lt;</td><td align="left">小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。注意，这些变量名的大写。</td><td align="left">(a &lt; b) 返回 True。</td></tr><tr><td align="left">&gt;=</td><td align="left">大于等于 - 返回x是否大于等于y。</td><td align="left">(a &gt;= b) 返回 False。</td></tr><tr><td align="left">&lt;=</td><td align="left">小于等于 - 返回x是否小于等于y。</td><td align="left">(a &lt;= b) 返回 True。</td></tr></tbody></table></li><li><p>赋值运算符</p><ul><li>a = 10，b = 20</li></ul><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">=</td><td align="left">简单的赋值运算符</td><td align="left">c = a + b 将 a + b 的运算结果赋值为 c</td></tr><tr><td align="left">+=</td><td align="left">加法赋值运算符</td><td align="left">c += a 等效于 c = c + a</td></tr><tr><td align="left">-=</td><td align="left">减法赋值运算符</td><td align="left">c -= a 等效于 c = c - a</td></tr><tr><td align="left">*=</td><td align="left">乘法赋值运算符</td><td align="left">c *= a 等效于 c = c * a</td></tr><tr><td align="left">/=</td><td align="left">除法赋值运算符</td><td align="left">c /= a 等效于 c = c / a</td></tr><tr><td align="left">%=</td><td align="left">取模赋值运算符</td><td align="left">c %= a 等效于 c = c % a</td></tr><tr><td align="left">**=</td><td align="left">幂赋值运算符</td><td align="left">c **= a 等效于 c = c ** a</td></tr><tr><td align="left">//=</td><td align="left">取整除赋值运算符</td><td align="left">c //= a 等效于 c = c // a</td></tr><tr><td align="left">:=</td><td align="left">海象运算符，可在表达式内部为变量赋值。<strong>Python3.8 版本新增运算符</strong>。</td><td align="left">在这个示例中，赋值表达式可以避免调用 len() 两次:<br><code>if (n := len(a)) &gt; 10:    print(f&quot;List is too long (&#123;n&#125; elements, expected &lt;= 10)&quot;)</code></td></tr></tbody></table></li><li><p>逻辑运算符</p><ul><li>a = 10，b = 20</li></ul><table><thead><tr><th align="left">运算符</th><th align="left">逻辑表达式</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">and</td><td align="left">x and y</td><td align="left">布尔”与” - 如果 x 为 False，x and y 返回 x 的值，否则返回 y 的计算值。</td><td align="left">(a and b) 返回 20。</td></tr><tr><td align="left">or</td><td align="left">x or y</td><td align="left">布尔”或” - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。</td><td align="left">(a or b) 返回 10。</td></tr><tr><td align="left">not</td><td align="left">not x</td><td align="left">布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。</td><td align="left">not(a and b) 返回 False</td></tr></tbody></table></li><li><p>位运算符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">60</span>     <span class="comment"># 0011 1100</span></span><br><span class="line">b = <span class="number">13</span>     <span class="comment"># 0000 1101</span></span><br><span class="line">-----------------</span><br><span class="line">a&amp;b = <span class="number">12</span>   <span class="comment"># 0000 1100   按位与</span></span><br><span class="line">a|b = <span class="number">61</span>   <span class="comment"># 0011 1101   按位或</span></span><br><span class="line">a^b = <span class="number">49</span>   <span class="comment"># 0011 0001   按位异或</span></span><br><span class="line">~a = -<span class="number">61</span>   <span class="comment"># 1100 0011   按位取反</span></span><br><span class="line">a&lt;&lt;<span class="number">2</span> = <span class="number">240</span> <span class="comment"># 1111 0000   左移</span></span><br><span class="line">a&gt;&gt;<span class="number">2</span> = <span class="number">15</span>  <span class="comment"># 0000 1111   右移</span></span><br></pre></td></tr></table></figure></li><li><p>成员运算符</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">in</td><td align="left">如果在指定的序列中找到值返回 True，否则返回 False。</td><td align="left">x 在 y 序列中 , 如果 x 在 y 序列中返回 True。</td></tr><tr><td align="left">not in</td><td align="left">如果在指定的序列中没有找到值返回 True，否则返回 False。</td><td align="left">x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。</td></tr></tbody></table></li><li><p>身份运算符</p><ul><li>比较两个对象的存储单元</li><li><code>id()</code>：获取对象内存地址。</li><li>is和==<ul><li>is 用于判断两个变量引用对象是否为同一个</li><li> == 用于判断引用变量的值是否相等。</li></ul></li></ul><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">is</td><td align="left">is 是判断两个标识符是不是引用自一个对象</td><td align="left"><strong>x is y</strong>, 类似 <strong>id(x) == id(y)</strong> , 如果引用的是同一个对象则返回 True，否则返回 False</td></tr><tr><td align="left">is  not</td><td align="left">is not 是判断两个标识符是不是引用自不同对象</td><td align="left"><strong>x is not y</strong> ， 类似 **id(a) != id(b)**。如果引用的不是同一个对象则返回结果 True，否则返回 False。</td></tr></tbody></table></li><li><p>运算符优先级</p></li></ol><h4 id="标准数据类型"><a href="#标准数据类型" class="headerlink" title="标准数据类型"></a>标准数据类型</h4><ul><li>不可变数据：Number（数字）、String（字符串）、Tuple（元组）；<ul><li>变量赋值 <strong>a=5</strong> 后再赋值 <strong>a=10</strong>，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变 a 的值，相当于新生成了 a。</li></ul></li><li>可变数据：List（列表）、Dictionary（字典）、Set（集合）。<ul><li>变量赋值 <strong>la=[1,2,3,4]</strong> 后再赋值 <strong>la[2]=5</strong> 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。</li></ul></li></ul><h5 id="Numbers（数字）"><a href="#Numbers（数字）" class="headerlink" title="Numbers（数字）"></a>Numbers（数字）</h5><ul><li><p>数字数据类型用于存储数值。</p></li><li><p>他们是<strong>不可改变</strong>的数据类型，这意味着改变数字数据类型会分配一个新的对象。</p></li><li><p>当你指定一个值时，Number 对象就会被创建：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var1 = <span class="number">1</span></span><br><span class="line">var2 = <span class="number">10</span></span><br></pre></td></tr></table></figure><p><strong>删除</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> var1[,var2,[var3[..., varN]]]</span><br><span class="line"><span class="keyword">del</span> var</span><br><span class="line"><span class="keyword">del</span> var_a, var_b</span><br></pre></td></tr></table></figure><p><strong>数字类型</strong>：</p><ul><li>查询变量所指的对象类型<ul><li>内置的<code>type（）</code>函数：不会认为子类是一种父类类型</li><li><code>isinstance（）</code>：会认为子类是一种父类类型</li></ul></li></ul><table><thead><tr><th align="left">int</th><th align="left">long</th><th align="left">float</th><th align="left">complex</th></tr></thead><tbody><tr><td align="left">10</td><td align="left">51924361L</td><td align="left">0.0</td><td align="left">3.14j</td></tr><tr><td align="left">100</td><td align="left">-0x19323L</td><td align="left">15.20</td><td align="left">45.j</td></tr><tr><td align="left">-786</td><td align="left">0122L</td><td align="left">-21.9</td><td align="left">9.322e-36j</td></tr><tr><td align="left">080</td><td align="left">0xDEFABCECBDAECBFBAEl</td><td align="left">32.3e+18</td><td align="left">.876j</td></tr><tr><td align="left">-0490</td><td align="left">535633629843L</td><td align="left">-90.</td><td align="left">-.6545+0J</td></tr><tr><td align="left">-0x260</td><td align="left">-052318172735L</td><td align="left">-32.54e100</td><td align="left">3e+26J</td></tr><tr><td align="left">0x69</td><td align="left">-4721885298529L</td><td align="left">70.2E-12</td><td align="left">4.53e-7j</td></tr></tbody></table><ul><li><p>int（有符号整型）：通常被称为是整型或整数，是正或负整数，不带小数点</p></li><li><p>long（长整数）</p><ul><li><p>长整型也可以使用小写 l，但是还是建议您使用大写 L，避免与数字 1 混淆。Python使用 L 来显示长整型。</p><blockquote><p>long 类型只存在于 Python2.X 版本中，在 2.2 以后的版本中，int 类型数据溢出后会自动转为long类型。在 Python3.X 版本中 long 类型被移除，使用 int 替代。</p></blockquote></li></ul></li><li><p>float（浮点数）： 浮点型由整数部分与小数部分组成，浮点型也可以使用科学计数法表示（2.5e2 = 2.5 x 102 = 250）</p></li><li><p>bool（布尔值）</p><ul><li><blockquote><p>python2中没有这个数据类型</p></blockquote></li></ul></li><li><p>complex（复数）</p><ul><li>复数由实数部分和虚数部分构成，可以用 a + bj,或者 complex(a,b) 表示</li><li>复数的实部 a 和虚部 b 都是浮点型。</li></ul></li></ul><p><strong>运算：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> / <span class="number">4</span>    <span class="comment"># 除法，得到一个浮点数</span></span><br><span class="line"><span class="number">2</span> // <span class="number">4</span>   <span class="comment"># 除法，得到一个整数，但不一定是int类型的整数，可能是 1.0</span></span><br><span class="line"><span class="number">17</span> % <span class="number">3</span>   <span class="comment"># 取余</span></span><br><span class="line"><span class="number">2</span> ** <span class="number">5</span>   <span class="comment"># 乘方，得到32</span></span><br></pre></td></tr></table></figure><h5 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;hello world&quot;</span></span><br><span class="line">s[<span class="number">0</span>] = <span class="string">&#x27;1&#x27;</span>   <span class="comment"># 会报错</span></span><br></pre></td></tr></table></figure><p><strong>下标索引</strong></p><img src="/2020/12/15/python/截屏2020-12-15 下午6.08.56.png" alt="截屏2020-12-15 下午6.08.56" style="zoom:33%;"><ul><li>左往右：0开始，右往左：-1开始</li></ul><blockquote><p>在Python2中，普通字符串是以8位ASCII码进行存储的，而Unicode字符串则存储为16位unicode字符串，这样能够表示更多的字符集。使用的语法是在字符串前面加上前缀 <strong>u</strong>。</p><p>在Python3中，所有的字符串都是Unicode字符串</p></blockquote><p><strong>字符串操作</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&#x27;abcdef&#x27;</span></span><br><span class="line"><span class="built_in">print</span> (s[<span class="number">1</span>:<span class="number">5</span>])    <span class="comment"># bcde</span></span><br><span class="line"><span class="built_in">print</span> (s[<span class="number">1</span>:<span class="number">5</span>:<span class="number">2</span>])  <span class="comment"># bd</span></span><br><span class="line"><span class="built_in">print</span> (s * <span class="number">2</span>)     <span class="comment"># abcdefabcdef</span></span><br><span class="line"><span class="built_in">print</span> (s[:<span class="number">2</span>] + <span class="string">&#x27;11&#x27;</span>)  <span class="comment"># ab11</span></span><br></pre></td></tr></table></figure><ul><li>使用<code>[头下标:尾下标:步长]</code>来截取字符串，在头下标-尾下标的范围内以步长来截取字符</li><li><strong>注意</strong>：所有的截取都取不到尾下标</li></ul><p><strong>原始字符串：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">r&#x27;\n&#x27;</span>)    <span class="comment"># \n，不会进行换行，而是直接输出</span></span><br></pre></td></tr></table></figure><ul><li>所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。</li><li> 原始字符串除在字符串的第一个引号前加上字母 <strong>r/R</strong>以外，与普通字符串有着几乎完全相同的语法。</li></ul><p><strong>字符串格式化：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> (<span class="string">&quot;我叫 %s 今年 %d 岁!&quot;</span> % (<span class="string">&#x27;小明&#x27;</span>, <span class="number">10</span>))</span><br><span class="line"><span class="comment"># 我叫 小明 今年 10 岁!</span></span><br></pre></td></tr></table></figure><ul><li><p>使用与 C 中 sprintf 函数一样的语法。</p><blockquote><p>Python2.6 开始，新增了一种格式化字符串的函数 str.format()，它增强了字符串格式化的功能。</p></blockquote></li></ul><p><strong>f-string：</strong></p><ul><li>之后版本添加的，称之为字面量格式化字符串，是新的格式化字符串的语法。</li><li>不用再去判断使用 %s，还是 %d。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#### 以前 ###</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">&#x27;world&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;Hello %s&#x27;</span> % name</span><br><span class="line"><span class="string">&#x27;Hello world&#x27;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">#### 现在 ###</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">&#x27;world&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f&#x27;Hello <span class="subst">&#123;name&#125;</span>&#x27;</span>  <span class="comment"># 替换变量</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f&#x27;<span class="subst">&#123;<span class="number">1</span>+<span class="number">2</span>&#125;</span>&#x27;</span>         <span class="comment"># 使用表达式</span></span><br><span class="line"><span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>w = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;url&#x27;</span>: <span class="string">&#x27;www.runoob.com&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f&#x27;<span class="subst">&#123;w[<span class="string">&quot;name&quot;</span>]&#125;</span>: <span class="subst">&#123;w[<span class="string">&quot;url&quot;</span>]&#125;</span>&#x27;</span></span><br><span class="line"><span class="string">&#x27;Runoob: www.runoob.com&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">f&#x27;<span class="subst">&#123;x+<span class="number">1</span>&#125;</span>&#x27;</span>)   <span class="comment"># Python 3.6</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">f&#x27;<span class="subst">&#123;x+<span class="number">1</span>=&#125;</span>&#x27;</span>)  <span class="comment"># Python 3.8</span></span><br><span class="line"><span class="string">&#x27;x+1=2&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>内建函数：</strong></p><ul><li><p>列表 = 字符串.split(“str”)</p></li><li><p>capitalize()</p><ul><li>将字符串的第一个字符转换为大写</li></ul></li><li><p>center(width, fillchar)</p><ul><li>返回一个指定的宽度 width 居中的字符串，fillchar 为填充的字符，默认为空格。</li></ul></li><li><p>count(str, beg= 0,end=len(string))</p><ul><li>返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数</li></ul></li><li><p>bytes.decode(encoding=”utf-8”, errors=”strict”)</p><blockquote><p>Python3 中没有 decode 方法，但我们可以使用 bytes 对象的 decode() 方法来解码给定的 bytes 对象，这个 bytes 对象可以由 str.encode() 来编码返回。</p></blockquote></li><li><p>encode(encoding=’UTF-8’,errors=’strict’)</p><ul><li>以 encoding 指定的编码格式编码字符串，如果出错默认报一个ValueError 的异常，除非 errors 指定的是’ignore’或者’replace’</li></ul></li><li><p>endswith(suffix, beg=0, end=len(string))</p><ul><li>检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False.</li></ul></li><li><p>expandtabs(tabsize=8)</p><ul><li>把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8 。<br>8    </li></ul></li><li><p>find(str, beg=0, end=len(string))</p><ul><li>检测 str 是否包含在字符串中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1</li></ul></li><li><p>index(str, beg=0, end=len(string))</p><ul><li>跟find()方法一样，只不过如果str不在字符串中会报一个异常。</li></ul></li><li><p>isalnum()</p><ul><li>如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 True，否则返回 False</li></ul></li><li><p>isalpha()</p><ul><li>如果字符串至少有一个字符并且所有字符都是字母或中文字则返回 True, 否则返回 False</li></ul></li><li><p>isdigit()</p><ul><li>如果字符串只包含数字则返回 True 否则返回 False..</li></ul></li><li><p>islower()</p><ul><li>如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False</li></ul></li><li><p>isnumeric()</p><ul><li>如果字符串中只包含数字字符，则返回 True，否则返回 False</li></ul></li><li><p>isspace()</p><ul><li>如果字符串中只包含空白，则返回 True，否则返回 False.</li></ul></li><li><p>istitle()</p><ul><li>如果字符串是标题化的(见 title())则返回 True，否则返回 False</li></ul></li><li><p>isupper()</p><ul><li>如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False</li></ul></li><li><p>‘char’.join(seq)</p><ul><li>以指定字符串作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串</li></ul></li><li><p>len(string)</p><ul><li>返回字符串长度</li></ul></li><li><p>ljust(width[, fillchar])</p><ul><li>返回一个原字符串左对齐,并使用 fillchar 填充至长度 width 的新字符串，fillchar 默认为空格。</li></ul></li><li><p>lower()</p><ul><li>转换字符串中所有大写字符为小写.</li></ul></li><li><p>lstrip()</p><ul><li>截掉字符串左边的空格或指定字符。</li></ul></li><li><p>maketrans()</p><ul><li>创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目</li></ul></li><li><p>max(str)</p><ul><li>返回字符串 str 中最大的字母。</li></ul></li><li><p>min(str)</p><ul><li>返回字符串 str 中最小的字母。</li></ul></li><li><p>replace(old, new [, max])</p><ul><li>把将字符串中的 old 替换成 new,如果 max 指定，则替换不超过 max 次。</li></ul><blockquote><p><strong>注意：</strong>replace函数将会返回一个新的字符串，原来的字符串不会改变</p><p>需要使用：<code>str = str.replace(old, new)</code></p></blockquote></li><li><p>rfind(str, beg=0,end=len(string))</p><ul><li>类似于 find()函数，不过是从右边开始查找.</li></ul></li><li><p>rindex( str, beg=0, end=len(string))</p><ul><li>类似于 index()，不过是从右边开始.</li></ul></li><li><p>rjust(width,[, fillchar])</p><ul><li>返回一个原字符串右对齐,并使用fillchar(默认空格）填充至长度 width 的新字符串</li></ul></li><li><p>rstrip()</p><ul><li>删除字符串字符串末尾的空格.</li></ul></li><li><p>split(str=””, num=string.count(str))</p><ul><li>以 str 为分隔符截取字符串，如果 num 有指定值，则仅截取 num+1 个子字符串</li></ul></li><li><p>splitlines([keepends])</p><ul><li>按照行(‘\r’, ‘\r\n’, \n’)分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。</li></ul></li><li><p>startswith(substr, beg=0,end=len(string))</p><ul><li>检查字符串是否是以指定子字符串 substr 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查。</li></ul></li><li><p>strip([chars])</p><ul><li>在字符串上执行 lstrip()和 rstrip()</li></ul></li><li><p>swapcase()</p><ul><li>将字符串中大写转换为小写，小写转换为大写</li></ul></li><li><p>title()</p><ul><li>返回”标题化”的字符串,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle())</li></ul></li><li><p>translate(table, deletechars=””)</p><ul><li>根据 str 给出的表(包含 256 个字符)转换 string 的字符, 要过滤掉的字符放到 deletechars 参数中</li></ul></li><li><p>upper()</p><ul><li>转换字符串中的小写字母为大写</li></ul></li><li><p>zfill (width)</p><ul><li>返回长度为 width 的字符串，原字符串右对齐，前面填充0</li></ul></li><li><p>isdecimal()</p><ul><li>检查字符串是否只包含十进制字符，如果是返回 true，否则返回 false。</li></ul></li></ul><table><thead><tr><th align="left">序号</th><th align="left">方法及描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-capitalize.html">capitalize()<i class="fas fa-external-link-alt"></i></a> <br>将字符串的第一个字符转换为大写</td></tr><tr><td align="left">2</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-center.html">center(width, fillchar)<i class="fas fa-external-link-alt"></i></a> <br>返回一个指定的宽度 width 居中的字符串，fillchar 为填充的字符，默认为空格。</td></tr><tr><td align="left">3</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-count.html">count(str, beg= 0,end=len(string))<i class="fas fa-external-link-alt"></i></a> <br>返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数</td></tr><tr><td align="left">4</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-decode.html">bytes.decode(encoding=”utf-8”, errors=”strict”)<i class="fas fa-external-link-alt"></i></a><br> Python3 中没有 decode 方法，但我们可以使用 bytes 对象的 decode() 方法来解码给定的 bytes 对象，这个 bytes 对象可以由 str.encode() 来编码返回。</td></tr><tr><td align="left">5</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-encode.html">encode(encoding=’UTF-8’,errors=’strict’)<i class="fas fa-external-link-alt"></i></a> <br>以 encoding 指定的编码格式编码字符串，如果出错默认报一个ValueError 的异常，除非 errors 指定的是’ignore’或者’replace’</td></tr><tr><td align="left">6</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-endswith.html">endswith(suffix, beg=0, end=len(string))<i class="fas fa-external-link-alt"></i></a> <br>检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False.</td></tr><tr><td align="left">7</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-expandtabs.html">expandtabs(tabsize=8)<i class="fas fa-external-link-alt"></i></a> <br>把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8 。</td></tr><tr><td align="left">8</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-find.html">find(str, beg=0, end=len(string))<i class="fas fa-external-link-alt"></i></a> <br>检测 str 是否包含在字符串中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1</td></tr><tr><td align="left">9</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-index.html">index(str, beg=0, end=len(string))<i class="fas fa-external-link-alt"></i></a> <br>跟find()方法一样，只不过如果str不在字符串中会报一个异常。</td></tr><tr><td align="left">10</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-isalnum.html">isalnum()<i class="fas fa-external-link-alt"></i></a> <br>如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 True，否则返回 False</td></tr><tr><td align="left">11</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-isalpha.html">isalpha()<i class="fas fa-external-link-alt"></i></a> <br>如果字符串至少有一个字符并且所有字符都是字母或中文字则返回 True, 否则返回 False</td></tr><tr><td align="left">12</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-isdigit.html">isdigit()<i class="fas fa-external-link-alt"></i></a> <br>如果字符串只包含数字则返回 True 否则返回 False..</td></tr><tr><td align="left">13</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-islower.html">islower()<i class="fas fa-external-link-alt"></i></a> <br>如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False</td></tr><tr><td align="left">14</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-isnumeric.html">isnumeric()<i class="fas fa-external-link-alt"></i></a> <br>如果字符串中只包含数字字符，则返回 True，否则返回 False</td></tr><tr><td align="left">15</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-isspace.html">isspace()<i class="fas fa-external-link-alt"></i></a> <br>如果字符串中只包含空白，则返回 True，否则返回 False.</td></tr><tr><td align="left">16</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-istitle.html">istitle()<i class="fas fa-external-link-alt"></i></a> <br>如果字符串是标题化的(见 title())则返回 True，否则返回 False</td></tr><tr><td align="left">17</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-isupper.html">isupper()<i class="fas fa-external-link-alt"></i></a><br>如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False</td></tr><tr><td align="left">18</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-join.html">join(seq)<i class="fas fa-external-link-alt"></i></a> <br>以指定字符串作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串</td></tr><tr><td align="left">19</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-len.html">len(string)<i class="fas fa-external-link-alt"></i></a> <br>返回字符串长度</td></tr><tr><td align="left">20</td><td align="left">ljust(width[, fillchar]) <br>返回一个原字符串左对齐,并使用 fillchar 填充至长度 width 的新字符串，fillchar 默认为空格。</td></tr><tr><td align="left">21</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-lower.html">lower()<i class="fas fa-external-link-alt"></i></a> <br>转换字符串中所有大写字符为小写.</td></tr><tr><td align="left">22</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-lstrip.html">lstrip()<i class="fas fa-external-link-alt"></i></a> <br>截掉字符串左边的空格或指定字符。</td></tr><tr><td align="left">23</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-maketrans.html">maketrans()<i class="fas fa-external-link-alt"></i></a><br> 创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。</td></tr><tr><td align="left">24</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-max.html">max(str)<i class="fas fa-external-link-alt"></i></a> <br>返回字符串 str 中最大的字母。</td></tr><tr><td align="left">25</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-min.html">min(str)<i class="fas fa-external-link-alt"></i></a> <br>返回字符串 str 中最小的字母。</td></tr><tr><td align="left">26</td><td align="left">[replace(old, new [, max])] <br>把 将字符串中的 old 替换成 new,如果 max 指定，则替换不超过 max 次。</td></tr><tr><td align="left">27</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-rfind.html">rfind(str, beg=0,end=len(string))<i class="fas fa-external-link-alt"></i></a> <br>类似于 find()函数，不过是从右边开始查找.</td></tr><tr><td align="left">28</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-rindex.html">rindex( str, beg=0, end=len(string))<i class="fas fa-external-link-alt"></i></a> <br>类似于 index()，不过是从右边开始.</td></tr><tr><td align="left">29</td><td align="left">rjust(width,[, fillchar])<br>返回一个原字符串右对齐,并使用fillchar(默认空格）填充至长度 width 的新字符串</td></tr><tr><td align="left">30</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-rstrip.html">rstrip()<i class="fas fa-external-link-alt"></i></a> <br>删除字符串字符串末尾的空格.</td></tr><tr><td align="left">31</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-split.html">split(str=””, num=string.count(str))<i class="fas fa-external-link-alt"></i></a> <br>以 str 为分隔符截取字符串，如果 num 有指定值，则仅截取 num+1 个子字符串</td></tr><tr><td align="left">32</td><td align="left">splitlines([keepends]) <br>按照行(‘\r’, ‘\r\n’, \n’)分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。</td></tr><tr><td align="left">33</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-startswith.html">startswith(substr, beg=0,end=len(string))<i class="fas fa-external-link-alt"></i></a> <br>检查字符串是否是以指定子字符串 substr 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查。</td></tr><tr><td align="left">34</td><td align="left">strip([chars])<br>在字符串上执行 lstrip()和 rstrip()</td></tr><tr><td align="left">35</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-swapcase.html">swapcase()<i class="fas fa-external-link-alt"></i></a> <br>将字符串中大写转换为小写，小写转换为大写</td></tr><tr><td align="left">36</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-title.html">title()<i class="fas fa-external-link-alt"></i></a> <br>返回”标题化”的字符串,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle())</td></tr><tr><td align="left">37</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-translate.html">translate(table, deletechars=””)<i class="fas fa-external-link-alt"></i></a> <br>根据 str 给出的表(包含 256 个字符)转换 string 的字符, 要过滤掉的字符放到 deletechars 参数中</td></tr><tr><td align="left">38</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-upper.html">upper()<i class="fas fa-external-link-alt"></i></a> <br>转换字符串中的小写字母为大写</td></tr><tr><td align="left">39</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-zfill.html">zfill (width)<i class="fas fa-external-link-alt"></i></a> <br>返回长度为 width 的字符串，原字符串右对齐，前面填充0</td></tr><tr><td align="left">40</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-isdecimal.html">isdecimal()<i class="fas fa-external-link-alt"></i></a> <br>检查字符串是否只包含十进制字符，如果是返回 true，否则返回 false。</td></tr></tbody></table><h5 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h5><ul><li>通用符合数据类型，用[标识]</li><li>有序集合</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">0</span>, <span class="number">1</span>, <span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;def&#x27;</span>, <span class="number">4</span> ]</span><br><span class="line">y = [<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> (x[<span class="number">2</span>:<span class="number">4</span>])   <span class="comment"># [&#x27;abc&#x27;, &#x27;def&#x27;]</span></span><br><span class="line"><span class="built_in">print</span> (x * <span class="number">2</span>)    <span class="comment"># [0, 1, &#x27;abc&#x27;, &#x27;def&#x27;, 4, 0, 1, &#x27;abc&#x27;, &#x27;def&#x27;, 4]</span></span><br><span class="line"><span class="built_in">print</span> (x + y)    <span class="comment"># [0, 1, &#x27;abc&#x27;, &#x27;def&#x27;, 4, &#x27;b&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> x[<span class="number">1</span>]         <span class="comment"># 使用del删除列表元素</span></span><br><span class="line"><span class="built_in">print</span> (x)        <span class="comment"># [0, &#x27;abc&#x27;, &#x27;def&#x27;, 4 ]</span></span><br></pre></td></tr></table></figure><p><strong>迭代</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> a: print(x, end=<span class="string">&quot;。&quot;</span>)</span><br><span class="line"><span class="comment"># 1。2。3。      迭代列表a，每个元素后面跟&quot;。&quot;</span></span><br></pre></td></tr></table></figure><p><strong>内置函数：</strong></p><ul><li><p>字符串 = ‘char’.join(列表)</p></li><li><p>len(list)</p><ul><li>列表元素个数</li></ul></li><li><p>max(list)</p><ul><li>返回列表元素最大值</li></ul></li><li><p>min(list)</p><ul><li>返回列表元素最小值</li></ul></li><li><p>list(seq\string\dict.items()…)</p><ul><li>将元组、字符串、字典元素等转换为列表</li></ul><blockquote><p><code>list(dictionary)</code>将会得到一个元素为元组的列表，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;disList = <span class="built_in">list</span>(dic)</span><br><span class="line">&gt;<span class="comment"># [(key0, value0), (key1, value1), (key2, value2), ...]</span></span><br><span class="line">&gt;disList[<span class="number">1</span>] <span class="comment"># (key1, value1)</span></span><br><span class="line">&gt;disList[<span class="number">1</span>][<span class="number">0</span>] <span class="comment"># key1</span></span><br><span class="line">&gt;disList[<span class="number">1</span>][<span class="number">1</span>] <span class="comment"># value1</span></span><br></pre></td></tr></table></figure></blockquote></li></ul><p><strong>方法</strong></p><ul><li>list.append(obj)<ul><li>在列表末尾添加新的对象</li></ul></li><li>list.count(obj)<ul><li>统计某个元素在列表中出现的次数</li></ul></li><li>list.extend(seq)<ul><li>在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</li></ul></li><li>list.index(obj)<ul><li>从列表中找出某个值第一个匹配项的索引位置</li></ul></li><li>list.insert(index, obj)<ul><li>将对象插入列表</li></ul></li><li>list.pop([index=-1])<ul><li>移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</li></ul></li><li>list.remove(obj)<ul><li>移除列表中某个值的第一个匹配项</li></ul></li><li>list.reverse()<ul><li>反向列表中元素</li></ul></li><li>list.sort( key=None, reverse=False)<ul><li>对原列表进行排序</li></ul></li><li>list.clear()<ul><li>清空列表</li></ul></li><li>list.copy()<ul><li>复制列表</li></ul></li></ul><p><strong>列表元素反转</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseWords</span>(<span class="params"><span class="built_in">input</span></span>):</span> </span><br><span class="line">      </span><br><span class="line">    <span class="comment"># 通过空格将字符串分隔符，把各个单词分隔为列表[&#x27;I&#x27;, &#x27;like&#x27;, &#x27;runoob&#x27;]</span></span><br><span class="line">    inputWords = <span class="built_in">input</span>.split(<span class="string">&quot; &quot;</span>) </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 翻转字符串</span></span><br><span class="line">    <span class="comment"># 假设列表 list = [1,2,3,4],  </span></span><br><span class="line">    <span class="comment"># list[0]=1, list[1]=2 ，而 -1 表示最后一个元素 list[-1]=4 ( 与 list[3]=4 一样) </span></span><br><span class="line">    <span class="comment"># inputWords[-1::-1] 有三个参数</span></span><br><span class="line">    <span class="comment"># 第一个参数 -1 表示最后一个元素</span></span><br><span class="line">    <span class="comment"># 第二个参数为空，表示移动到列表末尾</span></span><br><span class="line">    <span class="comment"># 第三个参数为步长，-1 表示逆向</span></span><br><span class="line">    inputWords=inputWords[-<span class="number">1</span>::-<span class="number">1</span>] </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 重新组合字符串，与split相反，将inputWords列表中的每个对象以空格合并</span></span><br><span class="line">    output = <span class="string">&#x27; &#x27;</span>.join(inputWords) </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> output </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>: </span><br><span class="line">    <span class="built_in">input</span> = <span class="string">&#x27;I like runoob&#x27;</span></span><br><span class="line">    rw = reverseWords(<span class="built_in">input</span>) </span><br><span class="line">    print(rw)</span><br></pre></td></tr></table></figure><h5 id="Tuple（元组）"><a href="#Tuple（元组）" class="headerlink" title="Tuple（元组）"></a>Tuple（元组）</h5><ul><li><p>元组是另一个数据类型，类似于 List（列表）。</p></li><li><p>元组用 <strong>()</strong> 标识。内部元素用逗号隔开。</p></li><li><p>与字符串一样，元组的元素不能修改，相当于只读列表。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">y = <span class="number">4</span></span><br><span class="line">z = (x, y)</span><br><span class="line">print(z)        <span class="comment"># ([1, 2], 4)</span></span><br><span class="line"></span><br><span class="line">x.append(<span class="number">3</span>)</span><br><span class="line">print(z)        <span class="comment"># ([1, 2, 3], 4)</span></span><br><span class="line"></span><br><span class="line">x[<span class="number">0</span>] = <span class="number">333</span></span><br><span class="line">print(z)        <span class="comment"># ([333, 2, 3], 4)</span></span><br><span class="line"></span><br><span class="line">x = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]   </span><br><span class="line">print(z)        <span class="comment"># ([1, 2, 3], 4)，相当于x换了个对象，所以不行</span></span><br><span class="line"></span><br><span class="line">z[<span class="number">0</span>] = <span class="string">&#x27;123&#x27;</span>    <span class="comment"># 会报错，元组是不可变的</span></span><br><span class="line"></span><br><span class="line">z = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)   <span class="comment"># 重新赋值的元组 z，绑定到新的对象了，不是修改了原来的对象。</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tup1 = ()      <span class="comment"># 创建空元组</span></span><br><span class="line">tup1 = (<span class="number">50</span>)    <span class="comment"># 整数50</span></span><br><span class="line">tup1 = (<span class="number">50</span>,)   <span class="comment"># 元组</span></span><br></pre></td></tr></table></figure><ul><li>元组中只包含一个元素时，需要在元素后面添加逗号，否则括号会被当作运算符使用</li></ul><p><strong>内置函数：</strong></p><ul><li><p>len(tuple)</p><ul><li>计算元组元素个数。    </li></ul></li><li><p>max(tuple)</p><ul><li>返回元组中元素最大值。    </li></ul></li><li><p>min(tuple)</p><ul><li>返回元组中元素最小值。    </li></ul></li><li><p>tuple(iterable)</p><ul><li><p>将可迭代系列转换为元组。</p></li><li><pre><code class="python">&gt;&gt;&gt; list1= [&#39;Google&#39;, &#39;Taobao&#39;, &#39;Runoob&#39;, &#39;Baidu&#39;]&gt;&gt;&gt; tuple1=tuple(list1)&gt;&gt;&gt; tuple1(&#39;Google&#39;, &#39;Taobao&#39;, &#39;Runoob&#39;, &#39;Baidu&#39;)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### Set（集合）</span><br><span class="line"></span><br><span class="line">* 集合（set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员。</span><br><span class="line">* 基本功能是进行成员关系测试和删除重复元素。</span><br><span class="line">* 可以使用大括号 **&#123; &#125;** 或者 **set()** 函数创建集合</span><br><span class="line">  * **注意**：创建一个空集合必须用 **set()** 而不是 **&#123; &#125;**，因为 **&#123; &#125;** 是用来创建一个空字典。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line">parame &#x3D; &#123;value01,value02,...&#125;</span><br><span class="line"># 或者</span><br><span class="line">parame &#x3D; set(value)</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><p><strong>集合运算</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">set</span>(<span class="string">&#x27;abracadabra&#x27;</span>)</span><br><span class="line">b = <span class="built_in">set</span>(<span class="string">&#x27;alacazam&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 成员测试</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">in</span> sites :</span><br><span class="line">    print(<span class="string">&#x27;a 在集合中&#x27;</span>)     <span class="comment"># true</span></span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">    print(<span class="string">&#x27;a 不在集合中&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结合运算</span></span><br><span class="line">print(a)      <span class="comment">#               &#123;&#x27;b&#x27;, &#x27;c&#x27;, &#x27;a&#x27;, &#x27;r&#x27;, &#x27;d&#x27;&#125;</span></span><br><span class="line">print(a - b)  <span class="comment"># a 和 b 的差集  &#123;&#x27;r&#x27;, &#x27;b&#x27;, &#x27;d&#x27;&#125;</span></span><br><span class="line">print(a | b)  <span class="comment"># a 和 b 的并集  &#123;&#x27;b&#x27;, &#x27;c&#x27;, &#x27;a&#x27;, &#x27;z&#x27;, &#x27;m&#x27;, &#x27;r&#x27;, &#x27;l&#x27;, &#x27;d&#x27;&#125;</span></span><br><span class="line">print(a &amp; b)  <span class="comment"># a 和 b 的交集  &#123;&#x27;c&#x27;, &#x27;a&#x27;&#125;</span></span><br><span class="line">print(a ^ b)  <span class="comment"># a 和 b 中不同时存在的元素 &#123;&#x27;z&#x27;, &#x27;b&#x27;, &#x27;m&#x27;, &#x27;r&#x27;, &#x27;l&#x27;, &#x27;d&#x27;&#125;</span></span><br></pre></td></tr></table></figure><p><strong>基本操作：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">set</span>(<span class="string">&#x27;abracadabra&#x27;</span>)</span><br><span class="line">a.add(<span class="string">&#x27;h&#x27;</span>)      <span class="comment"># &#123;&#x27;a&#x27;, &#x27;h&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;r&#x27;, &#x27;d&#x27;&#125;</span></span><br><span class="line">s.update(<span class="string">&#x27;h&#x27;</span>)   <span class="comment"># 效果相同</span></span><br><span class="line"></span><br><span class="line">s.remove(<span class="string">&#x27;h&#x27;</span>)   <span class="comment"># &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;r&#x27;, &#x27;d&#x27;&#125;</span></span><br><span class="line">s.discard(<span class="string">&#x27;h&#x27;</span>)  <span class="comment"># 效果相同</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机删除集合中的一个元素</span></span><br><span class="line">x = a.pop()     <span class="comment"># x为a中随机一个元素</span></span><br></pre></td></tr></table></figure><p><strong>内置函数：</strong></p><ul><li>len(set)<ul><li>输出集合的个数</li></ul></li></ul><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">add()</td><td align="left">为集合添加元素</td></tr><tr><td align="left">clear()</td><td align="left">移除集合中的所有元素</td></tr><tr><td align="left">copy()</td><td align="left">拷贝一个集合</td></tr><tr><td align="left">difference()</td><td align="left">返回多个集合的差集</td></tr><tr><td align="left">difference_update()</td><td align="left">移除集合中的元素，该元素在指定的集合也存在。</td></tr><tr><td align="left">discard()</td><td align="left">删除集合中指定的元素</td></tr><tr><td align="left">intersection()</td><td align="left">返回集合的交集</td></tr><tr><td align="left">intersection_update()</td><td align="left">返回集合的交集。</td></tr><tr><td align="left">isdisjoint()</td><td align="left">判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 False。</td></tr><tr><td align="left">issubset()</td><td align="left">判断指定集合是否为该方法参数集合的子集。</td></tr><tr><td align="left">issuperset()</td><td align="left">判断该方法的参数集合是否为指定集合的子集</td></tr><tr><td align="left">pop()</td><td align="left">随机移除元素</td></tr><tr><td align="left">remove()</td><td align="left">移除指定元素</td></tr><tr><td align="left">symmetric_difference()</td><td align="left">返回两个集合中不重复的元素集合。</td></tr><tr><td align="left">symmetric_difference_update()</td><td align="left">移除当前集合中在另外一个指定集合相同的元素，并将另外一个指定集合中不同的元素插入到当前集合中。</td></tr><tr><td align="left">union()</td><td align="left">返回两个集合的并集</td></tr><tr><td align="left">update()</td><td align="left">给集合添加元素</td></tr></tbody></table><h5 id="Dictionary（字典）"><a href="#Dictionary（字典）" class="headerlink" title="Dictionary（字典）"></a>Dictionary（字典）</h5><ul><li>列表是有序的对象集合，字典是无序的对象集合。<ul><li>即使排序了，放进字典也是无序的</li></ul></li><li>两者之间的区别在于：<ul><li>字典当中的元素是通过键来存取的，而不是通过偏移存取。</li></ul></li><li>字典是一种映射类型，字典用 <strong>{ }</strong> 标识，它是一个无序的 <strong>键(key) : 值(value)</strong> 的集合。<ul><li>键(key)必须使用<strong>不可变类型</strong>。（列表等不行）</li><li>在同一个字典中，键(key)必须是<strong>唯一</strong>的，重复时选择后一个</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dict</span> = &#123;&#125;     <span class="comment"># 创建空字典</span></span><br><span class="line"><span class="built_in">dict</span>[<span class="string">&#x27;one&#x27;</span>] = <span class="string">&quot;111&quot;</span></span><br><span class="line"><span class="built_in">dict</span>[<span class="number">2</span>]     = <span class="string">&quot;222&quot;</span></span><br><span class="line"></span><br><span class="line">tinydict = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;aaa&#x27;</span>,<span class="string">&#x27;b&#x27;</span>:<span class="number">1</span>, (c): <span class="string">&#x27;ccc&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">dict</span>[<span class="string">&#x27;one&#x27;</span>])       <span class="comment"># 输出键为 &#x27;one&#x27; 的值  &quot;111&quot;</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">dict</span>[<span class="number">2</span>])           <span class="comment"># 输出键为 2 的值      &quot;222&quot;</span></span><br><span class="line"><span class="built_in">print</span> (tinydict)          <span class="comment"># 输出完整的字典   &#123;&#x27;a&#x27;:&#x27;aaa&#x27;,&#x27;b&#x27;:1,(c):&#x27;ccc&#x27;&#125;</span></span><br><span class="line"><span class="built_in">print</span> (tinydict.keys())   <span class="comment"># 输出所有键   dict_keys([&#x27;a&#x27;, &#x27;b&#x27;, (c)])</span></span><br><span class="line"><span class="built_in">print</span> (tinydict.values()) <span class="comment"># 输出所有值   dict_values([&#x27;aaa&#x27;, 1, &#x27;ccc&#x27;])</span></span><br></pre></td></tr></table></figure><p><strong>内置函数</strong></p><ul><li><p>构造函数<code>dict（）</code>：</p><ul><li><pre><code class="python">&gt;&gt;&gt; dict([(&#39;aa&#39;, 1), (&#39;bb&#39;, 2), (&#39;cc&#39;, 3)])&#123;&#39;aa&#39;: 1, &#39;bb&#39;: 2, &#39;cc&#39;: 3&#125;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* len(dict)</span><br><span class="line">  </span><br><span class="line">  * 计算字典元素个数，即键的总数</span><br><span class="line">* str(dict)</span><br><span class="line">  </span><br><span class="line">  * 输出字典，以可打印的字符串表示。</span><br><span class="line">* type(variable)</span><br><span class="line">  </span><br><span class="line">  * 返回输入的变量类型，如果变量是字典就返回字典类型。</span><br><span class="line">* keys()</span><br><span class="line">* values()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">| 序号 | 函数及描述                                                   |</span><br><span class="line">| :--- | :----------------------------------------------------------- |</span><br><span class="line">| 1    | [radiansdict.clear()](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-dictionary-clear.html) &lt;br &#x2F;&gt;删除字典内所有元素 |</span><br><span class="line">| 2    | [radiansdict.copy()](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-dictionary-copy.html) &lt;br &#x2F;&gt;返回一个字典的浅复制 |</span><br><span class="line">| 3    | [radiansdict.fromkeys()](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-dictionary-fromkeys.html) &lt;br &#x2F;&gt;创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值 |</span><br><span class="line">| 4    | [radiansdict.get(key, default&#x3D;None)](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-dictionary-get.html) &lt;br &#x2F;&gt;返回指定键的值，如果键不在字典中返回 default 设置的默认值 |</span><br><span class="line">| 5    | [key in dict](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-dictionary-in.html) &lt;br &#x2F;&gt;如果键在字典dict里返回true，否则返回false |</span><br><span class="line">| 6    | [radiansdict.items()](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-dictionary-items.html) &lt;br &#x2F;&gt;以列表返回可遍历的(键, 值) 元组数组 |</span><br><span class="line">| 7    | [radiansdict.keys()](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-dictionary-keys.html) &lt;br &#x2F;&gt;返回一个迭代器，可以使用 list() 来转换为列表 |</span><br><span class="line">| 8    | [radiansdict.setdefault(key, default&#x3D;None)](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-dictionary-setdefault.html)&lt;br &#x2F;&gt; 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default |</span><br><span class="line">| 9    | [radiansdict.update(dict2)](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-dictionary-update.html) &lt;br &#x2F;&gt;把字典dict2的键&#x2F;值对更新到dict里 |</span><br><span class="line">| 10   | [radiansdict.values()](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-dictionary-values.html) &lt;br &#x2F;&gt;返回一个迭代器，可以使用 list() 来转换为列表 |</span><br><span class="line">| 11   | pop(key[,default\]) &lt;br &#x2F;&gt;删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。 |</span><br><span class="line">| 12   | [popitem()](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-dictionary-popitem.html) &lt;br &#x2F;&gt;随机返回并删除字典中的最后一对键和值。 |</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">#### 数据类型转换</span><br><span class="line"></span><br><span class="line">| 函数                    | 描述                                                |</span><br><span class="line">| :---------------------- | :-------------------------------------------------- |</span><br><span class="line">| int(x)                  | 将x转换为一个整数                                   |</span><br><span class="line">| float(x)                | 将x转换到一个浮点数                                 |</span><br><span class="line">| complex(real [,imag\])] | 创建一个复数，实部是real，虚部是imag                |</span><br><span class="line">| str(x)                  | 将对象 x 转换为字符串                               |</span><br><span class="line">| repr(x)                 | 将对象 x 转换为表达式字符串                         |</span><br><span class="line">| eval(str)               | 用来计算在字符串中的有效Python表达式,并返回一个对象 |</span><br><span class="line">| tuple(s)                | 将序列 s 转换为一个元组                             |</span><br><span class="line">| list(s)                 | 将序列 s 转换为一个列表                             |</span><br><span class="line">| set(s)                  | 转换为可变集合                                      |</span><br><span class="line">| dict(d)                 | 创建一个字典。d 必须是一个 (key, value)元组序列。   |</span><br><span class="line">| frozenset(s)            | 转换为不可变集合                                    |</span><br><span class="line">| chr(x)                  | 将一个整数转换为一个字符                            |</span><br><span class="line">| ord(x)                  | 将一个字符转换为它的整数值                          |</span><br><span class="line">| hex(x)                  | 将一个整数转换为一个十六进制字符串                  |</span><br><span class="line">| oct(x)                  | 将一个整数转换为一个八进制字符串                    |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### **进制转换：**</span><br><span class="line"></span><br><span class="line">**二进制表示**</span><br><span class="line"></span><br><span class="line">* 通过&#96;0b&#x2F;-0b&#96;开头的字符串来表示二进制</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line">print 0b101 # 输出5</span><br><span class="line">print 0b10  # 输出2</span><br><span class="line">print -0b101 # 输出-5</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p><code>bin()</code>函数将十进制转换成而二进制表示</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bin</span>(<span class="number">5</span>)  <span class="comment"># 输出0b101</span></span><br></pre></td></tr></table></figure><p><strong>二进制位操作：</strong></p><ul><li>关于bit有一个很有用的Packag叫做bitarray，其中bitarray对象可以帮助我们存储0，1值或者Boolean值，并像list一样进行操作。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bitarray <span class="keyword">import</span> bitarray</span><br><span class="line"></span><br><span class="line"><span class="comment">#初始化一个有10个bit位的数组，初始值为0</span></span><br><span class="line">a = bitarray(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#可以像操作list一样操作bitarray对象</span></span><br><span class="line">a[<span class="number">1</span>:<span class="number">8</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#bitarray还提供了一些特殊的方法，如：all()</span></span><br><span class="line"><span class="comment">#当bitarray中所有的元素都为1时，all()返回为True</span></span><br><span class="line"><span class="keyword">if</span> a.<span class="built_in">all</span>():</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;all bits are True.&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h3><h4 id="条件控制"><a href="#条件控制" class="headerlink" title="条件控制"></a>条件控制</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition_1:</span><br><span class="line">    statement_block_1</span><br><span class="line"><span class="keyword">elif</span> condition_2:</span><br><span class="line">    statement_block_2</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    statement_block_3</span><br></pre></td></tr></table></figure><ul><li>python中没有<code>switch-case</code></li></ul><h4 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h4><p><strong>while</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> 判断条件(condition)：</span><br><span class="line">    执行语句(statements)……</span><br></pre></td></tr></table></figure><p>​    </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> &lt;expr&gt;:</span><br><span class="line">    &lt;statement(s)&gt;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    &lt;additional_statement(s)&gt;</span><br></pre></td></tr></table></figure><ul><li>条件语句为 false 时执行 else 的语句块。</li></ul><p>​     </p><p><strong>for</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &lt;variable&gt; <span class="keyword">in</span> &lt;sequence&gt;:</span><br><span class="line">    &lt;statements&gt;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    &lt;statements&gt;</span><br></pre></td></tr></table></figure><ul><li>在没有循环数据时执行else的语句块</li></ul><p>​    </p><p><code>range()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">  print(i)   <span class="comment"># 0 1 2 3 4</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>, <span class="number">9</span>):</span><br><span class="line">  print(i)   <span class="comment"># 5 6 7 8</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>, <span class="number">3</span>):</span><br><span class="line">  print(i)   <span class="comment"># 0 3 6 9</span></span><br></pre></td></tr></table></figure><p><strong>continue break</strong></p><ul><li>同java，c++等的使用一样</li></ul><p>​    </p><p><strong>pass</strong></p><ul><li>pass是空语句，是为了保持程序结构的完整性。</li><li>pass 不做任何事情，一般用做占位语句</li></ul><p>​    </p><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><ul><li>在字典中遍历时，关键字和对应的值可以使用<code>items()</code> 方法同时解读出来：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>knights = &#123;<span class="string">&#x27;gallahad&#x27;</span>: <span class="string">&#x27;the pure&#x27;</span>, <span class="string">&#x27;robin&#x27;</span>: <span class="string">&#x27;the brave&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> k, v <span class="keyword">in</span> knights.items():</span><br><span class="line"><span class="meta">... </span>    print(k, v)</span><br><span class="line">...</span><br><span class="line">gallahad the pure</span><br><span class="line">robin the brave</span><br></pre></td></tr></table></figure><ul><li>在序列中遍历时，索引位置和对应值可以使用 <code>enumerate()</code> 函数同时得到：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>([<span class="string">&#x27;tic&#x27;</span>, <span class="string">&#x27;tac&#x27;</span>, <span class="string">&#x27;toe&#x27;</span>]):</span><br><span class="line"><span class="meta">... </span>    print(i, v)</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> tic</span><br><span class="line"><span class="number">1</span> tac</span><br><span class="line"><span class="number">2</span> toe</span><br></pre></td></tr></table></figure><ul><li>同时遍历两个或更多的序列，可以使用 <code>zip()</code> 组合：</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>questions = [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;quest&#x27;</span>, <span class="string">&#x27;favorite color&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>answers = [<span class="string">&#x27;lancelot&#x27;</span>, <span class="string">&#x27;the holy grail&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> q, a <span class="keyword">in</span> <span class="built_in">zip</span>(questions, answers):</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">&#x27;What is your &#123;0&#125;?  It is &#123;1&#125;.&#x27;</span>.<span class="built_in">format</span>(q, a))</span><br><span class="line">...</span><br><span class="line">What is your name?  It is lancelot.</span><br><span class="line">What is your quest?  It is the holy grail.</span><br><span class="line">What is your favorite color?  It is blue.</span><br></pre></td></tr></table></figure><ul><li>反向遍历一个序列，首先指定这个序列，然后调用 <code>reversed()</code> 函数：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>)):</span><br><span class="line"><span class="meta">... </span>    print(i)</span><br><span class="line">...</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>要按顺序遍历一个序列，使用 <code>sorted()</code>函数返回一个已排序的序列，并不修改原值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>basket = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> f <span class="keyword">in</span> <span class="built_in">sorted</span>(<span class="built_in">set</span>(basket)):</span><br><span class="line"><span class="meta">... </span>    print(f)</span><br><span class="line">...</span><br><span class="line">apple</span><br><span class="line">banana</span><br><span class="line">orange</span><br><span class="line">pear</span><br></pre></td></tr></table></figure><h3 id="迭代器与生成器"><a href="#迭代器与生成器" class="headerlink" title="迭代器与生成器"></a>迭代器与生成器</h3><ul><li>迭代是Python最强大的功能之一，是访问集合元素的一种方式。</li><li>迭代器是一个可以记住遍历的位置的对象。</li><li>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</li><li>迭代器有两个基本的方法：<strong>iter()</strong> 和 **next()**。</li><li>字符串，列表或元组对象都可用于创建迭代器：</li></ul><h4 id="iter"><a href="#iter" class="headerlink" title="iter()"></a>iter()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">it = <span class="built_in">iter</span>(<span class="built_in">list</span>)  <span class="comment"># 创建迭代器对象</span></span><br><span class="line">print(it)        <span class="comment"># &lt;list_iterator object at 0x7fe777a83d30&gt;</span></span><br><span class="line">print(<span class="built_in">next</span>(it))  <span class="comment"># 1 输出迭代器的下一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### for ###</span></span><br><span class="line"><span class="built_in">list</span>=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it = <span class="built_in">iter</span>(<span class="built_in">list</span>)  <span class="comment"># 创建迭代器对象</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> it:</span><br><span class="line">    <span class="built_in">print</span> (x, end=<span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="next"><a href="#next" class="headerlink" title="next()"></a>next()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys         <span class="comment"># 引入 sys 模块</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">list</span>=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it = <span class="built_in">iter</span>(<span class="built_in">list</span>)    <span class="comment"># 创建迭代器对象</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span> (<span class="built_in">next</span>(it))</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        sys.exit()</span><br></pre></td></tr></table></figure><p><strong>创建一个迭代器：</strong></p><ul><li><p>把一个类作为一个迭代器使用需要在类中实现两个方法 __iter__() 与__next__() 。</p></li><li><p>如果你已经了解的面向对象编程，就知道类都有一个构造函数，Python 的构造函数为 <strong>init</strong>(), 它会在对象初始化的时候执行。</p><ul><li>更多内容查阅：Python3 面向对象</li></ul></li><li><p> __iter__()：返回一个特殊的迭代器对象， 这个迭代器对象实现了 __next__() 方法并通过 StopIteration 异常标识迭代的完成。</p></li><li><p> __next__()：（Python 2 里是 next()）会返回下一个迭代器对象。</p></li></ul><p>创建一个返回数字的迭代器，初始值为 1，逐步递增 1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyNumbers</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> self</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span></span><br><span class="line">    x = self.a</span><br><span class="line">    self.a += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"> </span><br><span class="line">myclass = MyNumbers()</span><br><span class="line">myiter = <span class="built_in">iter</span>(myclass)</span><br><span class="line"> </span><br><span class="line">print(<span class="built_in">next</span>(myiter))   <span class="comment"># 1</span></span><br><span class="line">print(<span class="built_in">next</span>(myiter))   <span class="comment"># 2</span></span><br><span class="line">print(<span class="built_in">next</span>(myiter))   <span class="comment"># 3</span></span><br></pre></td></tr></table></figure><h4 id="StopIteration"><a href="#StopIteration" class="headerlink" title="StopIteration"></a>StopIteration</h4><ul><li>StopIteration 异常用于标识迭代的完成，防止出现无限循环的情况，在__next__() 方法中我们可以设置在完成指定循环次数后触发 StopIteration 异常来结束迭代。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyNumbers</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> self</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">if</span> self.a &lt;= <span class="number">20</span>:      <span class="comment"># 设置迭代20次后停止</span></span><br><span class="line">      x = self.a</span><br><span class="line">      self.a += <span class="number">1</span></span><br><span class="line">      <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">raise</span> StopIteration</span><br><span class="line"> </span><br><span class="line">myclass = MyNumbers()</span><br><span class="line">myiter = <span class="built_in">iter</span>(myclass)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> myiter:</span><br><span class="line">  print(x)</span><br></pre></td></tr></table></figure><h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><ul><li>在 Python 中，使用了 yield 的函数被称为生成器（generator）。</li><li>跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。 </li><li>在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。</li><li>调用一个生成器函数，返回的是一个迭代器对象。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 yield 实现斐波那契数列</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span>(<span class="params">n</span>):</span> <span class="comment"># 生成器函数 - 斐波那契</span></span><br><span class="line">    a, b, counter = <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> (counter &gt; n): </span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        counter += <span class="number">1</span></span><br><span class="line">f = fibonacci(<span class="number">10</span>) <span class="comment"># f 是一个迭代器，由生成器返回生成</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span> (<span class="built_in">next</span>(f), end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        sys.exit()</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> 函数名（参数列表）:</span></span><br><span class="line">    函数体</span><br></pre></td></tr></table></figure><img src="/2020/12/15/python/截屏2020-12-16 下午3.51.47.png" alt="截屏2020-12-16 下午3.51.47" style="zoom:50%;">    <h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><blockquote><p>python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。</p></blockquote><ul><li><strong>不可变类型：</strong>类似 C++ 的值传递，如 整数、字符串、元组。如 fun(a)，传递的只是 a 的值，没有影响 a 对象本身。如果在 fun(a)）内部修改 a 的值，则是新生成来一个 a。</li><li><strong>可变类型：</strong>类似 C++ 的引用传递，如 列表，字典。如 fun(la)，则是将 la 真正的传过去，修改后 fun 外部的 la 也会受影响</li></ul><p><strong>调用函数时可使用的正式参数类型：</strong></p><ul><li><p>必需参数</p><ul><li><p>必需参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#可写函数说明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printme</span>(<span class="params"> <span class="built_in">str</span> </span>):</span></span><br><span class="line">   <span class="string">&quot;打印任何传入的字符串&quot;</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="built_in">str</span>)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用 printme 函数，不加参数会报错</span></span><br><span class="line">printme()</span><br></pre></td></tr></table></figure></li></ul></li><li><p>关键字参数</p><ul><li><p>关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。</p></li><li><p>使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#可写函数说明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printinfo</span>(<span class="params"> name, age </span>):</span></span><br><span class="line">   <span class="string">&quot;打印任何传入的字符串&quot;</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;名字: &quot;</span>, name)</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;年龄: &quot;</span>, age)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#调用printinfo函数</span></span><br><span class="line">printinfo( age=<span class="number">50</span>, name=<span class="string">&quot;runoob&quot;</span> )</span><br></pre></td></tr></table></figure></li></ul></li><li><p>默认参数</p><ul><li><p>调用函数时，如果没有传递参数，则会使用默认参数。以下实例中如果没有传入 age 参数，则使用默认值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#可写函数说明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printinfo</span>(<span class="params"> name, age = <span class="number">35</span> </span>):</span></span><br><span class="line">   <span class="string">&quot;打印任何传入的字符串&quot;</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;名字: &quot;</span>, name)</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;年龄: &quot;</span>, age)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#调用printinfo函数</span></span><br><span class="line">printinfo( age=<span class="number">50</span>, name=<span class="string">&quot;runoob&quot;</span> )  <span class="comment"># 名字: runoob    年龄: 50</span></span><br><span class="line">printinfo( name=<span class="string">&quot;runoob&quot;</span> )          <span class="comment"># 名字: runoob    年龄: 35</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>不定长参数</p><ul><li><p>可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述 2 种参数不同，声明时不会命名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">functionname</span>(<span class="params">[formal_args,] *var_args_tuple </span>):</span></span><br><span class="line">   <span class="string">&quot;函数_文档字符串&quot;</span></span><br><span class="line">   function_suite</span><br><span class="line">   <span class="keyword">return</span> [expression]</span><br></pre></td></tr></table></figure></li><li><p>带<code>*</code>以元组形式传入</p><ul><li>如果单独出现星号<code>*</code>后的参数必须用关键字传入。</li><li><code>def f(a,b,*,c):</code>  调用：<code>f(1,2,c=3)</code></li></ul></li><li><p>带<code>**</code>以字典形式传入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printinfo</span>(<span class="params"> arg1, *vartuple </span>):</span></span><br><span class="line">   <span class="string">&quot;打印任何传入的参数&quot;</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;输出: &quot;</span>)</span><br><span class="line">   <span class="built_in">print</span> (arg1)</span><br><span class="line">   <span class="built_in">print</span> (vartuple)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用printinfo 函数</span></span><br><span class="line">printinfo( <span class="number">70</span>, <span class="number">60</span>, <span class="number">50</span> )</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="number">70</span></span><br><span class="line">(<span class="number">60</span>, <span class="number">50</span>)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><ul><li>python 使用<code>lambda</code>来创建匿名函数。</li><li>所谓匿名，意即不再使用 def 语句这样标准的形式定义一个函数。<ul><li>lambda 只是一个表达式，函数体比 def 简单很多。</li><li>lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。</li><li>lambda 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。</li><li>虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。</li></ul></li></ul><h4 id="函数库"><a href="#函数库" class="headerlink" title="函数库"></a>函数库</h4><h5 id="math"><a href="#math" class="headerlink" title="math"></a>math</h5><h6 id="数学常量"><a href="#数学常量" class="headerlink" title="数学常量"></a>数学常量</h6><ul><li><code>pi</code>：数学常量 pi（圆周率，一般以π来表示）</li><li><code>e</code>：数学常量 e，e即自然常数（自然常数）</li></ul><h6 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h6><ul><li><p>abs(x)    返回数字的绝对值，如abs(-10) 返回 10</p></li><li><p>ceil(x)    返回数字的上入整数，如math.ceil(4.1) 返回 5</p></li><li><p>cmp(x, y)</p><ul><li>如果 x &lt; y 返回 -1, 如果 x == y 返回 0, 如果 x &gt; y 返回 1。</li><li> Python 3 已废弃，使用 (x&gt;y)-(x&lt;y) 替换。</li></ul></li><li><p>exp(x)    返回e的x次幂(ex)，如math.exp(1) 返回2.718281828459045</p></li><li><p>fabs(x)    返回数字的绝对值的浮点类型，如math.fabs(-10) 返回10.0</p></li><li><p>floor(x)    返回数字的下舍整数，如math.floor(4.9)返回 4</p></li><li><p>log(x)    如math.log(math.e)返回1.0，math.log(100,10)返回2.0</p></li><li><p>log10(x)    返回以10为基数的x的对数，如math.log10(100)返回 2.0</p></li><li><p>max(x1, x2,…)    返回给定参数的最大值，参数可以为序列。</p></li><li><p>min(x1, x2,…)    返回给定参数的最小值，参数可以为序列。</p></li><li><p>modf(x)    返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。</p></li><li><p>pow(x, y)    x**y 运算后的值。</p></li><li><p>round(x [,n])    返回浮点数 x 的四舍五入值，如给出 n 值，则代表舍入到小数点后的位数。</p><ul><li>其实准确的说是保留值将保留到离上一位更近的一端。</li></ul></li><li><p>sqrt(x)    返回数字x的平方根。</p></li></ul><h6 id="随机数函数"><a href="#随机数函数" class="headerlink" title="随机数函数"></a>随机数函数</h6><ul><li>choice(seq)    从序列的元素中随机挑选一个元素<ul><li>比如：random.choice(range(10))，从0到9中随机挑选一个整数。</li></ul></li><li>randrange ([start,] stop [,step])    从指定范围内，按指定基数递增的集合中获取一个随机数，基数默认值为 1</li><li>random()    随机生成下一个实数，它在[0,1)范围内。</li><li>seed([x])    改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed。</li><li>shuffle(lst)    将序列的所有元素随机排序</li><li>uniform(x, y)    随机生成下一个实数，它在[x,y]范围内。</li></ul><h6 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h6><ul><li>acos(x)    返回x的反余弦弧度值。</li><li>asin(x)    返回x的反正弦弧度值。</li><li>atan(x)    返回x的反正切弧度值。</li><li>atan2(y, x)    返回给定的 X 及 Y 坐标值的反正切值。</li><li>cos(x)    返回x的弧度的余弦值。</li><li>hypot(x, y)    返回欧几里德范数 sqrt(x<em>x + y</em>y)。</li><li>sin(x)    返回的x弧度的正弦值。</li><li>tan(x)    返回x弧度的正切值。</li><li>degrees(x)    将弧度转换为角度,如degrees(math.pi/2) ， 返回90.0</li><li>radians(x)    将角度转换为弧度</li></ul><h5 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h5><p>很多Python函数用一个元组装起来的9组数字处理时间:</p><table><thead><tr><th>4位数年</th><th>2008</th><th></th></tr></thead><tbody><tr><td>1</td><td>月</td><td>1 到 12</td></tr><tr><td>2</td><td>日</td><td>1到31</td></tr><tr><td>3</td><td>小时</td><td>0到23</td></tr><tr><td>4</td><td>分钟</td><td>0到59</td></tr><tr><td>5</td><td>秒</td><td>0到61 (60或61 是闰秒)</td></tr><tr><td>6</td><td>一周的第几日</td><td>0到6 (0是周一)</td></tr><tr><td>7</td><td>一年的第几日</td><td>1到366 (儒略历)</td></tr><tr><td>8</td><td>夏令时</td><td>-1, 0, 1, -1是决定是否为夏令时的旗帜</td></tr></tbody></table><p>上述也就是struct_time元组。这种结构具有如下属性：</p><table><thead><tr><th align="left">序号</th><th align="left">属性</th><th align="left">值</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">tm_year</td><td align="left">2008</td></tr><tr><td align="left">1</td><td align="left">tm_mon</td><td align="left">1 到 12</td></tr><tr><td align="left">2</td><td align="left">tm_mday</td><td align="left">1 到 31</td></tr><tr><td align="left">3</td><td align="left">tm_hour</td><td align="left">0 到 23</td></tr><tr><td align="left">4</td><td align="left">tm_min</td><td align="left">0 到 59</td></tr><tr><td align="left">5</td><td align="left">tm_sec</td><td align="left">0 到 61 (60或61 是闰秒)</td></tr><tr><td align="left">6</td><td align="left">tm_wday</td><td align="left">0到6 (0是周一)</td></tr><tr><td align="left">7</td><td align="left">tm_yday</td><td align="left">一年中的第几天，1 到 366</td></tr><tr><td align="left">8</td><td align="left">tm_isdst</td><td align="left">是否为夏令时，值有：1(夏令时)、0(不是夏令时)、-1(未知)，默认 -1</td></tr></tbody></table><h6 id="time"><a href="#time" class="headerlink" title="time"></a>time</h6><ul><li><p>以下时间均为<code>2020-12-16 15:35:15 周三</code></p></li><li><p>time.time()</p><ul><li>获取当前时间戳<code>1608104115.4493172</code></li><li>时间戳单位最适于做日期运算。但是1970年之前的日期就无法以此表示了。太遥远的日期也不行，UNIX和Windows只支持到2038年。</li></ul></li><li><p>time.localtime(时间戳)</p><ul><li><p>获取当前时间</p></li><li><pre><code class="python">time.struct_time(tm_year=2020, tm_mon=12, tm_mday=16, tm_hour=15, tm_min=35, tm_sec=15, tm_wday=2, tm_yday=351, tm_isdst=0)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* time.asctime(time.localtime(时间戳))</span><br><span class="line"></span><br><span class="line">  * 获取格式化的时间</span><br><span class="line"></span><br><span class="line">  * &#96;&#96;&#96;python</span><br><span class="line">    Wed Dec 16 15:35:15 2020</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>time.strftime(format[, time])</p><ul><li><p>格式化日期</p></li><li><pre><code class="python"># 格式化成2020-12-16 15:35:15形式print (time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime()))# 格式化成Wed Dec 16 15:35:15 2020形式print (time.strftime(&quot;%a %b %d %H:%M:%S %Y&quot;, time.localtime()))# 将格式字符串转换为时间戳a = &quot;Wed Dec 16 15:35:15 2020&quot;print (time.mktime(time.strptime(a,&quot;%a %b %d %H:%M:%S %Y&quot;)))<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">​         </span><br><span class="line"></span><br><span class="line">**两个非常重要的属性：**</span><br><span class="line"></span><br><span class="line">1. time.timezone</span><br><span class="line">   * 属性time.timezone是当地时区（未启动夏令时）距离格林威治的偏移秒数（&gt;0，美洲;&lt;&#x3D;0大部分欧洲，亚洲，非洲）。</span><br><span class="line">2. time.tzname</span><br><span class="line">   * 属性time.tzname包含一对根据情况的不同而不同的字符串，分别是带夏令时的本地时区名称，和不带的。</span><br><span class="line"></span><br><span class="line">| 序号 | 函数及描述                                                   | 实例                                                         |</span><br><span class="line">| :--- | :----------------------------------------------------------- | :----------------------------------------------------------- |</span><br><span class="line">| 1    | time.altzone&lt;br &#x2F;&gt;返回格林威治西部的夏令时地区的偏移秒数。如果该地区在格林威治东部会返回负值（如西欧，包括英国）。对夏令时启用地区才能使用。 | 以下实例展示了 altzone()函数的使用方法：&lt;br &#x2F;&gt;&#96;&gt;&gt;&gt; import time &#96;&lt;br &#x2F;&gt;&#96;&gt;&gt;&gt; print (&quot;time.altzone %d &quot; % time.altzone) &#96;&lt;br &#x2F;&gt;&#96;time.altzone -28800 &#96; |</span><br><span class="line">| 2    | time.asctime([tupletime]) &lt;br &#x2F;&gt;接受时间元组并返回一个可读的形式为&quot;Tue Dec 11 18:07:14 2008&quot;（2008年12月11日 周二18时07分14秒）的24个字符的字符串。 | 以下实例展示了 asctime()函数的使用方法：&lt;br &#x2F;&gt;&#96;&gt;&gt;&gt; import time &gt;&gt;&gt; t &#x3D; time.localtime() &#96;&lt;br &#x2F;&gt;&#96;&gt;&gt;&gt; print (&quot;time.asctime(t): %s &quot; % time.asctime(t)) &#96;&lt;br &#x2F;&gt;&#96;time.asctime(t): Thu Apr  7 10:36:20 2016 &#96; |</span><br><span class="line">| 3    | [time.clock()](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-time-clock.html) &lt;br &#x2F;&gt;用以浮点数计算的秒数返回当前的CPU时间。用来衡量不同程序的耗时，比time.time()更有用。 | [实例](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-time-clock.html)由于该方法依赖操作系统，在 Python 3.3 以后不被推荐，而在 3.8 版本中被移除，需使用下列两个函数替代。&#96;time.perf_counter()  # 返回系统运行时间 time.process_time()  # 返回进程运行时间&#96; |</span><br><span class="line">| 4    | time.ctime([secs]) &lt;br &#x2F;&gt;作用相当于asctime(localtime(secs))，未给参数相当于asctime() | 以下实例展示了 ctime()函数的使用方法：&lt;br &#x2F;&gt;&#96;&gt;&gt;&gt; import time &#96;&lt;br &#x2F;&gt;&#96;&gt;&gt;&gt; print (&quot;time.ctime() : %s&quot; % time.ctime()) &#96;&lt;br &#x2F;&gt;&#96;time.ctime() : Thu Apr  7 10:51:58 2016&#96; |</span><br><span class="line">| 5    | time.gmtime([secs]) &lt;br &#x2F;&gt;接收时间戳（1970纪元后经过的浮点秒数）并返回格林威治天文时间下的时间元组t。注：t.tm_isdst始终为0 | 以下实例展示了 gmtime()函数的使用方法：&lt;br &#x2F;&gt;&#96;&gt;&gt;&gt; import time &#96;&lt;br &#x2F;&gt;&#96;&gt;&gt;&gt; print (&quot;gmtime :&quot;, time.gmtime(1455508609.34375)) &#96;&lt;br &#x2F;&gt;&#96;gmtime: time.struct_time(tm_year&#x3D;2016, tm_mon&#x3D;2, tm_mday&#x3D;15, tm_hour&#x3D;3, tm_min&#x3D;56, tm_sec&#x3D;49, tm_wday&#x3D;0, tm_yday&#x3D;46, tm_isdst&#x3D;0)&#96; |</span><br><span class="line">| 6    | time.localtime([secs] &lt;br &#x2F;&gt;接收时间戳（1970纪元后经过的浮点秒数）并返回当地时间下的时间元组t（t.tm_isdst可取0或1，取决于当地当时是不是夏令时）。 | 以下实例展示了 localtime()函数的使用方法：&lt;br &#x2F;&gt;&#96;&gt;&gt;&gt; import time &#96;&lt;br &#x2F;&gt;&#96;&gt;&gt;&gt; print (&quot;localtime(): &quot;, time.localtime(1455508609.34375)) &#96;&lt;br &#x2F;&gt;&#96;localtime():  time.struct_time(tm_year&#x3D;2016, tm_mon&#x3D;2, tm_mday&#x3D;15, tm_hour&#x3D;11, tm_min&#x3D;56, tm_sec&#x3D;49, tm_wday&#x3D;0, tm_yday&#x3D;46, tm_isdst&#x3D;0)&#96; |</span><br><span class="line">| 7    | [time.mktime(tupletime)](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-time-mktime.html)&lt;br &#x2F;&gt; 接受时间元组并返回时间戳（1970纪元后经过的浮点秒数）。 | [实例](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-time-mktime.html) |</span><br><span class="line">| 8    | time.sleep(secs) &lt;br &#x2F;&gt;推迟调用线程的运行，secs指秒数。      | 以下实例展示了 sleep()函数的使用方法：&#96;#!&#x2F;usr&#x2F;bin&#x2F;python3 import time print (&quot;Start : %s&quot; % time.ctime()) time.sleep( 5 ) print (&quot;End : %s&quot; % time.ctime())&#96; |</span><br><span class="line">| 9    | time.strftime(fmt[,tupletime]) &lt;br &#x2F;&gt;接收以时间元组，并返回以可读字符串表示的当地时间，格式由fmt决定。 | 以下实例展示了 strftime()函数的使用方法：&#96;&gt;&gt;&gt; import time &gt;&gt;&gt; print (time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime())) 2016-04-07 11:18:05&#96; |</span><br><span class="line">| 10   | time.strptime(str,fmt&#x3D;&#39;%a %b %d %H:%M:%S %Y&#39;) &lt;br &#x2F;&gt;根据fmt的格式把一个时间字符串解析为时间元组。 | 以下实例展示了 strptime()函数的使用方法：&#96;&gt;&gt;&gt; import time &gt;&gt;&gt; struct_time &#x3D; time.strptime(&quot;30 Nov 00&quot;, &quot;%d %b %y&quot;) &gt;&gt;&gt; print (&quot;返回元组: &quot;, struct_time) 返回元组:  time.struct_time(tm_year&#x3D;2000, tm_mon&#x3D;11, tm_mday&#x3D;30, tm_hour&#x3D;0, tm_min&#x3D;0, tm_sec&#x3D;0, tm_wday&#x3D;3, tm_yday&#x3D;335, tm_isdst&#x3D;-1)&#96; |</span><br><span class="line">| 11   | time.time( ) &lt;br &#x2F;&gt;返回当前时间的时间戳（1970纪元后经过的浮点秒数）。 | 以下实例展示了 time()函数的使用方法：&#96;&gt;&gt;&gt; import time &gt;&gt;&gt; print(time.time()) 1459999336.1963577&#96; |</span><br><span class="line">| 12   | [time.tzset()](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-time-tzset.html) &lt;br &#x2F;&gt;根据环境变量TZ重新初始化时间相关设置。 | [实例](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-time-tzset.html) |</span><br><span class="line">| 13   | **time.perf_counter()** &lt;br &#x2F;&gt;返回计时器的精准时间（系统的运行时间），包含整个系统的睡眠时间。由于返回值的基准点是未定义的，所以，只有连续调用的结果之间的差才是有效的。 | [实例](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-date-time.html#comment-35499) |</span><br><span class="line">| 14   | **time.process_time()**  &lt;br &#x2F;&gt;返回当前进程执行 CPU 的时间总和，不包含睡眠时间。由于返回值的基准点是未定义的，所以，只有连续调用的结果之间的差才是有效的。 |                                                              |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**日期格式化符号：**</span><br><span class="line"></span><br><span class="line">- %y 两位数的年份表示（00-99）</span><br><span class="line">- %Y 四位数的年份表示（000-9999）</span><br><span class="line">- %m 月份（01-12）</span><br><span class="line">- %d 月内中的一天（0-31）</span><br><span class="line">- %H 24小时制小时数（0-23）</span><br><span class="line">- %I 12小时制小时数（01-12）</span><br><span class="line">- %M 分钟数（00&#x3D;59）</span><br><span class="line">- %S 秒（00-59）</span><br><span class="line">- %a 本地简化星期名称</span><br><span class="line">- %A 本地完整星期名称</span><br><span class="line">- %b 本地简化的月份名称</span><br><span class="line">- %B 本地完整的月份名称</span><br><span class="line">- %c 本地相应的日期表示和时间表示</span><br><span class="line">- %j 年内的一天（001-366）</span><br><span class="line">- %p 本地A.M.或P.M.的等价符</span><br><span class="line">- %U 一年中的星期数（00-53）星期天为星期的开始</span><br><span class="line">- %w 星期（0-6），星期天为星期的开始</span><br><span class="line">- %W 一年中的星期数（00-53）星期一为星期的开始</span><br><span class="line">- %x 本地相应的日期表示</span><br><span class="line">- %X 本地相应的时间表示</span><br><span class="line">- %Z 当前时区的名称</span><br><span class="line">- %% %号本身</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###### calendar</span><br><span class="line"></span><br><span class="line">* 星期一是默认的每周第一天，星期天是默认的最后一天。更改设置需调用calendar.setfirstweekday()函数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">| 序号 | 函数及描述                                                   |</span><br><span class="line">| :--- | :----------------------------------------------------------- |</span><br><span class="line">| 1    | **calendar.calendar(year,w&#x3D;2,l&#x3D;1,c&#x3D;6)**&lt;br &#x2F;&gt; 返回一个多行字符串格式的year年年历，3个月一行，间隔距离为c。 每日宽度间隔为w字符。每行长度为21* W+18+2* C。l是每星期行数。 |</span><br><span class="line">| 2    | **calendar.firstweekday( )** &lt;br &#x2F;&gt;返回当前每周起始日期的设置。默认情况下，首次载入caendar模块时返回0，即星期一。 |</span><br><span class="line">| 3    | **calendar.isleap(year)** &lt;br &#x2F;&gt;是闰年返回 True，否则为 false。&lt;br &#x2F;&gt;&lt;img src&#x3D;&quot;python&#x2F;截屏2020-12-16 下午3.44.04.png&quot; alt&#x3D;&quot;截屏2020-12-16 下午3.44.04&quot; style&#x3D;&quot;zoom:40%;&quot; &#x2F;&gt; |</span><br><span class="line">| 4    | **calendar.leapdays(y1,y2)** &lt;br &#x2F;&gt;返回在Y1，Y2两年之间的闰年总数。 |</span><br><span class="line">| 5    | **calendar.month(year,month,w&#x3D;2,l&#x3D;1)**&lt;br &#x2F;&gt; 返回一个多行字符串格式的year年month月日历，两行标题，一周一行。每日宽度间隔为w字符。每行的长度为7* w+6。l是每星期的行数。 |</span><br><span class="line">| 6    | **calendar.monthcalendar(year,month)** &lt;br &#x2F;&gt;返回一个整数的单层嵌套列表。每个子列表装载代表一个星期的整数。Year年month月外的日期都设为0;范围内的日子都由该月第几日表示，从1开始。 |</span><br><span class="line">| 7    | **calendar.monthrange(year,month)** &lt;br &#x2F;&gt;返回两个整数。第一个是该月的星期几，第二个是该月有几天。星期几是从0（星期一）到 6（星期日）。&lt;br &#x2F;&gt;&lt;img src&#x3D;&quot;python&#x2F;截屏2020-12-16 下午3.44.50.png&quot; alt&#x3D;&quot;截屏2020-12-16 下午3.44.50&quot; style&#x3D;&quot;zoom:45%;&quot; &#x2F;&gt;&lt;br &#x2F;&gt;(5, 30)解释：5 表示 2014 年 11 月份的第一天是周六，30 表示 2014 年 11 月份总共有 30 天。 |</span><br><span class="line">| 8    | **calendar.prcal(year, w&#x3D;0, l&#x3D;0, c&#x3D;6, m&#x3D;3)** &lt;br &#x2F;&gt;相当于 print (calendar.calendar(year, w&#x3D;0, l&#x3D;0, c&#x3D;6, m&#x3D;3))。 |</span><br><span class="line">| 9    | **calendar.prmonth(theyear, themonth, w&#x3D;0, l&#x3D;0)** &lt;br &#x2F;&gt;相当于 **print(calendar.month(theyear, themonth, w&#x3D;0, l&#x3D;0))**。 |</span><br><span class="line">| 10   | **calendar.setfirstweekday(weekday)** &lt;br &#x2F;&gt;设置每周的起始日期码。0（星期一）到6（星期日）。 |</span><br><span class="line">| 11   | **calendar.timegm(tupletime)** &lt;br &#x2F;&gt;和time.gmtime相反：接受一个时间元组形式，返回该时刻的时间戳（1970纪元后经过的浮点秒数）。 |</span><br><span class="line">| 12   | **calendar.weekday(year,month,day)**&lt;br &#x2F;&gt; 返回给定日期的日期码。0（星期一）到6（星期日）。月份为 1（一月） 到 12（12月）。 |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###### datetime</span><br><span class="line"></span><br><span class="line">- [datetime模块](https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;datetime.html)</span><br><span class="line">- datetime模块为日期和时间处理同时提供了简单和复杂的方法。</span><br><span class="line">- 支持日期和时间算法的同时，实现的重点放在更有效的处理和格式化输出。</span><br><span class="line">- 该模块还支持时区处理</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line">now &#x3D; date.today()</span><br><span class="line">print(str(now))  # 2020-12-17</span><br><span class="line">print(now.strftime(&quot;%m-%d-%y. %d %b %Y is a %A on the %d day of %B.&quot;))</span><br><span class="line"># 212-17-20. 17 Dec 2020 is a Thursday on the 17 day of December.</span><br><span class="line">birthday &#x3D; date(1964, 7, 31)</span><br><span class="line">age &#x3D; now - birthday</span><br><span class="line">print(birthday)    # 1964-07-31</span><br><span class="line">print(age)         # 20593 days, 0:00:00</span><br><span class="line">print(age.days)    # 20593</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h4 id="内置函数-build-in"><a href="#内置函数-build-in" class="headerlink" title="内置函数(build.in)"></a>内置函数(build.in)</h4><h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">sorted</span>(<span class="built_in">dict</span>.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><ul><li>根据value(x[1])值来进行排序</li><li>dict是无序的，所以即使sorted了，得到的依然不是完全的排序号的</li></ul><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><ul><li><strong>类(Class):</strong> 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。</li><li><strong>方法：</strong>类中定义的函数。</li><li><strong>类变量：</strong>类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。</li><li><strong>数据成员：</strong>类变量或者实例变量用于处理类及其实例对象的相关的数据。</li><li><strong>方法重写：</strong>如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。</li><li><strong>局部变量：</strong>定义在方法中的变量，只作用于当前实例的类。</li><li><strong>实例变量：</strong>在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用 self 修饰的变量。</li><li><strong>继承：</strong>即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟”是一个（is-a）”关系（例图，Dog是一个Animal）。</li><li><strong>实例化：</strong>创建一个类的实例，类的具体对象。</li><li><strong>对象：</strong>通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。</li></ul><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span></span><br><span class="line">  data = <span class="number">12345</span>            <span class="comment"># 基本属性</span></span><br><span class="line">  __private = <span class="number">0</span>            <span class="comment"># 私有属性</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, a</span>):</span>  <span class="comment"># 类的构造方法</span></span><br><span class="line">    self.data = a</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">self, b</span>):</span>         <span class="comment"># 类方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello world&#x27;</span> + b</span><br><span class="line">  </span><br><span class="line">myclass = MyClass(a)      <span class="comment"># 实例化类</span></span><br><span class="line">myclass.f(b)</span><br></pre></td></tr></table></figure><ul><li>在类的内部，使用 <code>def</code> 关键字来定义一个<strong>方法</strong>，与一般函数定义不同，类方法必须包含参数 <code>self</code>，且为第一个参数<ul><li><code>self</code>代表的是类的实例，代表当前对象的地址，而<code>self.class</code>则指向类。</li><li><code>self</code>的名字并不是规定死的，也可以使用 <code>this</code>，但是最好还是按照约定是用 <code>self</code>。</li></ul></li><li><ul><li>类方法必须包含参数<code>self</code>, 且为第一个参数</li></ul></li><li><code>__private_attrs</code>：两个下划线开头，声明该<strong>属性为私有</strong>，不能在类的外部被使用或直接访问。在类内部的方法中使用时 <code>self.__private_attrs</code>。</li><li><code>__private_method</code>：两个下划线开头，声明该方法为<strong>私有方法</strong>，只能在类的内部调用 ，不能在类的外部调用。<code>self.__private_methods</code>。</li></ul><p><strong>类的专有方法：</strong></p><ul><li><strong>__init__</strong> : 构造函数，在生成对象时调用</li><li><strong>__del__ :</strong> 析构函数，释放对象时使用</li><li><strong>__repr__ :</strong> 打印，转换</li><li><strong>__setitem__ :</strong> 按照索引赋值</li><li><strong>__getitem__:</strong> 按照索引获取值</li><li><strong>__len__:</strong> 获得长度</li><li><strong>__cmp__:</strong> 比较运算</li><li><strong>__call__:</strong> 函数调用</li><li><strong>__add__:</strong> 加运算</li><li><strong>__sub__:</strong> 减运算</li><li><strong>__mul__:</strong> 乘运算</li><li><strong>__truediv__:</strong> 除运算</li><li><strong>__mod__:</strong> 求余运算</li><li><strong>__pow__:</strong> 乘方</li></ul><p><strong>运算符重载：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, a, b</span>):</span></span><br><span class="line">      self.a = a</span><br><span class="line">      self.b = b</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;Vector (%d, %d)&#x27;</span> % (self.a, self.b)</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__add__</span>(<span class="params">self,other</span>):</span></span><br><span class="line">      <span class="keyword">return</span> Vector(self.a + other.a, self.b + other.b)</span><br><span class="line"> </span><br><span class="line">v1 = Vector(<span class="number">2</span>,<span class="number">10</span>)</span><br><span class="line">v2 = Vector(<span class="number">5</span>,-<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span> (v1 + v2)</span><br></pre></td></tr></table></figure><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClassName</span>(<span class="params">BaseClassName1, BaseClassNameN</span>):</span></span><br><span class="line">    &lt;statement-<span class="number">1</span>&gt;</span><br><span class="line">    .</span><br><span class="line">    &lt;statement-N&gt;</span><br><span class="line"><span class="comment">### or ##</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClassName</span>(<span class="params">modname.BaseClassName</span>):</span></span><br></pre></td></tr></table></figure><p><strong>单继承</strong></p><ul><li>以下实例<code>student</code>继承<code>people</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>:</span></span><br><span class="line">    <span class="comment">#定义基本属性</span></span><br><span class="line">    name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    age = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义私有属性,私有属性在类外部无法直接进行访问</span></span><br><span class="line">    __weight = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#定义构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,n,a,w</span>):</span></span><br><span class="line">        self.name = n</span><br><span class="line">        self.age = a</span><br><span class="line">        self.__weight = w</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;%s 说: 我 %d 岁。&quot;</span> %(self.name,self.age))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#单继承示例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span>(<span class="params">people</span>):</span></span><br><span class="line">    grade = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,n,a,w,g</span>):</span></span><br><span class="line">        <span class="comment">#调用父类的构函</span></span><br><span class="line">        people.__init__(self,n,a,w)</span><br><span class="line">        self.grade = g</span><br><span class="line">       </span><br><span class="line">    <span class="comment">#覆写父类的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;</span>%(self.name, self.age, self.grade))</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">s = student(<span class="string">&#x27;ken&#x27;</span>,<span class="number">10</span>,<span class="number">60</span>,<span class="number">3</span>)</span><br><span class="line">s.speak()</span><br><span class="line"><span class="comment"># ken 说: 我 10 岁了，我在读 3 年级</span></span><br></pre></td></tr></table></figure><p><strong>多继承</strong></p><ul><li>需要注意圆括号中父类的顺序，若是父类中有相同的方法名，而在子类使用时未指定，python从左至右搜索，即方法在子类中未找到时，从左到右查找父类中是否包含方法。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>:</span></span><br><span class="line">    <span class="comment">#定义基本属性</span></span><br><span class="line">    name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    age = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义私有属性,私有属性在类外部无法直接进行访问</span></span><br><span class="line">    __weight = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,n,a,w</span>):</span></span><br><span class="line">        self.name = n</span><br><span class="line">        self.age = a</span><br><span class="line">        self.__weight = w</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;%s 说: 我 %d 岁。&quot;</span> %(self.name,self.age))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#单继承示例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span>(<span class="params">people</span>):</span></span><br><span class="line">    grade = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,n,a,w,g</span>):</span></span><br><span class="line">        <span class="comment">#调用父类的构函</span></span><br><span class="line">        people.__init__(self,n,a,w)</span><br><span class="line">        self.grade = g</span><br><span class="line">    <span class="comment">#覆写父类的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;</span>%(self.name, self.age, self.grade))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#另一个类，多重继承之前的准备</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">speaker</span>():</span></span><br><span class="line">    topic = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,n,t</span>):</span></span><br><span class="line">        self.name = n</span><br><span class="line">        self.topic = t</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;我叫 %s，我是一个演说家，我演讲的主题是 %s&quot;</span>%(self.name,self.topic))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#多重继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sample</span>(<span class="params">speaker,student</span>):</span></span><br><span class="line">    a =<span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,n,a,w,g,t</span>):</span></span><br><span class="line">        student.__init__(self,n,a,w,g)</span><br><span class="line">        speaker.__init__(self,n,t)</span><br><span class="line"> </span><br><span class="line">test = sample(<span class="string">&quot;Tim&quot;</span>,<span class="number">25</span>,<span class="number">80</span>,<span class="number">4</span>,<span class="string">&quot;Python&quot;</span>)</span><br><span class="line">test.speak()   <span class="comment">#方法名同，默认调用的是在括号中排前地父类的方法</span></span><br><span class="line"><span class="comment"># 我叫 Tim，我是一个演说家，我演讲的主题是 Python</span></span><br></pre></td></tr></table></figure><p><strong>方法重写</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>:</span>        <span class="comment"># 定义父类</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">myMethod</span>(<span class="params">self</span>):</span></span><br><span class="line">      <span class="built_in">print</span> (<span class="string">&#x27;调用父类方法&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>(<span class="params">Parent</span>):</span> <span class="comment"># 定义子类</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">myMethod</span>(<span class="params">self</span>):</span></span><br><span class="line">      <span class="built_in">print</span> (<span class="string">&#x27;调用子类方法&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">c = Child()          <span class="comment"># 子类实例</span></span><br><span class="line">c.myMethod()         <span class="comment"># &#x27;调用子类方法&#x27; 子类调用重写方法</span></span><br><span class="line"><span class="built_in">super</span>(Child,c).myMethod()  <span class="comment"># &#x27;调用父类方法&#x27; 用子类对象调用父类已被覆盖的方法</span></span><br></pre></td></tr></table></figure><ul><li>super() 函数：用于调用父类(超类)的一个方法。</li></ul><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;super method&#x27;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delegate</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.action()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inheritor</span>(<span class="params">Super</span>):</span> <span class="comment">#1 获得父类的一切内容</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Replacer</span>(<span class="params">Super</span>):</span> <span class="comment">#2 覆盖父类的method</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;replacer.method&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Extender</span>(<span class="params">Super</span>):</span> <span class="comment">#3  覆盖并回调method 定制父类的method方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;extender.method&#x27;</span>)</span><br><span class="line">        Super.method(self)</span><br><span class="line">        print(<span class="string">&#x27;ending extend.method&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Provider</span>(<span class="params">Super</span>):</span>  <span class="comment">#4</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">action</span>(<span class="params">self</span>):</span>  <span class="comment"># 实现super的delegate方法预期的action方法</span></span><br><span class="line">        print(<span class="string">&#x27;provider.action&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> (Inheritor,Replacer,Extender):</span><br><span class="line">        print(i.__name__)</span><br><span class="line">        i().method()</span><br><span class="line">        x = Provider()</span><br><span class="line">        x.delegate()</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Inheritor</span></span><br><span class="line"><span class="string">super method</span></span><br><span class="line"><span class="string">provider.action</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Replacer</span></span><br><span class="line"><span class="string">replacer.method</span></span><br><span class="line"><span class="string">provider.action</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Extender</span></span><br><span class="line"><span class="string">extender.method</span></span><br><span class="line"><span class="string">super method</span></span><br><span class="line"><span class="string">ending extend.method</span></span><br><span class="line"><span class="string">provider.action</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><p><strong>pyinstaller</strong></p><ul><li>打包py文件，将在当前目录生成一个<code>.spec</code>文件和<code>dist</code>目录，可执行文件在<code>dist</code>目录下</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pip install pyinstaller</span><br><span class="line"><span class="meta">#</span><span class="bash"> 到文件夹下</span></span><br><span class="line">pyinstaller -F file.py</span><br><span class="line"></span><br><span class="line"><span class="meta"> #</span><span class="bash"> -F 打包出来是一个可执行文件，不然的话是多个，没有把包封装进去，需要pythonu环境来运行</span></span><br></pre></td></tr></table></figure><p>=======</p><ul><li>终端切换</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chsh -s /bin/zsh</span><br><span class="line">chsh -s /bin/bash</span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换后重启完成</span></span><br></pre></td></tr></table></figure><h2 id="一些错误"><a href="#一些错误" class="headerlink" title="一些错误"></a>一些错误</h2><img src="/2020/12/15/python/截屏2020-12-25 下午10.44.40.png" alt="截屏2020-12-25 下午10.44.40" style="zoom: 67%;">    <ul><li>字典类型的键是不可变的，可以使用数字、字符串或元组充当，但是不能使用列表作为键值</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Anaconda&quot;&gt;&lt;a href=&quot;#Anaconda&quot; class=&quot;headerlink&quot; title=&quot;Anaconda&quot;&gt;&lt;/a&gt;Anaconda&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;link&quot; href=&quot;https://www.jiansh</summary>
      
    
    
    
    <category term="notebook" scheme="https://jieyang-wei.github.io/categories/notebook/"/>
    
    
    <category term="编程语言" scheme="https://jieyang-wei.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="python" scheme="https://jieyang-wei.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>gdb调试</title>
    <link href="https://jieyang-wei.github.io/2020/12/14/gdb%E8%B0%83%E8%AF%95/"/>
    <id>https://jieyang-wei.github.io/2020/12/14/gdb%E8%B0%83%E8%AF%95/</id>
    <published>2020-12-14T09:56:55.000Z</published>
    <updated>2020-12-30T11:28:27.571Z</updated>
    
    <content type="html"><![CDATA[<p>制作链接库的目的是希望别人使用我们已经实现的功能，但又不希望别人看到我们的源代码<br><code>Linux</code>下的静态链接库是以<code>.a</code>结尾的二进制文件，它作为程序的一个模块，在链接期间被组合到程序中。和静态链接库相对的是动态链接库（.so文件），它在程序运行阶段被加载进内存。</p><p>静态库生成步骤</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1 对所有源文件，只编译不链接</span></span><br><span class="line">gcc -c test.c</span><br><span class="line"><span class="comment">//2 利用ar命令，生成库文件</span></span><br><span class="line">ar rcs libtest.a test.o</span><br></pre></td></tr></table></figure><p><code>ar</code>是 Linux 的一个备份压缩命令，它可以将多个文件打包成一个备份文件（也叫归档文件），也可以从备份文件中提取成员文件，最常见的用法是将目标文件打包为静态链接库。</p><p>对参数的说明：</p><ul><li>r：用来替换库中已有的目标文件，或者加入新的目标文件。</li><li>c：表示创建一个库。不管库否存在，都将创建。</li><li>s：用来创建目标文件索引，这在创建较大的库时能提高速度。</li></ul><ul><li>-lm：表示连接系统的数学库libm.a<ul><li>需要放在库之后，不然找不到</li></ul></li></ul><p>Linux 下动态链接库（shared object file，共享对象文件）的文件后缀为.so，它是一种特殊的目标文件（object file），可以在程序运行时被加载（链接）进来。</p><p>使用动态链接库的优点是：程序的可执行文件更小，便于程序的模块化以及更新，同时，有效内存的使用效率更高</p><ol><li>如果想创建一个动态链接库，可以使用 GCC 的-shared选项。输入文件可以是源文件、汇编文件或者目标文件。</li><li>另外还得结合<code>-fPIC</code>选项。<code>-fPIC</code>选项作用于编译阶段，告诉编译器产生与位置无关代码（Position-Independent Code）；这样一来，产生的代码中就没有绝对地址了，全部使用相对地址，所以代码可以被加载器加载到内存的任意位置，都可以正确的执行。这正是共享库所要求的，共享库被加载时，在内存的位置不是固定的。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 从源文件生成动态链接库：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -fPIC -shared func.c -o libfunc.so</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从目标文件生成动态链接库：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -fPIC -c func.c -o func.o</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -shared func.o -o libfunc.so</span></span><br><span class="line"> * -fPIC 选项作用于编译阶段，在生成目标文件时就得使用该选项，以生成位置无关的代码。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;制作链接库的目的是希望别人使用我们已经实现的功能，但又不希望别人看到我们的源代码&lt;br&gt;&lt;code&gt;Linux&lt;/code&gt;下的静态链接库是以&lt;code&gt;.a&lt;/code&gt;结尾的二进制文件，它作为程序的一个模块，在链接期间被组合到程序中。和静态链接库相对的是动态链接库（.s</summary>
      
    
    
    
    <category term="course" scheme="https://jieyang-wei.github.io/categories/course/"/>
    
    
    <category term="linux" scheme="https://jieyang-wei.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>区块链</title>
    <link href="https://jieyang-wei.github.io/2020/12/14/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    <id>https://jieyang-wei.github.io/2020/12/14/%E5%8C%BA%E5%9D%97%E9%93%BE/</id>
    <published>2020-12-14T09:47:42.000Z</published>
    <updated>2021-02-12T10:14:04.370Z</updated>
    
    <content type="html"><![CDATA[<h1 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h1><ul><li>一个特殊的历史不可更改的链表<strong>数据结构</strong></li><li>一个电子记账本，以比特币和其他密码加密货币进行的交易公开地、按照日期顺序记录其中</li></ul><blockquote><p>总的来说，它是一个公开的数据库，新的数据存储在一个称为区块的容器中，并且附加到一个“不可变”的链条（即区块链）上，链条上还有以前附加的数据。</p><blockquote><p>这里的“不可变”指的是以前的数据一旦附加到链条上，后面是不可更改的。</p></blockquote></blockquote><p>结构：</p><img src="/2020/12/14/%E5%8C%BA%E5%9D%97%E9%93%BE/IMG_DD562F6FCFED-1.jpeg" alt="IMG_DD562F6FCFED-1" style="zoom: 50%;"><ul><li>genesis block：创世区块</li><li><strong>header</strong><ul><li>256bit：一串随机数nonce，需要使得整个区块信息取hash后值小于target（即前面有多少个0）</li><li>SHA256-1：前一个区块的hash值，创世区块没有前一个区块，所以该值为全0</li><li>SHA256-2：body数据的hash值</li></ul></li><li><strong>body</strong>：存储数据</li></ul><p>区块链大致分为三种类型，但从本质上讲，他们之间并不矛盾，只是使用了不同的技术：</p><ul><li><strong>私有链</strong>可以优先考虑系统的速度，因为它无需像公共区块链那样担心核心故障。理想情况下，将私有链部署在个人或组织可控且信息保密的情况下。</li><li>精心设计的<strong>公有链</strong>在防审计性方面往往更具优势，但代价是速度和吞吐量较低。这些是对交易结算（或智能合约）提供安全性保证的最佳选择。</li><li><strong>联盟链</strong>可减轻私有链中交易对手的风险（通过消除集中控制），并且较少的节点数通常可使它们能够比公共链更有效率的运行。联盟链适合于彼此之间需要相互沟通的单位组织。</li></ul><h1 id="Consensus-Algorithm，共识算法"><a href="#Consensus-Algorithm，共识算法" class="headerlink" title="Consensus Algorithm，共识算法"></a>Consensus Algorithm，共识算法</h1><p>什么是共识？</p><ol><li><strong>点的层面</strong>：多个节点对某个数据达成一致共识。</li><li><strong>线的层面</strong>：即多个节点对多个数据的顺序达成一致共识。<ul><li>这里的<strong>节点</strong>可以是任意的计算机设备，比如pc电脑，笔记本，手机，路由器等，</li><li>这里的<strong>数据</strong>可以是交易数据，状态数据等。</li><li>其中对<strong>数据顺序</strong>达成一致共识是很多共识算法要解决的本质问题。</li></ul></li></ol><blockquote><p>有一种常见的误解，认为PoW和PoS是共识算法。其实它们不是。它们只是通过约束稀缺资源的方式来选择区块生产者（抗女巫攻击的机制），而共识是就各节点上的数据达成一致性</p><ul><li>经典共识：让一组参与者进行多轮投票，直到一定比例的投票者达成共识。既PBFT</li><li>中本聪共识：当你看到提议的区块拥有最多工作量证明，就接受它。既选择最长链</li></ul></blockquote><p>共识算法是实现共识机制的方法，目前常见的有PoW，PoS，DPoS，PBFT，PAXOS, RAFT等</p><p>主流共识算法可大致分为三类</p><ol><li>挑战证明(Proof of Challenge)<ul><li>简单地说，就是给所有参与者一个有挑战性的问题，谁能在最短的时间内找到答案，那么他就是这轮公认的决策者。</li><li>PoW是一个典型的例子，每个参与者都必须计算一个块的哈希值，这个哈希值需要由N个前导0组成，谁找到了这个哈希值，那新的区块就属于谁。</li></ul></li><li>权益证明(Proof of Stake)<ul><li>简单地说，就是根据参与者所拥有的某种资产或授予的权利，标志在转盘上，然后开始转转盘，转到这对应位置的那个参与者，就是该轮公认的决策者。</li><li>现在的系统，有的根据拥有币的数量，有的根据贡献的储存空间，有的根据积分奖赏的额度等等，千奇百怪。虽然披着不同的羊皮，但他们都是狼，本质都是权益证明。现实生活中，民主选举投票领导人就是这种逻辑，</li><li>但权益证明有一定随机性。</li></ul></li><li>协商证明(Proof of Negotiation)<ul><li>简单地说，就是所有参与者坐在一起，通过多轮对话，协商一个新的决策者。例如PBFT，PAXOS都是属于这种类型，需要多轮交互协议，需要形式化证明协议的可靠性安全性。</li><li>但交互的次数太多引入了复杂性，给网络宽带资源带来了很大负担，这个一个缺点。现实生活中的民主协商制就是这种逻辑。</li><li>为了上述各种类型效率，聪明的人类引入了<strong>代表机制（Delegated）</strong>，不需要所有的参与者都参与最后的决策，而是先选出一些代表，每个代表代理一部分参与者的行使权力，例如DPoS。现实生活中，广大人民群众选出人民代表，召开人民代表大会就是这种逻辑。</li></ul></li></ol><p>也可按照作用区块链的类型分为三类：</p><img src="/2020/12/14/%E5%8C%BA%E5%9D%97%E9%93%BE/截屏2021-01-12 上午1.09.13.png" alt="截屏2021-01-12 上午1.09.13" style="zoom:40%;"><ol><li><p><strong>私链</strong>的共识算法即区块链这个概念还没普及时的传统分布式系统里的共识算法</p><ul><li>比如zookeeper的zab协议，就是类paxos算法的一种。私链的适用环境一般是不考虑集群中存在作恶节点，只考虑因为系统或者网络原因导致的<strong>故障节点</strong>。</li></ul></li><li><p><strong>联盟链</strong></p><ul><li><p>经典的代表项目是Hyperledger组织下的Fabric项目，Fabric0.6版本使用的就是pbft算法。</p></li><li><p>适用环境除了需要考虑集群中存在<strong>故障节点</strong>，还需要考虑集群中存在<strong>作恶节点</strong>。</p></li><li><p>对于联盟链，每个新加入的节点都是需要验证和审核的。</p></li></ul></li><li><p><strong>公链</strong></p><ul><li><p>不仅需要考虑网络中存在<strong>故障节点</strong>，还需要考虑<strong>作恶节点</strong>，这一点和联盟链是类似的。</p></li><li><p>但公链中的节点可以很自由的加入或者退出，不需要严格的验证和审核。</p></li></ul></li></ol><h2 id="PoW，工作量证明"><a href="#PoW，工作量证明" class="headerlink" title="PoW，工作量证明"></a>PoW，工作量证明</h2><p>Proof of Work</p><ul><li>最经典的共识机制.。基于给定难度值在最快时间通过迭代计算得到一个随机数 Nonce 以争夺记账权，对获得优先记账权的节点给予一定激励。</li><li>就是大家熟悉的挖矿，通过与或运算，计算出一个满足规则的随机数，即获得本次记账权，发出本轮需要记录的数据，全网其它节点验证后一起存储；<ul><li>优点：完全去中心化，节点自由进出；</li><li>缺点：<ul><li>目前bitcoin已经吸引全球大部分的算力，其它再用Pow共识机制的区块链应用很难获得相同的算力来保障自身的安全；</li><li>挖矿造成大量的资源浪费；</li><li>共识达成的周期较长，不适合商业应用</li></ul></li><li>代表：BTC，Ethereum，莱特币</li></ul></li></ul><h2 id="PoS，权益证明"><a href="#PoS，权益证明" class="headerlink" title="PoS，权益证明"></a>PoS，权益证明</h2><p>Proof of Stake</p><ul><li>通过计算全网节点的持有币量和持币时间（币龄）来决定投票权和打包权。 拥有打包权的节点打包交 易后对全网广播， 拥有投票权的节点投票决定最终上链的区块</li><li>根据每个节点持有币量和持币时间等比例降低计算随机数的难度，从而加快找随机数的速度。<ul><li>优点：在一定程度上缩短了共识达成的时间</li><li>缺点：还是需要挖矿，本质上没有解决商业应用的痛点</li><li>代表： Peercion(点点币) ，Nxt(未来币)</li></ul></li></ul><h2 id="DPoS，委托权益证明"><a href="#DPoS，委托权益证明" class="headerlink" title="DPoS，委托权益证明"></a>DPoS，委托权益证明</h2><p>Delegate Proof of Stake</p><ul><li>是 PoS 的升级版， 由全网普通节点投票选出一些代理节点进行交易验证和记账， 代理节点 完成共识后会获得一定数量的激励， 不合格的代理节点会被投票替换。</li><li>类似于董事会投票，持币者投出一定数量的节点，代理他们进行验证和记账。<ul><li>优点：大幅缩小参与验证和记账节点的数量，可以达到秒级的共识验证</li><li>缺点：整个共识机制还是依赖于代币，很多商业应用是不需要代币存在的</li><li>代表： Bitshare (比特股) ，EOS</li></ul></li></ul><blockquote><p><strong>拜占庭将军问题</strong></p><ul><li>占庭位于如今的土耳其的伊斯坦布尔，是古代东罗马帝国的首都。拜占庭罗马帝国国土辽阔，为了达到防御目的，每块封地都驻扎一支由将军统领的军队，每个军队都分隔很远，将军与将军之间只能靠信差传递消息。 在战争的时候，拜占庭军队内所有将军必需达成一致的共识，决定是否有赢的机会才去攻打敌人的阵营。但是，在军队内有可能存有<strong>叛徒</strong>和敌军的<strong>间谍</strong>，左右将军们的决定影响将军们达成一致共识。</li><li>在已知有将军是叛徒的情况下，其余忠诚的将军如何达成一致协议的问题，这就是拜占庭将军问题。</li><li><strong>前提</strong>：可靠信道<ul><li>如果信道不能保证可靠，那么拜占庭问题无解。</li></ul></li></ul><blockquote><p>关于信道可靠问题，会引出<strong>两军问题</strong>：在一个不可靠的通信链路上试图通过通信以达成一致是基本不可能或者十分困难的。</p></blockquote><p>拜占庭将军问题最早是由Leslie Lamport与另外两人在1982年发表的论文《The Byzantine Generals Problem 》提出的， 他证明了在将军总数大于3f ，背叛者为f 或者更少时，忠诚的将军可以达成命令上的一致，即3f+1&lt;=n。算法复杂度为o（n^(f+1))。</p><p>而Miguel Castro (卡斯特罗)和Barbara Liskov（利斯科夫）在1999年发表的论文《Practical Byzantine Fault Tolerance》中首次提出pbft算法，该算法容错数量也满足3f+1&lt;=n,算法复杂度为o（n^2）。</p></blockquote><h2 id="BFT，拜占庭容错"><a href="#BFT，拜占庭容错" class="headerlink" title="BFT，拜占庭容错"></a>BFT，拜占庭容错</h2><p>BFT共识算法可以应对分布式系统中的拜占庭故障（Byzantine failures），也就是可以在集群中部分节点存在恶意行为时依然保证整个系统的正常工作。</p><p><strong>开发库</strong></p><ol><li>Tendermint Core<ul><li>一个拜占庭容错的中间件，可以安全的将任何语言开发的状态机复制到集群中的其他机器上。</li><li>已经被用于Cosmos、币安链等多种公链环境中。</li></ul></li><li>BFT—SMaRt<ul><li>一个拜占庭容错的状态机复制实现，采用Java开发，目前由里斯本大学的LsSIGE研究组负责维护。BFT-SMaRt要求JRE 1.8+。</li><li>最知名的Java版BFT实现，京东的区块链就是采用这个库解决共识问题。</li></ul></li><li>Babble<ul><li>用于分布式应用的拜占庭共识平台，它可以让一组计算机表现的如同单一计算机。</li><li>使用P2P网络和BFT共识算法来保证一组彼此互联的计算机可以同样的顺序处理同样的命令，也就是通常说的状态机复制。</li><li>Babble可以让整个系统安全的应对部分节点的故障或恶意行为。</li></ul></li><li>Concord-BFT<ul><li>vmware开源的一个通用的状态机复制库，可以应对集群中的恶意行为（拜占庭故障）。</li><li>被设计用于分部署数据仓库复制的核心构建模块，特别适合作为许可制区块链系统的基础。</li><li>concord-bft的实现基于论文<a class="link" href="https://arxiv.org/pdf/1804.01626.pdf">SBFT: a Scalable Decentralized Trust Infrastructure for Blockchains<i class="fas fa-external-link-alt"></i></a>中的算法.</li></ul></li><li>HBBFT<ul><li>是论文<a class="link" href="https://eprint.iacr.org/2016/199.pdf">Honey Badger of BFT Protocols<i class="fas fa-external-link-alt"></i></a>提出的蜜獾BFT共识算法的Rust实现。<ul><li>蜜獾（Honey Badger）共识算法可以让分布式异步环境中的节点交易达成一致，该算法不需要主导节点，可以应对恶意节点的攻击，适合于去中心化数据库和区块链应用</li></ul></li><li>要求Rust 1.36+以及cargo</li></ul></li><li>libbft<ul><li>一个轻量级的拜占庭容错库，用于neo区块链，采用C++开发，由neo研究院维护，计划移植到Python、go等多种语言</li></ul></li></ol><h3 id="PBFT，实用拜占庭容错算法"><a href="#PBFT，实用拜占庭容错算法" class="headerlink" title="PBFT，实用拜占庭容错算法"></a>PBFT，实用拜占庭容错算法</h3><p>Practical Byzantine Fault Tolerance</p><ul><li>被广泛使用于联盟链，是一种能容忍全网 1 / 3 节点出现错误或异常的分布式系统共识算法， 该算法依赖节点对同一信息的多次重复确认， 从而达到全网共识。<ul><li>采用三阶段的方式保证了交易的全序<ul><li><strong>pre-prepare</strong>阶段：节点收到pre-prepare消息后，会选择接受或不接受。一个典型情况是消息里的视图编号和请求编号在之前收到的消息里曾经出现过，但是消息的内容却和之前的消息不一样，这时就会拒绝请求。拒绝的原因是主节点不会发送两条有相同编号却有不同内容的消息。</li><li><strong>prepare</strong>阶段：节点向其他节点发送prepare消息。如果节点收到了2f个不同节点的消息，代表该节点的prepare阶段已经完成。</li><li><strong>commit</strong>阶段：节点向其他节点广播commit消息。如果节点收到了2f+1个commit消息（包括自己），代表大多数节点已经进入commit阶段，这一阶段已达成共识。于是节点会执行请求，运行结果。</li></ul></li><li>适用场景：少量节点的政府和大型企业并不需要具备币机制时理想选择</li><li>代表： HyperLedger fabric0.6</li></ul></li></ul><p><strong>详细</strong></p><h3 id="IBFT"><a href="#IBFT" class="headerlink" title="IBFT"></a>IBFT</h3><h2 id="raft"><a href="#raft" class="headerlink" title="raft"></a>raft</h2><p>因为网上已经有大量文章对raft算法进行过详细的介绍，因此这部分只会简单的阐述算法的基本原理和流程。raft算法包含三种角色，分别是：跟随者（follower），候选人（candidate）和领导者（leader）。集群中的一个节点在某一时刻只能是这三种状态的其中一种，这三种角色是可以随着时间和条件的变化而互相转换的。</p><p>raft算法主要有两个过程：一个过程是领导者选举，另一个过程是日志复制，其中日志复制过程会分记录日志和提交数据两个阶段。raft算法支持最大的容错故障节点是（N-1）/2，其中N为 集群中总的节点数量。</p><h1 id="Smart-Contract，智能合约"><a href="#Smart-Contract，智能合约" class="headerlink" title="Smart Contract，智能合约"></a>Smart Contract，智能合约</h1><h1 id="P2P网络"><a href="#P2P网络" class="headerlink" title="P2P网络"></a>P2P网络</h1><p>种子，</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;区块链&quot;&gt;&lt;a href=&quot;#区块链&quot; class=&quot;headerlink&quot; title=&quot;区块链&quot;&gt;&lt;/a&gt;区块链&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;一个特殊的历史不可更改的链表&lt;strong&gt;数据结构&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;一个电子记账本，以比特币和其他</summary>
      
    
    
    
    <category term="notebook" scheme="https://jieyang-wei.github.io/categories/notebook/"/>
    
    
    <category term="blockchain" scheme="https://jieyang-wei.github.io/tags/blockchain/"/>
    
  </entry>
  
  <entry>
    <title>版本管理</title>
    <link href="https://jieyang-wei.github.io/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"/>
    <id>https://jieyang-wei.github.io/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/</id>
    <published>2020-12-14T07:55:40.000Z</published>
    <updated>2020-12-15T05:40:02.286Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h3 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h3><ol><li><p><strong>本地版本控制系统</strong>（Version Control Systems，简称VCS）</p><ul><li><p>大多都是采用某种简单的数据库来记录文件的历次更新差异</p></li><li><p>最流行的：<code>RCS</code></p><ul><li>工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，可以重新计算出各个版本的文件内容。”</li></ul></li></ul></li><li><p><strong>集中化版本控制系统</strong>（Centralized Version Control Systems，简称 CVCS ）</p><ul><li>诸如CVS、Subversion以及perforce等</li><li>容易单点故障、丢失所有历史更新记录的风险</li></ul></li><li><p><strong>分布式版本控制系统</strong>（Distributed Version Control System，简称 DVCS）</p><ul><li>像Git、Mercurial、Bazaar以及Darcs</li><li>客户端并不只提取最新版本的文件快照， 而是把代码仓库完整地镜像下来，包括完整的历史记录</li></ul></li></ol><ul><li>大部分系统以文件变更列表的方式存储信息，这类系统（CVS、Subversion、Perforce、Bazaar等）将他们存储的信息看作是一组基本文件和每个文件随时间逐步累积的差异（**基于差异[delta-based]**的版本控制）</li><li>Git 更像是把数据看作是对<strong>小型文件系统</strong>的一系列快照。 在 Git 中，每当你提交更新或保存项目状态时，它基本上就会对当时的全部文件创建一个快照并保存这个快照的索引。 为了效率，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 <strong>快照流</strong></li></ul><p><strong>git</strong>：分布式版本控制系统，c语言开发</p><p><strong>免费集中式版本控制</strong>：CVS、SVN  —  速度慢，且需要联网</p><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p><a class="link" href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">廖雪峰<i class="fas fa-external-link-alt"></i></a></p><p>电子书：progit_v2.1.54</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>git校验和机制</strong>：<strong>SHA-1散列</strong>，这是一个由 40 个十六进制字符（0-9 和 a-f）组成的字符串，基于 Git 中文件的内容或目录结构计算出来</p><h4 id="三种状态"><a href="#三种状态" class="headerlink" title="三种状态"></a>三种状态</h4><ul><li><strong>已提交（committed）</strong>：表示数据已经安全地保存在本地数据库中</li><li><strong>已修改（modified）</strong>：表示修改了文件，但还没保存到数据库中</li><li><strong>已暂存（staged）</strong>：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中</li></ul><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/截屏2020-12-09 下午2.58.04.png" alt="截屏2020-12-07 下午3.29.20"><ul><li>工作区：对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改</li><li>暂存区：是一个文件，保存了下次将要提交的文件列表信息，一般在 Git 仓库目录中。 按照 Git 的术语叫做“索引”，不过一般说法还是叫“暂存区</li><li>git目录：Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，复制的就是这里的数据</li></ul><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><ol><li>在工作区中修改文件。</li><li>将你想要下次提交的更改选择性地暂存，这样只会将更改的部分添加到暂存区。</li><li>提交更新，找到暂存区的文件，将快照永久性存储到 Git 目录。</li></ol><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install git-all</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看版本</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git --version</span></span><br></pre></td></tr></table></figure><p>工具目录结构</p><ul><li>git自带一个<code>git config</code>的工具来帮助设置，这些变量存储在三个不同的位置</li></ul><ol><li>/etc/gitconfig 文件：包含系统上每一个用户及他们仓库的通用配置。 如果在执行 git config 时带上 –system 选项，那么它就会读写该文件中的配置变量。 （由于它是系统配置文件，因此你需要管理员或超级用户权限来修改它。）</li><li>~/.gitconfig 或 ~/.config/git/config 文件：只针对当前用户。 你可以传递 –global 选项让 Git 读写此文件，这会对你系统上所有的仓库生效</li><li>当前使用仓库的 Git 目录中的 config 文件（即 .git/config）：针对该仓库。 你可以传递 –local 选项让 Git 强制读写此文件，虽然默认情况下用的就是它。。 （当然，你需要进入某个 Git 仓库中才能让该选项生效。）<ul><li>每一个级别会覆盖上一级别的配置，所以 .git/config 的配置变量会覆盖 /etc/gitconfig 中的配置变量</li></ul></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --list --show-origin  <span class="comment"># 查看所有配置以及他们所在文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置用户信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.name <span class="string">&quot;Weijieyang&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.email <span class="string">&quot;name@mail.com&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> git config 选项列表</span></span><br><span class="line"> * --list 列出所有 Git 当时能找到的配置</span><br><span class="line"> * --global 配置所有的项目</span><br></pre></td></tr></table></figure><ul><li>git工作目录下每一个文件只有两种状态<ol><li><strong>已跟踪</strong>：指那些被纳入了版本控制的文件，在上一次快照中有它们的记录。即git已经知道的文件</li><li><strong>未跟踪</strong>：其他文件</li></ol></li></ul><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="版本库（Repository）"><a href="#版本库（Repository）" class="headerlink" title="版本库（Repository）"></a>版本库（Repository）</h3><p>工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。</p><p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</p><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/截屏2020-12-07 下午3.29.20.png" alt="截屏2020-12-07 下午3.29.20" style="zoom:50%;"><ol><li><strong>创建版本库</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br></pre></td></tr></table></figure><ul><li>到需要版本管理的目录下</li><li>初始化后会在目录下形成一个<code>.git</code>文件，此文件为隐藏文件，需要使用命令<code>ls -a</code>查看</li></ul><ol start="2"><li><strong>使用步骤</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add file</span> </span><br></pre></td></tr></table></figure><ul><li>添加本地修改后的文件到暂存区</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"> * -s/--short 更为紧凑的输出展示效果</span><br></pre></td></tr></table></figure><ul><li>时刻掌握仓库当前情况，查看未被提交的修改，包括工作区和暂存区</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&#x27;注释&#x27;</span></span></span><br></pre></td></tr></table></figure><ul><li>将暂存区的修改提交到版本库中</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&#x27;注释&#x27;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add filemore</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend</span></span><br></pre></td></tr></table></figure><ul><li>第一次提交后发现漏了几个文件，可以使用<code>--amend</code>添加，此次提交将会替代上一次的提交，上一次的提交将不会出现在版本历史中ß</li></ul><ol start="3"><li><strong>版本管理</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line"> * —-pretty=onelines pretty可以指定不同于默认格式的方式展示历史</span><br><span class="line"> * onelines 输出消息更简洁，最前面是每个版本的commit id（用SHA1计算）</span><br><span class="line"> * format:&quot;%h - %an, %ar : %s&quot; 定制记录的显示格式</span><br><span class="line"> * 还有short、full和fuller</span><br><span class="line"> </span><br><span class="line"> * -p/--patch 显示每次提交所引入的差异（按 补丁 的格式输出）</span><br><span class="line"> * --stat 每次提交的简略统计信息</span><br><span class="line"> * --shortstat 只显示 --stat 中最后的行数修改添加移除统计</span><br><span class="line"> * --name-only 仅在提交信息后显示已修改的文件清单</span><br><span class="line"> * --name-status 显示新增、修改、删除的文件清单</span><br><span class="line"> * --graph 查看分支合并图，在日志旁以 ASCII 图形显示分支与合并历</span><br><span class="line"> * --abbrev-commit 查看详细的合并信息，仅显示 SHA-1 校验和所有 40 个字符中的前几个字符</span><br><span class="line"> * --relative-data 使用较短的相对时间而不是完整格式显示日期（比如“2 weeks ago”）</span><br></pre></td></tr></table></figure><ul><li>显示从最近到最远的提交日志</li><li><strong>format</strong>格式设置：<ul><li><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/截屏2020-12-09 下午3.39.00.png" alt="截屏2020-12-09 下午3.39.00" style="zoom: 33%;"></li><li><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/截屏2020-12-09 下午3.39.17.png" alt="截屏2020-12-09 下午3.39.17" style="zoom: 33%;"></li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git last</span></span><br></pre></td></tr></table></figure><ul><li>查看最后一次提交</li></ul><p><strong>取消暂存 reset</strong>  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard HEAD^</span> </span><br></pre></td></tr></table></figure><ul><li>回退到前一个版本<ul><li><code>HEAD</code>：相当于一个指针，指向<code>master</code>，而<code>master</code>指向提交</li><li><code>^</code>：是上一个版本，<code>^^</code>：前两个的版本，<code>HEAD～100</code>：往上100个版本</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard commitId</span></span><br></pre></td></tr></table></figure><ul><li>回退到版本号为<code>commitId</code>的版本</li><li><strong>注意</strong>：<code>--hard</code> 是一个危险的选项</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rerset HEAD &lt;file&gt;</span></span><br></pre></td></tr></table></figure><ul><li>撤销暂存区(unstage)的修改回退到工作区</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reflog</span></span><br><span class="line">e475afc HEAD@&#123;1&#125;: reset: moving to HEAD^</span><br><span class="line">1094adb (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: append GPL</span><br><span class="line">e475afc HEAD@&#123;3&#125;: commit: add distributed</span><br><span class="line">eaadf4e HEAD@&#123;4&#125;: commit (initial): wrote a readme file</span><br></pre></td></tr></table></figure><ul><li>记录了你的每一次命令，可以用来找已经撤销掉的版本id</li></ul><ol start="4"><li><strong>其他操作</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff file</span></span><br></pre></td></tr></table></figure><ul><li>查看修改内容，<code>diff</code>均是未提交的内容</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff --staged</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看已暂存文件和最后一次提交的文件差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff --cached</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看已经暂存起来的变化（--staged和--cached是同义词）</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff HEAD -- file</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看工作区和版本库里面最新版本的区别</span></span><br></pre></td></tr></table></figure><p><strong>撤销操作 checkout</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -- &lt;file&gt;</span></span><br></pre></td></tr></table></figure><ul><li>撤销上一次修改，回到最近一次git commit或者git add状态，不管是在工作区还是在暂存区<ul><li>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</li><li>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</li><li>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考<a class="link" href="https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192">版本回退<i class="fas fa-external-link-alt"></i></a>一节，不过前提是没有推送到远程库。</li></ul></li></ul><p><strong>删除文件 rm</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rm file</span></span><br></pre></td></tr></table></figure><ul><li>通过rm删除了文件之后，status会告诉删除信息，因为删除也算是修改操作（deleted： file）</li><li>在本地目录中删除文件之后可以选择彻底删除或者使用git恢复<ol><li>彻底删除：<code>$ git rm file</code>— 在暂存区中删除，<code>$ git commit</code> — 确定要在版本库中删除<ul><li>(如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失<strong>最近一次提交后你修改的内容</strong>。)</li></ul></li><li>恢复：<code>$ git checkout --file</code><ul><li>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</li></ul></li></ol></li></ul><p><strong>改名操作 mv</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git mv old new</span></span><br><span class="line">---- 相当于 ----</span><br><span class="line"><span class="meta">$</span><span class="bash"> mv old new</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm old</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add new</span></span><br></pre></td></tr></table></figure><p><strong>忽略文件</strong></p><p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。在这种情况下，我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件的模式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat .gitignore</span></span><br><span class="line">*～      # 忽略所有名字以～结尾的文件（通常是副本文件）</span><br><span class="line">*.[oa]   # 忽略以.o .a 结尾的文件</span><br><span class="line">!lib.a.  # 忽略.a文件，但跟踪所有 lib.a 文件</span><br><span class="line">/TODO    # 只忽略当前目录下的 TODO 文件</span><br><span class="line">build/   # 忽略任何目录下名为 build 的文件夹</span><br><span class="line">doc/*.txt    #忽略doc下的txt，但不忽略doc/server/a.txt</span><br><span class="line">doc/**/*.pdf #忽略doc及其子目录下的所有pdf文件</span><br></pre></td></tr></table></figure><p>格式规范：</p><ul><li>所有空行或者以 # 开头的行都会被 Git 忽略。</li><li>可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。</li><li>匹配模式可以以（/）开头防止递归。</li><li>匹配模式可以以（/）结尾指定目录。</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上叹号（!）取反。</li></ul><h3 id="远程仓库（github）"><a href="#远程仓库（github）" class="headerlink" title="远程仓库（github）"></a>远程仓库（github）</h3><ol><li><strong>创建电脑用户自己的密钥</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen -t rsa -C <span class="string">&quot;youremail@example.com&quot;</span></span></span><br><span class="line"> * -t 指定密钥类型，默认是 rsa ，可以省略。</span><br><span class="line"> * -C 设置注释文字，比如邮箱。</span><br><span class="line"> * -f 指定密钥文件存储文件名.</span><br></pre></td></tr></table></figure><ul><li>在用户主目录<code>/home/username</code>下创建密钥</li><li>生成<code>id_rsa</code>和<code>id_rsa.pub</code></li></ul><ol start="2"><li><strong>绑定电脑用户和github用户</strong></li></ol><ul><li>将公钥<code>id_rsa.pub</code>加载到github网站上<code>Add SSH Key</code></li></ul><ol start="3"><li><strong>添加远程仓库</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote add origin git@github-link</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote -v</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote show &lt;remote&gt;    <span class="comment"># 查看摸一个远程仓库的更多信息</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote rename old new   <span class="comment"># 给远程仓库改名</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote remove name      <span class="comment"># 删除远程仓库，及所有跟踪分支和配置信息</span></span></span><br></pre></td></tr></table></figure><ul><li>链接本地仓库和github上创建的远程仓库</li><li><code>origin</code>为远程仓库的默认名字，可自行更改</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push -u origin mymaster:master</span></span><br></pre></td></tr></table></figure><ul><li>将本地仓库的内容推送到远程仓库上，实际上是把当前分支master推送到远程</li><li><code>-u</code>：如果当前分支与多个主机存在追踪关系，则可以使用 -u 参数指定一个默认主机，这样后面就可以不加任何参数使用<code>git push</code><ul><li>不指定<code>mymaster</code>：将会删除远程的<code>master</code>分支，这相当于是push了一个空分支到<code>master</code></li><li>不指定<code>:master</code>：默认推送到与<code>mymaster</code>有追踪关系的分支，一般为同名分支，没有的话会在远程建一个（<code>git remote show &lt;origin&gt;</code>查看各个分支的追踪关系）</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull origin master:mymaster</span></span><br></pre></td></tr></table></figure><ul><li>提交远程之前，最好先将远程仓库的文件拉取下来，再<code>push</code>，以免造成冲突</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git fetch &lt;remote&gt; &lt;remote branchname&gt;:&lt;your branchname&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 不指定远程分支将会默认为‘default’分支（一般为master）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 不给本地分支命名的话，会自动默认指针 FETCH_HEAD</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者使用远程分支名 origin/master 指定fetch的分支</span></span><br></pre></td></tr></table></figure><ul><li>他与pull一样，就拉取远程仓库中有但你没有的文件（不要拉取到当前所在分支）</li><li>不同的是，fetch并不会自动合并或修改你当前的工作，更安全。 当准备好时你必须手动将其合并入你的工作。</li><li><strong>pull = fetch + merge (FETCH_HEAD)</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git fetch origin</span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge origin/<span class="string">&#x27;default&#x27;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 拉取远程默认分支到本地当前分支上，再与远程的默认分支合并</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git fetch origin master:mymaster-tmp</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge mymaster-tmp</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 建议建一个专用存放fetch的分支tmp，拉去下来文件后，再与myaster来merge</span></span><br></pre></td></tr></table></figure><p><strong><code>FETCH_HEAD</code></strong></p><ul><li>某个branch在服务器上的最新状态.</li><li>每一个执行过fetch操作的项目都会存在一个FETCH_HEAD列表,这个列表保存在 <code>.git/FETCH_HEAD</code> 文件中, 其中每一行对应于远程服务器的一个分支.当前分支指向的FETCH_HEAD, 就是这个文件第一行对应的那个分支</li><li>一般来说, 存在两种情况:<ul><li>如果没有显式的指定<code>远程分支</code>, 则远程分支的<code>master</code>将作为默认的<code>FETCH_HEAD</code>.</li><li>如果指定了<code>远程分支</code>, 就将这个远程分支作为<code>FETCH_HEAD</code>.</li></ul></li></ul><p><strong><code>–rebase</code></strong></p><ul><li>作用是取消掉本地库中刚刚的commit，并把他们接到更新后的版本库之中。</li></ul><ol start="4"><li><strong>克隆远程仓库</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> git@github-link</span></span><br></pre></td></tr></table></figure><ul><li>如果远程仓库已有文件，可以将其克隆到本地的空仓库中</li></ul><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p><code>master</code>：主分支</p><p><code>HEAD</code>：指向当前分支，即指向<code>master</code></p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul><li><strong>新建<code>dev</code>分支</strong>：现在修改东西就是<code>dev</code>指针移动了，而<code>HEAD</code>指向当前的<code>dev</code>分支<ul><li>此时修改<code>dev</code>分支，<code>master</code>分支将不会改变</li></ul></li></ul><p><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/3DEC42CC-E46F-4939-ACAA-33BD4B3F88B2.png" alt="3DEC42CC-E46F-4939-ACAA-33BD4B3F88B2" style="zoom:67%;"><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/截屏2020-12-07 下午4.12.29.png" alt="截屏2020-12-07 下午4.12.29" style="zoom: 33%;"></p><ul><li><strong>合并分支</strong>：改改指针的问题                                          <ul><li>将<code>dev</code>分支合并到<code>master</code>上，右图为不使用<code>Fast-Forward</code>快进模式时（–no-ff）</li></ul></li></ul><p><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/69B01EAC-0670-4DED-85A9-A41465FCBF3C.png" alt="69B01EAC-0670-4DED-85A9-A41465FCBF3C" style="zoom: 67%;"><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/B0212A11-D318-457F-9943-E5FCD27820B4.png" alt="B0212A11-D318-457F-9943-E5FCD27820B4" style="zoom: 67%;"></p><ul><li><strong>删除分支</strong>：将dev指针给删掉就行了</li></ul><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/9CA8FECF-51AB-438D-86D7-59846BF675C9.png" alt="9CA8FECF-51AB-438D-86D7-59846BF675C9" style="zoom:80%;"><h4 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h4><ul><li>创建分支：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout (-b) dev</span></span><br><span class="line"> * -b 创建并切换分支</span><br><span class="line">-------------------------</span><br><span class="line"><span class="meta">$</span><span class="bash"> git switch (-c) dev</span></span><br><span class="line"> * -c 创建并切换分支</span><br></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch dev     //创建分支(会创建一个和当前分支有一样内容的分支)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout/switch dev   //切换分支</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br><span class="line">* dev</span><br><span class="line">  master</span><br></pre></td></tr></table></figure><ul><li>查看当前分支，当前分支上会加上<code>*</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -d dev</span></span><br></pre></td></tr></table></figure><ul><li>删除分支dev</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br><span class="line"> * -vv 将所有的本地分支列出来并且包含更多的信息</span><br><span class="line"> * -r 查看远程所有分支</span><br><span class="line"> * -a 查看本地和远程的所有分支</span><br><span class="line"> * &lt;branchname&gt; 新建分支</span><br><span class="line"> * -d -r &lt;branchname&gt; 删除远程分支，删除后还需要推送到服务器</span><br><span class="line"> * -m old new 重命名分支</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch --set-upstream-to origin/branchname</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch --set-upstream-to=origin/branchname  branchname</span></span><br></pre></td></tr></table></figure><ul><li>修改<code>pull</code>时的远程分支关联<ul><li>upstream：将当前分支推送到其上游分支（ tracking &gt;是不推荐的同义词对于上游）</li><li>current：将当前分支推送到同名分支</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git merge dev</span>   </span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge --no-ff -m <span class="string">&quot;merge with no-ff” dev</span></span> </span><br></pre></td></tr></table></figure><ul><li>合并分支到当前分支（如：将<code>dev</code>上的工作结果合并到<code>master</code>上）</li><li>注：两个分支分别都修改了文件的冲突情况下，需要进行手动更改冲突<ul><li>一般合并分支会在<code>Fast Forward</code>模式，但此模式下删除分支，会丢失掉分支信息；</li><li>如果要强制禁用<code>Fast Forward</code>模式，Git就会在<code>merge</code>时生成一个新的<code>commit</code>，这样，从分支历史上就可以看出分支信息。</li><li><code>--no-ff</code>方式的git merge：看的出原来发生过合并，而merge看不出</li></ul></li></ul><ul><li><strong>分支策略</strong>：<ul><li>master：最稳定的，用来发布版本；</li><li>dev：不稳定，所有人将自己的修改合并到这个分支上</li></ul></li></ul><p><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/FD4949A7-CB58-4BD1-B887-3A833E23A7DD.png" alt="FD4949A7-CB58-4BD1-B887-3A833E23A7DD"></p><p>修改bug：创建新的分支进行修改，修改后合并到dev上，但是因为commit是一次提交所有的暂存区，所以需要将现在在写的，不需要提交的先用stash指令存储起来</p><p>git stash：将当前工作现场存储起来，等以后恢复现场工作后继续使用，此时git status非常的干净</p><p>查看：git stash list</p><p>恢复：git stash apply  -  恢复后不删除stash中的内容，需要用 git stash drop 来删除</p><p>​      git stash pop  -  恢复的同时删除</p><p>​       git stash apply stash@{0}：恢复指令的stash</p><p>feature分支</p><p>每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分</p><p>强行删除未合并的分支：git branch -D <file></file></p><h3 id="标签设置"><a href="#标签设置" class="headerlink" title="标签设置"></a>标签设置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出标签</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag -l <span class="string">&quot;v1.8.5&quot;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -l/-list 指定需要某些标签，如上只输出 v1.8.5 系列的</span></span><br></pre></td></tr></table></figure><h4 id="标签类型"><a href="#标签类型" class="headerlink" title="标签类型"></a><strong>标签类型</strong></h4><ol><li><strong>轻量标签（lightweight）</strong>：像一个不会改变的分支，它只是某个提交的引用</li><li><strong>附注标签（annotated）</strong>：是存储在git数据库的一个完整对象，它可以被校验，其中包含打标签者的名字、电子邮件、地址、日期时间，此外还有一个标签信息，并且可以使用GNU Privacy Guard（GPG）签名并验证</li></ol><h4 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a><strong>创建标签</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag -a v1.4 -m <span class="string">&quot;指定一条标签信息&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 轻量只用指定标签名字</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag v1.4</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 给历史版本打标签</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag -a v1.4 commitId</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git show v1.4</span></span><br></pre></td></tr></table></figure><ul><li>查看标签信息和与之对应的提交信息，如果是轻量标签则只会有提交信息</li></ul><h4 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a><strong>删除标签</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag -d v1.4</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin :refs/tags/v1.4</span></span><br></pre></td></tr></table></figure><ul><li>本地删除标签后并不会在远程仓库移除，需要执行第二条指令</li><li>将冒号前面的空值推送到远程标签名，从而高效地删除它</li><li>或者使用下面的方式更直观的删除</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin --delete &lt;tagname&gt;</span></span><br></pre></td></tr></table></figure><h4 id="共享标签"><a href="#共享标签" class="headerlink" title="共享标签"></a><strong>共享标签</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin v1.4</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin --tags</span></span><br></pre></td></tr></table></figure><ul><li><p>在创建完标签后你必须显式地推送标签到共享服务器上</p></li><li><p>–tags：这将会把所有不在远程仓库服务器上的标签全部传送到那里</p></li></ul><h4 id="检出标签"><a href="#检出标签" class="headerlink" title="检出标签"></a><strong>检出标签</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout 2.0.0</span></span><br></pre></td></tr></table></figure><ul><li>查看某个标签所指向的文件版本，但这会是你的仓库处于“分离头指针（detached HEAD）”的状态<ul><li>此状态如果你做了某些更改然后提交它们，标签不会发生变化， 但你的新提交将不属于任何分支，并且将无法访问，除非通过确切的提交哈希才能访问。 因此，如果你需要进行更改，比如你要修复旧版本中的错误，那么通常需要创建一个新分支<code>$ git checkout -b version2 v2.0.0</code></li></ul></li></ul><h3 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h3><h1 id="SVM"><a href="#SVM" class="headerlink" title="SVM"></a>SVM</h1><p>阿斯顿</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;h3 id=&quot;发展历史&quot;&gt;&lt;a href=&quot;#发展历史&quot; class=&quot;headerlink&quot; title=&quot;发展历史&quot;&gt;&lt;/a&gt;发展历史&lt;/h</summary>
      
    
    
    
    <category term="notebook" scheme="https://jieyang-wei.github.io/categories/notebook/"/>
    
    
    <category term="linux" scheme="https://jieyang-wei.github.io/tags/linux/"/>
    
    <category term="git" scheme="https://jieyang-wei.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://jieyang-wei.github.io/2020/12/12/hello-world/"/>
    <id>https://jieyang-wei.github.io/2020/12/12/hello-world/</id>
    <published>2020-12-12T08:51:34.056Z</published>
    <updated>2020-12-14T10:13:12.832Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a class="link" href="https://hexo.io/">Hexo<i class="fas fa-external-link-alt"></i></a>! This is your very first post. Check <a class="link" href="https://hexo.io/docs/">documentation<i class="fas fa-external-link-alt"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link" href="https://hexo.io/docs/troubleshooting.html">troubleshooting<i class="fas fa-external-link-alt"></i></a> or you can ask me on <a class="link" href="https://github.com/hexojs/hexo/issues">GitHub<i class="fas fa-external-link-alt"></i></a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a class="link" href="https://hexo.io/docs/writing.html">Writing<i class="fas fa-external-link-alt"></i></a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a class="link" href="https://hexo.io/docs/server.html">Server<i class="fas fa-external-link-alt"></i></a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a class="link" href="https://hexo.io/docs/generating.html">Generating<i class="fas fa-external-link-alt"></i></a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a class="link" href="https://hexo.io/docs/one-command-deployment.html">Deployment<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a class=&quot;link&quot; href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;i class=&quot;fas fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/a&gt;! This is your very first post. Check </summary>
      
    
    
    
    <category term="course" scheme="https://jieyang-wei.github.io/categories/course/"/>
    
    
    <category term="hello-world" scheme="https://jieyang-wei.github.io/tags/hello-world/"/>
    
  </entry>
  
</feed>
