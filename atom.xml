<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WeiJY&#39;s blog</title>
  
  
  <link href="https://jieyang-wei.github.io/atom.xml" rel="self"/>
  
  <link href="https://jieyang-wei.github.io/"/>
  <updated>2020-12-15T08:31:27.453Z</updated>
  <id>https://jieyang-wei.github.io/</id>
  
  <author>
    <name>Wei Jieyang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python</title>
    <link href="https://jieyang-wei.github.io/2020/12/15/python/"/>
    <id>https://jieyang-wei.github.io/2020/12/15/python/</id>
    <published>2020-12-15T06:32:10.000Z</published>
    <updated>2020-12-15T08:31:27.453Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a>Anaconda</h1><ul><li><a class="link" href="https://www.jianshu.com/p/62f155eb6ac5">Anaconda部分原博客<i class="fas fa-external-link-alt"></i></a></li><li>Anaconda（<a class="link" href="https://link.jianshu.com/?t=https://www.anaconda.com/download/%23macos">官方网站<i class="fas fa-external-link-alt"></i></a>）就是可以便捷获取包且对包能够进行管理，同时对环境可以统一管理的发行版本。</li><li>Anaconda包含了conda、Python在内的超过180个科学包及其依赖项。</li><li>其特点的实现是因为包含：<ul><li> conda包</li><li>环境管理器</li><li>1000+开源库</li></ul></li></ul><p>特点：</p><ul><li>开源</li><li>安装过程简单</li><li>高性能使用python和R语言</li><li>免费的社区支持</li></ul><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><h3 id="1-Anaconda"><a href="#1-Anaconda" class="headerlink" title="1. Anaconda"></a>1. Anaconda</h3><ul><li>Anaconda是一个包含180+的科学包及其依赖项的发行版本。</li><li>其包含的科学包包括：<ul><li>conda, numpy, scipy, ipython notebook等。</li></ul></li></ul><h3 id="2-conda"><a href="#2-conda" class="headerlink" title="2. conda"></a>2. conda</h3><ul><li><p>conda是包及其依赖项和环境的管理工具。</p></li><li><p>适用语言：</p><ul><li>Python, R, Ruby, Lua, Scala, Java, JavaScript, C/C++, FORTRAN。</li></ul></li><li><p>适用平台：</p><ul><li>Windows, macOS, Linux</li></ul></li></ul><p><strong>用途</strong>：</p><ol><li>快速安装、运行和升级包及其依赖项。</li><li>在计算机中便捷地创建、保存、加载和切换环境。</li></ol><blockquote><p>如果你需要的包要求不同版本的Python，你无需切换到不同的环境，因为conda同样是一个环境管理器。仅需要几条命令，你可以创建一个完全独立的环境来运行不同的Python版本，同时继续在你常规的环境中使用你常用的Python版本。——<a class="link" href="https://link.jianshu.com/?t=https://conda.io/docs/">conda官方网站<i class="fas fa-external-link-alt"></i></a></p></blockquote><ul><li>onda为Python项目而创造，但可适用于上述的多种语言。</li><li>conda包和环境管理器包含于Anaconda的所有版本当中。</li></ul><h3 id="3-pip"><a href="#3-pip" class="headerlink" title="3. pip"></a>3. pip</h3><ul><li><p>pip是用于安装和管理软件包的包管理器。</p></li><li><p>pip编写语言：Python。</p></li><li><p>Python中默认安装的版本：</p><ul><li>Python 2.7.9及后续版本：默认安装，命令为<code>pip</code></li><li>Python 3.4及后续版本：默认安装，命令为<code>pip3</code></li></ul></li><li><p>pip名称的由来：pip采用的是<strong>递归缩写</strong>进行命名的。其名字被普遍认为来源于2处：</p><ul><li>“Pip installs Packages”（“pip安装包”）</li><li>“Pip installs Python”（“pip安装Python”）</li></ul></li></ul><h3 id="4-virtualenv"><a href="#4-virtualenv" class="headerlink" title="4.virtualenv"></a>4.virtualenv</h3><ul><li><p>virtualenv：用于创建一个<strong>独立的</strong>Python环境的工具。</p></li><li><p>解决问题：</p><ol><li>当一个程序需要使用Python 2.7版本，而另一个程序需要使用Python 3.6版本，如何同时使用这两个程序？</li><li>如果将所有程序都安装在系统下的默认路径，如：<code>/usr/lib/python2.7/site-packages</code>，当不小心升级了本不该升级的程序时，将会对其他的程序造成影响。</li><li>如果想要安装程序并在程序运行时对其库或库的版本进行修改，都会导致程序的中断。</li><li>在共享主机时，无法在全局<code>site-packages</code>目录中安装包。</li></ol></li><li><p>virtualenv将会为它自己的安装目录创建一个环境，这并<strong>不与</strong>其他virtualenv环境共享库；同时也可以<strong>选择性</strong>地不连接已安装的全局库。</p></li></ul><hr><p><strong>pip与conda比较</strong>：</p><ol><li><p><strong>依赖项检查</strong></p><ul><li>pip：<ul><li><strong>不一定</strong>会展示所需其他依赖包。</li><li>安装包时<strong>或许</strong>会直接忽略依赖项而安装，仅在结果中提示错误。</li></ul></li><li>conda：<ul><li>列出所需其他依赖包。</li><li>安装包时自动安装其依赖项。</li><li>可以便捷地在包的不同版本中自由切换。</li></ul></li></ul></li><li><p><strong>环境管理</strong></p><ul><li>pip：维护多个环境难度较大。</li><li>conda：比较方便地在不同环境之间进行切换，环境管理较为简单。</li></ul></li><li><p><strong>对系统自带Python的影响</strong></p><ul><li>pip：在系统自带Python中包的**更新/回退版本/卸载将影响其他程序。</li><li>conda：不会影响系统自带Python。</li></ul></li><li><p><strong>适用语言</strong></p><ul><li>pip：仅适用于Python。</li><li>conda：适用于Python, R, Ruby, Lua, Scala, Java, JavaScript, C/C++, FORTRAN。</li></ul></li></ol><p> <strong>conda与pip、virtualenv的关系</strong></p><ul><li>conda<strong>结合</strong>了pip和virtualenv的功能。</li></ul><hr><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>查看是否安装了python和anaconda：</p><p><img src="/2020/12/15/python/DF8274195F82F3A1713FE9FAB66C46B5.png" alt="DF8274195F82F3A1713FE9FAB66C46B5"></p><ol><li><p><code>$ conda list</code>：如果Anaconda被成功安装，则会显示已经安装的包名和版本号。</p></li><li><p><code>$ python</code>：进入python终端的命令行</p><ul><li>如果同时安装了Anaconda，则会显示上图红色的部分</li><li>exit() / quit()：退出</li></ul></li><li><p>终端输入<code>$ anaconda-navigator</code>将会打开anaconda-navigator图形界面</p></li></ol><p><strong>安装教程</strong>：自行百度，或者<a class="link" href="https://www.jianshu.com/p/62f155eb6ac5">原博客<i class="fas fa-external-link-alt"></i></a>有</p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="管理conda和环境"><a href="#管理conda和环境" class="headerlink" title="管理conda和环境"></a>管理conda和环境</h3><ul><li>验证conda已被安装</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda list              <span class="comment"># 显示已经安装的包名和版本号</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> conda --version         <span class="comment"># 查看conda版本号码</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> conda update conda      <span class="comment"># 更新conda至最新版本</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> conda --<span class="built_in">help</span>            <span class="comment"># 查看帮助信息</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rm -rf anaconda安装路径   <span class="comment"># 删除只需要删除安装目录即可（mac os）</span></span> </span><br></pre></td></tr></table></figure><p><strong>创建新环境</strong> </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda create --name &lt;env_name&gt; &lt;package_names&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;env_name&gt;</code>：即创建的环境名。建议以英文命名，且不加空格，名称两边不加尖括号“&lt;&gt;”。</li><li><code>&lt;package_names&gt;</code>：即安装在环境中的包名。名称两边不加尖括号“&lt;&gt;”。<ol><li>如果要安装指定的版本号，则只需要在包名后面以<code>=</code>和版本号的形式执行。如：<code>conda create --name python2 python=2.7</code>，即创建一个名为“python2”的环境，环境中安装版本为2.7的python。</li><li>如果要在新创建的环境中创建多个包，则直接在<code>&lt;package_names&gt;</code>后以<strong>空格</strong>隔开，添加多个包名即可。如：<code>conda create -n python3 python=3.5 numpy pandas</code>，即创建一个名为“python3”的环境，环境中安装版本为3.5的python，同时也安装了numpy和pandas。</li></ol></li><li>默认情况下，新创建的环境将会被保存在<code>/Users/&lt;user_name&gt;/anaconda3/env</code>目录下，其中，<code>&lt;user_name&gt;</code>为当前用户的用户名。</li></ul><p><strong>切换环境</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Linux 或macOS</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> activate &lt;env_name&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Windows</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> activate &lt;env_name&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>如果创建环境后安装Python时没有指定Python的版本，那么将会安装与Anaconda版本相同的Python版本，即如果安装Anaconda第2版，则会自动安装Python 2.x；如果安装Anaconda第3版，则会自动安装Python 3.x。</p></li><li><p>当成功切换环境之后，在该行行首将以“(env_name)”或“[env_name]”开头。其中，“env_name”为切换到的环境名。如：在macOS系统中执行<code>source active python2</code>，即切换至名为“python2”的环境，则行首将会以(python2)开头。</p></li></ul><p><strong>退出环境至root</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Linux 或macOS</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> deactivate</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Windows</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> deactivate</span></span><br></pre></td></tr></table></figure><ul><li>当执行退出当前环境，回到root环境命令后，原本行首以 “(env_name)” 或 “[env_name]” 开头的字符将不再显示。</li></ul><p><strong>显示已创建的环境</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda info -envs</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> conda info -e</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> conda env list</span></span><br></pre></td></tr></table></figure><p><img src="/2020/12/15/python/6349AECA-85FB-4EBA-82CE-CCBE8F84A59B.png" alt="6349AECA-85FB-4EBA-82CE-CCBE8F84A59B"></p><ul><li>结果中星号<code>*</code>所在行即为当前所在环境。macOS系统中默认创建的环境名为<code>base</code>。</li></ul><p><strong>复制环境</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda create --name &lt;new_env_name&gt; --<span class="built_in">clone</span> &lt;copied_env_name&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;copied_env_name&gt;</code>即为被复制/克隆环境名。环境名两边不加尖括号“&lt;&gt;”</li><li><code>&lt;new_env_name&gt;</code>即为复制之后新环境的名称。环境名两边不加尖括号“&lt;&gt;”。<ul><li>如：<code>$ conda create --name py2 --clone python2</code>，即为克隆名为“python2”的环境，克隆后的新环境名为“py2”。此时，环境中将同时存在“python2”和“py2”环境，且两个环境的配置相同。</li></ul></li></ul><p><strong>删除环境</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda remove --name &lt;env_name&gt; --all</span></span><br></pre></td></tr></table></figure><p><strong>复制环境</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda create --name &lt;new_env_name&gt; --<span class="built_in">clone</span> &lt;copied_env_name&gt;</span></span><br></pre></td></tr></table></figure><h3 id="管理包"><a href="#管理包" class="headerlink" title="管理包"></a>管理包</h3><h4 id="1-查找可供安装的包版本"><a href="#1-查找可供安装的包版本" class="headerlink" title="1. 查找可供安装的包版本"></a>1. 查找可供安装的包版本</h4><ol><li>精确查找</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ conda search --full-name &lt;package_full_name&gt;</span><br></pre></td></tr></table></figure><ul><li><code>--full-name</code>：精确查找的参数。</li><li><code>&lt;package_full_name&gt;</code>：是被查找包的<strong>全名</strong>。包名两边不加尖括号“&lt;&gt;”。<ul><li>例如：<code>conda search --full-name python</code>即查找全名为“python”的包有哪些版本可供安装。</li></ul></li></ul><ol start="2"><li>模糊查找</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda search &lt;text&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;text&gt;</code>：查找含有<strong>此字段</strong>的包名。此字段两边不加尖括号“&lt;&gt;”。<ul><li>例如：<code>conda search py</code>即查找含有“py”字段的包，有哪些版本可供安装。</li></ul></li></ul><h4 id="2-获取当前环境中已安装的包信息"><a href="#2-获取当前环境中已安装的包信息" class="headerlink" title="2. 获取当前环境中已安装的包信息"></a>2. 获取当前环境中已安装的包信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda list</span></span><br></pre></td></tr></table></figure><ul><li>执行上述命令后将在终端显示当前环境已安装包的包名及其版本号。</li></ul><h4 id="3-安装包"><a href="#3-安装包" class="headerlink" title="3. 安装包"></a>3. 安装包</h4><ol><li><strong>在指定环境中安装包</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda install --name &lt;env_name&gt; &lt;package_name&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;env_name&gt;</code>：将包安装的指定环境名。环境名两边不加尖括号“&lt;&gt;”。</li><li><code>&lt;package_name&gt;</code>：要安装的包名。包名两边不加尖括号“&lt;&gt;”。<ul><li>例如：<code>conda install --name python2 pandas</code>即在名为“python2”的环境中安装pandas包。</li></ul></li></ul><ol start="2"><li><strong>在当前环境中安装包</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda install &lt;package_name&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;package_name&gt;</code>：要安装的包名。包名两边不加尖括号“&lt;&gt;”。</li><li>执行命令后在当前环境中安装包。<ul><li>例如：<code>conda install pandas</code>即在当前环境中安装pandas包。</li></ul></li></ul><ol start="3"><li><strong>使用pip安装包</strong></li></ol><p><strong>使用场景</strong>：</p><ul><li>当使用<code>conda install</code>无法进行安装时，可以使用pip进行安装。例如：see包。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> pip install &lt;package_name&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;pacage_name&gt;</code>：指定安装包的名称。包名两边不加尖括号“&lt;&gt;”。<ul><li>如：<code>pip install see</code>即安装see包。</li></ul></li></ul><p><strong>注意：</strong></p><ul><li>pip只是包管理器，无法对环境进行管理。因此如果想在指定环境中使用pip进行安装包，则需要先切换到指定环境中，再使用pip命令安装包。</li><li>pip无法更新python，因为pip并不将python视为包。</li><li>pip可以安装一些conda无法安装的包；conda也可以安装一些pip无法安装的包。因此当使用一种命令无法安装包时，可以尝试用另一种命令。</li></ul><ol start="4"><li><strong>从Anaconda.org安装包</strong></li></ol><p><strong>使用场景</strong></p><ul><li>当使用<code>conda install</code>无法进行安装时，可以考虑从Anaconda.org中获取安装包的命令，并进行安装。</li></ul><p><strong>注意</strong></p><ol><li>从Anaconda.org安装包时，无需注册。</li><li>在<strong>当前环境</strong>中安装来自于Anaconda.org的包时，需要通过输入要安装的包在Anaconda.org中的路径作为获取途径（channel）</li></ol><h4 id="4-卸载包"><a href="#4-卸载包" class="headerlink" title="4. 卸载包"></a>4. 卸载包</h4><ol><li>卸载指定环境中的包</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda remove --name &lt;env_name&gt; &lt;package_name&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;env_name&gt;</code>：卸载包所在指定环境的名称。环境名两边不加尖括号“&lt;&gt;”</li><li><code>&lt;package_name&gt;</code>：要卸载包的名称。包名两边不加尖括号“&lt;&gt;”。<ul><li>例如：<code>conda remove --name python2 pandas</code>即卸载名为“python2”中的pandas包。</li></ul></li></ul><ol start="2"><li>卸载当前环境中的包</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda remove &lt;package_name&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;package_name&gt;</code>：要卸载包的名称。包名两边不加尖括号“&lt;&gt;”。</li><li>执行命令后即在当前环境中卸载指定包。<ul><li>例如：<code>conda remove pandas</code>即在当前环境中卸载pandas包。</li></ul></li></ul><h4 id="5-更新包"><a href="#5-更新包" class="headerlink" title="5. 更新包"></a>5. 更新包</h4><ol><li>更新所有包</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda update --all</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> conda upgrade --all</span></span><br></pre></td></tr></table></figure><ul><li>建议：在安装Anaconda之后执行上述命令更新Anaconda中的所有包至最新版本，便于使用。</li></ul><ol start="2"><li>更新指定包</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda update &lt;package_name&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> conda upgrade &lt;package_name&gt;</span></span><br></pre></td></tr></table></figure><ul><li>注意：<ol><li><code>&lt;package_name&gt;</code>为指定更新的包名。包名两边不加尖括号“&lt;&gt;”。</li><li>更新多个指定包，则包名以<strong>空格</strong>隔开，向后排列。如：<code>conda update pandas numpy matplotlib</code>即更新pandas、numpy、matplotlib包。</li></ol></li></ul><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><p><a class="link" href="https://www.runoob.com/python/python-tutorial.html">菜鸟教程<i class="fas fa-external-link-alt"></i></a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>Python 是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言</li><li>Python 的设计具有很强的可读性，相比其他语言经常使用英文关键字，其他语言的一些标点符号，它具有比其他语言更有特色语法结构。<ul><li><strong>Python 是一种解释型语言：</strong>这意味着开发过程中没有了编译这个环节。类似于PHP和Perl语言。</li><li><strong>Python 是交互式语言：</strong>这意味着，您可以在一个 Python 提示符 <strong>&gt;&gt;&gt;</strong> 后直接执行代码。</li><li><strong>Python 是面向对象语言：</strong> 这意味着Python支持面向对象的风格或代码封装在对象的编程技术。</li><li><strong>Python 是初学者的语言：</strong>Python 对初级程序员而言，是一种伟大的语言，它支持广泛的应用程序开发，从简单的文字处理到 WWW 浏览器再到游戏。</li></ul></li></ul><p>特点：</p><ol><li><strong>易于学习：</strong>Python有相对较少的关键字，结构简单，和一个明确定义的语法，学习起来更加简单。</li><li><strong>易于阅读：</strong>Python代码定义的更清晰。</li><li><strong>易于维护：</strong>Python的成功在于它的源代码是相当容易维护的。</li><li><strong>一个广泛的标准库：</strong>Python的最大的优势之一是丰富的库，跨平台的，在UNIX，Windows和Macintosh兼容很好。</li><li><strong>互动模式：</strong>互动模式的支持，您可以从终端输入执行代码并获得结果的语言，互动的测试和调试代码片断。</li><li><strong>可移植：</strong>基于其开放源代码的特性，Python已经被移植（也就是使其工作）到许多平台。</li><li><strong>可扩展：</strong>如果你需要一段运行很快的关键代码，或者是想要编写一些不愿开放的算法，你可以使用C或C++完成那部分程序，然后从你的Python程序中调用。</li><li><strong>数据库：</strong>Python提供所有主要的商业数据库的接口。</li><li><strong>GUI编程：</strong>Python支持GUI可以创建和移植到许多系统调用。</li><li><strong>可嵌入：</strong>你可以将Python嵌入到C/C++程序，让你的程序的用户获得”脚本化”的能力。</li></ol><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><p>安装过程：自行百度云</p><p><strong>环境变量</strong></p><table><thead><tr><th>PYTHONPATH</th><th>PYTHONPATH是Python搜索路径，默认我们import的模块都会从PYTHONPATH里面寻找。</th></tr></thead><tbody><tr><td>PYTHONSTARTUP</td><td>Python启动后，先寻找PYTHONSTARTUP环境变量，然后执行此变量指定的文件中的代码。</td></tr><tr><td>PYTHONCASEOK</td><td>加入PYTHONCASEOK的环境变量, 就会使python导入模块的时候不区分大小写.</td></tr><tr><td>PYTHONHOME</td><td>另一种模块搜索路径。它通常内嵌于的PYTHONSTARTUP或PYTHONPATH目录中，使得两个模块库更容易切换。</td></tr></tbody></table><p><strong>集成开发环境（IDE, Integrated Development Environment）</strong>：PyCharm</p><ul><li>PyCharm 是由 JetBrains 打造的一款 Python IDE，支持 macOS、 Windows、 Linux 系统。</li><li>功能 : <ul><li>调试、语法高亮、Project管理、代码跳转、智能提示、自动完成、单元测试、版本控制……</li></ul></li><li><a class="link" href="https://www.jetbrains.com/pycharm/download/">下载地址<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" href="http://www.runoob.com/w3cnote/pycharm-windows-install.html](https://www.runoob.com/w3cnote/pycharm-windows-install.html)">安装地址<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="基础教程"><a href="#基础教程" class="headerlink" title="基础教程"></a>基础教程</h2><p><strong>中文编码</strong></p><img src="/2020/12/15/python/截屏2020-12-15 下午4.13.19.png" alt="截屏2020-12-15 下午4.13.19" style="zoom:60%;"><ul><li>python3.x源文件默认支持中文编码，无需制定</li><li>如果你使用编辑器，同时需要设置 py 文件存储的格式为 UTF-8，否则会出现错误信息<ul><li>进入 <strong>file &gt; Settings</strong>，在输入框搜索 <strong>encoding</strong>。</li><li>找到 <strong>Editor &gt; File encodings</strong>，将 <strong>IDE Encoding</strong> 和 <strong>Project Encoding</strong> 设置为utf-8。</li></ul></li></ul><h4 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> num     <span class="comment"># python2.x</span></span><br><span class="line"><span class="built_in">print</span> (num)   <span class="comment"># python3.x</span></span><br></pre></td></tr></table></figure><p><strong>python2.x中使用python2.x的print函数</strong>：</p><ul><li><code>from __future__ import print_function</code></li><li>可以导入 <code>__future__</code>包，该包禁用 Python2.x 的 print 语句，采用 Python3.x 的 print 函数</li><li>Python3.x 与 Python2.x 的许多兼容性设计的功能可以通过  <code>__future__</code>这个包来导入</li></ul><h5 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h5><ul><li><p>标识符由字母、数字、下划线组成。</p></li><li><p>所有标识符可以包括英文、数字以及下划线(_)，但不能以数字开头。</p></li><li><p>Python 中的标识符是区分大小写的。</p></li><li><p>以<strong>下划线开头</strong>的标识符是有特殊意义的。</p><ul><li>以单下划线开头<code> _foo</code>的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用<code>from xxx import *</code>而导入。</li><li>以双下划线开头的<code>__foo</code>代表类的私有成员，以双下划线开头和结尾的 <code>__foo__</code>代表 Python 里特殊方法专用的标识<ul><li>如<code>__init__()</code>代表类的构造函数。</li></ul></li></ul></li><li><p>Python 可以同一行显示多条语句，方法是用分号 <strong>;</strong> 分开</p><ul><li><code>print (&#39;hello&#39;); print (&#39;world&#39;)</code></li></ul></li></ul><h5 id="保留字符"><a href="#保留字符" class="headerlink" title="保留字符"></a>保留字符</h5><ul><li>不能用作常数或变数，或任何其他标识符名称</li><li>所有 Python 的关键字只包含小写字母</li></ul><table><thead><tr><th>and</th><th>exec</th><th>not</th></tr></thead><tbody><tr><td>assert</td><td>finally</td><td>or</td></tr><tr><td>break</td><td>for</td><td>pass</td></tr><tr><td>class</td><td>from</td><td>print</td></tr><tr><td>continue</td><td>global</td><td>raise</td></tr><tr><td>def</td><td>if</td><td>return</td></tr><tr><td>del</td><td>import</td><td>try</td></tr><tr><td>elif</td><td>in</td><td>while</td></tr><tr><td>else</td><td>is</td><td>with</td></tr><tr><td>except</td><td>lambda</td><td>yield</td></tr></tbody></table><h5 id="行和缩进"><a href="#行和缩进" class="headerlink" title="行和缩进"></a>行和缩进</h5><ul><li>学习 Python 与其他语言最大的区别就是，Python 的代码块不使用大括号 <strong>{}</strong> 来控制类，函数以及其他逻辑判断。python 最具特色的就是用缩进来写模块。</li><li>缩进的空白数量是可变的，但是所有代码块语句必须包含相同的缩进空白数量，这个必须严格执行。<ul><li><img src="/2020/12/15/python/截屏2020-12-15 下午4.27.30.png" alt="截屏2020-12-15 下午4.27.30" style="zoom:50%;"></li></ul></li></ul><p><strong>多行语句：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">total = item_one + \</span><br><span class="line">        item_two + \</span><br><span class="line">        item_three</span><br><span class="line"><span class="comment"># 和</span></span><br><span class="line">days = [<span class="string">&#x27;Monday&#x27;</span>, <span class="string">&#x27;Tuesday&#x27;</span>, <span class="string">&#x27;Wednesday&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Thursday&#x27;</span>, <span class="string">&#x27;Friday&#x27;</span>]</span><br></pre></td></tr></table></figure><p><strong>引号：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">word = <span class="string">&#x27;word&#x27;</span></span><br><span class="line">sentence = <span class="string">&quot;这是一个句子。&quot;</span></span><br><span class="line">paragraph = <span class="string">&quot;&quot;&quot;这是一个段落</span></span><br><span class="line"><span class="string">包含了多个语句&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><ul><li>三引号可以由多行组成，编写多行文本的快捷语法，常用于文档字符串，在文件的特定地点，被当做注释。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Anaconda&quot;&gt;&lt;a href=&quot;#Anaconda&quot; class=&quot;headerlink&quot; title=&quot;Anaconda&quot;&gt;&lt;/a&gt;Anaconda&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;link&quot; href=&quot;https://www.jiansh</summary>
      
    
    
    
    <category term="notebook" scheme="https://jieyang-wei.github.io/categories/notebook/"/>
    
    
    <category term="python" scheme="https://jieyang-wei.github.io/tags/python/"/>
    
    <category term="编程语言" scheme="https://jieyang-wei.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>gdb调试</title>
    <link href="https://jieyang-wei.github.io/2020/12/14/gdb%E8%B0%83%E8%AF%95/"/>
    <id>https://jieyang-wei.github.io/2020/12/14/gdb%E8%B0%83%E8%AF%95/</id>
    <published>2020-12-14T09:56:55.000Z</published>
    <updated>2020-12-15T05:41:25.167Z</updated>
    
    <content type="html"><![CDATA[<p>制作链接库的目的是希望别人使用我们已经实现的功能，但又不希望别人看到我们的源代码<br><code>Linux</code>下的静态链接库是以<code>.a</code>结尾的二进制文件，它作为程序的一个模块，在链接期间被组合到程序中。和静态链接库相对的是动态链接库（.so文件），它在程序运行阶段被加载进内存。</p><p>静态库生成步骤</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1 对所有源文件，只编译不链接</span></span><br><span class="line">gcc -c test.c</span><br><span class="line"><span class="comment">//2 利用ar命令，生成库文件</span></span><br><span class="line">ar rcs libtest.a test.o</span><br></pre></td></tr></table></figure><p><code>ar</code>是 Linux 的一个备份压缩命令，它可以将多个文件打包成一个备份文件（也叫归档文件），也可以从备份文件中提取成员文件，最常见的用法是将目标文件打包为静态链接库。</p><p>对参数的说明：</p><ul><li>r：用来替换库中已有的目标文件，或者加入新的目标文件。</li><li>c：表示创建一个库。不管库否存在，都将创建。</li><li>s：用来创建目标文件索引，这在创建较大的库时能提高速度。</li></ul><p>Linux 下动态链接库（shared object file，共享对象文件）的文件后缀为.so，它是一种特殊的目标文件（object file），可以在程序运行时被加载（链接）进来。</p><p>使用动态链接库的优点是：程序的可执行文件更小，便于程序的模块化以及更新，同时，有效内存的使用效率更高</p><ol><li>如果想创建一个动态链接库，可以使用 GCC 的-shared选项。输入文件可以是源文件、汇编文件或者目标文件。</li><li>另外还得结合<code>-fPIC</code>选项。<code>-fPIC</code>选项作用于编译阶段，告诉编译器产生与位置无关代码（Position-Independent Code）；这样一来，产生的代码中就没有绝对地址了，全部使用相对地址，所以代码可以被加载器加载到内存的任意位置，都可以正确的执行。这正是共享库所要求的，共享库被加载时，在内存的位置不是固定的。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 从源文件生成动态链接库：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -fPIC -shared func.c -o libfunc.so</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从目标文件生成动态链接库：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -fPIC -c func.c -o func.o</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -shared func.o -o libfunc.so</span></span><br><span class="line"> * -fPIC 选项作用于编译阶段，在生成目标文件时就得使用该选项，以生成位置无关的代码。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;制作链接库的目的是希望别人使用我们已经实现的功能，但又不希望别人看到我们的源代码&lt;br&gt;&lt;code&gt;Linux&lt;/code&gt;下的静态链接库是以&lt;code&gt;.a&lt;/code&gt;结尾的二进制文件，它作为程序的一个模块，在链接期间被组合到程序中。和静态链接库相对的是动态链接库（.s</summary>
      
    
    
    
    <category term="course" scheme="https://jieyang-wei.github.io/categories/course/"/>
    
    
    <category term="linux" scheme="https://jieyang-wei.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>区块链</title>
    <link href="https://jieyang-wei.github.io/2020/12/14/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    <id>https://jieyang-wei.github.io/2020/12/14/%E5%8C%BA%E5%9D%97%E9%93%BE/</id>
    <published>2020-12-14T09:47:42.000Z</published>
    <updated>2020-12-15T06:27:25.340Z</updated>
    
    <content type="html"><![CDATA[<h1 id="crypto-currency（加密货币）"><a href="#crypto-currency（加密货币）" class="headerlink" title="crypto-currency（加密货币）"></a>crypto-currency（加密货币）</h1><h1 id="比特币-BTC"><a href="#比特币-BTC" class="headerlink" title="比特币 BTC"></a>比特币 BTC</h1><h2 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h2><h3 id="1-crypto-graphic-hash-function"><a href="#1-crypto-graphic-hash-function" class="headerlink" title="1. crypto graphic hash function"></a>1. crypto graphic hash function</h3><p>特性：</p><ol><li><p>collision resistance：抗碰撞性</p></li><li><p>hiding：x可以算出H(x)，但H(x)不能反推出x，即这个hash函数不会泄露x</p><ul><li><p>需要满足，不然可以通过蛮力求解</p><ol><li><p>输入空间大</p></li><li><p>均匀分布</p></li></ol></li><li><p>digital commitment / digital equivalent of a sealed envelope：密封预测结果</p></li></ul></li><li><p>puzzle friendly：H(x)是事先不可预测的</p></li></ol><p>H(block header) &lt;= target 目标域值（nBits：目标域值编码）</p><p>proof of work POW，工作证明</p><p>difficult to solve, but easy to verify</p><p>SHA-256（Secure Hash Algorithm）</p><h3 id="2-签名"><a href="#2-签名" class="headerlink" title="2. 签名"></a><strong>2. 签名</strong></h3><p>账户 - public key, private key</p><ul><li>来源于非对称加密：asymmetric encryption algorithm</li><li>最早期是对称加密，symmetric encryption algorithm，但这样密钥分发是一个问题，所以有了公私钥</li></ul><p>a good source of randomness：使得生成的公钥相同的几率微乎其微</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="hash-point"><a href="#hash-point" class="headerlink" title="hash point"></a>hash point</h3><ul><li>无环链表都可以用 hash point 代替普通的point</li></ul><p><strong>全节点</strong>：保存所有的信息</p><p><strong>轻节点</strong>：只保存block header（如手机上）</p><ol><li>区块链</li></ol><p><img src="/2020/12/14/%E5%8C%BA%E5%9D%97%E9%93%BE/IMG_0230-7744726.jpg" alt="IMG_0230"></p><ul><li>block chain is a linked list using hash pointers：用hash point 代替普通的指针<ul><li>genesis block：创世区块            most recent blcok：最近产生的区块      H( )：hash point</li><li>tamper-evident log：最后一个hash值就能检查整个链表是否被修改过</li></ul></li></ul><ol start="2"><li>Merkle tree<ul><li>与binary tree的区别<ol><li>用hash point代替普通的指针</li><li>只要记录<code>root hash</code>，就能检测对整棵树的修改</li></ol></li><li>block header：只保存<code>root hash</code>，</li><li>block body：保存所有的交易信息等</li><li>作用：<ul><li>提供<code>merkle proof</code></li></ul></li></ul></li></ol><blockquote><p><img src="/2020/12/14/%E5%8C%BA%E5%9D%97%E9%93%BE/IMG_231E499E57D8-1.jpeg" alt="IMG_231E499E57D8-1"></p><ul><li><strong>proof of membership</strong>：轻节点想知道黄色交易是否在<code>merkle tree</code>上，只有一个<code>root hash</code>(在<code>block header</code>里面)</li></ul><ol><li>轻节点向某个全节点发出证明请求，请求一个能证明黄色交易包括在<code>merkle tree</code>里面的一个<code>merkle proof</code></li><li>全节点收到请求，会将图中红色的三个<code>hash值</code>发送给这个轻节点</li><li><strong>从下往上</strong>：轻节点会算出黄色交易的hash值绿1，绿1和红1一起算出hash值绿2，绿2和红2算出绿3，绿3和红3一起算出<code>root hash</code></li><li>轻节点比较这个算出来的<code>root hash</code>和<code>block header</code>的hash值</li></ol><blockquote><p><strong>注意</strong>：我们只能验证绿色的部分，不能验证红色部分的hash值</p></blockquote><blockquote><ul><li>如果考虑通过调整红色的部分，使得被篡改后的绿色的部分算出来hash不变，是不实际的</li><li>因为<code>Collision resistance</code>性质，这样的操作相当于人为的制造hash碰撞</li></ul></blockquote><ul><li><strong>proof of non-memership</strong>：轻节点想证明某个交易不存在</li></ul><ol><li></li></ol></blockquote><h2 id="数字货币"><a href="#数字货币" class="headerlink" title="数字货币"></a>数字货币</h2><ul><li>使用公私钥，非对成加密算法<ol><li>Double spending attack，双花攻击 - 花两次攻击：数字货币本质上是一个文件，带签名的数字货币可以复制</li></ol></li><li>每个数字货币上带编号（防范DSA，但是是中心化的）<ul><li>bank维护一个数据库，每个编号的数字货币在谁手里</li><li>每次验证数字货币的签名和编号，这个货币有没有发过，被谁花过</li></ul></li></ul><h3 id="BTC解决去中心化的数字货币发行问题"><a href="#BTC解决去中心化的数字货币发行问题" class="headerlink" title="BTC解决去中心化的数字货币发行问题"></a>BTC解决去中心化的数字货币发行问题</h3><ul><li><img src="/2020/12/14/%E5%8C%BA%E5%9D%97%E9%93%BE/IMG_9CCCEC7F3445-1.jpeg" alt="IMG_9CCCEC7F3445-1"><ul><li>交易中A的公钥表明是钱是哪儿来的，但是要将A和他的公钥联系在一起，不然E可以用自己的公钥冒充A的，再用自己的私钥签名<ul><li><strong>coinbase tx</strong>：需要验证A-&gt;B的钱的前一个交易（金币来源）中A的公钥，即金币来源的输出脚本，和交易中提供的A的公钥，即交易的输入脚本拼在一起合成一个程序，看能不能顺利执行</li></ul></li></ul></li></ul><h4 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h4><ul><li><strong>区块结构</strong><ul><li>Block Header<ul><li>version：比特币版本</li><li>hash of previous block header：指向前一个区块的指针（只算header的hash）<ul><li><img src="/2020/12/14/%E5%8C%BA%E5%9D%97%E9%93%BE/IMG_89EB07B3C160-1.jpeg" alt="IMG_89EB07B3C160-1"></li><li>merkle tree的root hash已经保证了<code>transaction list</code>是无法被篡改的</li></ul></li><li>merkle root hash：整棵merkle tree的根hash值</li><li>·target：挖矿难度目标域值</li><li>nonce：随机数</li></ul></li><li>Block Body<ul><li>transaction list</li></ul></li></ul></li><li><strong>节点</strong><ul><li>full node（fully validating node，全节点）：<br>* </li><li>light node（light weight node，轻节点）：<ul><li>一般无法验证交易的合法性，只是利用区块链的信息做一个查询</li></ul></li></ul></li></ul><h4 id="Consensus-in-BitCoin，比特币共识"><a href="#Consensus-in-BitCoin，比特币共识" class="headerlink" title="Consensus in BitCoin，比特币共识"></a>Consensus in BitCoin，比特币共识</h4><p>distributed consensus，分布式共识</p><ul><li>impossibility result：<ul><li>FLP：在一个异步的系统里（asynchronous），网络时延没有上线，哪怕系统中只要有一个用户是faulty的，都没有办法达成共识</li><li>CAP Theorem：以下三个性质中，最多满足两种<ul><li>一致性Consistency、可用性Availability、分区容错性Partition tolerance</li></ul></li></ul></li></ul><p>membership</p><p>hyperledger</p><p>联盟链 - fabric</p><p>sybil attacl，女巫攻击：找一个超级计算机，不停的产生用户节点，当总数超过一半时，就得到了这个链的控制权</p><ul><li>coinbase transaction：<ul><li>通过算例投票 puzzle friendly</li><li>hash rate</li><li>nonce</li></ul></li></ul><p>mining - 挖矿：比特币争夺记账权</p><ul><li>digital gold</li><li>miner</li></ul><h4 id="BTC系统实现"><a href="#BTC系统实现" class="headerlink" title="BTC系统实现"></a>BTC系统实现</h4><h5 id="transaction-based-ledger，基于交易的账本模式"><a href="#transaction-based-ledger，基于交易的账本模式" class="headerlink" title="transaction-based ledger，基于交易的账本模式"></a>transaction-based ledger，基于交易的账本模式</h5><ul><li>每个交易需要说清楚，币是从哪儿来的，它没有账户的概念</li></ul><p>全节点维护一个数据结构：</p><ul><li><p>UTXO，unspent Transaction Output：还没有被花掉的交易的输出集合</p><ul><li><p><strong>包括</strong> 2个数据就能定位UTXO的输出：</p><ol><li><p>产生这个输出的交易的hash 值</p></li><li><p>这个输出是交易中的第几个输出</p></li></ol></li><li><p><strong>作用</strong>：检测Double Spending</p></li><li><p>total inputs = total outputs：i可以略大于o，中间的<code>transaction fee</code>可能给了拥有记账权的区块</p></li><li><p>transaction fee：大约只有零点零几个币</p></li></ul></li></ul><p>account-based ledger，基于账户的模式</p><ul><li>系统需要显示的记录每个账户有多少个币，如以太坊ß</li></ul><h5 id="Bernoulli-trial"><a href="#Bernoulli-trial" class="headerlink" title="Bernoulli trial"></a>Bernoulli trial</h5><ul><li><p>a random experiment with binary outcome</p></li><li><p>每次求解nonce可以看作是Bernoulli trial</p></li></ul><p><strong>Bernoulli process</strong>：a sequence of independent Bernoulli</p><ul><li>大量实践的Bernoulli trial就组成了</li><li>性质：<ul><li>memoryless，无记忆的：实验结果和之前的实验结果是没有关系的</li></ul></li></ul><p>Poisson process：</p><p>exponential distribution，出块时间：服从指数分布</p><ul><li>memoryless：将来挖多少时间与之前已经挖了多少时间没有关系，即使等了10mins，下一挖到矿的时间仍然指数分布，平均是10mins</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;crypto-currency（加密货币）&quot;&gt;&lt;a href=&quot;#crypto-currency（加密货币）&quot; class=&quot;headerlink&quot; title=&quot;crypto-currency（加密货币）&quot;&gt;&lt;/a&gt;crypto-currency（加密货币）&lt;/</summary>
      
    
    
    
    <category term="notebook" scheme="https://jieyang-wei.github.io/categories/notebook/"/>
    
    
    <category term="BTC" scheme="https://jieyang-wei.github.io/tags/BTC/"/>
    
  </entry>
  
  <entry>
    <title>版本管理</title>
    <link href="https://jieyang-wei.github.io/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"/>
    <id>https://jieyang-wei.github.io/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/</id>
    <published>2020-12-14T07:55:40.000Z</published>
    <updated>2020-12-15T05:40:02.286Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h3 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h3><ol><li><p><strong>本地版本控制系统</strong>（Version Control Systems，简称VCS）</p><ul><li><p>大多都是采用某种简单的数据库来记录文件的历次更新差异</p></li><li><p>最流行的：<code>RCS</code></p><ul><li>工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，可以重新计算出各个版本的文件内容。”</li></ul></li></ul></li><li><p><strong>集中化版本控制系统</strong>（Centralized Version Control Systems，简称 CVCS ）</p><ul><li>诸如CVS、Subversion以及perforce等</li><li>容易单点故障、丢失所有历史更新记录的风险</li></ul></li><li><p><strong>分布式版本控制系统</strong>（Distributed Version Control System，简称 DVCS）</p><ul><li>像Git、Mercurial、Bazaar以及Darcs</li><li>客户端并不只提取最新版本的文件快照， 而是把代码仓库完整地镜像下来，包括完整的历史记录</li></ul></li></ol><ul><li>大部分系统以文件变更列表的方式存储信息，这类系统（CVS、Subversion、Perforce、Bazaar等）将他们存储的信息看作是一组基本文件和每个文件随时间逐步累积的差异（**基于差异[delta-based]**的版本控制）</li><li>Git 更像是把数据看作是对<strong>小型文件系统</strong>的一系列快照。 在 Git 中，每当你提交更新或保存项目状态时，它基本上就会对当时的全部文件创建一个快照并保存这个快照的索引。 为了效率，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 <strong>快照流</strong></li></ul><p><strong>git</strong>：分布式版本控制系统，c语言开发</p><p><strong>免费集中式版本控制</strong>：CVS、SVN  —  速度慢，且需要联网</p><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p><a class="link" href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">廖雪峰<i class="fas fa-external-link-alt"></i></a></p><p>电子书：progit_v2.1.54</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>git校验和机制</strong>：<strong>SHA-1散列</strong>，这是一个由 40 个十六进制字符（0-9 和 a-f）组成的字符串，基于 Git 中文件的内容或目录结构计算出来</p><h4 id="三种状态"><a href="#三种状态" class="headerlink" title="三种状态"></a>三种状态</h4><ul><li><strong>已提交（committed）</strong>：表示数据已经安全地保存在本地数据库中</li><li><strong>已修改（modified）</strong>：表示修改了文件，但还没保存到数据库中</li><li><strong>已暂存（staged）</strong>：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中</li></ul><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/截屏2020-12-09 下午2.58.04.png" alt="截屏2020-12-07 下午3.29.20"><ul><li>工作区：对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改</li><li>暂存区：是一个文件，保存了下次将要提交的文件列表信息，一般在 Git 仓库目录中。 按照 Git 的术语叫做“索引”，不过一般说法还是叫“暂存区</li><li>git目录：Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，复制的就是这里的数据</li></ul><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><ol><li>在工作区中修改文件。</li><li>将你想要下次提交的更改选择性地暂存，这样只会将更改的部分添加到暂存区。</li><li>提交更新，找到暂存区的文件，将快照永久性存储到 Git 目录。</li></ol><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install git-all</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看版本</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git --version</span></span><br></pre></td></tr></table></figure><p>工具目录结构</p><ul><li>git自带一个<code>git config</code>的工具来帮助设置，这些变量存储在三个不同的位置</li></ul><ol><li>/etc/gitconfig 文件：包含系统上每一个用户及他们仓库的通用配置。 如果在执行 git config 时带上 –system 选项，那么它就会读写该文件中的配置变量。 （由于它是系统配置文件，因此你需要管理员或超级用户权限来修改它。）</li><li>~/.gitconfig 或 ~/.config/git/config 文件：只针对当前用户。 你可以传递 –global 选项让 Git 读写此文件，这会对你系统上所有的仓库生效</li><li>当前使用仓库的 Git 目录中的 config 文件（即 .git/config）：针对该仓库。 你可以传递 –local 选项让 Git 强制读写此文件，虽然默认情况下用的就是它。。 （当然，你需要进入某个 Git 仓库中才能让该选项生效。）<ul><li>每一个级别会覆盖上一级别的配置，所以 .git/config 的配置变量会覆盖 /etc/gitconfig 中的配置变量</li></ul></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --list --show-origin  <span class="comment"># 查看所有配置以及他们所在文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置用户信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.name <span class="string">&quot;Weijieyang&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.email <span class="string">&quot;name@mail.com&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> git config 选项列表</span></span><br><span class="line"> * --list 列出所有 Git 当时能找到的配置</span><br><span class="line"> * --global 配置所有的项目</span><br></pre></td></tr></table></figure><ul><li>git工作目录下每一个文件只有两种状态<ol><li><strong>已跟踪</strong>：指那些被纳入了版本控制的文件，在上一次快照中有它们的记录。即git已经知道的文件</li><li><strong>未跟踪</strong>：其他文件</li></ol></li></ul><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="版本库（Repository）"><a href="#版本库（Repository）" class="headerlink" title="版本库（Repository）"></a>版本库（Repository）</h3><p>工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。</p><p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</p><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/截屏2020-12-07 下午3.29.20.png" alt="截屏2020-12-07 下午3.29.20" style="zoom:50%;"><ol><li><strong>创建版本库</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br></pre></td></tr></table></figure><ul><li>到需要版本管理的目录下</li><li>初始化后会在目录下形成一个<code>.git</code>文件，此文件为隐藏文件，需要使用命令<code>ls -a</code>查看</li></ul><ol start="2"><li><strong>使用步骤</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add file</span> </span><br></pre></td></tr></table></figure><ul><li>添加本地修改后的文件到暂存区</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"> * -s/--short 更为紧凑的输出展示效果</span><br></pre></td></tr></table></figure><ul><li>时刻掌握仓库当前情况，查看未被提交的修改，包括工作区和暂存区</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&#x27;注释&#x27;</span></span></span><br></pre></td></tr></table></figure><ul><li>将暂存区的修改提交到版本库中</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&#x27;注释&#x27;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add filemore</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend</span></span><br></pre></td></tr></table></figure><ul><li>第一次提交后发现漏了几个文件，可以使用<code>--amend</code>添加，此次提交将会替代上一次的提交，上一次的提交将不会出现在版本历史中ß</li></ul><ol start="3"><li><strong>版本管理</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line"> * —-pretty=onelines pretty可以指定不同于默认格式的方式展示历史</span><br><span class="line"> * onelines 输出消息更简洁，最前面是每个版本的commit id（用SHA1计算）</span><br><span class="line"> * format:&quot;%h - %an, %ar : %s&quot; 定制记录的显示格式</span><br><span class="line"> * 还有short、full和fuller</span><br><span class="line"> </span><br><span class="line"> * -p/--patch 显示每次提交所引入的差异（按 补丁 的格式输出）</span><br><span class="line"> * --stat 每次提交的简略统计信息</span><br><span class="line"> * --shortstat 只显示 --stat 中最后的行数修改添加移除统计</span><br><span class="line"> * --name-only 仅在提交信息后显示已修改的文件清单</span><br><span class="line"> * --name-status 显示新增、修改、删除的文件清单</span><br><span class="line"> * --graph 查看分支合并图，在日志旁以 ASCII 图形显示分支与合并历</span><br><span class="line"> * --abbrev-commit 查看详细的合并信息，仅显示 SHA-1 校验和所有 40 个字符中的前几个字符</span><br><span class="line"> * --relative-data 使用较短的相对时间而不是完整格式显示日期（比如“2 weeks ago”）</span><br></pre></td></tr></table></figure><ul><li>显示从最近到最远的提交日志</li><li><strong>format</strong>格式设置：<ul><li><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/截屏2020-12-09 下午3.39.00.png" alt="截屏2020-12-09 下午3.39.00" style="zoom: 33%;"></li><li><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/截屏2020-12-09 下午3.39.17.png" alt="截屏2020-12-09 下午3.39.17" style="zoom: 33%;"></li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git last</span></span><br></pre></td></tr></table></figure><ul><li>查看最后一次提交</li></ul><p><strong>取消暂存 reset</strong>  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard HEAD^</span> </span><br></pre></td></tr></table></figure><ul><li>回退到前一个版本<ul><li><code>HEAD</code>：相当于一个指针，指向<code>master</code>，而<code>master</code>指向提交</li><li><code>^</code>：是上一个版本，<code>^^</code>：前两个的版本，<code>HEAD～100</code>：往上100个版本</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard commitId</span></span><br></pre></td></tr></table></figure><ul><li>回退到版本号为<code>commitId</code>的版本</li><li><strong>注意</strong>：<code>--hard</code> 是一个危险的选项</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rerset HEAD &lt;file&gt;</span></span><br></pre></td></tr></table></figure><ul><li>撤销暂存区(unstage)的修改回退到工作区</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reflog</span></span><br><span class="line">e475afc HEAD@&#123;1&#125;: reset: moving to HEAD^</span><br><span class="line">1094adb (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: append GPL</span><br><span class="line">e475afc HEAD@&#123;3&#125;: commit: add distributed</span><br><span class="line">eaadf4e HEAD@&#123;4&#125;: commit (initial): wrote a readme file</span><br></pre></td></tr></table></figure><ul><li>记录了你的每一次命令，可以用来找已经撤销掉的版本id</li></ul><ol start="4"><li><strong>其他操作</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff file</span></span><br></pre></td></tr></table></figure><ul><li>查看修改内容，<code>diff</code>均是未提交的内容</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff --staged</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看已暂存文件和最后一次提交的文件差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff --cached</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看已经暂存起来的变化（--staged和--cached是同义词）</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff HEAD -- file</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看工作区和版本库里面最新版本的区别</span></span><br></pre></td></tr></table></figure><p><strong>撤销操作 checkout</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -- &lt;file&gt;</span></span><br></pre></td></tr></table></figure><ul><li>撤销上一次修改，回到最近一次git commit或者git add状态，不管是在工作区还是在暂存区<ul><li>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</li><li>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</li><li>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考<a class="link" href="https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192">版本回退<i class="fas fa-external-link-alt"></i></a>一节，不过前提是没有推送到远程库。</li></ul></li></ul><p><strong>删除文件 rm</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rm file</span></span><br></pre></td></tr></table></figure><ul><li>通过rm删除了文件之后，status会告诉删除信息，因为删除也算是修改操作（deleted： file）</li><li>在本地目录中删除文件之后可以选择彻底删除或者使用git恢复<ol><li>彻底删除：<code>$ git rm file</code>— 在暂存区中删除，<code>$ git commit</code> — 确定要在版本库中删除<ul><li>(如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失<strong>最近一次提交后你修改的内容</strong>。)</li></ul></li><li>恢复：<code>$ git checkout --file</code><ul><li>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</li></ul></li></ol></li></ul><p><strong>改名操作 mv</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git mv old new</span></span><br><span class="line">---- 相当于 ----</span><br><span class="line"><span class="meta">$</span><span class="bash"> mv old new</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm old</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add new</span></span><br></pre></td></tr></table></figure><p><strong>忽略文件</strong></p><p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。在这种情况下，我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件的模式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat .gitignore</span></span><br><span class="line">*～      # 忽略所有名字以～结尾的文件（通常是副本文件）</span><br><span class="line">*.[oa]   # 忽略以.o .a 结尾的文件</span><br><span class="line">!lib.a.  # 忽略.a文件，但跟踪所有 lib.a 文件</span><br><span class="line">/TODO    # 只忽略当前目录下的 TODO 文件</span><br><span class="line">build/   # 忽略任何目录下名为 build 的文件夹</span><br><span class="line">doc/*.txt    #忽略doc下的txt，但不忽略doc/server/a.txt</span><br><span class="line">doc/**/*.pdf #忽略doc及其子目录下的所有pdf文件</span><br></pre></td></tr></table></figure><p>格式规范：</p><ul><li>所有空行或者以 # 开头的行都会被 Git 忽略。</li><li>可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。</li><li>匹配模式可以以（/）开头防止递归。</li><li>匹配模式可以以（/）结尾指定目录。</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上叹号（!）取反。</li></ul><h3 id="远程仓库（github）"><a href="#远程仓库（github）" class="headerlink" title="远程仓库（github）"></a>远程仓库（github）</h3><ol><li><strong>创建电脑用户自己的密钥</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen -t rsa -C <span class="string">&quot;youremail@example.com&quot;</span></span></span><br><span class="line"> * -t 指定密钥类型，默认是 rsa ，可以省略。</span><br><span class="line"> * -C 设置注释文字，比如邮箱。</span><br><span class="line"> * -f 指定密钥文件存储文件名.</span><br></pre></td></tr></table></figure><ul><li>在用户主目录<code>/home/username</code>下创建密钥</li><li>生成<code>id_rsa</code>和<code>id_rsa.pub</code></li></ul><ol start="2"><li><strong>绑定电脑用户和github用户</strong></li></ol><ul><li>将公钥<code>id_rsa.pub</code>加载到github网站上<code>Add SSH Key</code></li></ul><ol start="3"><li><strong>添加远程仓库</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote add origin git@github-link</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote -v</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote show &lt;remote&gt;    <span class="comment"># 查看摸一个远程仓库的更多信息</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote rename old new   <span class="comment"># 给远程仓库改名</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote remove name      <span class="comment"># 删除远程仓库，及所有跟踪分支和配置信息</span></span></span><br></pre></td></tr></table></figure><ul><li>链接本地仓库和github上创建的远程仓库</li><li><code>origin</code>为远程仓库的默认名字，可自行更改</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push -u origin mymaster:master</span></span><br></pre></td></tr></table></figure><ul><li>将本地仓库的内容推送到远程仓库上，实际上是把当前分支master推送到远程</li><li><code>-u</code>：如果当前分支与多个主机存在追踪关系，则可以使用 -u 参数指定一个默认主机，这样后面就可以不加任何参数使用<code>git push</code><ul><li>不指定<code>mymaster</code>：将会删除远程的<code>master</code>分支，这相当于是push了一个空分支到<code>master</code></li><li>不指定<code>:master</code>：默认推送到与<code>mymaster</code>有追踪关系的分支，一般为同名分支，没有的话会在远程建一个（<code>git remote show &lt;origin&gt;</code>查看各个分支的追踪关系）</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull origin master:mymaster</span></span><br></pre></td></tr></table></figure><ul><li>提交远程之前，最好先将远程仓库的文件拉取下来，再<code>push</code>，以免造成冲突</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git fetch &lt;remote&gt; &lt;remote branchname&gt;:&lt;your branchname&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 不指定远程分支将会默认为‘default’分支（一般为master）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 不给本地分支命名的话，会自动默认指针 FETCH_HEAD</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者使用远程分支名 origin/master 指定fetch的分支</span></span><br></pre></td></tr></table></figure><ul><li>他与pull一样，就拉取远程仓库中有但你没有的文件（不要拉取到当前所在分支）</li><li>不同的是，fetch并不会自动合并或修改你当前的工作，更安全。 当准备好时你必须手动将其合并入你的工作。</li><li><strong>pull = fetch + merge (FETCH_HEAD)</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git fetch origin</span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge origin/<span class="string">&#x27;default&#x27;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 拉取远程默认分支到本地当前分支上，再与远程的默认分支合并</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git fetch origin master:mymaster-tmp</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge mymaster-tmp</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 建议建一个专用存放fetch的分支tmp，拉去下来文件后，再与myaster来merge</span></span><br></pre></td></tr></table></figure><p><strong><code>FETCH_HEAD</code></strong></p><ul><li>某个branch在服务器上的最新状态.</li><li>每一个执行过fetch操作的项目都会存在一个FETCH_HEAD列表,这个列表保存在 <code>.git/FETCH_HEAD</code> 文件中, 其中每一行对应于远程服务器的一个分支.当前分支指向的FETCH_HEAD, 就是这个文件第一行对应的那个分支</li><li>一般来说, 存在两种情况:<ul><li>如果没有显式的指定<code>远程分支</code>, 则远程分支的<code>master</code>将作为默认的<code>FETCH_HEAD</code>.</li><li>如果指定了<code>远程分支</code>, 就将这个远程分支作为<code>FETCH_HEAD</code>.</li></ul></li></ul><p><strong><code>–rebase</code></strong></p><ul><li>作用是取消掉本地库中刚刚的commit，并把他们接到更新后的版本库之中。</li></ul><ol start="4"><li><strong>克隆远程仓库</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> git@github-link</span></span><br></pre></td></tr></table></figure><ul><li>如果远程仓库已有文件，可以将其克隆到本地的空仓库中</li></ul><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p><code>master</code>：主分支</p><p><code>HEAD</code>：指向当前分支，即指向<code>master</code></p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul><li><strong>新建<code>dev</code>分支</strong>：现在修改东西就是<code>dev</code>指针移动了，而<code>HEAD</code>指向当前的<code>dev</code>分支<ul><li>此时修改<code>dev</code>分支，<code>master</code>分支将不会改变</li></ul></li></ul><p><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/3DEC42CC-E46F-4939-ACAA-33BD4B3F88B2.png" alt="3DEC42CC-E46F-4939-ACAA-33BD4B3F88B2" style="zoom:67%;"><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/截屏2020-12-07 下午4.12.29.png" alt="截屏2020-12-07 下午4.12.29" style="zoom: 33%;"></p><ul><li><strong>合并分支</strong>：改改指针的问题                                          <ul><li>将<code>dev</code>分支合并到<code>master</code>上，右图为不使用<code>Fast-Forward</code>快进模式时（–no-ff）</li></ul></li></ul><p><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/69B01EAC-0670-4DED-85A9-A41465FCBF3C.png" alt="69B01EAC-0670-4DED-85A9-A41465FCBF3C" style="zoom: 67%;"><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/B0212A11-D318-457F-9943-E5FCD27820B4.png" alt="B0212A11-D318-457F-9943-E5FCD27820B4" style="zoom: 67%;"></p><ul><li><strong>删除分支</strong>：将dev指针给删掉就行了</li></ul><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/9CA8FECF-51AB-438D-86D7-59846BF675C9.png" alt="9CA8FECF-51AB-438D-86D7-59846BF675C9" style="zoom:80%;"><h4 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h4><ul><li>创建分支：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout (-b) dev</span></span><br><span class="line"> * -b 创建并切换分支</span><br><span class="line">-------------------------</span><br><span class="line"><span class="meta">$</span><span class="bash"> git switch (-c) dev</span></span><br><span class="line"> * -c 创建并切换分支</span><br></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch dev     //创建分支(会创建一个和当前分支有一样内容的分支)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout/switch dev   //切换分支</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br><span class="line">* dev</span><br><span class="line">  master</span><br></pre></td></tr></table></figure><ul><li>查看当前分支，当前分支上会加上<code>*</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -d dev</span></span><br></pre></td></tr></table></figure><ul><li>删除分支dev</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br><span class="line"> * -vv 将所有的本地分支列出来并且包含更多的信息</span><br><span class="line"> * -r 查看远程所有分支</span><br><span class="line"> * -a 查看本地和远程的所有分支</span><br><span class="line"> * &lt;branchname&gt; 新建分支</span><br><span class="line"> * -d -r &lt;branchname&gt; 删除远程分支，删除后还需要推送到服务器</span><br><span class="line"> * -m old new 重命名分支</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch --set-upstream-to origin/branchname</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch --set-upstream-to=origin/branchname  branchname</span></span><br></pre></td></tr></table></figure><ul><li>修改<code>pull</code>时的远程分支关联<ul><li>upstream：将当前分支推送到其上游分支（ tracking &gt;是不推荐的同义词对于上游）</li><li>current：将当前分支推送到同名分支</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git merge dev</span>   </span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge --no-ff -m <span class="string">&quot;merge with no-ff” dev</span></span> </span><br></pre></td></tr></table></figure><ul><li>合并分支到当前分支（如：将<code>dev</code>上的工作结果合并到<code>master</code>上）</li><li>注：两个分支分别都修改了文件的冲突情况下，需要进行手动更改冲突<ul><li>一般合并分支会在<code>Fast Forward</code>模式，但此模式下删除分支，会丢失掉分支信息；</li><li>如果要强制禁用<code>Fast Forward</code>模式，Git就会在<code>merge</code>时生成一个新的<code>commit</code>，这样，从分支历史上就可以看出分支信息。</li><li><code>--no-ff</code>方式的git merge：看的出原来发生过合并，而merge看不出</li></ul></li></ul><ul><li><strong>分支策略</strong>：<ul><li>master：最稳定的，用来发布版本；</li><li>dev：不稳定，所有人将自己的修改合并到这个分支上</li></ul></li></ul><p><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/FD4949A7-CB58-4BD1-B887-3A833E23A7DD.png" alt="FD4949A7-CB58-4BD1-B887-3A833E23A7DD"></p><p>修改bug：创建新的分支进行修改，修改后合并到dev上，但是因为commit是一次提交所有的暂存区，所以需要将现在在写的，不需要提交的先用stash指令存储起来</p><p>git stash：将当前工作现场存储起来，等以后恢复现场工作后继续使用，此时git status非常的干净</p><p>查看：git stash list</p><p>恢复：git stash apply  -  恢复后不删除stash中的内容，需要用 git stash drop 来删除</p><p>​      git stash pop  -  恢复的同时删除</p><p>​       git stash apply stash@{0}：恢复指令的stash</p><p>feature分支</p><p>每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分</p><p>强行删除未合并的分支：git branch -D <file></file></p><h3 id="标签设置"><a href="#标签设置" class="headerlink" title="标签设置"></a>标签设置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出标签</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag -l <span class="string">&quot;v1.8.5&quot;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -l/-list 指定需要某些标签，如上只输出 v1.8.5 系列的</span></span><br></pre></td></tr></table></figure><h4 id="标签类型"><a href="#标签类型" class="headerlink" title="标签类型"></a><strong>标签类型</strong></h4><ol><li><strong>轻量标签（lightweight）</strong>：像一个不会改变的分支，它只是某个提交的引用</li><li><strong>附注标签（annotated）</strong>：是存储在git数据库的一个完整对象，它可以被校验，其中包含打标签者的名字、电子邮件、地址、日期时间，此外还有一个标签信息，并且可以使用GNU Privacy Guard（GPG）签名并验证</li></ol><h4 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a><strong>创建标签</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag -a v1.4 -m <span class="string">&quot;指定一条标签信息&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 轻量只用指定标签名字</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag v1.4</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 给历史版本打标签</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag -a v1.4 commitId</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git show v1.4</span></span><br></pre></td></tr></table></figure><ul><li>查看标签信息和与之对应的提交信息，如果是轻量标签则只会有提交信息</li></ul><h4 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a><strong>删除标签</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag -d v1.4</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin :refs/tags/v1.4</span></span><br></pre></td></tr></table></figure><ul><li>本地删除标签后并不会在远程仓库移除，需要执行第二条指令</li><li>将冒号前面的空值推送到远程标签名，从而高效地删除它</li><li>或者使用下面的方式更直观的删除</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin --delete &lt;tagname&gt;</span></span><br></pre></td></tr></table></figure><h4 id="共享标签"><a href="#共享标签" class="headerlink" title="共享标签"></a><strong>共享标签</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin v1.4</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin --tags</span></span><br></pre></td></tr></table></figure><ul><li><p>在创建完标签后你必须显式地推送标签到共享服务器上</p></li><li><p>–tags：这将会把所有不在远程仓库服务器上的标签全部传送到那里</p></li></ul><h4 id="检出标签"><a href="#检出标签" class="headerlink" title="检出标签"></a><strong>检出标签</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout 2.0.0</span></span><br></pre></td></tr></table></figure><ul><li>查看某个标签所指向的文件版本，但这会是你的仓库处于“分离头指针（detached HEAD）”的状态<ul><li>此状态如果你做了某些更改然后提交它们，标签不会发生变化， 但你的新提交将不属于任何分支，并且将无法访问，除非通过确切的提交哈希才能访问。 因此，如果你需要进行更改，比如你要修复旧版本中的错误，那么通常需要创建一个新分支<code>$ git checkout -b version2 v2.0.0</code></li></ul></li></ul><h3 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h3><h1 id="SVM"><a href="#SVM" class="headerlink" title="SVM"></a>SVM</h1><p>阿斯顿</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;h3 id=&quot;发展历史&quot;&gt;&lt;a href=&quot;#发展历史&quot; class=&quot;headerlink&quot; title=&quot;发展历史&quot;&gt;&lt;/a&gt;发展历史&lt;/h</summary>
      
    
    
    
    <category term="notebook" scheme="https://jieyang-wei.github.io/categories/notebook/"/>
    
    
    <category term="linux" scheme="https://jieyang-wei.github.io/tags/linux/"/>
    
    <category term="git" scheme="https://jieyang-wei.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://jieyang-wei.github.io/2020/12/12/hello-world/"/>
    <id>https://jieyang-wei.github.io/2020/12/12/hello-world/</id>
    <published>2020-12-12T08:51:34.056Z</published>
    <updated>2020-12-14T10:13:12.832Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a class="link" href="https://hexo.io/">Hexo<i class="fas fa-external-link-alt"></i></a>! This is your very first post. Check <a class="link" href="https://hexo.io/docs/">documentation<i class="fas fa-external-link-alt"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link" href="https://hexo.io/docs/troubleshooting.html">troubleshooting<i class="fas fa-external-link-alt"></i></a> or you can ask me on <a class="link" href="https://github.com/hexojs/hexo/issues">GitHub<i class="fas fa-external-link-alt"></i></a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a class="link" href="https://hexo.io/docs/writing.html">Writing<i class="fas fa-external-link-alt"></i></a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a class="link" href="https://hexo.io/docs/server.html">Server<i class="fas fa-external-link-alt"></i></a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a class="link" href="https://hexo.io/docs/generating.html">Generating<i class="fas fa-external-link-alt"></i></a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a class="link" href="https://hexo.io/docs/one-command-deployment.html">Deployment<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a class=&quot;link&quot; href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;i class=&quot;fas fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/a&gt;! This is your very first post. Check </summary>
      
    
    
    
    <category term="course" scheme="https://jieyang-wei.github.io/categories/course/"/>
    
    
    <category term="hello-world" scheme="https://jieyang-wei.github.io/tags/hello-world/"/>
    
  </entry>
  
</feed>
