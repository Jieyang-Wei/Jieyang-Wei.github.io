<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WeiJY&#39;s blog</title>
  
  
  <link href="https://jieyang-wei.github.io/atom.xml" rel="self"/>
  
  <link href="https://jieyang-wei.github.io/"/>
  <updated>2020-12-16T08:19:32.150Z</updated>
  <id>https://jieyang-wei.github.io/</id>
  
  <author>
    <name>Wei Jieyang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>编程语言学习</title>
    <link href="https://jieyang-wei.github.io/2020/12/16/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    <id>https://jieyang-wei.github.io/2020/12/16/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-12-16T08:18:33.000Z</published>
    <updated>2020-12-16T08:19:32.150Z</updated>
    
    <content type="html"><![CDATA[<p>最快掌握编程语言</p><ul><li>coder：<ul><li>图灵完备：相互之间可以替代的，c的能做，java也能，bat不是</li><li>标记语言，不是编程语言，没有逻辑</li></ul></li></ul><ol><li><p>语言背景</p></li><li><p>程序逻辑</p><ul><li>编程语言环境<ul><li>强类型：<ul><li>定义a = “string”，就知道a是一个字符串类型</li><li>Java，python</li></ul></li><li>弱类型：<ul><li>需要定义 String a = “String”，才知道类型，像C需要程序猿去判定类型</li><li>C，PHP，js</li></ul></li></ul></li></ul></li><li><p>变量</p><ul><li>变量定义<ul><li>动态类型<ul><li>js</li></ul></li><li>静态类型<ul><li>java</li></ul></li></ul></li><li>变量类型<ul><li>值类型（基本类型）<ul><li>变量在栈里面声明，</li><li>C，C++，引用类型通过指针来实现</li></ul></li><li>引用类型（封装类型）<ul><li>变量是指针，指向了内存地址中变量的地址</li><li>python，js</li></ul></li><li>java - 即保留值类型，也保留引用类型</li><li>应用在比较变量中，引用类型需要重写equal方法，不然比较的是地址</li></ul></li></ul></li><li><p>容器对象</p><ul><li>简单操作</li><li>浅复制，深复制、序列化</li></ul></li><li><p>类接口、抽象类</p></li><li><p>函数</p></li><li><p>生态、依赖</p><ul><li>框架，包管理工具</li></ul></li><li><p>高级特性</p><ul><li>java - 并发、高性能处理</li><li>是否支持携程</li></ul></li></ol><p>训练任务：</p><ol><li>支持消息循环的交互程序，一个文字版RPG小游戏</li><li>比较机械的控制，比如二进制位控制，</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最快掌握编程语言&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;coder：&lt;ul&gt;
&lt;li&gt;图灵完备：相互之间可以替代的，c的能做，java也能，bat不是&lt;/li&gt;
&lt;li&gt;标记语言，不是编程语言，没有逻辑&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;语言背景&lt;/</summary>
      
    
    
    
    <category term="notebook" scheme="https://jieyang-wei.github.io/categories/notebook/"/>
    
    
    <category term="编程语言" scheme="https://jieyang-wei.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>python</title>
    <link href="https://jieyang-wei.github.io/2020/12/15/python/"/>
    <id>https://jieyang-wei.github.io/2020/12/15/python/</id>
    <published>2020-12-15T06:32:10.000Z</published>
    <updated>2020-12-16T08:20:16.234Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a>Anaconda</h1><ul><li><a class="link" href="https://www.jianshu.com/p/62f155eb6ac5">Anaconda部分原博客<i class="fas fa-external-link-alt"></i></a></li><li>Anaconda（<a class="link" href="https://link.jianshu.com/?t=https://www.anaconda.com/download/%23macos">官方网站<i class="fas fa-external-link-alt"></i></a>）就是可以便捷获取包且对包能够进行管理，同时对环境可以统一管理的发行版本。</li><li>Anaconda包含了conda、Python在内的超过180个科学包及其依赖项。</li><li>其特点的实现是因为包含：<ul><li> conda包</li><li>环境管理器</li><li>1000+开源库</li></ul></li></ul><p>特点：</p><ul><li>开源</li><li>安装过程简单</li><li>高性能使用python和R语言</li><li>免费的社区支持</li></ul><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><h3 id="1-Anaconda"><a href="#1-Anaconda" class="headerlink" title="1. Anaconda"></a>1. Anaconda</h3><ul><li>Anaconda是一个包含180+的科学包及其依赖项的发行版本。</li><li>其包含的科学包包括：<ul><li>conda, numpy, scipy, ipython notebook等。</li></ul></li></ul><h3 id="2-conda"><a href="#2-conda" class="headerlink" title="2. conda"></a>2. conda</h3><ul><li><p>conda是包及其依赖项和环境的管理工具。</p></li><li><p>适用语言：</p><ul><li>Python, R, Ruby, Lua, Scala, Java, JavaScript, C/C++, FORTRAN。</li></ul></li><li><p>适用平台：</p><ul><li>Windows, macOS, Linux</li></ul></li></ul><p><strong>用途</strong>：</p><ol><li>快速安装、运行和升级包及其依赖项。</li><li>在计算机中便捷地创建、保存、加载和切换环境。</li></ol><blockquote><p>如果你需要的包要求不同版本的Python，你无需切换到不同的环境，因为conda同样是一个环境管理器。仅需要几条命令，你可以创建一个完全独立的环境来运行不同的Python版本，同时继续在你常规的环境中使用你常用的Python版本。——<a class="link" href="https://link.jianshu.com/?t=https://conda.io/docs/">conda官方网站<i class="fas fa-external-link-alt"></i></a></p></blockquote><ul><li>onda为Python项目而创造，但可适用于上述的多种语言。</li><li>conda包和环境管理器包含于Anaconda的所有版本当中。</li></ul><h3 id="3-pip"><a href="#3-pip" class="headerlink" title="3. pip"></a>3. pip</h3><ul><li><p>pip是用于安装和管理软件包的包管理器。</p></li><li><p>pip编写语言：Python。</p></li><li><p>Python中默认安装的版本：</p><ul><li>Python 2.7.9及后续版本：默认安装，命令为<code>pip</code></li><li>Python 3.4及后续版本：默认安装，命令为<code>pip3</code></li></ul></li><li><p>pip名称的由来：pip采用的是<strong>递归缩写</strong>进行命名的。其名字被普遍认为来源于2处：</p><ul><li>“Pip installs Packages”（“pip安装包”）</li><li>“Pip installs Python”（“pip安装Python”）</li></ul></li></ul><h3 id="4-virtualenv"><a href="#4-virtualenv" class="headerlink" title="4.virtualenv"></a>4.virtualenv</h3><ul><li><p>virtualenv：用于创建一个<strong>独立的</strong>Python环境的工具。</p></li><li><p>解决问题：</p><ol><li>当一个程序需要使用Python 2.7版本，而另一个程序需要使用Python 3.6版本，如何同时使用这两个程序？</li><li>如果将所有程序都安装在系统下的默认路径，如：<code>/usr/lib/python2.7/site-packages</code>，当不小心升级了本不该升级的程序时，将会对其他的程序造成影响。</li><li>如果想要安装程序并在程序运行时对其库或库的版本进行修改，都会导致程序的中断。</li><li>在共享主机时，无法在全局<code>site-packages</code>目录中安装包。</li></ol></li><li><p>virtualenv将会为它自己的安装目录创建一个环境，这并<strong>不与</strong>其他virtualenv环境共享库；同时也可以<strong>选择性</strong>地不连接已安装的全局库。</p></li></ul><hr><p><strong>pip与conda比较</strong>：</p><ol><li><p><strong>依赖项检查</strong></p><ul><li>pip：<ul><li><strong>不一定</strong>会展示所需其他依赖包。</li><li>安装包时<strong>或许</strong>会直接忽略依赖项而安装，仅在结果中提示错误。</li></ul></li><li>conda：<ul><li>列出所需其他依赖包。</li><li>安装包时自动安装其依赖项。</li><li>可以便捷地在包的不同版本中自由切换。</li></ul></li></ul></li><li><p><strong>环境管理</strong></p><ul><li>pip：维护多个环境难度较大。</li><li>conda：比较方便地在不同环境之间进行切换，环境管理较为简单。</li></ul></li><li><p><strong>对系统自带Python的影响</strong></p><ul><li>pip：在系统自带Python中包的**更新/回退版本/卸载将影响其他程序。</li><li>conda：不会影响系统自带Python。</li></ul></li><li><p><strong>适用语言</strong></p><ul><li>pip：仅适用于Python。</li><li>conda：适用于Python, R, Ruby, Lua, Scala, Java, JavaScript, C/C++, FORTRAN。</li></ul></li></ol><p> <strong>conda与pip、virtualenv的关系</strong></p><ul><li>conda<strong>结合</strong>了pip和virtualenv的功能。</li></ul><hr><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>查看是否安装了python和anaconda：</p><p><img src="/2020/12/15/python/DF8274195F82F3A1713FE9FAB66C46B5.png" alt="DF8274195F82F3A1713FE9FAB66C46B5"></p><ol><li><p><code>$ conda list</code>：如果Anaconda被成功安装，则会显示已经安装的包名和版本号。</p></li><li><p><code>$ python</code>：进入python终端的命令行</p><ul><li>如果同时安装了Anaconda，则会显示上图红色的部分</li><li>exit() / quit()：退出</li></ul></li><li><p>终端输入<code>$ anaconda-navigator</code>将会打开anaconda-navigator图形界面</p></li></ol><p><strong>安装教程</strong>：自行百度，或者<a class="link" href="https://www.jianshu.com/p/62f155eb6ac5">原博客<i class="fas fa-external-link-alt"></i></a>有</p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="管理conda和环境"><a href="#管理conda和环境" class="headerlink" title="管理conda和环境"></a>管理conda和环境</h3><ul><li>验证conda已被安装</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda list              <span class="comment"># 显示已经安装的包名和版本号</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> conda --version         <span class="comment"># 查看conda版本号码</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> conda update conda      <span class="comment"># 更新conda至最新版本</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> conda --<span class="built_in">help</span>            <span class="comment"># 查看帮助信息</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rm -rf anaconda安装路径   <span class="comment"># 删除只需要删除安装目录即可（mac os）</span></span> </span><br></pre></td></tr></table></figure><p><strong>创建新环境</strong> </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda create --name &lt;env_name&gt; &lt;package_names&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;env_name&gt;</code>：即创建的环境名。建议以英文命名，且不加空格，名称两边不加尖括号“&lt;&gt;”。</li><li><code>&lt;package_names&gt;</code>：即安装在环境中的包名。名称两边不加尖括号“&lt;&gt;”。<ol><li>如果要安装指定的版本号，则只需要在包名后面以<code>=</code>和版本号的形式执行。如：<code>conda create --name python2 python=2.7</code>，即创建一个名为“python2”的环境，环境中安装版本为2.7的python。</li><li>如果要在新创建的环境中创建多个包，则直接在<code>&lt;package_names&gt;</code>后以<strong>空格</strong>隔开，添加多个包名即可。如：<code>conda create -n python3 python=3.5 numpy pandas</code>，即创建一个名为“python3”的环境，环境中安装版本为3.5的python，同时也安装了numpy和pandas。</li></ol></li><li>默认情况下，新创建的环境将会被保存在<code>/Users/&lt;user_name&gt;/anaconda3/env</code>目录下，其中，<code>&lt;user_name&gt;</code>为当前用户的用户名。</li></ul><p><strong>切换环境</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Linux 或macOS</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> activate &lt;env_name&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Windows</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> activate &lt;env_name&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>如果创建环境后安装Python时没有指定Python的版本，那么将会安装与Anaconda版本相同的Python版本，即如果安装Anaconda第2版，则会自动安装Python 2.x；如果安装Anaconda第3版，则会自动安装Python 3.x。</p></li><li><p>当成功切换环境之后，在该行行首将以“(env_name)”或“[env_name]”开头。其中，“env_name”为切换到的环境名。如：在macOS系统中执行<code>source active python2</code>，即切换至名为“python2”的环境，则行首将会以(python2)开头。</p></li></ul><p><strong>退出环境至root</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Linux 或macOS</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> deactivate</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Windows</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> deactivate</span></span><br></pre></td></tr></table></figure><ul><li>当执行退出当前环境，回到root环境命令后，原本行首以 “(env_name)” 或 “[env_name]” 开头的字符将不再显示。</li></ul><p><strong>显示已创建的环境</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda info -envs</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> conda info -e</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> conda env list</span></span><br></pre></td></tr></table></figure><p><img src="/2020/12/15/python/6349AECA-85FB-4EBA-82CE-CCBE8F84A59B.png" alt="6349AECA-85FB-4EBA-82CE-CCBE8F84A59B"></p><ul><li>结果中星号<code>*</code>所在行即为当前所在环境。macOS系统中默认创建的环境名为<code>base</code>。</li></ul><p><strong>复制环境</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda create --name &lt;new_env_name&gt; --<span class="built_in">clone</span> &lt;copied_env_name&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;copied_env_name&gt;</code>即为被复制/克隆环境名。环境名两边不加尖括号“&lt;&gt;”</li><li><code>&lt;new_env_name&gt;</code>即为复制之后新环境的名称。环境名两边不加尖括号“&lt;&gt;”。<ul><li>如：<code>$ conda create --name py2 --clone python2</code>，即为克隆名为“python2”的环境，克隆后的新环境名为“py2”。此时，环境中将同时存在“python2”和“py2”环境，且两个环境的配置相同。</li></ul></li></ul><p><strong>删除环境</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda remove --name &lt;env_name&gt; --all</span></span><br></pre></td></tr></table></figure><p><strong>复制环境</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda create --name &lt;new_env_name&gt; --<span class="built_in">clone</span> &lt;copied_env_name&gt;</span></span><br></pre></td></tr></table></figure><h3 id="管理包"><a href="#管理包" class="headerlink" title="管理包"></a>管理包</h3><h4 id="1-查找可供安装的包版本"><a href="#1-查找可供安装的包版本" class="headerlink" title="1. 查找可供安装的包版本"></a>1. 查找可供安装的包版本</h4><ol><li>精确查找</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ conda search --full-name &lt;package_full_name&gt;</span><br></pre></td></tr></table></figure><ul><li><code>--full-name</code>：精确查找的参数。</li><li><code>&lt;package_full_name&gt;</code>：是被查找包的<strong>全名</strong>。包名两边不加尖括号“&lt;&gt;”。<ul><li>例如：<code>conda search --full-name python</code>即查找全名为“python”的包有哪些版本可供安装。</li></ul></li></ul><ol start="2"><li>模糊查找</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda search &lt;text&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;text&gt;</code>：查找含有<strong>此字段</strong>的包名。此字段两边不加尖括号“&lt;&gt;”。<ul><li>例如：<code>conda search py</code>即查找含有“py”字段的包，有哪些版本可供安装。</li></ul></li></ul><h4 id="2-获取当前环境中已安装的包信息"><a href="#2-获取当前环境中已安装的包信息" class="headerlink" title="2. 获取当前环境中已安装的包信息"></a>2. 获取当前环境中已安装的包信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda list</span></span><br></pre></td></tr></table></figure><ul><li>执行上述命令后将在终端显示当前环境已安装包的包名及其版本号。</li></ul><h4 id="3-安装包"><a href="#3-安装包" class="headerlink" title="3. 安装包"></a>3. 安装包</h4><ol><li><strong>在指定环境中安装包</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda install --name &lt;env_name&gt; &lt;package_name&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;env_name&gt;</code>：将包安装的指定环境名。环境名两边不加尖括号“&lt;&gt;”。</li><li><code>&lt;package_name&gt;</code>：要安装的包名。包名两边不加尖括号“&lt;&gt;”。<ul><li>例如：<code>conda install --name python2 pandas</code>即在名为“python2”的环境中安装pandas包。</li></ul></li></ul><ol start="2"><li><strong>在当前环境中安装包</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda install &lt;package_name&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;package_name&gt;</code>：要安装的包名。包名两边不加尖括号“&lt;&gt;”。</li><li>执行命令后在当前环境中安装包。<ul><li>例如：<code>conda install pandas</code>即在当前环境中安装pandas包。</li></ul></li></ul><ol start="3"><li><strong>使用pip安装包</strong></li></ol><p><strong>使用场景</strong>：</p><ul><li>当使用<code>conda install</code>无法进行安装时，可以使用pip进行安装。例如：see包。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> pip install &lt;package_name&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;pacage_name&gt;</code>：指定安装包的名称。包名两边不加尖括号“&lt;&gt;”。<ul><li>如：<code>pip install see</code>即安装see包。</li></ul></li></ul><p><strong>注意：</strong></p><ul><li>pip只是包管理器，无法对环境进行管理。因此如果想在指定环境中使用pip进行安装包，则需要先切换到指定环境中，再使用pip命令安装包。</li><li>pip无法更新python，因为pip并不将python视为包。</li><li>pip可以安装一些conda无法安装的包；conda也可以安装一些pip无法安装的包。因此当使用一种命令无法安装包时，可以尝试用另一种命令。</li></ul><ol start="4"><li><strong>从Anaconda.org安装包</strong></li></ol><p><strong>使用场景</strong></p><ul><li>当使用<code>conda install</code>无法进行安装时，可以考虑从Anaconda.org中获取安装包的命令，并进行安装。</li></ul><p><strong>注意</strong></p><ol><li>从Anaconda.org安装包时，无需注册。</li><li>在<strong>当前环境</strong>中安装来自于Anaconda.org的包时，需要通过输入要安装的包在Anaconda.org中的路径作为获取途径（channel）</li></ol><h4 id="4-卸载包"><a href="#4-卸载包" class="headerlink" title="4. 卸载包"></a>4. 卸载包</h4><ol><li>卸载指定环境中的包</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda remove --name &lt;env_name&gt; &lt;package_name&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;env_name&gt;</code>：卸载包所在指定环境的名称。环境名两边不加尖括号“&lt;&gt;”</li><li><code>&lt;package_name&gt;</code>：要卸载包的名称。包名两边不加尖括号“&lt;&gt;”。<ul><li>例如：<code>conda remove --name python2 pandas</code>即卸载名为“python2”中的pandas包。</li></ul></li></ul><ol start="2"><li>卸载当前环境中的包</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda remove &lt;package_name&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;package_name&gt;</code>：要卸载包的名称。包名两边不加尖括号“&lt;&gt;”。</li><li>执行命令后即在当前环境中卸载指定包。<ul><li>例如：<code>conda remove pandas</code>即在当前环境中卸载pandas包。</li></ul></li></ul><h4 id="5-更新包"><a href="#5-更新包" class="headerlink" title="5. 更新包"></a>5. 更新包</h4><ol><li>更新所有包</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda update --all</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> conda upgrade --all</span></span><br></pre></td></tr></table></figure><ul><li>建议：在安装Anaconda之后执行上述命令更新Anaconda中的所有包至最新版本，便于使用。</li></ul><ol start="2"><li>更新指定包</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda update &lt;package_name&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> conda upgrade &lt;package_name&gt;</span></span><br></pre></td></tr></table></figure><ul><li>注意：<ol><li><code>&lt;package_name&gt;</code>为指定更新的包名。包名两边不加尖括号“&lt;&gt;”。</li><li>更新多个指定包，则包名以<strong>空格</strong>隔开，向后排列。如：<code>conda update pandas numpy matplotlib</code>即更新pandas、numpy、matplotlib包。</li></ol></li></ul><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><p><a class="link" href="https://www.runoob.com/python/python-tutorial.html">菜鸟教程<i class="fas fa-external-link-alt"></i></a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>Python 是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言</li><li>Python 的设计具有很强的可读性，相比其他语言经常使用英文关键字，其他语言的一些标点符号，它具有比其他语言更有特色语法结构。<ul><li><strong>Python 是一种解释型语言：</strong>这意味着开发过程中没有了编译这个环节。类似于PHP和Perl语言。</li><li><strong>Python 是交互式语言：</strong>这意味着，您可以在一个 Python 提示符 <strong>&gt;&gt;&gt;</strong> 后直接执行代码。</li><li><strong>Python 是面向对象语言：</strong> 这意味着Python支持面向对象的风格或代码封装在对象的编程技术。</li><li><strong>Python 是初学者的语言：</strong>Python 对初级程序员而言，是一种伟大的语言，它支持广泛的应用程序开发，从简单的文字处理到 WWW 浏览器再到游戏。</li></ul></li></ul><p>特点：</p><ol><li><strong>易于学习：</strong>Python有相对较少的关键字，结构简单，和一个明确定义的语法，学习起来更加简单。</li><li><strong>易于阅读：</strong>Python代码定义的更清晰。</li><li><strong>易于维护：</strong>Python的成功在于它的源代码是相当容易维护的。</li><li><strong>一个广泛的标准库：</strong>Python的最大的优势之一是丰富的库，跨平台的，在UNIX，Windows和Macintosh兼容很好。</li><li><strong>互动模式：</strong>互动模式的支持，您可以从终端输入执行代码并获得结果的语言，互动的测试和调试代码片断。</li><li><strong>可移植：</strong>基于其开放源代码的特性，Python已经被移植（也就是使其工作）到许多平台。</li><li><strong>可扩展：</strong>如果你需要一段运行很快的关键代码，或者是想要编写一些不愿开放的算法，你可以使用C或C++完成那部分程序，然后从你的Python程序中调用。</li><li><strong>数据库：</strong>Python提供所有主要的商业数据库的接口。</li><li><strong>GUI编程：</strong>Python支持GUI可以创建和移植到许多系统调用。</li><li><strong>可嵌入：</strong>你可以将Python嵌入到C/C++程序，让你的程序的用户获得”脚本化”的能力。</li></ol><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><p>安装过程：自行百度云</p><p><strong>环境变量</strong></p><table><thead><tr><th>PYTHONPATH</th><th>PYTHONPATH是Python搜索路径，默认我们import的模块都会从PYTHONPATH里面寻找。</th></tr></thead><tbody><tr><td>PYTHONSTARTUP</td><td>Python启动后，先寻找PYTHONSTARTUP环境变量，然后执行此变量指定的文件中的代码。</td></tr><tr><td>PYTHONCASEOK</td><td>加入PYTHONCASEOK的环境变量, 就会使python导入模块的时候不区分大小写.</td></tr><tr><td>PYTHONHOME</td><td>另一种模块搜索路径。它通常内嵌于的PYTHONSTARTUP或PYTHONPATH目录中，使得两个模块库更容易切换。</td></tr></tbody></table><p><strong>集成开发环境（IDE, Integrated Development Environment）</strong>：PyCharm</p><ul><li>PyCharm 是由 JetBrains 打造的一款 Python IDE，支持 macOS、 Windows、 Linux 系统。</li><li>功能 : <ul><li>调试、语法高亮、Project管理、代码跳转、智能提示、自动完成、单元测试、版本控制……</li></ul></li><li><a class="link" href="https://www.jetbrains.com/pycharm/download/">下载地址<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" href="http://www.runoob.com/w3cnote/pycharm-windows-install.html](https://www.runoob.com/w3cnote/pycharm-windows-install.html)">安装地址<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="基础教程"><a href="#基础教程" class="headerlink" title="基础教程"></a>基础教程</h2><p><strong>中文编码</strong></p><img src="/2020/12/15/python/截屏2020-12-15 下午4.13.19.png" alt="截屏2020-12-15 下午4.13.19" style="zoom:60%;"><ul><li>python3.x源文件默认支持中文编码，无需制定</li><li>如果你使用编辑器，同时需要设置 py 文件存储的格式为 UTF-8，否则会出现错误信息<ul><li>进入 <strong>file &gt; Settings</strong>，在输入框搜索 <strong>encoding</strong>。</li><li>找到 <strong>Editor &gt; File encodings</strong>，将 <strong>IDE Encoding</strong> 和 <strong>Project Encoding</strong> 设置为utf-8。</li></ul></li></ul><h4 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> num     <span class="comment"># python2.x</span></span><br><span class="line"><span class="built_in">print</span> (num)   <span class="comment"># python3.x</span></span><br></pre></td></tr></table></figure><ul><li>默认换行输出，如果不需要换行，在末尾加入逗号<code>print x,</code>这样的话只会空格</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]: <span class="built_in">print</span> (x, end=<span class="string">&quot;。&quot;</span>)   <span class="comment"># 1。2。3。</span></span><br></pre></td></tr></table></figure><ul><li>指定以”。”为末尾输出，默认是”\n”换行</li></ul><p><strong>等待用户输入：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&quot;\n\n按下 enter 键后退出。&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>python2.x中使用python2.x的print函数</strong>：</p><ul><li><code>from __future__ import print_function</code></li><li>可以导入 <code>__future__</code>包，该包禁用 Python2.x 的 print 语句，采用 Python3.x 的 print 函数</li><li>Python3.x 与 Python2.x 的许多兼容性设计的功能可以通过  <code>__future__</code>这个包来导入</li></ul><h5 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h5><ul><li><p>标识符由字母、数字、下划线组成。</p></li><li><p>所有标识符可以包括英文、数字以及下划线(_)，但不能以数字开头。</p></li><li><p>Python 中的标识符是区分大小写的。</p></li><li><p>以<strong>下划线开头</strong>的标识符是有特殊意义的。</p><ul><li>以单下划线开头<code> _foo</code>的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用<code>from xxx import *</code>而导入。</li><li>以双下划线开头的<code>__foo</code>代表类的私有成员，以双下划线开头和结尾的 <code>__foo__</code>代表 Python 里特殊方法专用的标识<ul><li>如<code>__init__()</code>代表类的构造函数。</li></ul></li></ul></li><li><p>Python 可以同一行显示多条语句，方法是用分号 <strong>;</strong> 分开</p><ul><li><code>print (&#39;hello&#39;); print (&#39;world&#39;)</code></li></ul></li></ul><h5 id="保留字符"><a href="#保留字符" class="headerlink" title="保留字符"></a>保留字符</h5><ul><li>不能用作常数或变数，或任何其他标识符名称</li><li>所有 Python 的关键字只包含小写字母</li></ul><table><thead><tr><th>and</th><th>exec</th><th>not</th></tr></thead><tbody><tr><td>assert</td><td>finally</td><td>or</td></tr><tr><td>break</td><td>for</td><td>pass</td></tr><tr><td>class</td><td>from</td><td>print</td></tr><tr><td>continue</td><td>global</td><td>raise</td></tr><tr><td>def</td><td>if</td><td>return</td></tr><tr><td>del</td><td>import</td><td>try</td></tr><tr><td>elif</td><td>in</td><td>while</td></tr><tr><td>else</td><td>is</td><td>with</td></tr><tr><td>except</td><td>lambda</td><td>yield</td></tr></tbody></table><h5 id="行和缩进"><a href="#行和缩进" class="headerlink" title="行和缩进"></a>行和缩进</h5><ul><li>学习 Python 与其他语言最大的区别就是，Python 的代码块不使用大括号 <strong>{}</strong> 来控制类，函数以及其他逻辑判断。python 最具特色的就是用缩进来写模块。</li><li>缩进的空白数量是可变的，但是所有代码块语句必须包含相同的缩进空白数量，这个必须严格执行。<ul><li><img src="/2020/12/15/python/截屏2020-12-15 下午4.27.30.png" alt="截屏2020-12-15 下午4.27.30" style="zoom:50%;"></li></ul></li></ul><p><strong>多行语句：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">total = item_one + \</span><br><span class="line">        item_two + \</span><br><span class="line">        item_three</span><br><span class="line"><span class="comment"># 和</span></span><br><span class="line">days = [<span class="string">&#x27;Monday&#x27;</span>, <span class="string">&#x27;Tuesday&#x27;</span>, <span class="string">&#x27;Wednesday&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Thursday&#x27;</span>, <span class="string">&#x27;Friday&#x27;</span>]</span><br></pre></td></tr></table></figure><p><strong>引号：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">word = <span class="string">&#x27;word&#x27;</span></span><br><span class="line">sentence = <span class="string">&quot;这是一个句子。&quot;</span></span><br><span class="line">paragraph = <span class="string">&quot;&quot;&quot;这是一个段落</span></span><br><span class="line"><span class="string">包含了多个语句&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">多行注释1</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">多行注释2</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><ul><li>三引号可以由多行组成，编写多行文本的快捷语法，常用于文档字符串，在文件的特定地点，被当做注释。</li></ul><p><strong>空行：</strong></p><ul><li>函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。</li><li>空行与代码缩进不同，空行并不是Python语法的一部分。书写时不插入空行，Python解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。</li><li>记住：空行也是程序代码的一部分。</li></ul><h4 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h4><h5 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = b = c = <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>以上实例，创建一个整型对象，值为1，三个变量被分配到相同的内存空间上。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b, c = <span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;john&quot;</span></span><br></pre></td></tr></table></figure><ul><li>为多个对象指定多个变量</li></ul><h5 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h5><ol><li><p>算术运算符</p><ul><li>a = 10，b = 21</li></ul><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">+</td><td align="left">加 - 两个对象相加</td><td align="left">a + b 输出结果 31</td></tr><tr><td align="left">-</td><td align="left">减 - 得到负数或是一个数减去另一个数</td><td align="left">a - b 输出结果 -11</td></tr><tr><td align="left">*</td><td align="left">乘 - 两个数相乘或是返回一个被重复若干次的字符串</td><td align="left">a * b 输出结果 210</td></tr><tr><td align="left">/</td><td align="left">除 - x 除以 y</td><td align="left">b / a 输出结果 2.1</td></tr><tr><td align="left">%</td><td align="left">取模 - 返回除法的余数</td><td align="left">b % a 输出结果 1</td></tr><tr><td align="left">**</td><td align="left">幂 - 返回x的y次幂</td><td align="left">a**b 为10的21次方</td></tr><tr><td align="left">//</td><td align="left">取整除 - 向下取接近商的整数</td><td align="left"><code>&gt;&gt;&gt; 9//2 4 &gt;&gt;&gt; -9//2 -5</code></td></tr></tbody></table></li><li><p>比较（关系）运算符</p><ul><li>a = 10，b = 20</li></ul><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">==</td><td align="left">等于 - 比较对象是否相等</td><td align="left">(a == b) 返回 False。</td></tr><tr><td align="left">!=</td><td align="left">不等于 - 比较两个对象是否不相等</td><td align="left">(a != b) 返回 True。</td></tr><tr><td align="left">&gt;</td><td align="left">大于 - 返回x是否大于y</td><td align="left">(a &gt; b) 返回 False。</td></tr><tr><td align="left">&lt;</td><td align="left">小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。注意，这些变量名的大写。</td><td align="left">(a &lt; b) 返回 True。</td></tr><tr><td align="left">&gt;=</td><td align="left">大于等于 - 返回x是否大于等于y。</td><td align="left">(a &gt;= b) 返回 False。</td></tr><tr><td align="left">&lt;=</td><td align="left">小于等于 - 返回x是否小于等于y。</td><td align="left">(a &lt;= b) 返回 True。</td></tr></tbody></table></li><li><p>赋值运算符</p><ul><li>a = 10，b = 20</li></ul><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">=</td><td align="left">简单的赋值运算符</td><td align="left">c = a + b 将 a + b 的运算结果赋值为 c</td></tr><tr><td align="left">+=</td><td align="left">加法赋值运算符</td><td align="left">c += a 等效于 c = c + a</td></tr><tr><td align="left">-=</td><td align="left">减法赋值运算符</td><td align="left">c -= a 等效于 c = c - a</td></tr><tr><td align="left">*=</td><td align="left">乘法赋值运算符</td><td align="left">c *= a 等效于 c = c * a</td></tr><tr><td align="left">/=</td><td align="left">除法赋值运算符</td><td align="left">c /= a 等效于 c = c / a</td></tr><tr><td align="left">%=</td><td align="left">取模赋值运算符</td><td align="left">c %= a 等效于 c = c % a</td></tr><tr><td align="left">**=</td><td align="left">幂赋值运算符</td><td align="left">c **= a 等效于 c = c ** a</td></tr><tr><td align="left">//=</td><td align="left">取整除赋值运算符</td><td align="left">c //= a 等效于 c = c // a</td></tr><tr><td align="left">:=</td><td align="left">海象运算符，可在表达式内部为变量赋值。<strong>Python3.8 版本新增运算符</strong>。</td><td align="left">在这个示例中，赋值表达式可以避免调用 len() 两次:<br><code>if (n := len(a)) &gt; 10:    print(f&quot;List is too long (&#123;n&#125; elements, expected &lt;= 10)&quot;)</code></td></tr></tbody></table></li><li><p>逻辑运算符</p><ul><li>a = 10，b = 20</li></ul><table><thead><tr><th align="left">运算符</th><th align="left">逻辑表达式</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">and</td><td align="left">x and y</td><td align="left">布尔”与” - 如果 x 为 False，x and y 返回 x 的值，否则返回 y 的计算值。</td><td align="left">(a and b) 返回 20。</td></tr><tr><td align="left">or</td><td align="left">x or y</td><td align="left">布尔”或” - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。</td><td align="left">(a or b) 返回 10。</td></tr><tr><td align="left">not</td><td align="left">not x</td><td align="left">布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。</td><td align="left">not(a and b) 返回 False</td></tr></tbody></table></li><li><p>位运算符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">60</span>     <span class="comment"># 0011 1100</span></span><br><span class="line">b = <span class="number">13</span>     <span class="comment"># 0000 1101</span></span><br><span class="line">-----------------</span><br><span class="line">a&amp;b = <span class="number">12</span>   <span class="comment"># 0000 1100   按位与</span></span><br><span class="line">a|b = <span class="number">61</span>   <span class="comment"># 0011 1101   按位或</span></span><br><span class="line">a^b = <span class="number">49</span>   <span class="comment"># 0011 0001   按位异或</span></span><br><span class="line">~a = -<span class="number">61</span>   <span class="comment"># 1100 0011   按位取反</span></span><br><span class="line">a&lt;&lt;<span class="number">2</span> = <span class="number">240</span> <span class="comment"># 1111 0000   左移</span></span><br><span class="line">a&gt;&gt;<span class="number">2</span> = <span class="number">15</span>  <span class="comment"># 0000 1111   右移</span></span><br></pre></td></tr></table></figure></li><li><p>成员运算符</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">in</td><td align="left">如果在指定的序列中找到值返回 True，否则返回 False。</td><td align="left">x 在 y 序列中 , 如果 x 在 y 序列中返回 True。</td></tr><tr><td align="left">not in</td><td align="left">如果在指定的序列中没有找到值返回 True，否则返回 False。</td><td align="left">x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。</td></tr></tbody></table></li><li><p>身份运算符</p><ul><li>比较两个对象的存储单元</li><li><code>id()</code>：获取对象内存地址。</li><li>is和==<ul><li>is 用于判断两个变量引用对象是否为同一个</li><li> == 用于判断引用变量的值是否相等。</li></ul></li></ul><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">is</td><td align="left">is 是判断两个标识符是不是引用自一个对象</td><td align="left"><strong>x is y</strong>, 类似 <strong>id(x) == id(y)</strong> , 如果引用的是同一个对象则返回 True，否则返回 False</td></tr><tr><td align="left">is  not</td><td align="left">is not 是判断两个标识符是不是引用自不同对象</td><td align="left"><strong>x is not y</strong> ， 类似 **id(a) != id(b)**。如果引用的不是同一个对象则返回结果 True，否则返回 False。</td></tr></tbody></table></li><li><p>运算符优先级</p></li></ol><h5 id="标准数据类型"><a href="#标准数据类型" class="headerlink" title="标准数据类型"></a>标准数据类型</h5><ul><li>不可变数据：Number（数字）、String（字符串）、Tuple（元组）；<ul><li>变量赋值 <strong>a=5</strong> 后再赋值 <strong>a=10</strong>，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变 a 的值，相当于新生成了 a。</li></ul></li><li>可变数据：List（列表）、Dictionary（字典）、Set（集合）。<ul><li>变量赋值 <strong>la=[1,2,3,4]</strong> 后再赋值 <strong>la[2]=5</strong> 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。</li></ul></li></ul><h6 id="Numbers（数字）"><a href="#Numbers（数字）" class="headerlink" title="Numbers（数字）"></a>Numbers（数字）</h6><ul><li><p>数字数据类型用于存储数值。</p></li><li><p>他们是<strong>不可改变</strong>的数据类型，这意味着改变数字数据类型会分配一个新的对象。</p></li><li><p>当你指定一个值时，Number 对象就会被创建：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var1 = <span class="number">1</span></span><br><span class="line">var2 = <span class="number">10</span></span><br></pre></td></tr></table></figure><p><strong>删除</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> var1[,var2,[var3[..., varN]]]</span><br><span class="line"><span class="keyword">del</span> var</span><br><span class="line"><span class="keyword">del</span> var_a, var_b</span><br></pre></td></tr></table></figure><p><strong>数字类型</strong>：</p><ul><li>查询变量所指的对象类型<ul><li>内置的<code>type（）</code>函数：不会认为子类是一种父类类型</li><li><code>isinstance（）</code>：会认为子类是一种父类类型</li></ul></li></ul><table><thead><tr><th align="left">int</th><th align="left">long</th><th align="left">float</th><th align="left">complex</th></tr></thead><tbody><tr><td align="left">10</td><td align="left">51924361L</td><td align="left">0.0</td><td align="left">3.14j</td></tr><tr><td align="left">100</td><td align="left">-0x19323L</td><td align="left">15.20</td><td align="left">45.j</td></tr><tr><td align="left">-786</td><td align="left">0122L</td><td align="left">-21.9</td><td align="left">9.322e-36j</td></tr><tr><td align="left">080</td><td align="left">0xDEFABCECBDAECBFBAEl</td><td align="left">32.3e+18</td><td align="left">.876j</td></tr><tr><td align="left">-0490</td><td align="left">535633629843L</td><td align="left">-90.</td><td align="left">-.6545+0J</td></tr><tr><td align="left">-0x260</td><td align="left">-052318172735L</td><td align="left">-32.54e100</td><td align="left">3e+26J</td></tr><tr><td align="left">0x69</td><td align="left">-4721885298529L</td><td align="left">70.2E-12</td><td align="left">4.53e-7j</td></tr></tbody></table><ul><li><p>int（有符号整型）：通常被称为是整型或整数，是正或负整数，不带小数点</p></li><li><p>long（长整数）</p><ul><li><p>长整型也可以使用小写 l，但是还是建议您使用大写 L，避免与数字 1 混淆。Python使用 L 来显示长整型。</p><blockquote><p>long 类型只存在于 Python2.X 版本中，在 2.2 以后的版本中，int 类型数据溢出后会自动转为long类型。在 Python3.X 版本中 long 类型被移除，使用 int 替代。</p></blockquote></li></ul></li><li><p>float（浮点数）： 浮点型由整数部分与小数部分组成，浮点型也可以使用科学计数法表示（2.5e2 = 2.5 x 102 = 250）</p></li><li><p>bool（布尔值）</p><ul><li><blockquote><p>python2中没有这个数据类型</p></blockquote></li></ul></li><li><p>complex（复数）</p><ul><li>复数由实数部分和虚数部分构成，可以用 a + bj,或者 complex(a,b) 表示</li><li>复数的实部 a 和虚部 b 都是浮点型。</li></ul></li></ul><p><strong>运算：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> / <span class="number">4</span>    <span class="comment"># 除法，得到一个浮点数</span></span><br><span class="line"><span class="number">2</span> // <span class="number">4</span>   <span class="comment"># 除法，得到一个整数，但不一定是int类型的整数，可能是 1.0</span></span><br><span class="line"><span class="number">17</span> % <span class="number">3</span>   <span class="comment"># 取余</span></span><br><span class="line"><span class="number">2</span> ** <span class="number">5</span>   <span class="comment"># 乘方，得到32</span></span><br></pre></td></tr></table></figure><h6 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;hello world&quot;</span></span><br><span class="line">s[<span class="number">0</span>] = <span class="string">&#x27;1&#x27;</span>   <span class="comment"># 会报错</span></span><br></pre></td></tr></table></figure><p><strong>下标索引</strong></p><img src="/2020/12/15/python/截屏2020-12-15 下午6.08.56.png" alt="截屏2020-12-15 下午6.08.56" style="zoom:33%;"><ul><li>左往右：0开始，右往左：-1开始</li></ul><blockquote><p>在Python2中，普通字符串是以8位ASCII码进行存储的，而Unicode字符串则存储为16位unicode字符串，这样能够表示更多的字符集。使用的语法是在字符串前面加上前缀 <strong>u</strong>。</p><p>在Python3中，所有的字符串都是Unicode字符串</p></blockquote><p><strong>字符串操作</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&#x27;abcdef&#x27;</span></span><br><span class="line"><span class="built_in">print</span> (s[<span class="number">1</span>:<span class="number">5</span>])    <span class="comment"># bcde</span></span><br><span class="line"><span class="built_in">print</span> (s[<span class="number">1</span>:<span class="number">5</span>:<span class="number">2</span>])  <span class="comment"># bd</span></span><br><span class="line"><span class="built_in">print</span> (s * <span class="number">2</span>)     <span class="comment"># abcdefabcdef</span></span><br><span class="line"><span class="built_in">print</span> (s[:<span class="number">2</span>] + <span class="string">&#x27;11&#x27;</span>)  <span class="comment"># ab11</span></span><br></pre></td></tr></table></figure><ul><li>使用<code>[头下标:尾下标:步长]</code>来截取字符串，在头下标-尾下标的范围内以步长来截取字符</li><li><strong>注意</strong>：所有的截取都取不到尾下标</li></ul><p><strong>原始字符串：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">r&#x27;\n&#x27;</span>)    <span class="comment"># \n，不会进行换行，而是直接输出</span></span><br></pre></td></tr></table></figure><ul><li>所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。</li><li> 原始字符串除在字符串的第一个引号前加上字母 <strong>r/R</strong>以外，与普通字符串有着几乎完全相同的语法。</li></ul><p><strong>字符串格式化：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> (<span class="string">&quot;我叫 %s 今年 %d 岁!&quot;</span> % (<span class="string">&#x27;小明&#x27;</span>, <span class="number">10</span>))</span><br><span class="line"><span class="comment"># 我叫 小明 今年 10 岁!</span></span><br></pre></td></tr></table></figure><ul><li><p>使用与 C 中 sprintf 函数一样的语法。</p><blockquote><p>Python2.6 开始，新增了一种格式化字符串的函数 str.format()，它增强了字符串格式化的功能。</p></blockquote></li></ul><p><strong>f-string：</strong></p><ul><li>之后版本添加的，称之为字面量格式化字符串，是新的格式化字符串的语法。</li><li>不用再去判断使用 %s，还是 %d。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#### 以前 ###</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">&#x27;world&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;Hello %s&#x27;</span> % name</span><br><span class="line"><span class="string">&#x27;Hello world&#x27;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">#### 现在 ###</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">&#x27;world&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f&#x27;Hello <span class="subst">&#123;name&#125;</span>&#x27;</span>  <span class="comment"># 替换变量</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f&#x27;<span class="subst">&#123;<span class="number">1</span>+<span class="number">2</span>&#125;</span>&#x27;</span>         <span class="comment"># 使用表达式</span></span><br><span class="line"><span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>w = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;url&#x27;</span>: <span class="string">&#x27;www.runoob.com&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f&#x27;<span class="subst">&#123;w[<span class="string">&quot;name&quot;</span>]&#125;</span>: <span class="subst">&#123;w[<span class="string">&quot;url&quot;</span>]&#125;</span>&#x27;</span></span><br><span class="line"><span class="string">&#x27;Runoob: www.runoob.com&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">f&#x27;<span class="subst">&#123;x+<span class="number">1</span>&#125;</span>&#x27;</span>)   <span class="comment"># Python 3.6</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">f&#x27;<span class="subst">&#123;x+<span class="number">1</span>=&#125;</span>&#x27;</span>)  <span class="comment"># Python 3.8</span></span><br><span class="line"><span class="string">&#x27;x+1=2&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>内建函数：</strong></p><ul><li><p>列表 = 字符串.split(“str”)</p></li><li><p>capitalize()</p><ul><li>将字符串的第一个字符转换为大写</li></ul></li><li><p>center(width, fillchar)</p><ul><li>返回一个指定的宽度 width 居中的字符串，fillchar 为填充的字符，默认为空格。</li></ul></li><li><p>count(str, beg= 0,end=len(string))</p><ul><li>返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数</li></ul></li><li><p>bytes.decode(encoding=”utf-8”, errors=”strict”)</p><blockquote><p>Python3 中没有 decode 方法，但我们可以使用 bytes 对象的 decode() 方法来解码给定的 bytes 对象，这个 bytes 对象可以由 str.encode() 来编码返回。</p></blockquote></li><li><p>encode(encoding=’UTF-8’,errors=’strict’)</p><ul><li>以 encoding 指定的编码格式编码字符串，如果出错默认报一个ValueError 的异常，除非 errors 指定的是’ignore’或者’replace’</li></ul></li><li><p>endswith(suffix, beg=0, end=len(string))</p><ul><li>检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False.</li></ul></li><li><p>expandtabs(tabsize=8)</p><ul><li>把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8 。<br>8    </li></ul></li><li><p>find(str, beg=0, end=len(string))</p><ul><li>检测 str 是否包含在字符串中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1</li></ul></li><li><p>index(str, beg=0, end=len(string))</p><ul><li>跟find()方法一样，只不过如果str不在字符串中会报一个异常。</li></ul></li><li><p>isalnum()</p><ul><li>如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 True，否则返回 False</li></ul></li><li><p>isalpha()</p><ul><li>如果字符串至少有一个字符并且所有字符都是字母或中文字则返回 True, 否则返回 False</li></ul></li><li><p>isdigit()</p><ul><li>如果字符串只包含数字则返回 True 否则返回 False..</li></ul></li><li><p>islower()</p><ul><li>如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False</li></ul></li><li><p>isnumeric()</p><ul><li>如果字符串中只包含数字字符，则返回 True，否则返回 False</li></ul></li><li><p>isspace()</p><ul><li>如果字符串中只包含空白，则返回 True，否则返回 False.</li></ul></li><li><p>istitle()</p><ul><li>如果字符串是标题化的(见 title())则返回 True，否则返回 False</li></ul></li><li><p>isupper()</p><ul><li>如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False</li></ul></li><li><p>join(seq)</p><ul><li>以指定字符串作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串</li></ul></li><li><p>len(string)</p><ul><li>返回字符串长度</li></ul></li><li><p>ljust(width[, fillchar])</p><ul><li>返回一个原字符串左对齐,并使用 fillchar 填充至长度 width 的新字符串，fillchar 默认为空格。</li></ul></li><li><p>lower()</p><ul><li>转换字符串中所有大写字符为小写.</li></ul></li><li><p>lstrip()</p><ul><li>截掉字符串左边的空格或指定字符。</li></ul></li><li><p>maketrans()</p><ul><li>创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目</li></ul></li><li><p>max(str)</p><ul><li>返回字符串 str 中最大的字母。</li></ul></li><li><p>min(str)</p><ul><li>返回字符串 str 中最小的字母。</li></ul></li><li><p>replace(old, new [, max])</p><ul><li>把将字符串中的 old 替换成 new,如果 max 指定，则替换不超过 max 次。</li></ul></li><li><p>rfind(str, beg=0,end=len(string))</p><ul><li>类似于 find()函数，不过是从右边开始查找.</li></ul></li><li><p>rindex( str, beg=0, end=len(string))</p><ul><li>类似于 index()，不过是从右边开始.</li></ul></li><li><p>rjust(width,[, fillchar])</p><ul><li>返回一个原字符串右对齐,并使用fillchar(默认空格）填充至长度 width 的新字符串</li></ul></li><li><p>rstrip()</p><ul><li>删除字符串字符串末尾的空格.</li></ul></li><li><p>split(str=””, num=string.count(str))</p><ul><li>以 str 为分隔符截取字符串，如果 num 有指定值，则仅截取 num+1 个子字符串</li></ul></li><li><p>splitlines([keepends])</p><ul><li>按照行(‘\r’, ‘\r\n’, \n’)分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。</li></ul></li><li><p>startswith(substr, beg=0,end=len(string))</p><ul><li>检查字符串是否是以指定子字符串 substr 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查。</li></ul></li><li><p>strip([chars])</p><ul><li>在字符串上执行 lstrip()和 rstrip()</li></ul></li><li><p>swapcase()</p><ul><li>将字符串中大写转换为小写，小写转换为大写</li></ul></li><li><p>title()</p><ul><li>返回”标题化”的字符串,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle())</li></ul></li><li><p>translate(table, deletechars=””)</p><ul><li>根据 str 给出的表(包含 256 个字符)转换 string 的字符, 要过滤掉的字符放到 deletechars 参数中</li></ul></li><li><p>upper()</p><ul><li>转换字符串中的小写字母为大写</li></ul></li><li><p>zfill (width)</p><ul><li>返回长度为 width 的字符串，原字符串右对齐，前面填充0</li></ul></li><li><p>isdecimal()</p><ul><li>检查字符串是否只包含十进制字符，如果是返回 true，否则返回 false。</li></ul></li></ul><table><thead><tr><th align="left">序号</th><th align="left">方法及描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-capitalize.html">capitalize()<i class="fas fa-external-link-alt"></i></a> <br>将字符串的第一个字符转换为大写</td></tr><tr><td align="left">2</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-center.html">center(width, fillchar)<i class="fas fa-external-link-alt"></i></a> <br>返回一个指定的宽度 width 居中的字符串，fillchar 为填充的字符，默认为空格。</td></tr><tr><td align="left">3</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-count.html">count(str, beg= 0,end=len(string))<i class="fas fa-external-link-alt"></i></a> <br>返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数</td></tr><tr><td align="left">4</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-decode.html">bytes.decode(encoding=”utf-8”, errors=”strict”)<i class="fas fa-external-link-alt"></i></a><br> Python3 中没有 decode 方法，但我们可以使用 bytes 对象的 decode() 方法来解码给定的 bytes 对象，这个 bytes 对象可以由 str.encode() 来编码返回。</td></tr><tr><td align="left">5</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-encode.html">encode(encoding=’UTF-8’,errors=’strict’)<i class="fas fa-external-link-alt"></i></a> <br>以 encoding 指定的编码格式编码字符串，如果出错默认报一个ValueError 的异常，除非 errors 指定的是’ignore’或者’replace’</td></tr><tr><td align="left">6</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-endswith.html">endswith(suffix, beg=0, end=len(string))<i class="fas fa-external-link-alt"></i></a> <br>检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False.</td></tr><tr><td align="left">7</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-expandtabs.html">expandtabs(tabsize=8)<i class="fas fa-external-link-alt"></i></a> <br>把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8 。</td></tr><tr><td align="left">8</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-find.html">find(str, beg=0, end=len(string))<i class="fas fa-external-link-alt"></i></a> <br>检测 str 是否包含在字符串中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1</td></tr><tr><td align="left">9</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-index.html">index(str, beg=0, end=len(string))<i class="fas fa-external-link-alt"></i></a> <br>跟find()方法一样，只不过如果str不在字符串中会报一个异常。</td></tr><tr><td align="left">10</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-isalnum.html">isalnum()<i class="fas fa-external-link-alt"></i></a> <br>如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 True，否则返回 False</td></tr><tr><td align="left">11</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-isalpha.html">isalpha()<i class="fas fa-external-link-alt"></i></a> <br>如果字符串至少有一个字符并且所有字符都是字母或中文字则返回 True, 否则返回 False</td></tr><tr><td align="left">12</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-isdigit.html">isdigit()<i class="fas fa-external-link-alt"></i></a> <br>如果字符串只包含数字则返回 True 否则返回 False..</td></tr><tr><td align="left">13</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-islower.html">islower()<i class="fas fa-external-link-alt"></i></a> <br>如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False</td></tr><tr><td align="left">14</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-isnumeric.html">isnumeric()<i class="fas fa-external-link-alt"></i></a> <br>如果字符串中只包含数字字符，则返回 True，否则返回 False</td></tr><tr><td align="left">15</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-isspace.html">isspace()<i class="fas fa-external-link-alt"></i></a> <br>如果字符串中只包含空白，则返回 True，否则返回 False.</td></tr><tr><td align="left">16</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-istitle.html">istitle()<i class="fas fa-external-link-alt"></i></a> <br>如果字符串是标题化的(见 title())则返回 True，否则返回 False</td></tr><tr><td align="left">17</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-isupper.html">isupper()<i class="fas fa-external-link-alt"></i></a><br>如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False</td></tr><tr><td align="left">18</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-join.html">join(seq)<i class="fas fa-external-link-alt"></i></a> <br>以指定字符串作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串</td></tr><tr><td align="left">19</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-len.html">len(string)<i class="fas fa-external-link-alt"></i></a> <br>返回字符串长度</td></tr><tr><td align="left">20</td><td align="left">ljust(width[, fillchar]) <br>返回一个原字符串左对齐,并使用 fillchar 填充至长度 width 的新字符串，fillchar 默认为空格。</td></tr><tr><td align="left">21</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-lower.html">lower()<i class="fas fa-external-link-alt"></i></a> <br>转换字符串中所有大写字符为小写.</td></tr><tr><td align="left">22</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-lstrip.html">lstrip()<i class="fas fa-external-link-alt"></i></a> <br>截掉字符串左边的空格或指定字符。</td></tr><tr><td align="left">23</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-maketrans.html">maketrans()<i class="fas fa-external-link-alt"></i></a><br> 创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。</td></tr><tr><td align="left">24</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-max.html">max(str)<i class="fas fa-external-link-alt"></i></a> <br>返回字符串 str 中最大的字母。</td></tr><tr><td align="left">25</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-min.html">min(str)<i class="fas fa-external-link-alt"></i></a> <br>返回字符串 str 中最小的字母。</td></tr><tr><td align="left">26</td><td align="left">[replace(old, new [, max])] <br>把 将字符串中的 old 替换成 new,如果 max 指定，则替换不超过 max 次。</td></tr><tr><td align="left">27</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-rfind.html">rfind(str, beg=0,end=len(string))<i class="fas fa-external-link-alt"></i></a> <br>类似于 find()函数，不过是从右边开始查找.</td></tr><tr><td align="left">28</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-rindex.html">rindex( str, beg=0, end=len(string))<i class="fas fa-external-link-alt"></i></a> <br>类似于 index()，不过是从右边开始.</td></tr><tr><td align="left">29</td><td align="left">rjust(width,[, fillchar])<br>返回一个原字符串右对齐,并使用fillchar(默认空格）填充至长度 width 的新字符串</td></tr><tr><td align="left">30</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-rstrip.html">rstrip()<i class="fas fa-external-link-alt"></i></a> <br>删除字符串字符串末尾的空格.</td></tr><tr><td align="left">31</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-split.html">split(str=””, num=string.count(str))<i class="fas fa-external-link-alt"></i></a> <br>以 str 为分隔符截取字符串，如果 num 有指定值，则仅截取 num+1 个子字符串</td></tr><tr><td align="left">32</td><td align="left">splitlines([keepends]) <br>按照行(‘\r’, ‘\r\n’, \n’)分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。</td></tr><tr><td align="left">33</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-startswith.html">startswith(substr, beg=0,end=len(string))<i class="fas fa-external-link-alt"></i></a> <br>检查字符串是否是以指定子字符串 substr 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查。</td></tr><tr><td align="left">34</td><td align="left">strip([chars])<br>在字符串上执行 lstrip()和 rstrip()</td></tr><tr><td align="left">35</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-swapcase.html">swapcase()<i class="fas fa-external-link-alt"></i></a> <br>将字符串中大写转换为小写，小写转换为大写</td></tr><tr><td align="left">36</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-title.html">title()<i class="fas fa-external-link-alt"></i></a> <br>返回”标题化”的字符串,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle())</td></tr><tr><td align="left">37</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-translate.html">translate(table, deletechars=””)<i class="fas fa-external-link-alt"></i></a> <br>根据 str 给出的表(包含 256 个字符)转换 string 的字符, 要过滤掉的字符放到 deletechars 参数中</td></tr><tr><td align="left">38</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-upper.html">upper()<i class="fas fa-external-link-alt"></i></a> <br>转换字符串中的小写字母为大写</td></tr><tr><td align="left">39</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-zfill.html">zfill (width)<i class="fas fa-external-link-alt"></i></a> <br>返回长度为 width 的字符串，原字符串右对齐，前面填充0</td></tr><tr><td align="left">40</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-isdecimal.html">isdecimal()<i class="fas fa-external-link-alt"></i></a> <br>检查字符串是否只包含十进制字符，如果是返回 true，否则返回 false。</td></tr></tbody></table><h6 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h6><ul><li>通用符合数据类型，用[标识]</li><li>有序集合</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">0</span>, <span class="number">1</span>, <span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;def&#x27;</span>, <span class="number">4</span> ]</span><br><span class="line">y = [<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> (x[<span class="number">2</span>:<span class="number">4</span>])   <span class="comment"># [&#x27;abc&#x27;, &#x27;def&#x27;]</span></span><br><span class="line"><span class="built_in">print</span> (x * <span class="number">2</span>)    <span class="comment"># [0, 1, &#x27;abc&#x27;, &#x27;def&#x27;, 4, 0, 1, &#x27;abc&#x27;, &#x27;def&#x27;, 4]</span></span><br><span class="line"><span class="built_in">print</span> (x + y)    <span class="comment"># [0, 1, &#x27;abc&#x27;, &#x27;def&#x27;, 4, &#x27;b&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> x[<span class="number">1</span>]         <span class="comment"># 使用del删除列表元素</span></span><br><span class="line"><span class="built_in">print</span> (x)        <span class="comment"># [0, &#x27;abc&#x27;, &#x27;def&#x27;, 4 ]</span></span><br></pre></td></tr></table></figure><p><strong>迭代</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> a: print(x, end=<span class="string">&quot;。&quot;</span>)</span><br><span class="line"><span class="comment"># 1。2。3。      迭代列表a，每个元素后面跟&quot;。&quot;</span></span><br></pre></td></tr></table></figure><p><strong>内置函数：</strong></p><ul><li>字符串 = ‘char’.join(列表)</li><li>len(list)<ul><li>列表元素个数</li></ul></li><li>max(list)<ul><li>返回列表元素最大值</li></ul></li><li>min(list)<ul><li>返回列表元素最小值</li></ul></li><li>list(seq)<ul><li>将元组转换为列表</li></ul></li></ul><p><strong>方法</strong></p><ul><li>list.append(obj)<ul><li>在列表末尾添加新的对象</li></ul></li><li>list.count(obj)<ul><li>统计某个元素在列表中出现的次数</li></ul></li><li>list.extend(seq)<ul><li>在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</li></ul></li><li>list.index(obj)<ul><li>从列表中找出某个值第一个匹配项的索引位置</li></ul></li><li>list.insert(index, obj)<ul><li>将对象插入列表</li></ul></li><li>list.pop([index=-1])<ul><li>移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</li></ul></li><li>list.remove(obj)<ul><li>移除列表中某个值的第一个匹配项</li></ul></li><li>list.reverse()<ul><li>反向列表中元素</li></ul></li><li>list.sort( key=None, reverse=False)<ul><li>对原列表进行排序</li></ul></li><li>list.clear()<ul><li>清空列表</li></ul></li><li>list.copy()<ul><li>复制列表</li></ul></li></ul><p><strong>列表元素反转</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseWords</span>(<span class="params"><span class="built_in">input</span></span>):</span> </span><br><span class="line">      </span><br><span class="line">    <span class="comment"># 通过空格将字符串分隔符，把各个单词分隔为列表[&#x27;I&#x27;, &#x27;like&#x27;, &#x27;runoob&#x27;]</span></span><br><span class="line">    inputWords = <span class="built_in">input</span>.split(<span class="string">&quot; &quot;</span>) </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 翻转字符串</span></span><br><span class="line">    <span class="comment"># 假设列表 list = [1,2,3,4],  </span></span><br><span class="line">    <span class="comment"># list[0]=1, list[1]=2 ，而 -1 表示最后一个元素 list[-1]=4 ( 与 list[3]=4 一样) </span></span><br><span class="line">    <span class="comment"># inputWords[-1::-1] 有三个参数</span></span><br><span class="line">    <span class="comment"># 第一个参数 -1 表示最后一个元素</span></span><br><span class="line">    <span class="comment"># 第二个参数为空，表示移动到列表末尾</span></span><br><span class="line">    <span class="comment"># 第三个参数为步长，-1 表示逆向</span></span><br><span class="line">    inputWords=inputWords[-<span class="number">1</span>::-<span class="number">1</span>] </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 重新组合字符串，与split相反，将inputWords列表中的每个对象以空格合并</span></span><br><span class="line">    output = <span class="string">&#x27; &#x27;</span>.join(inputWords) </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> output </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>: </span><br><span class="line">    <span class="built_in">input</span> = <span class="string">&#x27;I like runoob&#x27;</span></span><br><span class="line">    rw = reverseWords(<span class="built_in">input</span>) </span><br><span class="line">    print(rw)</span><br></pre></td></tr></table></figure><h6 id="Tuple（元组）"><a href="#Tuple（元组）" class="headerlink" title="Tuple（元组）"></a>Tuple（元组）</h6><ul><li><p>元组是另一个数据类型，类似于 List（列表）。</p></li><li><p>元组用 <strong>()</strong> 标识。内部元素用逗号隔开。</p></li><li><p>与字符串一样，元组的元素不能修改，相当于只读列表。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">y = <span class="number">4</span></span><br><span class="line">z = (x, y)</span><br><span class="line">print(z)        <span class="comment"># ([1, 2], 4)</span></span><br><span class="line"></span><br><span class="line">x.append(<span class="number">3</span>)</span><br><span class="line">print(z)        <span class="comment"># ([1, 2, 3], 4)</span></span><br><span class="line"></span><br><span class="line">x[<span class="number">0</span>] = <span class="number">333</span></span><br><span class="line">print(z)        <span class="comment"># ([333, 2, 3], 4)</span></span><br><span class="line"></span><br><span class="line">x = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]   </span><br><span class="line">print(z)        <span class="comment"># ([1, 2, 3], 4)，相当于x换了个对象，所以不行</span></span><br><span class="line"></span><br><span class="line">z[<span class="number">0</span>] = <span class="string">&#x27;123&#x27;</span>    <span class="comment"># 会报错，元组是不可变的</span></span><br><span class="line"></span><br><span class="line">z = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)   <span class="comment"># 重新赋值的元组 z，绑定到新的对象了，不是修改了原来的对象。</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tup1 = ()      <span class="comment"># 创建空元组</span></span><br><span class="line">tup1 = (<span class="number">50</span>)    <span class="comment"># 整数50</span></span><br><span class="line">tup1 = (<span class="number">50</span>,)   <span class="comment"># 元组</span></span><br></pre></td></tr></table></figure><ul><li>元组中只包含一个元素时，需要在元素后面添加逗号，否则括号会被当作运算符使用</li></ul><p><strong>内置函数：</strong></p><ul><li><p>len(tuple)</p><ul><li>计算元组元素个数。    </li></ul></li><li><p>max(tuple)</p><ul><li>返回元组中元素最大值。    </li></ul></li><li><p>min(tuple)</p><ul><li>返回元组中元素最小值。    </li></ul></li><li><p>tuple(iterable)</p><ul><li><p>将可迭代系列转换为元组。</p></li><li><pre><code class="python">&gt;&gt;&gt; list1= [&#39;Google&#39;, &#39;Taobao&#39;, &#39;Runoob&#39;, &#39;Baidu&#39;]&gt;&gt;&gt; tuple1=tuple(list1)&gt;&gt;&gt; tuple1(&#39;Google&#39;, &#39;Taobao&#39;, &#39;Runoob&#39;, &#39;Baidu&#39;)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###### Set（集合）</span><br><span class="line"></span><br><span class="line">* 集合（set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员。</span><br><span class="line">* 基本功能是进行成员关系测试和删除重复元素。</span><br><span class="line">* 可以使用大括号 **&#123; &#125;** 或者 **set()** 函数创建集合</span><br><span class="line">  * **注意**：创建一个空集合必须用 **set()** 而不是 **&#123; &#125;**，因为 **&#123; &#125;** 是用来创建一个空字典。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line">parame &#x3D; &#123;value01,value02,...&#125;</span><br><span class="line"># 或者</span><br><span class="line">parame &#x3D; set(value)</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><p><strong>集合运算</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">set</span>(<span class="string">&#x27;abracadabra&#x27;</span>)</span><br><span class="line">b = <span class="built_in">set</span>(<span class="string">&#x27;alacazam&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 成员测试</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">in</span> sites :</span><br><span class="line">    print(<span class="string">&#x27;a 在集合中&#x27;</span>)     <span class="comment"># true</span></span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">    print(<span class="string">&#x27;a 不在集合中&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结合运算</span></span><br><span class="line">print(a)      <span class="comment">#               &#123;&#x27;b&#x27;, &#x27;c&#x27;, &#x27;a&#x27;, &#x27;r&#x27;, &#x27;d&#x27;&#125;</span></span><br><span class="line">print(a - b)  <span class="comment"># a 和 b 的差集  &#123;&#x27;r&#x27;, &#x27;b&#x27;, &#x27;d&#x27;&#125;</span></span><br><span class="line">print(a | b)  <span class="comment"># a 和 b 的并集  &#123;&#x27;b&#x27;, &#x27;c&#x27;, &#x27;a&#x27;, &#x27;z&#x27;, &#x27;m&#x27;, &#x27;r&#x27;, &#x27;l&#x27;, &#x27;d&#x27;&#125;</span></span><br><span class="line">print(a &amp; b)  <span class="comment"># a 和 b 的交集  &#123;&#x27;c&#x27;, &#x27;a&#x27;&#125;</span></span><br><span class="line">print(a ^ b)  <span class="comment"># a 和 b 中不同时存在的元素 &#123;&#x27;z&#x27;, &#x27;b&#x27;, &#x27;m&#x27;, &#x27;r&#x27;, &#x27;l&#x27;, &#x27;d&#x27;&#125;</span></span><br></pre></td></tr></table></figure><p><strong>基本操作：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">set</span>(<span class="string">&#x27;abracadabra&#x27;</span>)</span><br><span class="line">a.add(<span class="string">&#x27;h&#x27;</span>)      <span class="comment"># &#123;&#x27;a&#x27;, &#x27;h&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;r&#x27;, &#x27;d&#x27;&#125;</span></span><br><span class="line">s.update(<span class="string">&#x27;h&#x27;</span>)   <span class="comment"># 效果相同</span></span><br><span class="line"></span><br><span class="line">s.remove(<span class="string">&#x27;h&#x27;</span>)   <span class="comment"># &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;r&#x27;, &#x27;d&#x27;&#125;</span></span><br><span class="line">s.discard(<span class="string">&#x27;h&#x27;</span>)  <span class="comment"># 效果相同</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机删除集合中的一个元素</span></span><br><span class="line">x = a.pop()     <span class="comment"># x为a中随机一个元素</span></span><br></pre></td></tr></table></figure><p><strong>内置函数：</strong></p><ul><li>len(set)<ul><li>输出集合的个数</li></ul></li></ul><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">add()</td><td align="left">为集合添加元素</td></tr><tr><td align="left">clear()</td><td align="left">移除集合中的所有元素</td></tr><tr><td align="left">copy()</td><td align="left">拷贝一个集合</td></tr><tr><td align="left">difference()</td><td align="left">返回多个集合的差集</td></tr><tr><td align="left">difference_update()</td><td align="left">移除集合中的元素，该元素在指定的集合也存在。</td></tr><tr><td align="left">discard()</td><td align="left">删除集合中指定的元素</td></tr><tr><td align="left">intersection()</td><td align="left">返回集合的交集</td></tr><tr><td align="left">intersection_update()</td><td align="left">返回集合的交集。</td></tr><tr><td align="left">isdisjoint()</td><td align="left">判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 False。</td></tr><tr><td align="left">issubset()</td><td align="left">判断指定集合是否为该方法参数集合的子集。</td></tr><tr><td align="left">issuperset()</td><td align="left">判断该方法的参数集合是否为指定集合的子集</td></tr><tr><td align="left">pop()</td><td align="left">随机移除元素</td></tr><tr><td align="left">remove()</td><td align="left">移除指定元素</td></tr><tr><td align="left">symmetric_difference()</td><td align="left">返回两个集合中不重复的元素集合。</td></tr><tr><td align="left">symmetric_difference_update()</td><td align="left">移除当前集合中在另外一个指定集合相同的元素，并将另外一个指定集合中不同的元素插入到当前集合中。</td></tr><tr><td align="left">union()</td><td align="left">返回两个集合的并集</td></tr><tr><td align="left">update()</td><td align="left">给集合添加元素</td></tr></tbody></table><h6 id="Dictionary（字典）"><a href="#Dictionary（字典）" class="headerlink" title="Dictionary（字典）"></a>Dictionary（字典）</h6><ul><li>列表是有序的对象集合，字典是无序的对象集合。</li><li>两者之间的区别在于：<ul><li>字典当中的元素是通过键来存取的，而不是通过偏移存取。</li></ul></li><li>字典是一种映射类型，字典用 <strong>{ }</strong> 标识，它是一个无序的 <strong>键(key) : 值(value)</strong> 的集合。<ul><li>键(key)必须使用<strong>不可变类型</strong>。（列表等不行）</li><li>在同一个字典中，键(key)必须是<strong>唯一</strong>的，重复时选择后一个</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dict</span> = &#123;&#125;     <span class="comment"># 创建空字典</span></span><br><span class="line"><span class="built_in">dict</span>[<span class="string">&#x27;one&#x27;</span>] = <span class="string">&quot;111&quot;</span></span><br><span class="line"><span class="built_in">dict</span>[<span class="number">2</span>]     = <span class="string">&quot;222&quot;</span></span><br><span class="line"></span><br><span class="line">tinydict = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;aaa&#x27;</span>,<span class="string">&#x27;b&#x27;</span>:<span class="number">1</span>, (c): <span class="string">&#x27;ccc&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">dict</span>[<span class="string">&#x27;one&#x27;</span>])       <span class="comment"># 输出键为 &#x27;one&#x27; 的值  &quot;111&quot;</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">dict</span>[<span class="number">2</span>])           <span class="comment"># 输出键为 2 的值      &quot;222&quot;</span></span><br><span class="line"><span class="built_in">print</span> (tinydict)          <span class="comment"># 输出完整的字典   &#123;&#x27;a&#x27;:&#x27;aaa&#x27;,&#x27;b&#x27;:1,(c):&#x27;ccc&#x27;&#125;</span></span><br><span class="line"><span class="built_in">print</span> (tinydict.keys())   <span class="comment"># 输出所有键   dict_keys([&#x27;a&#x27;, &#x27;b&#x27;, (c)])</span></span><br><span class="line"><span class="built_in">print</span> (tinydict.values()) <span class="comment"># 输出所有值   dict_values([&#x27;aaa&#x27;, 1, &#x27;ccc&#x27;])</span></span><br></pre></td></tr></table></figure><p><strong>内置函数</strong></p><ul><li><p>构造函数<code>dict（）</code>：</p><ul><li><pre><code class="python">&gt;&gt;&gt; dict([(&#39;aa&#39;, 1), (&#39;bb&#39;, 2), (&#39;cc&#39;, 3)])&#123;&#39;aa&#39;: 1, &#39;bb&#39;: 2, &#39;cc&#39;: 3&#125;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* len(dict)</span><br><span class="line">  * 计算字典元素个数，即键的总数</span><br><span class="line">* str(dict)</span><br><span class="line">  * 输出字典，以可打印的字符串表示。</span><br><span class="line">* type(variable)</span><br><span class="line">  * 返回输入的变量类型，如果变量是字典就返回字典类型。</span><br><span class="line">* keys()</span><br><span class="line">* values()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">| 序号 | 函数及描述                                                   |</span><br><span class="line">| :--- | :----------------------------------------------------------- |</span><br><span class="line">| 1    | [radiansdict.clear()](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-dictionary-clear.html) &lt;br &#x2F;&gt;删除字典内所有元素 |</span><br><span class="line">| 2    | [radiansdict.copy()](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-dictionary-copy.html) &lt;br &#x2F;&gt;返回一个字典的浅复制 |</span><br><span class="line">| 3    | [radiansdict.fromkeys()](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-dictionary-fromkeys.html) &lt;br &#x2F;&gt;创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值 |</span><br><span class="line">| 4    | [radiansdict.get(key, default&#x3D;None)](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-dictionary-get.html) &lt;br &#x2F;&gt;返回指定键的值，如果键不在字典中返回 default 设置的默认值 |</span><br><span class="line">| 5    | [key in dict](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-dictionary-in.html) &lt;br &#x2F;&gt;如果键在字典dict里返回true，否则返回false |</span><br><span class="line">| 6    | [radiansdict.items()](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-dictionary-items.html) &lt;br &#x2F;&gt;以列表返回可遍历的(键, 值) 元组数组 |</span><br><span class="line">| 7    | [radiansdict.keys()](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-dictionary-keys.html) &lt;br &#x2F;&gt;返回一个迭代器，可以使用 list() 来转换为列表 |</span><br><span class="line">| 8    | [radiansdict.setdefault(key, default&#x3D;None)](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-dictionary-setdefault.html)&lt;br &#x2F;&gt; 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default |</span><br><span class="line">| 9    | [radiansdict.update(dict2)](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-dictionary-update.html) &lt;br &#x2F;&gt;把字典dict2的键&#x2F;值对更新到dict里 |</span><br><span class="line">| 10   | [radiansdict.values()](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-dictionary-values.html) &lt;br &#x2F;&gt;返回一个迭代器，可以使用 list() 来转换为列表 |</span><br><span class="line">| 11   | pop(key[,default\]) &lt;br &#x2F;&gt;删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。 |</span><br><span class="line">| 12   | [popitem()](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-dictionary-popitem.html) &lt;br &#x2F;&gt;随机返回并删除字典中的最后一对键和值。 |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 数据类型转换</span><br><span class="line"></span><br><span class="line">| 函数                    | 描述                                                |</span><br><span class="line">| :---------------------- | :-------------------------------------------------- |</span><br><span class="line">| int(x)                  | 将x转换为一个整数                                   |</span><br><span class="line">| float(x)                | 将x转换到一个浮点数                                 |</span><br><span class="line">| complex(real [,imag\])] | 创建一个复数，实部是real，虚部是imag                |</span><br><span class="line">| str(x)                  | 将对象 x 转换为字符串                               |</span><br><span class="line">| repr(x)                 | 将对象 x 转换为表达式字符串                         |</span><br><span class="line">| eval(str)               | 用来计算在字符串中的有效Python表达式,并返回一个对象 |</span><br><span class="line">| tuple(s)                | 将序列 s 转换为一个元组                             |</span><br><span class="line">| list(s)                 | 将序列 s 转换为一个列表                             |</span><br><span class="line">| set(s)                  | 转换为可变集合                                      |</span><br><span class="line">| dict(d)                 | 创建一个字典。d 必须是一个 (key, value)元组序列。   |</span><br><span class="line">| frozenset(s)            | 转换为不可变集合                                    |</span><br><span class="line">| chr(x)                  | 将一个整数转换为一个字符                            |</span><br><span class="line">| ord(x)                  | 将一个字符转换为它的整数值                          |</span><br><span class="line">| hex(x)                  | 将一个整数转换为一个十六进制字符串                  |</span><br><span class="line">| oct(x)                  | 将一个整数转换为一个八进制字符串                    |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 逻辑</span><br><span class="line"></span><br><span class="line">##### 条件控制</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line">if condition_1:</span><br><span class="line">    statement_block_1</span><br><span class="line">elif condition_2:</span><br><span class="line">    statement_block_2</span><br><span class="line">else:</span><br><span class="line">    statement_block_3</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>python中没有<code>switch-case</code></p></li></ul><h5 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h5><p><strong>while</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> 判断条件(condition)：</span><br><span class="line">    执行语句(statements)……</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> &lt;expr&gt;:</span><br><span class="line">    &lt;statement(s)&gt;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    &lt;additional_statement(s)&gt;</span><br></pre></td></tr></table></figure><ul><li>条件语句为 false 时执行 else 的语句块。</li></ul><p><strong>for</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &lt;variable&gt; <span class="keyword">in</span> &lt;sequence&gt;:</span><br><span class="line">    &lt;statements&gt;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    &lt;statements&gt;</span><br></pre></td></tr></table></figure><ul><li>在没有循环数据时执行else的语句块</li></ul><p><code>range()</code></p><ul><li><pre><code class="python">for i in range(5):  print(i)   # 0 1 2 3 4<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* &#96;&#96;&#96;python</span><br><span class="line">  for i in range(5, 9):</span><br><span class="line">    print(i)   # 5 6 7 8</span><br></pre></td></tr></table></figure></code></pre></li><li><pre><code class="python">for i in range(0, 10, 3):  print(i)   # 0 3 6 9<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**continue break**</span><br><span class="line"></span><br><span class="line">* 同java，c++等的使用一样</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**pass**</span><br><span class="line"></span><br><span class="line">* pass是空语句，是为了保持程序结构的完整性。</span><br><span class="line">* pass 不做任何事情，一般用做占位语句</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 遍历</span><br><span class="line"></span><br><span class="line">* 在字典中遍历时，关键字和对应的值可以使用&#96;items()&#96; 方法同时解读出来：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line">&gt;&gt;&gt; knights &#x3D; &#123;&#39;gallahad&#39;: &#39;the pure&#39;, &#39;robin&#39;: &#39;the brave&#39;&#125;</span><br><span class="line">&gt;&gt;&gt; for k, v in knights.items():</span><br><span class="line">...     print(k, v)</span><br><span class="line">...</span><br><span class="line">gallahad the pure</span><br><span class="line">robin the brave</span><br></pre></td></tr></table></figure></code></pre></li></ul><ul><li>在序列中遍历时，索引位置和对应值可以使用 <code>enumerate()</code> 函数同时得到：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>([<span class="string">&#x27;tic&#x27;</span>, <span class="string">&#x27;tac&#x27;</span>, <span class="string">&#x27;toe&#x27;</span>]):</span><br><span class="line"><span class="meta">... </span>    print(i, v)</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> tic</span><br><span class="line"><span class="number">1</span> tac</span><br><span class="line"><span class="number">2</span> toe</span><br></pre></td></tr></table></figure><ul><li>同时遍历两个或更多的序列，可以使用 <code>zip()</code> 组合：</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>questions = [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;quest&#x27;</span>, <span class="string">&#x27;favorite color&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>answers = [<span class="string">&#x27;lancelot&#x27;</span>, <span class="string">&#x27;the holy grail&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> q, a <span class="keyword">in</span> <span class="built_in">zip</span>(questions, answers):</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">&#x27;What is your &#123;0&#125;?  It is &#123;1&#125;.&#x27;</span>.<span class="built_in">format</span>(q, a))</span><br><span class="line">...</span><br><span class="line">What is your name?  It is lancelot.</span><br><span class="line">What is your quest?  It is the holy grail.</span><br><span class="line">What is your favorite color?  It is blue.</span><br></pre></td></tr></table></figure><ul><li>反向遍历一个序列，首先指定这个序列，然后调用 <code>reversed()</code> 函数：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>)):</span><br><span class="line"><span class="meta">... </span>    print(i)</span><br><span class="line">...</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>要按顺序遍历一个序列，使用 <code>sorted()</code>函数返回一个已排序的序列，并不修改原值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>basket = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> f <span class="keyword">in</span> <span class="built_in">sorted</span>(<span class="built_in">set</span>(basket)):</span><br><span class="line"><span class="meta">... </span>    print(f)</span><br><span class="line">...</span><br><span class="line">apple</span><br><span class="line">banana</span><br><span class="line">orange</span><br><span class="line">pear</span><br></pre></td></tr></table></figure><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> 函数名（参数列表）:</span></span><br><span class="line">    函数体</span><br></pre></td></tr></table></figure><img src="/2020/12/15/python/../../../Desktop/截屏2020-12-16 下午3.51.47.png" alt="截屏2020-12-16 下午3.51.47" style="zoom:50%;"><h5 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h5><blockquote><p>python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。</p></blockquote><ul><li><strong>不可变类型：</strong>类似 C++ 的值传递，如 整数、字符串、元组。如 fun(a)，传递的只是 a 的值，没有影响 a 对象本身。如果在 fun(a)）内部修改 a 的值，则是新生成来一个 a。</li><li><strong>可变类型：</strong>类似 C++ 的引用传递，如 列表，字典。如 fun(la)，则是将 la 真正的传过去，修改后 fun 外部的 la 也会受影响</li></ul><p><strong>调用函数时可使用的正式参数类型：</strong></p><ul><li><p>必需参数</p><ul><li><p>必需参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#可写函数说明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printme</span>(<span class="params"> <span class="built_in">str</span> </span>):</span></span><br><span class="line">   <span class="string">&quot;打印任何传入的字符串&quot;</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="built_in">str</span>)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用 printme 函数，不加参数会报错</span></span><br><span class="line">printme()</span><br></pre></td></tr></table></figure></li></ul></li><li><p>关键字参数</p><ul><li><p>关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。</p></li><li><p>使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#可写函数说明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printinfo</span>(<span class="params"> name, age </span>):</span></span><br><span class="line">   <span class="string">&quot;打印任何传入的字符串&quot;</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;名字: &quot;</span>, name)</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;年龄: &quot;</span>, age)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#调用printinfo函数</span></span><br><span class="line">printinfo( age=<span class="number">50</span>, name=<span class="string">&quot;runoob&quot;</span> )</span><br></pre></td></tr></table></figure></li></ul></li><li><p>默认参数</p><ul><li><p>调用函数时，如果没有传递参数，则会使用默认参数。以下实例中如果没有传入 age 参数，则使用默认值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#可写函数说明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printinfo</span>(<span class="params"> name, age = <span class="number">35</span> </span>):</span></span><br><span class="line">   <span class="string">&quot;打印任何传入的字符串&quot;</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;名字: &quot;</span>, name)</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;年龄: &quot;</span>, age)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#调用printinfo函数</span></span><br><span class="line">printinfo( age=<span class="number">50</span>, name=<span class="string">&quot;runoob&quot;</span> )  <span class="comment"># 名字: runoob    年龄: 50</span></span><br><span class="line">printinfo( name=<span class="string">&quot;runoob&quot;</span> )          <span class="comment"># 名字: runoob    年龄: 35</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>不定长参数</p><ul><li><p>可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述 2 种参数不同，声明时不会命名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">functionname</span>(<span class="params">[formal_args,] *var_args_tuple </span>):</span></span><br><span class="line">   <span class="string">&quot;函数_文档字符串&quot;</span></span><br><span class="line">   function_suite</span><br><span class="line">   <span class="keyword">return</span> [expression]</span><br></pre></td></tr></table></figure></li><li><p>带<code>*</code>以元组形式传入</p><ul><li>如果单独出现星号<code>*</code>后的参数必须用关键字传入。</li><li><code>def f(a,b,*,c):</code>  调用：<code>f(1,2,c=3)</code></li></ul></li><li><p>带<code>**</code>以字典形式传入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printinfo</span>(<span class="params"> arg1, *vartuple </span>):</span></span><br><span class="line">   <span class="string">&quot;打印任何传入的参数&quot;</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;输出: &quot;</span>)</span><br><span class="line">   <span class="built_in">print</span> (arg1)</span><br><span class="line">   <span class="built_in">print</span> (vartuple)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用printinfo 函数</span></span><br><span class="line">printinfo( <span class="number">70</span>, <span class="number">60</span>, <span class="number">50</span> )</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="number">70</span></span><br><span class="line">(<span class="number">60</span>, <span class="number">50</span>)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h5><ul><li>python 使用<code>lambda</code>来创建匿名函数。</li><li>所谓匿名，意即不再使用 def 语句这样标准的形式定义一个函数。<ul><li>lambda 只是一个表达式，函数体比 def 简单很多。</li><li>lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。</li><li>lambda 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。</li><li>虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。</li></ul></li></ul><h4 id="函数库"><a href="#函数库" class="headerlink" title="函数库"></a>函数库</h4><h5 id="math"><a href="#math" class="headerlink" title="math"></a>math</h5><h6 id="数学常量"><a href="#数学常量" class="headerlink" title="数学常量"></a>数学常量</h6><ul><li><code>pi</code>：数学常量 pi（圆周率，一般以π来表示）</li><li><code>e</code>：数学常量 e，e即自然常数（自然常数）</li><li></li></ul><h6 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h6><ul><li><p>abs(x)    返回数字的绝对值，如abs(-10) 返回 10</p></li><li><p>ceil(x)    返回数字的上入整数，如math.ceil(4.1) 返回 5</p></li><li><p>cmp(x, y)</p><ul><li>如果 x &lt; y 返回 -1, 如果 x == y 返回 0, 如果 x &gt; y 返回 1。</li><li> Python 3 已废弃，使用 (x&gt;y)-(x&lt;y) 替换。</li></ul></li><li><p>exp(x)    返回e的x次幂(ex)，如math.exp(1) 返回2.718281828459045</p></li><li><p>fabs(x)    返回数字的绝对值的浮点类型，如math.fabs(-10) 返回10.0</p></li><li><p>floor(x)    返回数字的下舍整数，如math.floor(4.9)返回 4</p></li><li><p>log(x)    如math.log(math.e)返回1.0，math.log(100,10)返回2.0</p></li><li><p>log10(x)    返回以10为基数的x的对数，如math.log10(100)返回 2.0</p></li><li><p>max(x1, x2,…)    返回给定参数的最大值，参数可以为序列。</p></li><li><p>min(x1, x2,…)    返回给定参数的最小值，参数可以为序列。</p></li><li><p>modf(x)    返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。</p></li><li><p>pow(x, y)    x**y 运算后的值。</p></li><li><p>round(x [,n])    返回浮点数 x 的四舍五入值，如给出 n 值，则代表舍入到小数点后的位数。</p><ul><li>其实准确的说是保留值将保留到离上一位更近的一端。</li></ul></li><li><p>sqrt(x)    返回数字x的平方根。</p></li></ul><h6 id="随机数函数"><a href="#随机数函数" class="headerlink" title="随机数函数"></a>随机数函数</h6><ul><li>choice(seq)    从序列的元素中随机挑选一个元素<ul><li>比如：random.choice(range(10))，从0到9中随机挑选一个整数。</li></ul></li><li>randrange ([start,] stop [,step])    从指定范围内，按指定基数递增的集合中获取一个随机数，基数默认值为 1</li><li>random()    随机生成下一个实数，它在[0,1)范围内。</li><li>seed([x])    改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed。</li><li>shuffle(lst)    将序列的所有元素随机排序</li><li>uniform(x, y)    随机生成下一个实数，它在[x,y]范围内。</li></ul><h6 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h6><ul><li>acos(x)    返回x的反余弦弧度值。</li><li>asin(x)    返回x的反正弦弧度值。</li><li>atan(x)    返回x的反正切弧度值。</li><li>atan2(y, x)    返回给定的 X 及 Y 坐标值的反正切值。</li><li>cos(x)    返回x的弧度的余弦值。</li><li>hypot(x, y)    返回欧几里德范数 sqrt(x<em>x + y</em>y)。</li><li>sin(x)    返回的x弧度的正弦值。</li><li>tan(x)    返回x弧度的正切值。</li><li>degrees(x)    将弧度转换为角度,如degrees(math.pi/2) ， 返回90.0</li><li>radians(x)    将角度转换为弧度</li></ul><h5 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h5><p>很多Python函数用一个元组装起来的9组数字处理时间:</p><table><thead><tr><th>4位数年</th><th>2008</th><th></th></tr></thead><tbody><tr><td>1</td><td>月</td><td>1 到 12</td></tr><tr><td>2</td><td>日</td><td>1到31</td></tr><tr><td>3</td><td>小时</td><td>0到23</td></tr><tr><td>4</td><td>分钟</td><td>0到59</td></tr><tr><td>5</td><td>秒</td><td>0到61 (60或61 是闰秒)</td></tr><tr><td>6</td><td>一周的第几日</td><td>0到6 (0是周一)</td></tr><tr><td>7</td><td>一年的第几日</td><td>1到366 (儒略历)</td></tr><tr><td>8</td><td>夏令时</td><td>-1, 0, 1, -1是决定是否为夏令时的旗帜</td></tr></tbody></table><p>上述也就是struct_time元组。这种结构具有如下属性：</p><table><thead><tr><th align="left">序号</th><th align="left">属性</th><th align="left">值</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">tm_year</td><td align="left">2008</td></tr><tr><td align="left">1</td><td align="left">tm_mon</td><td align="left">1 到 12</td></tr><tr><td align="left">2</td><td align="left">tm_mday</td><td align="left">1 到 31</td></tr><tr><td align="left">3</td><td align="left">tm_hour</td><td align="left">0 到 23</td></tr><tr><td align="left">4</td><td align="left">tm_min</td><td align="left">0 到 59</td></tr><tr><td align="left">5</td><td align="left">tm_sec</td><td align="left">0 到 61 (60或61 是闰秒)</td></tr><tr><td align="left">6</td><td align="left">tm_wday</td><td align="left">0到6 (0是周一)</td></tr><tr><td align="left">7</td><td align="left">tm_yday</td><td align="left">一年中的第几天，1 到 366</td></tr><tr><td align="left">8</td><td align="left">tm_isdst</td><td align="left">是否为夏令时，值有：1(夏令时)、0(不是夏令时)、-1(未知)，默认 -1</td></tr></tbody></table><h6 id="time"><a href="#time" class="headerlink" title="time"></a>time</h6><ul><li><p>以下时间均为<code>2020-12-16 15:35:15 周三</code></p></li><li><p>time.time()</p><ul><li>获取当前时间戳<code>1608104115.4493172</code></li><li>时间戳单位最适于做日期运算。但是1970年之前的日期就无法以此表示了。太遥远的日期也不行，UNIX和Windows只支持到2038年。</li></ul></li><li><p>time.localtime(时间戳)</p><ul><li><p>获取当前时间</p></li><li><pre><code class="python">time.struct_time(tm_year=2020, tm_mon=12, tm_mday=16, tm_hour=15, tm_min=35, tm_sec=15, tm_wday=2, tm_yday=351, tm_isdst=0)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* time.asctime(time.localtime(时间戳))</span><br><span class="line"></span><br><span class="line">  * 获取格式化的时间</span><br><span class="line"></span><br><span class="line">  * &#96;&#96;&#96;python</span><br><span class="line">    Wed Dec 16 15:35:15 2020</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>time.strftime(format[, time])</p><ul><li><p>格式化日期</p></li><li><pre><code class="python"># 格式化成2020-12-16 15:35:15形式print (time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime()))# 格式化成Wed Dec 16 15:35:15 2020形式print (time.strftime(&quot;%a %b %d %H:%M:%S %Y&quot;, time.localtime()))# 将格式字符串转换为时间戳a = &quot;Wed Dec 16 15:35:15 2020&quot;print (time.mktime(time.strptime(a,&quot;%a %b %d %H:%M:%S %Y&quot;)))<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**两个非常重要的属性：**</span><br><span class="line"></span><br><span class="line">1. time.timezone</span><br><span class="line">   * 属性time.timezone是当地时区（未启动夏令时）距离格林威治的偏移秒数（&gt;0，美洲;&lt;&#x3D;0大部分欧洲，亚洲，非洲）。</span><br><span class="line">2. time.tzname</span><br><span class="line">   * 属性time.tzname包含一对根据情况的不同而不同的字符串，分别是带夏令时的本地时区名称，和不带的。</span><br><span class="line"></span><br><span class="line">| 序号 | 函数及描述                                                   | 实例                                                         |</span><br><span class="line">| :--- | :----------------------------------------------------------- | :----------------------------------------------------------- |</span><br><span class="line">| 1    | time.altzone&lt;br &#x2F;&gt;返回格林威治西部的夏令时地区的偏移秒数。如果该地区在格林威治东部会返回负值（如西欧，包括英国）。对夏令时启用地区才能使用。 | 以下实例展示了 altzone()函数的使用方法：&lt;br &#x2F;&gt;&#96;&gt;&gt;&gt; import time &#96;&lt;br &#x2F;&gt;&#96;&gt;&gt;&gt; print (&quot;time.altzone %d &quot; % time.altzone) &#96;&lt;br &#x2F;&gt;&#96;time.altzone -28800 &#96; |</span><br><span class="line">| 2    | time.asctime([tupletime]) &lt;br &#x2F;&gt;接受时间元组并返回一个可读的形式为&quot;Tue Dec 11 18:07:14 2008&quot;（2008年12月11日 周二18时07分14秒）的24个字符的字符串。 | 以下实例展示了 asctime()函数的使用方法：&lt;br &#x2F;&gt;&#96;&gt;&gt;&gt; import time &gt;&gt;&gt; t &#x3D; time.localtime() &#96;&lt;br &#x2F;&gt;&#96;&gt;&gt;&gt; print (&quot;time.asctime(t): %s &quot; % time.asctime(t)) &#96;&lt;br &#x2F;&gt;&#96;time.asctime(t): Thu Apr  7 10:36:20 2016 &#96; |</span><br><span class="line">| 3    | [time.clock()](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-time-clock.html) &lt;br &#x2F;&gt;用以浮点数计算的秒数返回当前的CPU时间。用来衡量不同程序的耗时，比time.time()更有用。 | [实例](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-time-clock.html)由于该方法依赖操作系统，在 Python 3.3 以后不被推荐，而在 3.8 版本中被移除，需使用下列两个函数替代。&#96;time.perf_counter()  # 返回系统运行时间 time.process_time()  # 返回进程运行时间&#96; |</span><br><span class="line">| 4    | time.ctime([secs]) &lt;br &#x2F;&gt;作用相当于asctime(localtime(secs))，未给参数相当于asctime() | 以下实例展示了 ctime()函数的使用方法：&lt;br &#x2F;&gt;&#96;&gt;&gt;&gt; import time &#96;&lt;br &#x2F;&gt;&#96;&gt;&gt;&gt; print (&quot;time.ctime() : %s&quot; % time.ctime()) &#96;&lt;br &#x2F;&gt;&#96;time.ctime() : Thu Apr  7 10:51:58 2016&#96; |</span><br><span class="line">| 5    | time.gmtime([secs]) &lt;br &#x2F;&gt;接收时间戳（1970纪元后经过的浮点秒数）并返回格林威治天文时间下的时间元组t。注：t.tm_isdst始终为0 | 以下实例展示了 gmtime()函数的使用方法：&lt;br &#x2F;&gt;&#96;&gt;&gt;&gt; import time &#96;&lt;br &#x2F;&gt;&#96;&gt;&gt;&gt; print (&quot;gmtime :&quot;, time.gmtime(1455508609.34375)) &#96;&lt;br &#x2F;&gt;&#96;gmtime: time.struct_time(tm_year&#x3D;2016, tm_mon&#x3D;2, tm_mday&#x3D;15, tm_hour&#x3D;3, tm_min&#x3D;56, tm_sec&#x3D;49, tm_wday&#x3D;0, tm_yday&#x3D;46, tm_isdst&#x3D;0)&#96; |</span><br><span class="line">| 6    | time.localtime([secs] &lt;br &#x2F;&gt;接收时间戳（1970纪元后经过的浮点秒数）并返回当地时间下的时间元组t（t.tm_isdst可取0或1，取决于当地当时是不是夏令时）。 | 以下实例展示了 localtime()函数的使用方法：&lt;br &#x2F;&gt;&#96;&gt;&gt;&gt; import time &#96;&lt;br &#x2F;&gt;&#96;&gt;&gt;&gt; print (&quot;localtime(): &quot;, time.localtime(1455508609.34375)) &#96;&lt;br &#x2F;&gt;&#96;localtime():  time.struct_time(tm_year&#x3D;2016, tm_mon&#x3D;2, tm_mday&#x3D;15, tm_hour&#x3D;11, tm_min&#x3D;56, tm_sec&#x3D;49, tm_wday&#x3D;0, tm_yday&#x3D;46, tm_isdst&#x3D;0)&#96; |</span><br><span class="line">| 7    | [time.mktime(tupletime)](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-time-mktime.html)&lt;br &#x2F;&gt; 接受时间元组并返回时间戳（1970纪元后经过的浮点秒数）。 | [实例](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-time-mktime.html) |</span><br><span class="line">| 8    | time.sleep(secs) &lt;br &#x2F;&gt;推迟调用线程的运行，secs指秒数。      | 以下实例展示了 sleep()函数的使用方法：&#96;#!&#x2F;usr&#x2F;bin&#x2F;python3 import time print (&quot;Start : %s&quot; % time.ctime()) time.sleep( 5 ) print (&quot;End : %s&quot; % time.ctime())&#96; |</span><br><span class="line">| 9    | time.strftime(fmt[,tupletime]) &lt;br &#x2F;&gt;接收以时间元组，并返回以可读字符串表示的当地时间，格式由fmt决定。 | 以下实例展示了 strftime()函数的使用方法：&#96;&gt;&gt;&gt; import time &gt;&gt;&gt; print (time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime())) 2016-04-07 11:18:05&#96; |</span><br><span class="line">| 10   | time.strptime(str,fmt&#x3D;&#39;%a %b %d %H:%M:%S %Y&#39;) &lt;br &#x2F;&gt;根据fmt的格式把一个时间字符串解析为时间元组。 | 以下实例展示了 strptime()函数的使用方法：&#96;&gt;&gt;&gt; import time &gt;&gt;&gt; struct_time &#x3D; time.strptime(&quot;30 Nov 00&quot;, &quot;%d %b %y&quot;) &gt;&gt;&gt; print (&quot;返回元组: &quot;, struct_time) 返回元组:  time.struct_time(tm_year&#x3D;2000, tm_mon&#x3D;11, tm_mday&#x3D;30, tm_hour&#x3D;0, tm_min&#x3D;0, tm_sec&#x3D;0, tm_wday&#x3D;3, tm_yday&#x3D;335, tm_isdst&#x3D;-1)&#96; |</span><br><span class="line">| 11   | time.time( ) &lt;br &#x2F;&gt;返回当前时间的时间戳（1970纪元后经过的浮点秒数）。 | 以下实例展示了 time()函数的使用方法：&#96;&gt;&gt;&gt; import time &gt;&gt;&gt; print(time.time()) 1459999336.1963577&#96; |</span><br><span class="line">| 12   | [time.tzset()](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-time-tzset.html) &lt;br &#x2F;&gt;根据环境变量TZ重新初始化时间相关设置。 | [实例](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-time-tzset.html) |</span><br><span class="line">| 13   | **time.perf_counter()** &lt;br &#x2F;&gt;返回计时器的精准时间（系统的运行时间），包含整个系统的睡眠时间。由于返回值的基准点是未定义的，所以，只有连续调用的结果之间的差才是有效的。 | [实例](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-date-time.html#comment-35499) |</span><br><span class="line">| 14   | **time.process_time()**  &lt;br &#x2F;&gt;返回当前进程执行 CPU 的时间总和，不包含睡眠时间。由于返回值的基准点是未定义的，所以，只有连续调用的结果之间的差才是有效的。 |                                                              |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**日期格式化符号：**</span><br><span class="line"></span><br><span class="line">- %y 两位数的年份表示（00-99）</span><br><span class="line">- %Y 四位数的年份表示（000-9999）</span><br><span class="line">- %m 月份（01-12）</span><br><span class="line">- %d 月内中的一天（0-31）</span><br><span class="line">- %H 24小时制小时数（0-23）</span><br><span class="line">- %I 12小时制小时数（01-12）</span><br><span class="line">- %M 分钟数（00&#x3D;59）</span><br><span class="line">- %S 秒（00-59）</span><br><span class="line">- %a 本地简化星期名称</span><br><span class="line">- %A 本地完整星期名称</span><br><span class="line">- %b 本地简化的月份名称</span><br><span class="line">- %B 本地完整的月份名称</span><br><span class="line">- %c 本地相应的日期表示和时间表示</span><br><span class="line">- %j 年内的一天（001-366）</span><br><span class="line">- %p 本地A.M.或P.M.的等价符</span><br><span class="line">- %U 一年中的星期数（00-53）星期天为星期的开始</span><br><span class="line">- %w 星期（0-6），星期天为星期的开始</span><br><span class="line">- %W 一年中的星期数（00-53）星期一为星期的开始</span><br><span class="line">- %x 本地相应的日期表示</span><br><span class="line">- %X 本地相应的时间表示</span><br><span class="line">- %Z 当前时区的名称</span><br><span class="line">- %% %号本身</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###### calendar</span><br><span class="line"></span><br><span class="line">* 星期一是默认的每周第一天，星期天是默认的最后一天。更改设置需调用calendar.setfirstweekday()函数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">| 序号 | 函数及描述                                                   |</span><br><span class="line">| :--- | :----------------------------------------------------------- |</span><br><span class="line">| 1    | **calendar.calendar(year,w&#x3D;2,l&#x3D;1,c&#x3D;6)**&lt;br &#x2F;&gt; 返回一个多行字符串格式的year年年历，3个月一行，间隔距离为c。 每日宽度间隔为w字符。每行长度为21* W+18+2* C。l是每星期行数。 |</span><br><span class="line">| 2    | **calendar.firstweekday( )** &lt;br &#x2F;&gt;返回当前每周起始日期的设置。默认情况下，首次载入caendar模块时返回0，即星期一。 |</span><br><span class="line">| 3    | **calendar.isleap(year)** &lt;br &#x2F;&gt;是闰年返回 True，否则为 false。&lt;br &#x2F;&gt;&lt;img src&#x3D;&quot;python&#x2F;截屏2020-12-16 下午3.44.04.png&quot; alt&#x3D;&quot;截屏2020-12-16 下午3.44.04&quot; style&#x3D;&quot;zoom:40%;&quot; &#x2F;&gt; |</span><br><span class="line">| 4    | **calendar.leapdays(y1,y2)** &lt;br &#x2F;&gt;返回在Y1，Y2两年之间的闰年总数。 |</span><br><span class="line">| 5    | **calendar.month(year,month,w&#x3D;2,l&#x3D;1)**&lt;br &#x2F;&gt; 返回一个多行字符串格式的year年month月日历，两行标题，一周一行。每日宽度间隔为w字符。每行的长度为7* w+6。l是每星期的行数。 |</span><br><span class="line">| 6    | **calendar.monthcalendar(year,month)** &lt;br &#x2F;&gt;返回一个整数的单层嵌套列表。每个子列表装载代表一个星期的整数。Year年month月外的日期都设为0;范围内的日子都由该月第几日表示，从1开始。 |</span><br><span class="line">| 7    | **calendar.monthrange(year,month)** &lt;br &#x2F;&gt;返回两个整数。第一个是该月的星期几，第二个是该月有几天。星期几是从0（星期一）到 6（星期日）。&lt;br &#x2F;&gt;&lt;img src&#x3D;&quot;..&#x2F;..&#x2F;..&#x2F;..&#x2F;Desktop&#x2F;截屏2020-12-16 下午3.44.50.png&quot; alt&#x3D;&quot;截屏2020-12-16 下午3.44.50&quot; style&#x3D;&quot;zoom:45%;&quot; &#x2F;&gt;&lt;br &#x2F;&gt;(5, 30)解释：5 表示 2014 年 11 月份的第一天是周六，30 表示 2014 年 11 月份总共有 30 天。 |</span><br><span class="line">| 8    | **calendar.prcal(year, w&#x3D;0, l&#x3D;0, c&#x3D;6, m&#x3D;3)** &lt;br &#x2F;&gt;相当于 print (calendar.calendar(year, w&#x3D;0, l&#x3D;0, c&#x3D;6, m&#x3D;3))。 |</span><br><span class="line">| 9    | **calendar.prmonth(theyear, themonth, w&#x3D;0, l&#x3D;0)** &lt;br &#x2F;&gt;相当于 **print(calendar.month(theyear, themonth, w&#x3D;0, l&#x3D;0))**。 |</span><br><span class="line">| 10   | **calendar.setfirstweekday(weekday)** &lt;br &#x2F;&gt;设置每周的起始日期码。0（星期一）到6（星期日）。 |</span><br><span class="line">| 11   | **calendar.timegm(tupletime)** &lt;br &#x2F;&gt;和time.gmtime相反：接受一个时间元组形式，返回该时刻的时间戳（1970纪元后经过的浮点秒数）。 |</span><br><span class="line">| 12   | **calendar.weekday(year,month,day)**&lt;br &#x2F;&gt; 返回给定日期的日期码。0（星期一）到6（星期日）。月份为 1（一月） 到 12（12月）。 |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###### datetime</span><br><span class="line"></span><br><span class="line">- [datetime模块](https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;datetime.html)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Anaconda&quot;&gt;&lt;a href=&quot;#Anaconda&quot; class=&quot;headerlink&quot; title=&quot;Anaconda&quot;&gt;&lt;/a&gt;Anaconda&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;link&quot; href=&quot;https://www.jiansh</summary>
      
    
    
    
    <category term="notebook" scheme="https://jieyang-wei.github.io/categories/notebook/"/>
    
    
    <category term="编程语言" scheme="https://jieyang-wei.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="python" scheme="https://jieyang-wei.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>gdb调试</title>
    <link href="https://jieyang-wei.github.io/2020/12/14/gdb%E8%B0%83%E8%AF%95/"/>
    <id>https://jieyang-wei.github.io/2020/12/14/gdb%E8%B0%83%E8%AF%95/</id>
    <published>2020-12-14T09:56:55.000Z</published>
    <updated>2020-12-15T05:41:25.167Z</updated>
    
    <content type="html"><![CDATA[<p>制作链接库的目的是希望别人使用我们已经实现的功能，但又不希望别人看到我们的源代码<br><code>Linux</code>下的静态链接库是以<code>.a</code>结尾的二进制文件，它作为程序的一个模块，在链接期间被组合到程序中。和静态链接库相对的是动态链接库（.so文件），它在程序运行阶段被加载进内存。</p><p>静态库生成步骤</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1 对所有源文件，只编译不链接</span></span><br><span class="line">gcc -c test.c</span><br><span class="line"><span class="comment">//2 利用ar命令，生成库文件</span></span><br><span class="line">ar rcs libtest.a test.o</span><br></pre></td></tr></table></figure><p><code>ar</code>是 Linux 的一个备份压缩命令，它可以将多个文件打包成一个备份文件（也叫归档文件），也可以从备份文件中提取成员文件，最常见的用法是将目标文件打包为静态链接库。</p><p>对参数的说明：</p><ul><li>r：用来替换库中已有的目标文件，或者加入新的目标文件。</li><li>c：表示创建一个库。不管库否存在，都将创建。</li><li>s：用来创建目标文件索引，这在创建较大的库时能提高速度。</li></ul><p>Linux 下动态链接库（shared object file，共享对象文件）的文件后缀为.so，它是一种特殊的目标文件（object file），可以在程序运行时被加载（链接）进来。</p><p>使用动态链接库的优点是：程序的可执行文件更小，便于程序的模块化以及更新，同时，有效内存的使用效率更高</p><ol><li>如果想创建一个动态链接库，可以使用 GCC 的-shared选项。输入文件可以是源文件、汇编文件或者目标文件。</li><li>另外还得结合<code>-fPIC</code>选项。<code>-fPIC</code>选项作用于编译阶段，告诉编译器产生与位置无关代码（Position-Independent Code）；这样一来，产生的代码中就没有绝对地址了，全部使用相对地址，所以代码可以被加载器加载到内存的任意位置，都可以正确的执行。这正是共享库所要求的，共享库被加载时，在内存的位置不是固定的。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 从源文件生成动态链接库：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -fPIC -shared func.c -o libfunc.so</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从目标文件生成动态链接库：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -fPIC -c func.c -o func.o</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -shared func.o -o libfunc.so</span></span><br><span class="line"> * -fPIC 选项作用于编译阶段，在生成目标文件时就得使用该选项，以生成位置无关的代码。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;制作链接库的目的是希望别人使用我们已经实现的功能，但又不希望别人看到我们的源代码&lt;br&gt;&lt;code&gt;Linux&lt;/code&gt;下的静态链接库是以&lt;code&gt;.a&lt;/code&gt;结尾的二进制文件，它作为程序的一个模块，在链接期间被组合到程序中。和静态链接库相对的是动态链接库（.s</summary>
      
    
    
    
    <category term="course" scheme="https://jieyang-wei.github.io/categories/course/"/>
    
    
    <category term="linux" scheme="https://jieyang-wei.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>区块链</title>
    <link href="https://jieyang-wei.github.io/2020/12/14/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    <id>https://jieyang-wei.github.io/2020/12/14/%E5%8C%BA%E5%9D%97%E9%93%BE/</id>
    <published>2020-12-14T09:47:42.000Z</published>
    <updated>2020-12-15T06:27:25.340Z</updated>
    
    <content type="html"><![CDATA[<h1 id="crypto-currency（加密货币）"><a href="#crypto-currency（加密货币）" class="headerlink" title="crypto-currency（加密货币）"></a>crypto-currency（加密货币）</h1><h1 id="比特币-BTC"><a href="#比特币-BTC" class="headerlink" title="比特币 BTC"></a>比特币 BTC</h1><h2 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h2><h3 id="1-crypto-graphic-hash-function"><a href="#1-crypto-graphic-hash-function" class="headerlink" title="1. crypto graphic hash function"></a>1. crypto graphic hash function</h3><p>特性：</p><ol><li><p>collision resistance：抗碰撞性</p></li><li><p>hiding：x可以算出H(x)，但H(x)不能反推出x，即这个hash函数不会泄露x</p><ul><li><p>需要满足，不然可以通过蛮力求解</p><ol><li><p>输入空间大</p></li><li><p>均匀分布</p></li></ol></li><li><p>digital commitment / digital equivalent of a sealed envelope：密封预测结果</p></li></ul></li><li><p>puzzle friendly：H(x)是事先不可预测的</p></li></ol><p>H(block header) &lt;= target 目标域值（nBits：目标域值编码）</p><p>proof of work POW，工作证明</p><p>difficult to solve, but easy to verify</p><p>SHA-256（Secure Hash Algorithm）</p><h3 id="2-签名"><a href="#2-签名" class="headerlink" title="2. 签名"></a><strong>2. 签名</strong></h3><p>账户 - public key, private key</p><ul><li>来源于非对称加密：asymmetric encryption algorithm</li><li>最早期是对称加密，symmetric encryption algorithm，但这样密钥分发是一个问题，所以有了公私钥</li></ul><p>a good source of randomness：使得生成的公钥相同的几率微乎其微</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="hash-point"><a href="#hash-point" class="headerlink" title="hash point"></a>hash point</h3><ul><li>无环链表都可以用 hash point 代替普通的point</li></ul><p><strong>全节点</strong>：保存所有的信息</p><p><strong>轻节点</strong>：只保存block header（如手机上）</p><ol><li>区块链</li></ol><p><img src="/2020/12/14/%E5%8C%BA%E5%9D%97%E9%93%BE/IMG_0230-7744726.jpg" alt="IMG_0230"></p><ul><li>block chain is a linked list using hash pointers：用hash point 代替普通的指针<ul><li>genesis block：创世区块            most recent blcok：最近产生的区块      H( )：hash point</li><li>tamper-evident log：最后一个hash值就能检查整个链表是否被修改过</li></ul></li></ul><ol start="2"><li>Merkle tree<ul><li>与binary tree的区别<ol><li>用hash point代替普通的指针</li><li>只要记录<code>root hash</code>，就能检测对整棵树的修改</li></ol></li><li>block header：只保存<code>root hash</code>，</li><li>block body：保存所有的交易信息等</li><li>作用：<ul><li>提供<code>merkle proof</code></li></ul></li></ul></li></ol><blockquote><p><img src="/2020/12/14/%E5%8C%BA%E5%9D%97%E9%93%BE/IMG_231E499E57D8-1.jpeg" alt="IMG_231E499E57D8-1"></p><ul><li><strong>proof of membership</strong>：轻节点想知道黄色交易是否在<code>merkle tree</code>上，只有一个<code>root hash</code>(在<code>block header</code>里面)</li></ul><ol><li>轻节点向某个全节点发出证明请求，请求一个能证明黄色交易包括在<code>merkle tree</code>里面的一个<code>merkle proof</code></li><li>全节点收到请求，会将图中红色的三个<code>hash值</code>发送给这个轻节点</li><li><strong>从下往上</strong>：轻节点会算出黄色交易的hash值绿1，绿1和红1一起算出hash值绿2，绿2和红2算出绿3，绿3和红3一起算出<code>root hash</code></li><li>轻节点比较这个算出来的<code>root hash</code>和<code>block header</code>的hash值</li></ol><blockquote><p><strong>注意</strong>：我们只能验证绿色的部分，不能验证红色部分的hash值</p></blockquote><blockquote><ul><li>如果考虑通过调整红色的部分，使得被篡改后的绿色的部分算出来hash不变，是不实际的</li><li>因为<code>Collision resistance</code>性质，这样的操作相当于人为的制造hash碰撞</li></ul></blockquote><ul><li><strong>proof of non-memership</strong>：轻节点想证明某个交易不存在</li></ul><ol><li></li></ol></blockquote><h2 id="数字货币"><a href="#数字货币" class="headerlink" title="数字货币"></a>数字货币</h2><ul><li>使用公私钥，非对成加密算法<ol><li>Double spending attack，双花攻击 - 花两次攻击：数字货币本质上是一个文件，带签名的数字货币可以复制</li></ol></li><li>每个数字货币上带编号（防范DSA，但是是中心化的）<ul><li>bank维护一个数据库，每个编号的数字货币在谁手里</li><li>每次验证数字货币的签名和编号，这个货币有没有发过，被谁花过</li></ul></li></ul><h3 id="BTC解决去中心化的数字货币发行问题"><a href="#BTC解决去中心化的数字货币发行问题" class="headerlink" title="BTC解决去中心化的数字货币发行问题"></a>BTC解决去中心化的数字货币发行问题</h3><ul><li><img src="/2020/12/14/%E5%8C%BA%E5%9D%97%E9%93%BE/IMG_9CCCEC7F3445-1.jpeg" alt="IMG_9CCCEC7F3445-1"><ul><li>交易中A的公钥表明是钱是哪儿来的，但是要将A和他的公钥联系在一起，不然E可以用自己的公钥冒充A的，再用自己的私钥签名<ul><li><strong>coinbase tx</strong>：需要验证A-&gt;B的钱的前一个交易（金币来源）中A的公钥，即金币来源的输出脚本，和交易中提供的A的公钥，即交易的输入脚本拼在一起合成一个程序，看能不能顺利执行</li></ul></li></ul></li></ul><h4 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h4><ul><li><strong>区块结构</strong><ul><li>Block Header<ul><li>version：比特币版本</li><li>hash of previous block header：指向前一个区块的指针（只算header的hash）<ul><li><img src="/2020/12/14/%E5%8C%BA%E5%9D%97%E9%93%BE/IMG_89EB07B3C160-1.jpeg" alt="IMG_89EB07B3C160-1"></li><li>merkle tree的root hash已经保证了<code>transaction list</code>是无法被篡改的</li></ul></li><li>merkle root hash：整棵merkle tree的根hash值</li><li>·target：挖矿难度目标域值</li><li>nonce：随机数</li></ul></li><li>Block Body<ul><li>transaction list</li></ul></li></ul></li><li><strong>节点</strong><ul><li>full node（fully validating node，全节点）：<br>* </li><li>light node（light weight node，轻节点）：<ul><li>一般无法验证交易的合法性，只是利用区块链的信息做一个查询</li></ul></li></ul></li></ul><h4 id="Consensus-in-BitCoin，比特币共识"><a href="#Consensus-in-BitCoin，比特币共识" class="headerlink" title="Consensus in BitCoin，比特币共识"></a>Consensus in BitCoin，比特币共识</h4><p>distributed consensus，分布式共识</p><ul><li>impossibility result：<ul><li>FLP：在一个异步的系统里（asynchronous），网络时延没有上线，哪怕系统中只要有一个用户是faulty的，都没有办法达成共识</li><li>CAP Theorem：以下三个性质中，最多满足两种<ul><li>一致性Consistency、可用性Availability、分区容错性Partition tolerance</li></ul></li></ul></li></ul><p>membership</p><p>hyperledger</p><p>联盟链 - fabric</p><p>sybil attacl，女巫攻击：找一个超级计算机，不停的产生用户节点，当总数超过一半时，就得到了这个链的控制权</p><ul><li>coinbase transaction：<ul><li>通过算例投票 puzzle friendly</li><li>hash rate</li><li>nonce</li></ul></li></ul><p>mining - 挖矿：比特币争夺记账权</p><ul><li>digital gold</li><li>miner</li></ul><h4 id="BTC系统实现"><a href="#BTC系统实现" class="headerlink" title="BTC系统实现"></a>BTC系统实现</h4><h5 id="transaction-based-ledger，基于交易的账本模式"><a href="#transaction-based-ledger，基于交易的账本模式" class="headerlink" title="transaction-based ledger，基于交易的账本模式"></a>transaction-based ledger，基于交易的账本模式</h5><ul><li>每个交易需要说清楚，币是从哪儿来的，它没有账户的概念</li></ul><p>全节点维护一个数据结构：</p><ul><li><p>UTXO，unspent Transaction Output：还没有被花掉的交易的输出集合</p><ul><li><p><strong>包括</strong> 2个数据就能定位UTXO的输出：</p><ol><li><p>产生这个输出的交易的hash 值</p></li><li><p>这个输出是交易中的第几个输出</p></li></ol></li><li><p><strong>作用</strong>：检测Double Spending</p></li><li><p>total inputs = total outputs：i可以略大于o，中间的<code>transaction fee</code>可能给了拥有记账权的区块</p></li><li><p>transaction fee：大约只有零点零几个币</p></li></ul></li></ul><p>account-based ledger，基于账户的模式</p><ul><li>系统需要显示的记录每个账户有多少个币，如以太坊ß</li></ul><h5 id="Bernoulli-trial"><a href="#Bernoulli-trial" class="headerlink" title="Bernoulli trial"></a>Bernoulli trial</h5><ul><li><p>a random experiment with binary outcome</p></li><li><p>每次求解nonce可以看作是Bernoulli trial</p></li></ul><p><strong>Bernoulli process</strong>：a sequence of independent Bernoulli</p><ul><li>大量实践的Bernoulli trial就组成了</li><li>性质：<ul><li>memoryless，无记忆的：实验结果和之前的实验结果是没有关系的</li></ul></li></ul><p>Poisson process：</p><p>exponential distribution，出块时间：服从指数分布</p><ul><li>memoryless：将来挖多少时间与之前已经挖了多少时间没有关系，即使等了10mins，下一挖到矿的时间仍然指数分布，平均是10mins</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;crypto-currency（加密货币）&quot;&gt;&lt;a href=&quot;#crypto-currency（加密货币）&quot; class=&quot;headerlink&quot; title=&quot;crypto-currency（加密货币）&quot;&gt;&lt;/a&gt;crypto-currency（加密货币）&lt;/</summary>
      
    
    
    
    <category term="notebook" scheme="https://jieyang-wei.github.io/categories/notebook/"/>
    
    
    <category term="BTC" scheme="https://jieyang-wei.github.io/tags/BTC/"/>
    
  </entry>
  
  <entry>
    <title>版本管理</title>
    <link href="https://jieyang-wei.github.io/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"/>
    <id>https://jieyang-wei.github.io/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/</id>
    <published>2020-12-14T07:55:40.000Z</published>
    <updated>2020-12-15T05:40:02.286Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h3 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h3><ol><li><p><strong>本地版本控制系统</strong>（Version Control Systems，简称VCS）</p><ul><li><p>大多都是采用某种简单的数据库来记录文件的历次更新差异</p></li><li><p>最流行的：<code>RCS</code></p><ul><li>工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，可以重新计算出各个版本的文件内容。”</li></ul></li></ul></li><li><p><strong>集中化版本控制系统</strong>（Centralized Version Control Systems，简称 CVCS ）</p><ul><li>诸如CVS、Subversion以及perforce等</li><li>容易单点故障、丢失所有历史更新记录的风险</li></ul></li><li><p><strong>分布式版本控制系统</strong>（Distributed Version Control System，简称 DVCS）</p><ul><li>像Git、Mercurial、Bazaar以及Darcs</li><li>客户端并不只提取最新版本的文件快照， 而是把代码仓库完整地镜像下来，包括完整的历史记录</li></ul></li></ol><ul><li>大部分系统以文件变更列表的方式存储信息，这类系统（CVS、Subversion、Perforce、Bazaar等）将他们存储的信息看作是一组基本文件和每个文件随时间逐步累积的差异（**基于差异[delta-based]**的版本控制）</li><li>Git 更像是把数据看作是对<strong>小型文件系统</strong>的一系列快照。 在 Git 中，每当你提交更新或保存项目状态时，它基本上就会对当时的全部文件创建一个快照并保存这个快照的索引。 为了效率，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 <strong>快照流</strong></li></ul><p><strong>git</strong>：分布式版本控制系统，c语言开发</p><p><strong>免费集中式版本控制</strong>：CVS、SVN  —  速度慢，且需要联网</p><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p><a class="link" href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">廖雪峰<i class="fas fa-external-link-alt"></i></a></p><p>电子书：progit_v2.1.54</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>git校验和机制</strong>：<strong>SHA-1散列</strong>，这是一个由 40 个十六进制字符（0-9 和 a-f）组成的字符串，基于 Git 中文件的内容或目录结构计算出来</p><h4 id="三种状态"><a href="#三种状态" class="headerlink" title="三种状态"></a>三种状态</h4><ul><li><strong>已提交（committed）</strong>：表示数据已经安全地保存在本地数据库中</li><li><strong>已修改（modified）</strong>：表示修改了文件，但还没保存到数据库中</li><li><strong>已暂存（staged）</strong>：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中</li></ul><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/截屏2020-12-09 下午2.58.04.png" alt="截屏2020-12-07 下午3.29.20"><ul><li>工作区：对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改</li><li>暂存区：是一个文件，保存了下次将要提交的文件列表信息，一般在 Git 仓库目录中。 按照 Git 的术语叫做“索引”，不过一般说法还是叫“暂存区</li><li>git目录：Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，复制的就是这里的数据</li></ul><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><ol><li>在工作区中修改文件。</li><li>将你想要下次提交的更改选择性地暂存，这样只会将更改的部分添加到暂存区。</li><li>提交更新，找到暂存区的文件，将快照永久性存储到 Git 目录。</li></ol><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install git-all</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看版本</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git --version</span></span><br></pre></td></tr></table></figure><p>工具目录结构</p><ul><li>git自带一个<code>git config</code>的工具来帮助设置，这些变量存储在三个不同的位置</li></ul><ol><li>/etc/gitconfig 文件：包含系统上每一个用户及他们仓库的通用配置。 如果在执行 git config 时带上 –system 选项，那么它就会读写该文件中的配置变量。 （由于它是系统配置文件，因此你需要管理员或超级用户权限来修改它。）</li><li>~/.gitconfig 或 ~/.config/git/config 文件：只针对当前用户。 你可以传递 –global 选项让 Git 读写此文件，这会对你系统上所有的仓库生效</li><li>当前使用仓库的 Git 目录中的 config 文件（即 .git/config）：针对该仓库。 你可以传递 –local 选项让 Git 强制读写此文件，虽然默认情况下用的就是它。。 （当然，你需要进入某个 Git 仓库中才能让该选项生效。）<ul><li>每一个级别会覆盖上一级别的配置，所以 .git/config 的配置变量会覆盖 /etc/gitconfig 中的配置变量</li></ul></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --list --show-origin  <span class="comment"># 查看所有配置以及他们所在文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置用户信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.name <span class="string">&quot;Weijieyang&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.email <span class="string">&quot;name@mail.com&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> git config 选项列表</span></span><br><span class="line"> * --list 列出所有 Git 当时能找到的配置</span><br><span class="line"> * --global 配置所有的项目</span><br></pre></td></tr></table></figure><ul><li>git工作目录下每一个文件只有两种状态<ol><li><strong>已跟踪</strong>：指那些被纳入了版本控制的文件，在上一次快照中有它们的记录。即git已经知道的文件</li><li><strong>未跟踪</strong>：其他文件</li></ol></li></ul><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="版本库（Repository）"><a href="#版本库（Repository）" class="headerlink" title="版本库（Repository）"></a>版本库（Repository）</h3><p>工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。</p><p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</p><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/截屏2020-12-07 下午3.29.20.png" alt="截屏2020-12-07 下午3.29.20" style="zoom:50%;"><ol><li><strong>创建版本库</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br></pre></td></tr></table></figure><ul><li>到需要版本管理的目录下</li><li>初始化后会在目录下形成一个<code>.git</code>文件，此文件为隐藏文件，需要使用命令<code>ls -a</code>查看</li></ul><ol start="2"><li><strong>使用步骤</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add file</span> </span><br></pre></td></tr></table></figure><ul><li>添加本地修改后的文件到暂存区</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"> * -s/--short 更为紧凑的输出展示效果</span><br></pre></td></tr></table></figure><ul><li>时刻掌握仓库当前情况，查看未被提交的修改，包括工作区和暂存区</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&#x27;注释&#x27;</span></span></span><br></pre></td></tr></table></figure><ul><li>将暂存区的修改提交到版本库中</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&#x27;注释&#x27;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add filemore</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend</span></span><br></pre></td></tr></table></figure><ul><li>第一次提交后发现漏了几个文件，可以使用<code>--amend</code>添加，此次提交将会替代上一次的提交，上一次的提交将不会出现在版本历史中ß</li></ul><ol start="3"><li><strong>版本管理</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line"> * —-pretty=onelines pretty可以指定不同于默认格式的方式展示历史</span><br><span class="line"> * onelines 输出消息更简洁，最前面是每个版本的commit id（用SHA1计算）</span><br><span class="line"> * format:&quot;%h - %an, %ar : %s&quot; 定制记录的显示格式</span><br><span class="line"> * 还有short、full和fuller</span><br><span class="line"> </span><br><span class="line"> * -p/--patch 显示每次提交所引入的差异（按 补丁 的格式输出）</span><br><span class="line"> * --stat 每次提交的简略统计信息</span><br><span class="line"> * --shortstat 只显示 --stat 中最后的行数修改添加移除统计</span><br><span class="line"> * --name-only 仅在提交信息后显示已修改的文件清单</span><br><span class="line"> * --name-status 显示新增、修改、删除的文件清单</span><br><span class="line"> * --graph 查看分支合并图，在日志旁以 ASCII 图形显示分支与合并历</span><br><span class="line"> * --abbrev-commit 查看详细的合并信息，仅显示 SHA-1 校验和所有 40 个字符中的前几个字符</span><br><span class="line"> * --relative-data 使用较短的相对时间而不是完整格式显示日期（比如“2 weeks ago”）</span><br></pre></td></tr></table></figure><ul><li>显示从最近到最远的提交日志</li><li><strong>format</strong>格式设置：<ul><li><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/截屏2020-12-09 下午3.39.00.png" alt="截屏2020-12-09 下午3.39.00" style="zoom: 33%;"></li><li><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/截屏2020-12-09 下午3.39.17.png" alt="截屏2020-12-09 下午3.39.17" style="zoom: 33%;"></li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git last</span></span><br></pre></td></tr></table></figure><ul><li>查看最后一次提交</li></ul><p><strong>取消暂存 reset</strong>  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard HEAD^</span> </span><br></pre></td></tr></table></figure><ul><li>回退到前一个版本<ul><li><code>HEAD</code>：相当于一个指针，指向<code>master</code>，而<code>master</code>指向提交</li><li><code>^</code>：是上一个版本，<code>^^</code>：前两个的版本，<code>HEAD～100</code>：往上100个版本</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard commitId</span></span><br></pre></td></tr></table></figure><ul><li>回退到版本号为<code>commitId</code>的版本</li><li><strong>注意</strong>：<code>--hard</code> 是一个危险的选项</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rerset HEAD &lt;file&gt;</span></span><br></pre></td></tr></table></figure><ul><li>撤销暂存区(unstage)的修改回退到工作区</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reflog</span></span><br><span class="line">e475afc HEAD@&#123;1&#125;: reset: moving to HEAD^</span><br><span class="line">1094adb (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: append GPL</span><br><span class="line">e475afc HEAD@&#123;3&#125;: commit: add distributed</span><br><span class="line">eaadf4e HEAD@&#123;4&#125;: commit (initial): wrote a readme file</span><br></pre></td></tr></table></figure><ul><li>记录了你的每一次命令，可以用来找已经撤销掉的版本id</li></ul><ol start="4"><li><strong>其他操作</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff file</span></span><br></pre></td></tr></table></figure><ul><li>查看修改内容，<code>diff</code>均是未提交的内容</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff --staged</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看已暂存文件和最后一次提交的文件差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff --cached</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看已经暂存起来的变化（--staged和--cached是同义词）</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff HEAD -- file</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看工作区和版本库里面最新版本的区别</span></span><br></pre></td></tr></table></figure><p><strong>撤销操作 checkout</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -- &lt;file&gt;</span></span><br></pre></td></tr></table></figure><ul><li>撤销上一次修改，回到最近一次git commit或者git add状态，不管是在工作区还是在暂存区<ul><li>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</li><li>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</li><li>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考<a class="link" href="https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192">版本回退<i class="fas fa-external-link-alt"></i></a>一节，不过前提是没有推送到远程库。</li></ul></li></ul><p><strong>删除文件 rm</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rm file</span></span><br></pre></td></tr></table></figure><ul><li>通过rm删除了文件之后，status会告诉删除信息，因为删除也算是修改操作（deleted： file）</li><li>在本地目录中删除文件之后可以选择彻底删除或者使用git恢复<ol><li>彻底删除：<code>$ git rm file</code>— 在暂存区中删除，<code>$ git commit</code> — 确定要在版本库中删除<ul><li>(如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失<strong>最近一次提交后你修改的内容</strong>。)</li></ul></li><li>恢复：<code>$ git checkout --file</code><ul><li>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</li></ul></li></ol></li></ul><p><strong>改名操作 mv</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git mv old new</span></span><br><span class="line">---- 相当于 ----</span><br><span class="line"><span class="meta">$</span><span class="bash"> mv old new</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm old</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add new</span></span><br></pre></td></tr></table></figure><p><strong>忽略文件</strong></p><p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。在这种情况下，我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件的模式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat .gitignore</span></span><br><span class="line">*～      # 忽略所有名字以～结尾的文件（通常是副本文件）</span><br><span class="line">*.[oa]   # 忽略以.o .a 结尾的文件</span><br><span class="line">!lib.a.  # 忽略.a文件，但跟踪所有 lib.a 文件</span><br><span class="line">/TODO    # 只忽略当前目录下的 TODO 文件</span><br><span class="line">build/   # 忽略任何目录下名为 build 的文件夹</span><br><span class="line">doc/*.txt    #忽略doc下的txt，但不忽略doc/server/a.txt</span><br><span class="line">doc/**/*.pdf #忽略doc及其子目录下的所有pdf文件</span><br></pre></td></tr></table></figure><p>格式规范：</p><ul><li>所有空行或者以 # 开头的行都会被 Git 忽略。</li><li>可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。</li><li>匹配模式可以以（/）开头防止递归。</li><li>匹配模式可以以（/）结尾指定目录。</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上叹号（!）取反。</li></ul><h3 id="远程仓库（github）"><a href="#远程仓库（github）" class="headerlink" title="远程仓库（github）"></a>远程仓库（github）</h3><ol><li><strong>创建电脑用户自己的密钥</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen -t rsa -C <span class="string">&quot;youremail@example.com&quot;</span></span></span><br><span class="line"> * -t 指定密钥类型，默认是 rsa ，可以省略。</span><br><span class="line"> * -C 设置注释文字，比如邮箱。</span><br><span class="line"> * -f 指定密钥文件存储文件名.</span><br></pre></td></tr></table></figure><ul><li>在用户主目录<code>/home/username</code>下创建密钥</li><li>生成<code>id_rsa</code>和<code>id_rsa.pub</code></li></ul><ol start="2"><li><strong>绑定电脑用户和github用户</strong></li></ol><ul><li>将公钥<code>id_rsa.pub</code>加载到github网站上<code>Add SSH Key</code></li></ul><ol start="3"><li><strong>添加远程仓库</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote add origin git@github-link</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote -v</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote show &lt;remote&gt;    <span class="comment"># 查看摸一个远程仓库的更多信息</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote rename old new   <span class="comment"># 给远程仓库改名</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote remove name      <span class="comment"># 删除远程仓库，及所有跟踪分支和配置信息</span></span></span><br></pre></td></tr></table></figure><ul><li>链接本地仓库和github上创建的远程仓库</li><li><code>origin</code>为远程仓库的默认名字，可自行更改</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push -u origin mymaster:master</span></span><br></pre></td></tr></table></figure><ul><li>将本地仓库的内容推送到远程仓库上，实际上是把当前分支master推送到远程</li><li><code>-u</code>：如果当前分支与多个主机存在追踪关系，则可以使用 -u 参数指定一个默认主机，这样后面就可以不加任何参数使用<code>git push</code><ul><li>不指定<code>mymaster</code>：将会删除远程的<code>master</code>分支，这相当于是push了一个空分支到<code>master</code></li><li>不指定<code>:master</code>：默认推送到与<code>mymaster</code>有追踪关系的分支，一般为同名分支，没有的话会在远程建一个（<code>git remote show &lt;origin&gt;</code>查看各个分支的追踪关系）</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull origin master:mymaster</span></span><br></pre></td></tr></table></figure><ul><li>提交远程之前，最好先将远程仓库的文件拉取下来，再<code>push</code>，以免造成冲突</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git fetch &lt;remote&gt; &lt;remote branchname&gt;:&lt;your branchname&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 不指定远程分支将会默认为‘default’分支（一般为master）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 不给本地分支命名的话，会自动默认指针 FETCH_HEAD</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者使用远程分支名 origin/master 指定fetch的分支</span></span><br></pre></td></tr></table></figure><ul><li>他与pull一样，就拉取远程仓库中有但你没有的文件（不要拉取到当前所在分支）</li><li>不同的是，fetch并不会自动合并或修改你当前的工作，更安全。 当准备好时你必须手动将其合并入你的工作。</li><li><strong>pull = fetch + merge (FETCH_HEAD)</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git fetch origin</span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge origin/<span class="string">&#x27;default&#x27;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 拉取远程默认分支到本地当前分支上，再与远程的默认分支合并</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git fetch origin master:mymaster-tmp</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge mymaster-tmp</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 建议建一个专用存放fetch的分支tmp，拉去下来文件后，再与myaster来merge</span></span><br></pre></td></tr></table></figure><p><strong><code>FETCH_HEAD</code></strong></p><ul><li>某个branch在服务器上的最新状态.</li><li>每一个执行过fetch操作的项目都会存在一个FETCH_HEAD列表,这个列表保存在 <code>.git/FETCH_HEAD</code> 文件中, 其中每一行对应于远程服务器的一个分支.当前分支指向的FETCH_HEAD, 就是这个文件第一行对应的那个分支</li><li>一般来说, 存在两种情况:<ul><li>如果没有显式的指定<code>远程分支</code>, 则远程分支的<code>master</code>将作为默认的<code>FETCH_HEAD</code>.</li><li>如果指定了<code>远程分支</code>, 就将这个远程分支作为<code>FETCH_HEAD</code>.</li></ul></li></ul><p><strong><code>–rebase</code></strong></p><ul><li>作用是取消掉本地库中刚刚的commit，并把他们接到更新后的版本库之中。</li></ul><ol start="4"><li><strong>克隆远程仓库</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> git@github-link</span></span><br></pre></td></tr></table></figure><ul><li>如果远程仓库已有文件，可以将其克隆到本地的空仓库中</li></ul><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p><code>master</code>：主分支</p><p><code>HEAD</code>：指向当前分支，即指向<code>master</code></p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul><li><strong>新建<code>dev</code>分支</strong>：现在修改东西就是<code>dev</code>指针移动了，而<code>HEAD</code>指向当前的<code>dev</code>分支<ul><li>此时修改<code>dev</code>分支，<code>master</code>分支将不会改变</li></ul></li></ul><p><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/3DEC42CC-E46F-4939-ACAA-33BD4B3F88B2.png" alt="3DEC42CC-E46F-4939-ACAA-33BD4B3F88B2" style="zoom:67%;"><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/截屏2020-12-07 下午4.12.29.png" alt="截屏2020-12-07 下午4.12.29" style="zoom: 33%;"></p><ul><li><strong>合并分支</strong>：改改指针的问题                                          <ul><li>将<code>dev</code>分支合并到<code>master</code>上，右图为不使用<code>Fast-Forward</code>快进模式时（–no-ff）</li></ul></li></ul><p><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/69B01EAC-0670-4DED-85A9-A41465FCBF3C.png" alt="69B01EAC-0670-4DED-85A9-A41465FCBF3C" style="zoom: 67%;"><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/B0212A11-D318-457F-9943-E5FCD27820B4.png" alt="B0212A11-D318-457F-9943-E5FCD27820B4" style="zoom: 67%;"></p><ul><li><strong>删除分支</strong>：将dev指针给删掉就行了</li></ul><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/9CA8FECF-51AB-438D-86D7-59846BF675C9.png" alt="9CA8FECF-51AB-438D-86D7-59846BF675C9" style="zoom:80%;"><h4 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h4><ul><li>创建分支：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout (-b) dev</span></span><br><span class="line"> * -b 创建并切换分支</span><br><span class="line">-------------------------</span><br><span class="line"><span class="meta">$</span><span class="bash"> git switch (-c) dev</span></span><br><span class="line"> * -c 创建并切换分支</span><br></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch dev     //创建分支(会创建一个和当前分支有一样内容的分支)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout/switch dev   //切换分支</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br><span class="line">* dev</span><br><span class="line">  master</span><br></pre></td></tr></table></figure><ul><li>查看当前分支，当前分支上会加上<code>*</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -d dev</span></span><br></pre></td></tr></table></figure><ul><li>删除分支dev</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br><span class="line"> * -vv 将所有的本地分支列出来并且包含更多的信息</span><br><span class="line"> * -r 查看远程所有分支</span><br><span class="line"> * -a 查看本地和远程的所有分支</span><br><span class="line"> * &lt;branchname&gt; 新建分支</span><br><span class="line"> * -d -r &lt;branchname&gt; 删除远程分支，删除后还需要推送到服务器</span><br><span class="line"> * -m old new 重命名分支</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch --set-upstream-to origin/branchname</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch --set-upstream-to=origin/branchname  branchname</span></span><br></pre></td></tr></table></figure><ul><li>修改<code>pull</code>时的远程分支关联<ul><li>upstream：将当前分支推送到其上游分支（ tracking &gt;是不推荐的同义词对于上游）</li><li>current：将当前分支推送到同名分支</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git merge dev</span>   </span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge --no-ff -m <span class="string">&quot;merge with no-ff” dev</span></span> </span><br></pre></td></tr></table></figure><ul><li>合并分支到当前分支（如：将<code>dev</code>上的工作结果合并到<code>master</code>上）</li><li>注：两个分支分别都修改了文件的冲突情况下，需要进行手动更改冲突<ul><li>一般合并分支会在<code>Fast Forward</code>模式，但此模式下删除分支，会丢失掉分支信息；</li><li>如果要强制禁用<code>Fast Forward</code>模式，Git就会在<code>merge</code>时生成一个新的<code>commit</code>，这样，从分支历史上就可以看出分支信息。</li><li><code>--no-ff</code>方式的git merge：看的出原来发生过合并，而merge看不出</li></ul></li></ul><ul><li><strong>分支策略</strong>：<ul><li>master：最稳定的，用来发布版本；</li><li>dev：不稳定，所有人将自己的修改合并到这个分支上</li></ul></li></ul><p><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/FD4949A7-CB58-4BD1-B887-3A833E23A7DD.png" alt="FD4949A7-CB58-4BD1-B887-3A833E23A7DD"></p><p>修改bug：创建新的分支进行修改，修改后合并到dev上，但是因为commit是一次提交所有的暂存区，所以需要将现在在写的，不需要提交的先用stash指令存储起来</p><p>git stash：将当前工作现场存储起来，等以后恢复现场工作后继续使用，此时git status非常的干净</p><p>查看：git stash list</p><p>恢复：git stash apply  -  恢复后不删除stash中的内容，需要用 git stash drop 来删除</p><p>​      git stash pop  -  恢复的同时删除</p><p>​       git stash apply stash@{0}：恢复指令的stash</p><p>feature分支</p><p>每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分</p><p>强行删除未合并的分支：git branch -D <file></file></p><h3 id="标签设置"><a href="#标签设置" class="headerlink" title="标签设置"></a>标签设置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出标签</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag -l <span class="string">&quot;v1.8.5&quot;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -l/-list 指定需要某些标签，如上只输出 v1.8.5 系列的</span></span><br></pre></td></tr></table></figure><h4 id="标签类型"><a href="#标签类型" class="headerlink" title="标签类型"></a><strong>标签类型</strong></h4><ol><li><strong>轻量标签（lightweight）</strong>：像一个不会改变的分支，它只是某个提交的引用</li><li><strong>附注标签（annotated）</strong>：是存储在git数据库的一个完整对象，它可以被校验，其中包含打标签者的名字、电子邮件、地址、日期时间，此外还有一个标签信息，并且可以使用GNU Privacy Guard（GPG）签名并验证</li></ol><h4 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a><strong>创建标签</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag -a v1.4 -m <span class="string">&quot;指定一条标签信息&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 轻量只用指定标签名字</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag v1.4</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 给历史版本打标签</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag -a v1.4 commitId</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git show v1.4</span></span><br></pre></td></tr></table></figure><ul><li>查看标签信息和与之对应的提交信息，如果是轻量标签则只会有提交信息</li></ul><h4 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a><strong>删除标签</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag -d v1.4</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin :refs/tags/v1.4</span></span><br></pre></td></tr></table></figure><ul><li>本地删除标签后并不会在远程仓库移除，需要执行第二条指令</li><li>将冒号前面的空值推送到远程标签名，从而高效地删除它</li><li>或者使用下面的方式更直观的删除</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin --delete &lt;tagname&gt;</span></span><br></pre></td></tr></table></figure><h4 id="共享标签"><a href="#共享标签" class="headerlink" title="共享标签"></a><strong>共享标签</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin v1.4</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin --tags</span></span><br></pre></td></tr></table></figure><ul><li><p>在创建完标签后你必须显式地推送标签到共享服务器上</p></li><li><p>–tags：这将会把所有不在远程仓库服务器上的标签全部传送到那里</p></li></ul><h4 id="检出标签"><a href="#检出标签" class="headerlink" title="检出标签"></a><strong>检出标签</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout 2.0.0</span></span><br></pre></td></tr></table></figure><ul><li>查看某个标签所指向的文件版本，但这会是你的仓库处于“分离头指针（detached HEAD）”的状态<ul><li>此状态如果你做了某些更改然后提交它们，标签不会发生变化， 但你的新提交将不属于任何分支，并且将无法访问，除非通过确切的提交哈希才能访问。 因此，如果你需要进行更改，比如你要修复旧版本中的错误，那么通常需要创建一个新分支<code>$ git checkout -b version2 v2.0.0</code></li></ul></li></ul><h3 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h3><h1 id="SVM"><a href="#SVM" class="headerlink" title="SVM"></a>SVM</h1><p>阿斯顿</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;h3 id=&quot;发展历史&quot;&gt;&lt;a href=&quot;#发展历史&quot; class=&quot;headerlink&quot; title=&quot;发展历史&quot;&gt;&lt;/a&gt;发展历史&lt;/h</summary>
      
    
    
    
    <category term="notebook" scheme="https://jieyang-wei.github.io/categories/notebook/"/>
    
    
    <category term="linux" scheme="https://jieyang-wei.github.io/tags/linux/"/>
    
    <category term="git" scheme="https://jieyang-wei.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://jieyang-wei.github.io/2020/12/12/hello-world/"/>
    <id>https://jieyang-wei.github.io/2020/12/12/hello-world/</id>
    <published>2020-12-12T08:51:34.056Z</published>
    <updated>2020-12-14T10:13:12.832Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a class="link" href="https://hexo.io/">Hexo<i class="fas fa-external-link-alt"></i></a>! This is your very first post. Check <a class="link" href="https://hexo.io/docs/">documentation<i class="fas fa-external-link-alt"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link" href="https://hexo.io/docs/troubleshooting.html">troubleshooting<i class="fas fa-external-link-alt"></i></a> or you can ask me on <a class="link" href="https://github.com/hexojs/hexo/issues">GitHub<i class="fas fa-external-link-alt"></i></a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a class="link" href="https://hexo.io/docs/writing.html">Writing<i class="fas fa-external-link-alt"></i></a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a class="link" href="https://hexo.io/docs/server.html">Server<i class="fas fa-external-link-alt"></i></a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a class="link" href="https://hexo.io/docs/generating.html">Generating<i class="fas fa-external-link-alt"></i></a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a class="link" href="https://hexo.io/docs/one-command-deployment.html">Deployment<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a class=&quot;link&quot; href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;i class=&quot;fas fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/a&gt;! This is your very first post. Check </summary>
      
    
    
    
    <category term="course" scheme="https://jieyang-wei.github.io/categories/course/"/>
    
    
    <category term="hello-world" scheme="https://jieyang-wei.github.io/tags/hello-world/"/>
    
  </entry>
  
</feed>
