<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WeiJY&#39;s blog</title>
  
  
  <link href="https://jieyang-wei.github.io/atom.xml" rel="self"/>
  
  <link href="https://jieyang-wei.github.io/"/>
  <updated>2021-03-20T05:42:32.129Z</updated>
  <id>https://jieyang-wei.github.io/</id>
  
  <author>
    <name>Wei Jieyang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>网络爬虫</title>
    <link href="https://jieyang-wei.github.io/2021/03/20/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"/>
    <id>https://jieyang-wei.github.io/2021/03/20/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/</id>
    <published>2021-03-20T05:41:03.000Z</published>
    <updated>2021-03-20T05:42:32.129Z</updated>
    
    <content type="html"><![CDATA[<p>p2p基础</p><p>python包：</p><ul><li>request</li><li>webdriver</li><li>scrapy</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;p2p基础&lt;/p&gt;
&lt;p&gt;python包：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;request&lt;/li&gt;
&lt;li&gt;webdriver&lt;/li&gt;
&lt;li&gt;scrapy&lt;/li&gt;
&lt;/ul&gt;
</summary>
      
    
    
    
    <category term="course" scheme="https://jieyang-wei.github.io/categories/course/"/>
    
    <category term="network" scheme="https://jieyang-wei.github.io/categories/course/network/"/>
    
    
    <category term="python" scheme="https://jieyang-wei.github.io/tags/python/"/>
    
    <category term="network" scheme="https://jieyang-wei.github.io/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>fabric-Tutorials</title>
    <link href="https://jieyang-wei.github.io/2021/03/19/fabric-Tutorials/"/>
    <id>https://jieyang-wei.github.io/2021/03/19/fabric-Tutorials/</id>
    <published>2021-03-19T03:33:34.000Z</published>
    <updated>2021-03-22T07:54:38.996Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本部分详细介绍了Hyperledger Fabric中的客户端应用程序和智能合约开发的关键功能。对功能的深入了解将帮助您设计和实施高效的解决方案。</p><h1 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h1><p>智能合约是高级编程抽象的一个示例，可以在链码容器中定义智能合约。将链码安装在对等方上并部署到通道后，其中的所有智能合约都可用于您的应用程序。</p><blockquote><p>一个智能合约只能属于一个chaincode，但一个chaincode中可以包含多个智能合约</p><ul><li><strong>合同名称在链码文件中必须唯一</strong>。某些代码编辑器会在部署之前检测到相同类名的多个定义。如果显式或隐式指定了多个具有相同协定名称的类，则链代码将返回错误。</li><li><strong>不指定链码中的合约将默认使用第一个合约</strong></li><li><strong>单个链码中存放多个相关合约是有意义的</strong>。<ul><li>例如，在不同的货币计价的可能有合同的商业票据<code>EuroPaperContract</code>， <code>DollarPaperContract</code>，  <code>YenPaperContract </code>这可能需要保持在它们所部署的通道相互同步。</li></ul></li></ul></blockquote><h2 id="链码"><a href="#链码" class="headerlink" title="链码"></a>链码</h2><p>链码是用于将代码部署到Hyperledger Fabric区块链网络的通用容器</p><p>当写好链码文件后（此例中为 commercialpaper.js），需要经过以下步骤：</p><ul><li>打包：peer chaincode package</li><li>下载到通道：peer chaincode install</li><li>组织管理员批准链码：peer chaincode approveformyorg</li><li>当满足制定策略之后，通道上任一节点均可提交此链码：peer chaincode commit</li></ul><h3 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h3><p>链码的namespace允许它保持其世界状态与其他链码分离。</p><ul><li><p>具体来说，具有相同链码的智能合约共享对同一世界状态的直接访问，而具有不同链码的智能合约不能直接访问彼此的世界状态。</p><ul><li><p>即Chaincode命名空间提供了不同世界状态之间的<strong>隔离</strong></p><blockquote><p>注意：不能选择链码名称空间。它由Hyperledger Fabric分配，并直接映射到链码的名称</p></blockquote></li></ul></li><li><p>如果智能合约需要访问另一个链码世界状态，则可以通过执行链码到链码的调用来做到这一点。</p></li><li><p>最后，区块链可以包含与不同世界状态相关的交易。</p></li></ul><blockquote><p>注意：</p><p>将同一个链码部署到不同peer的channel上时，将创建一个完全独立的区块链，并创建两个新的世界状态数据库。但是，peer和chaincode container不会增加，每个都将连接到多个通道。</p></blockquote><h3 id="同链码访问"><a href="#同链码访问" class="headerlink" title="同链码访问"></a>同链码访问</h3><p><strong>示例图：</strong></p><p>![截屏2021-03-19 下午9.02.21](fabric-Tutorials/截屏2021-03-19 下午9.02.21.png)</p><ul><li>应用程序与对等方进行通信，并且对等方将请求路由到适当的链码容器，然后容器可以访问DBMS。该路由由图中所示的对等<strong>核心</strong>组件完成。</li></ul><p><strong>示例代码：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> euroPaper = network.getContract(papers, euroPaper);</span><br><span class="line">paper1 = euroPaper.submit(issue, PAP11);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> yenPaper = network.getContract(papers, yenPaper);</span><br><span class="line">paper2 = yenPaper.submit(redeem, PAP21);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> euroBond = network.getContract(bonds, euroBond);</span><br><span class="line">bond1 = euroBond.submit(buy, BON31);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> yenBond = network.getContract(bonds, yenBond);</span><br><span class="line">bond2 = yenBond.submit(sell, BON41);</span><br></pre></td></tr></table></figure><ol><li><strong>应用程序</strong><ul><li>使用 <code>getContract()</code> API访问 <code>papers</code>链码中的 <code>euroPaper</code> 和 <code>yenPaper</code> 合约。<ul><li>参见交互点<strong>1a</strong>和<strong>2a</strong>。</li></ul></li><li>使用 <code>getContract()</code>。API访问 <code>bonds</code> 链码中的 <code>euroBond</code> 和 <code>yenBond</code> 合约。<ul><li>参见交互点<strong>3a</strong>和<strong>4a</strong>。</li></ul></li><li>使用 <code>euroPaper</code> 合约将 <code>issue</code> 交易提交到网络以获取商业票据 <code>PAP11</code>。参见相互作用点<strong>1a</strong>。结果在  <code>world state A</code> 中产生了商业票据 <code>PAP11</code>；相互作用点<strong>1b</strong>。该操作在交互点<strong>1c</strong>被捕获为区块链中的交易。</li><li>使用 <code>yenPaper</code> 合约将 <code>redeem</code> 交易提交到网络以获取商业票据 <code>PAP21</code>。参见交互点<strong>2a</strong>。这导致在<code>world state A</code> 中商业票据 <code>PAP21</code> 的状态为赎回中；交互点<strong>2b</strong>。该操作在交互点<strong>2c</strong>被捕获为区块链中的交易。</li><li>使用 <code>euroBond</code> 合约操作 <code>BON41</code> 进行 <code>buy</code> 交易并提交到网络。参见相互作用点<strong>3a</strong>。这导致在 <code>world state B</code> 中 <code>BON31</code> 的状态更新，相互作用点<strong>3b</strong>。该操作在交互点<strong>3c</strong>被捕获为区块链中的交易。</li><li>使用 <code>yenBond</code> 合约操作 <code>BON41</code> 进行 <code>sell</code> 交易并提交到网络。参见相互作用点<strong>4a</strong>。这导致在 <code>world state B</code> 中 <code>BON41</code> 的状态更新，相互作用点 <strong>4b</strong>。该操作在交互点<strong>4c</strong>被捕获为区块链中的交易。</li></ul></li></ol><ol start="2"><li><strong>了解智能合约如何与世界状态交互：</strong></li></ol><ul><li><code>euroPaper</code>和<code>yenPaper</code>合同可以直接访问 <code>world state A</code>，但不能直接访问 <code>world state B</code>。<code>World state A</code> 物理地存储在与链码 <code>papers</code> 相对应的数据库管理系统（DBMS）中的数据库中。</li><li><code>euroBond</code>和<code>yenBond</code>合同可以直接访问 <code>world state B</code>，但不能直接访问 <code>world state A</code>。<code>World state B</code> 物理地存储在与链码 <code>Bonds</code> 相对应的数据库管理系统（DBMS）中的数据库中。</li></ul><ol start="3"><li><strong>了解区块链如何捕获所有世界各州的交易：</strong></li></ol><ul><li>互动<strong>1C</strong>和<strong>2C</strong>对应的交易分别创建和更新商业票据<code>PAP11</code>和<code>PAP21</code>分别。这些都包含在 <code>world state A</code> 中</li><li>互动<strong>3c</strong>和<strong>4c</strong>对应于更新债券 <code>BON31</code> 和  <code>BON41</code> 的交易。这些都包含 <code>world state B</code> 中。</li><li>如果 <code>world state A</code> 或 <code>world state B</code> 由于某种原因被销毁，则可以通过重新执行区块链中的所有交易来重新创建它们。</li></ul><h3 id="跨链码访问"><a href="#跨链码访问" class="headerlink" title="跨链码访问"></a>跨链码访问</h3><p><strong>示例图</strong></p><p><img src="/2021/03/19/fabric-Tutorials/develop.diagram.51.png" alt="develop.diagram.51"></p><ol><li>链码和智能合约如何通过他们的链码间接访问其他世界状态<ul><li>该应用程序在 <code>euroPaper</code> 智能合约中提交 <code>issue</code> 来发行 <code>PAP11</code>。参见互动<strong>1a</strong>。</li><li>智能合约 <code>euroPaper</code> 中的 <code>issue</code> 交易需要调用 <code>euroBond</code> 智能合约中的 <code>query</code> 交易。参见相互作用点<strong>1b</strong>。</li><li>在智能合约  <code>euroBond</code> 中 <code>query</code> 交易能检索 <code>world state B</code> 的信息。参见相互作用点<strong>1c</strong>。</li><li>当控制权返回 <code>issue</code> 交易时，它可以使用响应中的信息对 paper 定价并更新 。<code>world state A</code> 的信息。参见相互作用点<strong>1d</strong>。</li><li>发行以Yen计价的商业票据的控制流程是相同的。参见交互点<strong>2a</strong>，<strong>2b</strong>，<strong>2c</strong>和<strong>2d</strong>。</li></ul></li></ol><blockquote><p>使用<code>invokeChaincode()</code> <a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#invokeChaincode__anchor">API<i class="fas fa-external-link-alt"></i></a>在链代码之间传递control。</p><ul><li>该API将control从一个链码传递到另一个链码。</li><li>如果只 <strong>query</strong> 被调用的链码世界状态，调用可以在与调用者的链码不同的通道中进行。</li><li>如果需要 <strong>update</strong> 被调用的链码世界状态，调用必须与调用者链码在同一通道中。</li></ul></blockquote><p>尽管在示例中我们仅讨论了查询交易，但是可以调用智能合约来更新被调用的链码的世界状态</p><h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><p>在commercial paper中，链码papercontract中只包含了一个名为 <code>org.papernet.commercialpaper</code> 的合约</p><ul><li><p>合约构造</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommercialPaperContract</span> <span class="keyword">extends</span> <span class="title">Contract</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// Unique name when multiple contracts per chaincode file</span></span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&#x27;org.papernet.commercialpaper&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果未指定显式合同名称，则将分配默认名称 - 类的名称。<ul><li>在我们的示例中，<strong>默认合同名称</strong>为 <code>CommercialPaperContract</code>。</li></ul></li><li>建议使用显式的<strong>DNS样式</strong>命名约定，以帮助组织清晰且有意义的名称<ul><li><code>org.papernet.commercialpaper</code> 表示PaperNet网络已经定义了标准的商业用纸智能合约</li></ul></li></ul></li></ul><ul><li>合同名称在链码文件中必须唯一。某些代码编辑器会在部署之前检测到相同类名的多个定义。如果显式或隐式指定了多个具有相同协定名称的类，则链代码将返回错误。</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>将链码安装到对等方并部署到通道后，应用程序即可访问其中的智能合约：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> network = <span class="keyword">await</span> gateway.getNetwork(<span class="string">`papernet`</span>);</span><br><span class="line"><span class="keyword">const</span> contract = <span class="keyword">await</span> network.getContract(<span class="string">&#x27;papercontract&#x27;</span>, <span class="string">&#x27;org.papernet.commercialpaper&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> issueResponse = <span class="keyword">await</span> contract.submitTransaction(<span class="string">&#x27;issue&#x27;</span>, <span class="string">&#x27;MagnetoCorp&#x27;</span>, <span class="string">&#x27;00001&#x27;</span>, <span class="string">&#x27;2020-05-31&#x27;</span>, <span class="string">&#x27;2020-11-30&#x27;</span>, <span class="string">&#x27;5000000&#x27;</span>);</span><br></pre></td></tr></table></figure><ul><li>CommercialPaperContract 使用名称 org.papernet.commercialpaper 调用父类Contract来构造实例</li><li>所以network可以通过此名称定为到 CommercialPaperContract 类</li><li>contract 对象再调用CommercialPaperContract 类中定义的方法进行交易</li></ul><h1 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h1><h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><ul><li><p>允许智能合约在交易调用之间定义和维护用户变量</p></li><li><p>可以包含任意数量的用户变量，例如 <code>paperList</code>。</p></li><li><p>注意到一个智能合约的初始化流程：(路径：contract/papercontract.js)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommercialPaperContext</span> <span class="keyword">extends</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="comment">// All papers are held in a list of papers</span></span><br><span class="line">        <span class="built_in">this</span>.paperList = <span class="keyword">new</span> PaperList(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommercialPaperContract</span> <span class="keyword">extends</span> <span class="title">Contract</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// Unique namespace when multiple contracts per chaincode file</span></span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&#x27;org.papernet.commercialpaper&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="function"><span class="title">createContext</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommercialPaperContext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">issue</span>(<span class="params">ctx, issuer, paperNumber, ...</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">await</span> ctx.paperList.addPaper(...);</span><br><span class="line">        <span class="keyword">await</span> ctx.stub.putState(...);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">buy</span>(<span class="params">ctx, issuer, paperNumber, ...</span>)</span>&#123; &#125;</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">redeem</span>(<span class="params">ctx, issuer, paperNumber, ...</span>)</span>&#123; &#125;</span><br><span class="line">    ... ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>构建智能合约时，开发人员可以选择内置的 <code>Context</code> 类 <code>createContext</code> 方法以创建自定义上下文</li><li>本例中，<code>CommercialPaperContext</code>专门用于 <code>CommercialPaperContract</code>。观察指定的 <code>context</code> 如何通过 <code>this</code> 关键字将 <code>PaperList</code> 添加到自己的成员中</li></ul></li></ul><p>transaction context还包含两个内置元素，这些元素提供对范围广泛的Fabric功能的访问，从提交交易的客户端应用程序到分类帐访问。</p><ul><li>**<code>ctx.stub</code>**：用于访问API，这些API从分类账提供各种交易处理操作<ul><li><code>putState()</code> 和 <code>getState()</code> 访问分类账，<code>getTxID()</code> 以检索当前交易ID。</li></ul></li><li>**<code>ctx.clientIdentity</code>**： 用于获取有关提交交易的用户身份的信息。</li></ul><p>一个智能合约通过 <code>stub </code>和 <code>clientIdentity</code> 可以访问一系列的功能：</p><img src="/2021/03/19/fabric-Tutorials/develop.diagram.41.png" alt="develop.diagram.41" style="zoom:45%;"><h3 id="Stub"><a href="#Stub" class="headerlink" title="Stub"></a>Stub</h3><p>API分类：</p><ol><li><strong>World state data APIs</strong> - 交互点**(1)**<ul><li>使智能合约能够使用其密钥从世界状态中获取，放置和删除与各个对象相对应的状态<ul><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getState__anchor">getState( )<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#putState__anchor">putState( )<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#deleteState__anchor">deleteState( )<i class="fas fa-external-link-alt"></i></a></li></ul></li><li>辅以<strong>query API</strong>：交互点**(2)** - 使合同能够检索一组状态而不是单个状态，该集合可以通过使用完整或部分键的键值范围来定义，也可以根据基础世界状态数据库中的值进行查询 。对于大型查询，可以对结果集进行分页以减少存储需求：<ul><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getStateByRange__anchor">getStateByRange( )<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getStateByRangeWithPagination__anchor">getStateByRangeWithPagination( )<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getStateByPartialCompositeKey__anchor">getStateByPartialCompositeKey( )<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getStateByPartialCompositeKeyWithPagination__anchor">getStateByPartialCompositeKeyWithPagination( )<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getQueryResult__anchor">getQueryResult( )<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getQueryResultWithPagination__anchor">getQueryResultWithPagination( )<i class="fas fa-external-link-alt"></i></a></li></ul></li></ul></li></ol><ol start="2"><li><strong>私有数据APIs</strong> - 交互点**(3)**<ul><li>这些API使智能合约能够与私有数据收集进行交互。它们类似于用于世界状态交互的API，但用于私有数据。有一些API可以通过其键获取，放置和删除私有数据状态：<ul><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getPrivateData__anchor">getPrivateData( )<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#putPrivateData__anchor">putPrivateData( )<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#deletePrivateData__anchor">deletePrivateData( )<i class="fas fa-external-link-alt"></i></a></li></ul></li><li>辅以<strong>query API</strong>：交互点**(4)** - 这些API允许智能合约根据一系列键值（全部或部分键）从私有数据集合中检索一组状态，或者根据基础<strong>世界状态数据库</strong>中的值进行查询 。当前没有用于私有数据收集的分页API。<ul><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getPrivateDataByRange__anchor">getPrivateDataByRange( )<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getPrivateDataByPartialCompositeKey__anchor">getPrivateDataByPartialCompositeKey( )<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getPrivateDataQueryResult__anchor">getPrivateDataQueryResult( )<i class="fas fa-external-link-alt"></i></a></li></ul></li></ul></li></ol><ol start="3"><li><strong>Transaction APIs</strong> - 交互点**(5)**<ul><li>智能合约使用这些API来检索有关智能合约正在处理的当前交易提议的详细信息。这包括交易标识符和创建交易提议的时间。<ul><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getTxID__anchor">getTxID( )<i class="fas fa-external-link-alt"></i></a>：返回当前交易建议的id。**(5)**</li><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getTxTimestamp__anchor">getTxTimestamp( )<i class="fas fa-external-link-alt"></i></a> ：返回应用程序创建当前交易建议时的时间戳。**(5)**</li><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getCreator__anchor">getCreator( )<i class="fas fa-external-link-alt"></i></a> ：返回交易建议创建者的原始身份（X.509或其他）。如果这是X.509证书，则通常更适合使用 <code>ctx.ClientIdentity</code>。</li><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getSignedProposal__anchor">getSignedProposal( )<i class="fas fa-external-link-alt"></i></a> ：返回智能合约正在处理的当前交易提议的签名副本。</li><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getBinding__anchor">getBinding( )<i class="fas fa-external-link-alt"></i></a> ：用于防止使用随机数恶意或意外重播交易。（出于实际目的，随机数是由客户端应用程序生成并包含在加密哈希中的随机数。）例如，智能合约可以在**(1)<strong>使用此API 来检测交易是否重播</strong>(5)**。</li><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getTransient__anchor">getTransient( )<i class="fas fa-external-link-alt"></i></a> ：允许智能合约访问应用程序传递给智能合约的临时数据。请参阅交互点**(9)<strong>和</strong>(10)<strong>。临时数据是应用程序-智能合约交互的私有数据。它没有记录在分类帐中，通常与私人数据收集</strong>(3)**结合使用。</li></ul></li></ul></li></ol><ol start="4"><li><strong>Key APIs</strong> - 交互点**(2)<strong>和</strong>(4)**<ul><li>是智能合约可以操纵世界状态或私有数据收集中的状态密钥</li><li>这些API中最简单的API允许智能合约从其单独的组件中形成和拆分组合密钥。<ul><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/%7BBRACNH%7D/api/fabric-shim.ChaincodeStub.html#createCompositeKey__anchor">createCompositeKey( )<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#splitCompositeKey__anchor">splitCompositeKey( )<i class="fas fa-external-link-alt"></i></a></li></ul></li><li><code>ValidationParameter()</code> ：稍微先进一些，这些 API可以获取和设置针对世界状态**(2)<strong>和私有数据</strong>(4)**的基于状态的endorsement。<ul><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#setStateValidationParameter__anchor">setStateValidationParameter( )<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getStateValidationParameter__anchor">getStateValidationParameter( )<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getPrivateDataValidationParameter__anchor">getPrivateDataValidationParameter( )<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#setPrivateDataValidationParameter__anchor">setPrivateDataValidationParameter( )<i class="fas fa-external-link-alt"></i></a></li></ul></li><li><code>getHistoryForKey()</code>：通过返回存储值的的集合来检索状态的历史记录，该存储值包括执行状态更新的交易得id，从而允许从区块链读取交易**(10)**。<ul><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getHistoryForKey__anchor">getHistoryForKey( )<i class="fas fa-external-link-alt"></i></a></li></ul></li></ul></li></ol><ol start="5"><li><strong>Event APIs</strong> - 交互点**(5)**<ul><li>用于在处理智能合约期间设置事件</li><li>智能合约使用此API将事件添加到交易响应中。请注意，在交易中只能创建一个事件，并且当合同通过 <code>invokeChaincode</code> 相互调用时，该事件必须起源于最外面的合同。这些事件最终记录在区块链上，并在交互点**(11)**发送到侦听应用程序 。<ul><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#setEvent__anchor">setEvent( )<i class="fas fa-external-link-alt"></i></a></li></ul></li></ul></li></ol><ol start="6"><li><strong>Utility APIs</strong><ul><li>是有用的API的集合，这些API并不容易放入预定义的类别中，因此我们将它们分组在一起！它们包括检索当前通道名称，并将控制权传递给同一对等方上的不同链码。</li><li>任何peer均可使用，来获取应用程序在<strong>哪个通道</strong>上调用了智能合约 - 交互点**(13)**<ul><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getChannelID__anchor">getChannelID( )<i class="fas fa-external-link-alt"></i></a></li></ul></li><li>（不懂）MagnetoCorp组织中的Peer3上安装了多个智能合约。这些智能合约可以使用此API相互调用。智能合约必须并置/collocated；无法在其他对等方上调用智能合约。 - 交互点**(14)**<ul><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#invokeChaincode__anchor">invokeChaincode( )<i class="fas fa-external-link-alt"></i></a></li></ul></li><li>其中一些API仅在使用低级链码而不是智能合约的情况下使用。这些API主要用于链码输入的详细操作。智能合约 <code>Contract</code> 类会自动为开发人员整理所有的参数。<ul><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getFunctionAndParameters__anchor">getFunctionAndParameters( )<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getStringArgs__anchor">getStringArgs( )<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getArgs__anchor">getArgs( )<i class="fas fa-external-link-alt"></i></a></li></ul></li></ul></li></ol><h3 id="ClientIdentity"><a href="#ClientIdentity" class="headerlink" title="ClientIdentity"></a>ClientIdentity</h3><p>在大多数情况下，提交交易的应用程序将使用X.509证书。</p><p>在本示例中，由 <code>CA1</code> <strong>(7)**颁发的X.509证书</strong>(6)**被  <code>Isabella</code>  **(8)**在其应用程序中用来在交易 <code>t6</code> **(5)**中签署提案。</p><p><code>ClientIdentity </code> 接收  <code>getCreator()</code> 返回的信息，并将一组X.509实用程序API放在其顶部，以使其更易于在此常见用例中使用。</p><ul><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ClientIdentity.html#getX509Certificate__anchor">getX509Certificate( )<i class="fas fa-external-link-alt"></i></a>：返回交易提交者的完整X.509证书，包括其所有属性及其值 - 交互点**(6)**</li><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ClientIdentity.html#getAttributeValue__anchor">getAttributeValue( )<i class="fas fa-external-link-alt"></i></a>：返回特定X.509属性的值，例如，组织单位 <code>OU</code> 或专有名称 <code>DN</code> - 交互点**(6)**</li><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ClientIdentity.html#assertAttributeValue__anchor">assertAttributeValue( )<i class="fas fa-external-link-alt"></i></a>：返回<code>TRUE</code>，如果X.509属性的指定属性具有指定的值 - 交互点**(6)**</li><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ClientIdentity.html#getID__anchor">getID( )<i class="fas fa-external-link-alt"></i></a>：根据交易提交者的专有名称和颁发方CA的专有名称，返回交易提交者的唯一标识id，格式为 <code>x509::&#123;subject DN&#125;::&#123;issuer DN&#125;</code> - 交互点**(6)**。</li><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ClientIdentity.html#getMSPID__anchor">getMSPID( )<i class="fas fa-external-link-alt"></i></a>：返回交易提交者的channel MSP。这使智能合约可以根据提交者的组织身份做出处理决策 - 交互点**(15)<strong>或</strong>(16)**</li></ul><h2 id="Transaction-handlers"><a href="#Transaction-handlers" class="headerlink" title="Transaction handlers"></a>Transaction handlers</h2><p>交易处理程序允许智能合约开发人员在应用程序与智能合约之间的交互过程中的关键点定义通用处理。</p><ul><li>交易处理程序是可选的，但如果定义，它们将在调用智能合约中的每个交易之前或之后获得控制。即使没有定义也并不影响智能合约的正常运行。</li><li>还有一个特定的处理程序，该处理程序在发出请求以调用智能合约中未定义的交易时接收控制。</li><li>一个智能合约最多可以定义每种类型的一个handler，如果需要执行多个功能，则需要在功能内进行协调</li></ul><p><strong>1、类型：</strong></p><img src="/2021/03/19/fabric-Tutorials/截屏2021-03-20 下午4.54.53.png" alt="截屏2021-03-20 下午4.54.53" style="zoom:50%;"><ul><li><strong>Before handler</strong>：<ul><li>在每个智能合约交易被调用之前触发</li><li>通常用来修改交易的 <code>context</code>。可以访问所有范围的Fabric API；</li><li>例如，它可以issue <code>getState()</code> 和 <code>putState()</code>。</li></ul></li><li><strong>After handler</strong>：<ul><li>在每个智能合约交易被调用之后触发</li><li>通常执行所有交易的后加工。可以访问所有范围的Fabric API；</li></ul></li><li><strong>Unknown handler</strong>：<ul><li>在尝试调用智能合约中没有定义的交易时触发</li><li>通常用来记录故障，以供管理员进行后续处理。可以访问所有范围的Fabric API；</li></ul></li></ul><p><strong>2、定义：</strong></p><p>交易处理程序将作为具有明确定义名称的方法添加到智能合约中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">CommercialPaperContract <span class="keyword">extends</span> Contract &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">beforeTransaction</span>(<span class="params">ctx</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// Write the transaction ID as an informational to the console</span></span><br><span class="line">        <span class="built_in">console</span>.info(ctx.stub.getTxID());</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">afterTransaction</span>(<span class="params">ctx, result</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// This handler interacts with the ledger</span></span><br><span class="line">        ctx.stub.cpList.putState(...);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">unknownTransaction</span>(<span class="params">ctx</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// This handler throws an exception</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Unknown transaction function&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>交易处理程序定义的形式对于所有处理程序类型都是相似的，但是请注意，<code>afterTransaction(ctx, result)</code> 也将接收交易返回的任何结果。</li><li>该<a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/main/api/fabric-contract-api.Contract.html">API文档<i class="fas fa-external-link-alt"></i></a>您展示了这些处理器的确切形式。</li></ul><p><strong>3、过程</strong></p><p>将处理程序添加到智能合约后，将在交易处理期间将其调用。在处理期间，处理程序接收<code>ctx</code>， 也就是 <code>transaction context</code>，执行一些处理，并在完成时返回控制。处理继续如下：</p><ul><li><p><strong>在处理程序之前</strong>：如果处理程序成功完成，则使用更新的 <code>context</code> 调用交易。如果处理程序引发异常，则不会调用该交易，并且智能合约将失败，显示异常错误消息。</p></li><li><p><strong>处理程序之后</strong>：如果处理程序成功完成，则智能合约将根据所调用的交易确定完成。如果处理程序引发异常，则交易将失败，并显示异常错误消息。</p></li><li><p><strong>未知处理程序</strong>：处理程序应通过引发带有所需错误消息的异常来完成。如果未指定<strong>Unknown处理程序</strong>，或者未引发异常，则存在显式默认处理；智能合约将失败，并显示<strong>未知的交易</strong>错误消息。</p></li></ul><p>当处理程序需要访问函数和参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">beforeTransaction</span>(<span class="params">ctx</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// Retrieve details of the transaction</span></span><br><span class="line">    <span class="keyword">let</span> txnDetails = ctx.stub.getFunctionAndParameters();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.info(<span class="string">`Calling function: <span class="subst">$&#123;txnDetails.fcn&#125;</span> `</span>);</span><br><span class="line">    <span class="built_in">console</span>.info(util.format(<span class="string">`Function arguments : %j <span class="subst">$&#123;stub.getArgs()&#125;</span> `</span><span class="string">`);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>此处理程序通过<a class="link" href="https://hyperledger-fabric.readthedocs.io/en/latest/developapps/transactioncontext.html#stub">transaction context<i class="fas fa-external-link-alt"></i></a>对象调用 utility API <code>getFunctionAndParameters</code>。</li></ul><h1 id="背书策略"><a href="#背书策略" class="headerlink" title="背书策略"></a>背书策略</h1><p>背书策略定义了认可交易以使其生效所需的最小组织集合。</p><ul><li>要进行背书，组织的背书对等方需要运行与交易关联的智能合约并签署其结果。</li><li>当订购服务将交易发送给 committed 的对等方时，他们将分别检查交易中的背书是否满足背书策略。如果不满足，则该交易将无效，并且对世界状态没有任何影响。</li></ul><p>背书策略以两种不同的粒度起作用：</p><ul><li>可以为<strong>整个命名空间</strong>以及<strong>单个状态键</strong>设置它们。它们使用诸如 <code>AND</code> 和 <code>OR</code> 的基本逻辑表达式来表示。</li><li>例如，在PaperNet中，该方法可以按以下方式使用：从MagnetoCorp出售给DigiBank的paper的背书政策可以设置为 <code>AND(MagnetoCorp.peer, DigiBank.peer)</code>，要求对paper进行任何更改都必须由MagnetoCorp和DigiBank进行背书。</li></ul><h1 id="连接配置"><a href="#连接配置" class="headerlink" title="连接配置"></a>连接配置</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gateway.connect(connectionProfile, connectionOptions);</span><br></pre></td></tr></table></figure><h2 id="Connection-Profile"><a href="#Connection-Profile" class="headerlink" title="Connection Profile"></a>Connection Profile</h2><p>连接配置文件</p><p>应用程序主要使用连接配置文件来配置处理所有网络交互的<strong>网关</strong>，从而使其能够专注于业务逻辑。</p><ul><li><p>连接配置文件主要中来配置网关，通常由了解网络拓扑的<strong>管理员</strong>创建。</p></li><li><p><strong>静态连接配置文件</strong>通常由详细了解网络拓扑的管理员创建。这是因为静态配置文件可以包含很多信息，并且管理员需要在相应的连接配置文件中捕获此信息。相反，<strong>动态配置文件</strong>将所需的定义量减到最少。</p></li><li><p><strong>静态网关</strong>比动态网关需要更多的信息，因为<strong>动态网关</strong>可以使用<a class="link" href="https://hyperledger-fabric.readthedocs.io/en/latest/discovery-overview.html">服务发现<i class="fas fa-external-link-alt"></i></a>来动态扩展连接配置文件中的信息</p></li><li><p>连接配置文不应该是网络通道的详尽描述，它只需要包含足够的信息即可使用它的网关</p><ul><li>根据需要添加和删除对等方，订购方，证书颁发机构，渠道和组织。</li><li>组件可能会启动和停止，或者发生意外故障（例如断电）。</li><li>服务发现可以在连接配置文件中扩充信息。具体而言，可以使用最少的Fabric拓扑信息来配置动态网关。其余的可以发现。</li></ul></li><li><p><strong>语法</strong>：json或者yaml</p></li></ul><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> yaml = <span class="built_in">require</span>(<span class="string">&#x27;js-yaml&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; Gateway &#125; = <span class="built_in">require</span>(<span class="string">&#x27;fabric-network&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> connectionProfile = yaml.safeLoad(fs.readFileSync(<span class="string">&#x27;../gateway/paperNet.yaml&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>));</span><br><span class="line"><span class="keyword">const</span> gateway = <span class="keyword">new</span> Gateway();</span><br><span class="line"><span class="keyword">await</span> gateway.connect(connectionProfile, connectionOptions);</span><br></pre></td></tr></table></figure><ul><li>通过使用连接配置文件配置网关，<code>issue.js</code> 将为网关提供应用于处理交易的相关网络拓扑</li><li>对于任何给定的组织而言，连接配置文件定义一个以上的对等点都是一种很好的做法 – 它可以防止<strong>单点故障</strong>。这种做法也适用于动态网关。为服务发现提供多个起点。</li><li><code>connectionOptions</code> 传递给网关配合连接配置文件。它们允许应用程序声明网关希望使用连接配置文件的方式。SDK会对它们进行解释，以控制与网络组件的交互模式，例如，选择要与之连接的身份或用于事件通知的对等实体。阅读<a class="link" href="https://hyperledger-fabric.readthedocs.io/en/latest/developapps/connectionoptions.html">有关<i class="fas fa-external-link-alt"></i></a>可用连接选项的列表以及何时使用它们的信息。</li></ul><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>文件路径</strong>：<code>commercial-paper/organization/magnetocorp/gateway/paperNet.yaml</code></p><p><strong>结构：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="attr">x-type:</span> <span class="string">&quot;hlfv1&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;to descript this connection profile&quot;</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">&quot;1.0.0&quot;</span></span><br><span class="line"><span class="attr">channels:</span></span><br><span class="line">  <span class="attr">channelName:</span></span><br><span class="line">    <span class="attr">orderers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">orderer1.orgName.example.com</span></span><br><span class="line">    <span class="attr">peers:</span></span><br><span class="line">    <span class="attr">peer1.orgName.example.com:</span></span><br><span class="line">      <span class="attr">endorsingPeer:</span> <span class="literal">true</span></span><br><span class="line">      <span class="string">...</span></span><br><span class="line">    <span class="attr">peer2.orgName.example.com:</span></span><br><span class="line">    <span class="string">...</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">organizations:</span></span><br><span class="line"><span class="attr">org1Name:</span></span><br><span class="line"><span class="attr">mspid:</span> <span class="string">OrgNameMSP</span></span><br><span class="line"><span class="attr">peers:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">peer1.orgName.example.com</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">peer2.orgName.example.com</span></span><br><span class="line"><span class="attr">certificateAuthorities:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">ca-orgname</span></span><br><span class="line"><span class="attr">org2Name:</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"></span><br><span class="line"><span class="attr">orderers:</span></span><br><span class="line">  <span class="attr">orderer1.orgName.example.com:</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">grpc://localhost:7050</span></span><br><span class="line">    <span class="attr">grpcOptions:</span></span><br><span class="line">      <span class="attr">ssl-target-name-override:</span> <span class="string">orderer1.magnetocorp.example.com</span></span><br><span class="line"></span><br><span class="line"><span class="attr">peers:</span></span><br><span class="line"><span class="attr">peer1.orgName.example.com:</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">grpc://localhost:7251</span></span><br><span class="line">    <span class="attr">grpcOptions:</span></span><br><span class="line">      <span class="attr">ssl-target-name-override:</span> <span class="string">peer2.magnetocorp.example.com</span></span><br><span class="line">      <span class="attr">request-timeout:</span> <span class="number">120001</span></span><br><span class="line">  <span class="attr">peer2.orgName.example.com:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line"></span><br><span class="line"><span class="attr">certificateAuthorities:</span></span><br><span class="line"><span class="attr">ca1-orgname:</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">http://localhost:7054</span></span><br><span class="line">    <span class="attr">httpOptions:</span></span><br><span class="line">      <span class="attr">verify:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">registrar:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">enrollId:</span> <span class="string">admin</span></span><br><span class="line">        <span class="attr">enrollSecret:</span> <span class="string">adminpw</span></span><br><span class="line">    <span class="attr">caName:</span> <span class="string">ca-orgname</span></span><br></pre></td></tr></table></figure><p><strong>主要信息：</strong></p><ul><li><p>第9行： <code>name: &quot;papernet.magnetocorp.profile.sample&quot;</code></p><p>这是连接配置文件的名称。尝试使用DNS样式名称；它们是传达意义的一种非常简单的方法。</p></li><li><p>第16行： <code>x-type: &quot;hlfv1&quot;</code></p><p>用户可以添加自己 <code>x-</code> 的“application-specific”的属性，就像使用HTTP标头一样。它们主要是为将来使用而提供的。</p></li><li><p>第20行： <code>description: &quot;Sample connection profile for documentation topic&quot;</code></p><p>连接配置文件的简短描述。尝试使此功能对可能是第一次看到此内容的读者有所帮助！</p></li><li><p>第25行： <code>version: &quot;1.0&quot;</code></p><p>此连接配置文件的架构版本。当前仅支持1.0版，并且没有预见到该架构会经常更改。</p></li><li><p>第32行： <code>channels:</code></p><p>这是第一条真正重要的一行。</p><p><code>channels:</code> 标识此连接配置文件描述的<strong>所有</strong>通道属性。但是，优良作法是将不同的通道保留在不同的连接配置文件中，尤其是当它们彼此独立使用时。</p><ul><li><p>第36行： <code>papernet:</code></p><p>下面是有关 <code>papernet</code> 的详细信息，是此连接配置文件中的第一个channel</p></li><li><p>第41行： <code>orderers:</code></p><p><code>papernet</code> 中所有 orderers 的详细信息。</p><p> <code>orderer1.magnetocorp.example.com</code> 为此频道的orderer(45)。这只是一个逻辑名称；稍后在连接配置文件中（第134-147行），将详细介绍如何连接到这个orderer。</p><p> <code>orderer2.digibank.example.com</code> 不在此列表中。应用程序将用自己组织的订购者，而不是其他组织的订购者</p></li><li><p>第49行： <code>peers:</code></p><p><code>papernet</code> 中所有 peers 的详细信息</p><p>你可以看到从MagnetoCorp列出了三个同行： <code>peer1.magnetocorp.example.com</code>，<code>peer2.magnetocorp.example.com</code> 和  <code>peer3.magnetocorp.example.com</code>。</p><ul><li>无需像在此处列出的那样列出在MagnetoCorp的所有peer。比如DigiBank中只列出了一个peer：<code>peer9.digibank.example.com</code>; 现在我们将确认，包括该对等点开始意味着背书策略要求MagnetoCorp和DigiBank背书交易。</li></ul><blockquote><p>使用时最好有多个peer，以<strong>避免单点故障。</strong></p><p>每个peer下面，你可以看到四个非排他性的角色设置：<strong>endorsingPeer</strong>， <strong>chaincodeQuery</strong>，<strong>ledgerQuery</strong>和<strong>EventSource的</strong>。</p><ul><li>了解<code>peer1</code>以及 <code>peer2</code>如何在担任<code>papercontract</code>主人时扮演所有角色。</li><li>相比之下，<code>peer3</code> 只能用于通知或访问分类账的区块链组件而不是世界状态的分类账查询，因此不需要安装智能合约。</li><li>请注意<code>peer9</code>，除了背书之外，不应将其用于其他任何用途，因为MagnetoCorp的其他peer可以更好地担当这些角色。</li></ul><p>以上信息是通过peer的逻辑名称和角色来描述的，在配置文件的后面，我们将看到这些peer的物理信息。</p></blockquote></li></ul></li><li><p>第97行： <code>organizations:</code></p><p>配置<strong>所有通道</strong>上某组织的属性。请注意，尽管<code>papernet</code>目前是唯一列出的通道，但这些组织适用于所有通道。这是因为组织可以位于多个通道中，并且通道可以具有多个组织。而且，某些应用程序操作与组织有关，而不是与通道有关。</p><ul><li><p>例如，应用程序可以使用<a class="link" href="https://hyperledger-fabric.readthedocs.io/en/latest/developapps/connectionoptions.html">连接选项<i class="fas fa-external-link-alt"></i></a>从其组织内的一个或所有对等方或网络内的所有组织请求通知。为此，需要有一个组织到对等方的映射</p></li><li><p>第101行： <code>MagnetoCorp:</code></p><ul><li><p>第109 / 116行：<code>peers:</code> / <code>certificateAuthorities:</code></p><p>列出的所有peer都被认为MagnetoCorp的一部分：<code>peer1</code>， <code>peer2</code>和<code>peer3</code>。</p><p>证书颁发机构也是如此。</p><blockquote><p> 请注意此处仍使用逻辑名称，与本<code>channels:</code>节相同；物理信息将在配置文件的后面列出。</p></blockquote></li></ul></li><li><p>第121行： <code>DigiBank:</code></p><p>仅列出了DigiBank的一部分peer：<code>peer9</code></p><p>没有列出证书颁发机构。这是因为DigiBank其他的peer和DigiBank CA均与本连接配置文件的用户无关。</p></li></ul></li></ul><blockquote><p>以下是之前相关逻辑名称对应的物理信息</p></blockquote><ul><li><p>第134行： <code>orderers:</code></p><p>现在列出了 orderers 的物理信息。由于此连接配置文件仅提及 <code>papernet</code> 的一个订购者，所以只列出了 <code>orderer1.magnetocorp.example.com</code> 的详细信息。</p><p>其中包括其<strong>IP地址</strong>和<strong>端口</strong>，以及<strong>gRPC选项</strong> <code>ssl-target-name-override</code>，可以在需要时覆盖与订购者进行通信时使用的默认值。</p><p>与一样<code>peers:</code>，对于高可用性，指定多个订购者是一个好主意。</p></li><li><p>第152行： <code>peers:</code></p><p>现在列出了先前所有对等方的物理信息。此连接配置文件有MagnetoCorp的三个对等方： ，<code>peer1</code>，<code>peer2</code>和 <code>peer3</code>; 对于DigiBank，列出了单个对等方 <code>peer9 </code>的信息。</p><p>对于每个对等方，如orderer一样，将列出其<strong>IP地址</strong>和<strong>端口</strong>，并列出<strong>gRPC选项</strong>，这些选项可以覆盖与特定对等方进行通信时使用的默认值（如有必要）。</p></li><li><p>194行： <code>certificateAuthorities:</code></p><p>现在列出了证书颁发机构的物理信息。连接配置文件为MagnetoCorp列出了一个CA <code>ca1-magnetocorp</code>，其物理信息如下。</p><p>除了IP地址 <code>url:</code> 之外，<code>resigter:</code> 表示还允许将此CA用于证书签名请求（CSR）。这些用于请求本地生成的公用/专用密钥对的新证书。</p></li></ul><h2 id="Connection-Options"><a href="#Connection-Options" class="headerlink" title="Connection Options"></a>Connection Options</h2><p>配置选项：允许应用程序声明网关希望与连接配置文件交互的方式</p><p>连接选项与连接配置文件一起使用，以<strong>精确</strong>控制网关与网络的交互方式。使用网关可以使应用程序专注于<strong>业务逻辑</strong>，而不是网络拓扑。</p><blockquote><p>网络由<strong>连接配置文件</strong>标识，<strong>配置选项</strong>精确指定网关应如何与之交互。</p></blockquote><h3 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h3><p>以MagnetoCorp的 <code>issue.js</code>为示例 ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userName = <span class="string">&#x27;User1@org1.example.com&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> wallet = <span class="keyword">new</span> FileSystemWallet(<span class="string">&#x27;../identity/user/isabella/wallet&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> connectionOptions = &#123;</span><br><span class="line">  identity: userName,</span><br><span class="line">  wallet: wallet,</span><br><span class="line">  eventHandlerOptions: &#123;</span><br><span class="line">    commitTimeout: <span class="number">100</span>,</span><br><span class="line">    strategy: EventStrategies.MSPID_SCOPE_ANYFORTX</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> gateway.connect(connectionProfile, connectionOptions);</span><br></pre></td></tr></table></figure><ul><li><code>identity</code> 和 <code>wallet</code> 选项为 <code>connectionOptions</code> 对象的简单属性 。它们分别具有值 <code>userName</code> 和 <code>wallet</code>，这些值在代码的前面设置。</li><li><code>eventHandlerOptions</code> 本身就是对象的选项。它具有两个属性：<ul><li><code>commitTimeout: 100</code>:（以秒为单位）</li><li><code>strategy: EventStrategies.MSPID_SCOPE_ANYFORTX</code></li></ul></li></ul><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><img src="/2021/03/19/fabric-Tutorials/develop.diagram.35.png" alt="develop.diagram.35" style="zoom:45%;"><ul><li><p><code>wallet</code>：标识代表应用程序使用网关的钱包。**(1)** ; </p><ul><li>钱包是由应用程序指定的，但实际上是从中检索身份的网关。</li><li>必须指定一个钱包；决定使用的钱包<a class="link" href="https://hyperledger-fabric.readthedocs.io/en/latest/developapps/wallet.html#type">类型<i class="fas fa-external-link-alt"></i></a>是最重要的 - 文件系统，内存，HSM还是数据库。</li></ul></li><li><p><code>identity</code>：是应用程序将使用的来自 <code>wallet</code> 的用户身份。**(2a)** ; </p><ul><li><strong>用户身份由应用程序指定</strong>，并代表应用程序的用户Isabella**(2b)**。但身份实际上是由网关检索的。<ul><li>在我们的示例中，不同MSP**(2c)**， **(2d)**将使用Isabella的身份来标识她来自MagnetoCorp，并且在其中具有特定角色。这两个事实将相应地确定她对资源的许可，例如能够读取和写入分类帐。</li></ul></li><li><strong>必须指定用户身份</strong>。如您所见，此身份对于Hyperledger Fabric是一个<strong>permissioned</strong>网络 - 所有参与者都具有一个身份，包括应用程序，peers 和 oderers，这些身份决定了他们对资源的控制。您可以在会员服务<a class="link" href="https://hyperledger-fabric.readthedocs.io/en/latest/membership/membership.html">主题中<i class="fas fa-external-link-alt"></i></a>阅读有关此想法的更多信息。</li></ul></li><li><p><code>clientTlsIdentity</code>：是从钱包**(3a)<strong>检索并用于网关和不同通道组件（例如peers和orderers）之间的安全通信</strong>(3b)<strong>的</strong>identity**。</p><ul><li>请注意，此<strong>identity</strong>不同于用户身份。尽管  <code>clientTlsIdentity</code> 对于安全通信很重要，但它不如用户身份那么基础，因为它的范围不会扩展到安全网络通信之外。</li><li><code>clientTlsIdentity</code>是可选的。建议您在生产环境中进行设置。您应该始终使用跟  <code>identity</code>不同的 <code>clientTlsIdentity</code>，因为这些身份具有不同的含义和生命周期。<ul><li>例如，如果你的 <code>clientTlsIdentity</code> 受到了损害，那么你的 <code>identity</code> 也会受到损害。将它们分开是更安全的。</li></ul></li></ul></li><li><p><code>eventHandlerOptions</code></p><ul><li><p><code>commitTimeout</code>：是可选的。它以秒为单位指定在将控制权返回给应用程序之前，网关应等待对等方**(4a)**提交交易的最长时间（默认为300s）。</p></li><li><p><code>strategy</code>：是可选的。它标识网关应用于侦听交易已提交的通知的对等体的集合。例如，是侦听组织中的单个对等方还是所有对等方。它可以采用以下值之一：</p><ul><li><p><code>EventStrategies.MSPID_SCOPE_ANYFORTX</code>：侦听用户<strong>组织内</strong>的<strong>任何</strong>对等方**(4b)**。MagnetoCorp的对等体1，对等体2或对等体3中的任何一个都可以通知网关。</p></li><li><p><code>EventStrategies.MSPID_SCOPE_ALLFORTX</code>： 这是<strong>默认值</strong>。监听用户<strong>组织内</strong>的<strong>所有</strong>对等方**(4b)<strong>。MagnetoCorp的所有对等方</strong>都必须**已通知网关。不包括<code>stopped</code>或<code>falied</code>的对等方。</p></li><li><p><code>EventStrategies.NETWORK_SCOPE_ANYFORTX</code>：侦听整个<strong>网络通道</strong>中的<strong>任何</strong>对等方**(4b)<strong>和</strong>(4c)**。MagnetoCorp的对等方1-3或DigiBank的对等方7-9中的任何一个都可以通知网关。</p></li><li><p><code>EventStrategies.NETWORK_SCOPE_ALLFORTX</code>：侦听整个<strong>网络通道</strong>中的<strong>所有</strong>对等方**(4b)<strong>和</strong>(4c)<strong>。MagnetoCorp和DigiBank的所有对等方</strong>都必须**通知网关；对等1-3和对等7-9。不包括<code>stopped</code>或<code>falied</code>的对等方。</p></li><li><p>&lt; <code>PluginEventHandlerFunction</code>&gt;：用户定义的事件处理程序的名称。这允许用户定义自己的事件处理逻辑。了解如何<a class="link" href="https://hyperledger.github.io/fabric-sdk-node/main/tutorial-transaction-commit-events.html">定义<i class="fas fa-external-link-alt"></i></a>事件处理程序插件，并检查<a class="link" href="https://github.com/hyperledger/fabric-sdk-node/blob/main/test/integration/network-e2e/sample-transaction-event-handler.js">样本程序<i class="fas fa-external-link-alt"></i></a>。</p><blockquote><p>仅当有非常特定的事件处理要求时，才需要用户定义的事件处理程序。通常，使用内置事件策略之一就足够了。用户定义的事件处理程序的一个示例可能是等待组织中超过一半的对等方来确认交易已提交。</p><p>如果确实指定了用户定义的事件处理程序，则它不会影响您的应用程序逻辑。它与这完全不同。SDK在处理过程中会调用处理程序；它决定何时调用它，并使用其结果选择要用于事件通知的对等方。SDK完成处理后，应用程序将收到控制权。</p><p>如果未指定用户定义的事件处理程序，则使用<code>EventStrategies</code>的默认值 </p></blockquote></li></ul></li></ul></li><li><p><code>discovery</code></p><ul><li><code>enabled</code>：是可选的，并且可能具有<code>true</code>或值<code>false</code>。默认值为<code>true</code>。它确定网关是否使用<a class="link" href="https://hyperledger-fabric.readthedocs.io/en/latest/discovery-overview.html">服务发现<i class="fas fa-external-link-alt"></i></a>来扩展连接配置文件中指定的网络拓扑。**(6)** ; 网关使用的对等方gossip information。<ul><li>该值会被 <code>INITIALIIZE-WITH-DISCOVERY</code> 环境变量覆盖</li></ul></li><li><code>asLocalhost</code>：是可选的，并且可能具有<code>true</code>或值<code>false</code>。默认值为<code>true</code>。它确定是否把在服务发现期间找到的IP地址从docker网络转换为本地主机。<ul><li>通常，开发人员会编写使用docker容器作为其网络组件（例如peer，orderer和CA）的应用程序，但这些应用程序本身不会在docker容器中运行。这就是 <code>true</code> 默认设置的原因；</li><li>在生产环境中，应用程序可能会以与网络组件相同的方式在docker容器中运行，因此不需要地址转换。在这种情况下，应用程序应显式指定 <code>false</code> 或使用环境变量替代。</li><li>该值将被 <code>DISCOVERY-AS-LOCALHOST</code> 环境变量覆盖</li></ul></li></ul></li></ul><p><strong>注意事项：</strong></p><p>下面的注意事项列表在决定如何选择连接选项时会很有帮助。</p><ul><li><p><code>eventHandlerOptions.commitTimeout</code> 和 <code>eventHandlerOptions.strategy</code>一起工作。</p><ul><li>例如，<code>commitTimeout: 100</code> 和 <code>strategy: EventStrategies.MSPID_SCOPE_ANYFORTX</code>表示网关将等待多达100秒，以便<strong>任何一个</strong>对等方确认交易已提交。相反，<code>strategy: EventStrategies.NETWORK_SCOPE_ALLFORTX</code> 意味着网关将对<strong>所有</strong>组织中的<strong>所有</strong>对等方最多等待100秒。</li></ul></li><li><p>默认值 <code>eventHandlerOptions.strategy: EventStrategies.MSPID_SCOPE_ALLFORTX</code> 将等待应用程序组织中的所有对等方提交交易。</p><ul><li>这是一个很好的默认设置，因为应用程序可以确保所有对等方都拥有分类账的最新副本，从而最大程度地减少了并发问题</li><li>但是，随着组织中对等方数目的增加，等待所有对等方变得有点不必要，在这种情况下，使用**&lt;可插入事件处理程序&gt;**可以提供更有效的策略。例如，在共识将使所有分类帐保持同步的安全假设下，可以使用相同的一组对等方来提交交易和侦听通知。</li></ul></li><li><p>需要 <code>clientTlsIdentity</code> 来设置服务发现。</p><ul><li>这是因为与应用程序交换信息的对等方需要确信他们正在与自己信任的实体交换信息。如果 <code>clientTlsIdentity</code>未设置，则无论 <code>discovery</code> 是否设置，都将不服从。</li></ul></li><li><p>尽管应用程序可以在连接到网关时设置连接选项，但是管理员可能有必要覆盖这些选项。</p><ul><li>这是因为选项与网络交互有关，该交互可能随时间而变化。例如，管理员试图了解使用服务发现对网络性能的影响。</li><li>一种好的方法是在一个配置文件中定义应用程序的重写，当应用程序配置其与网关的连接时，该配置文件将由应用程序读取。</li><li>因为发现选项<code>enabled</code>和<code>asLocalHost</code>是管理员最经常需要覆盖的选项，所以提供了环境变量 <code>INITIALIIZE-WITH-DISCOVERY</code>和<code>DISCOVERY-AS-LOCALHOST</code>以便于使用。管理员应在应用程序的生产运行时环境中设置这些设置，该环境很可能是docker容器。</li></ul></li></ul><h1 id="wallet"><a href="#wallet" class="headerlink" title="wallet"></a>wallet</h1><p>钱包包含一组用户身份。用户运行的应用程序在连接到通道时会选择这些身份之一。结合MSP使用此身份确定对诸如分类帐之类的信道资源的访问权限。</p><p><strong>过程：</strong></p><img src="/2021/03/19/fabric-Tutorials/develop.diagram.10.png" alt="develop.diagram.10" style="zoom:45%;"><ul><li>当应用程序连接到诸如PaperNet之类的网络通道时，它会选择一个用户身份进行连接<code>ID1</code>。通道MSP将<code>ID1</code>与特定组织内的角色相关联，并且该角色最终将确定应用程序对通道资源的权利。例如，<code>ID1</code>可能将某个用户标识为可以读写账本的MagnetoCorp组织成员，而<code>ID2</code>可能会标识MagnetoCorp中可以向联盟添加新组织的管理员。</li></ul><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>钱包存储的三种不同类型：文件系统，内存和CouchDB。</p><ul><li><strong>文件系统</strong>：这是最常见的存放钱包的地方；文件系统无处不在，易于理解，并且可以通过网络安装。对于钱包来说，它们是一个很好的默认选择。</li><li><strong>内存中</strong>：应用程序存储中的钱包。当您的应用程序在受限环境中运行而无法访问文件系统时，请使用这种钱包。通常是网络浏览器。值得记住的是，这种钱包是易变的。应用程序正常结束或崩溃后，身份将丢失。</li><li><strong>CouchDB</strong>：存储在CouchDB中的钱包。这是最罕见的钱包存储形式，但是对于那些想要使用数据库备份和还原机制的用户，CouchDB钱包可以提供一个有用的选项来简化灾难恢复。</li></ul><blockquote><p>使用wallet类的工厂函数创建钱包</p></blockquote><h3 id="HSM"><a href="#HSM" class="headerlink" title="HSM"></a>HSM</h3><p>硬件安全模块（HSM）是一种超安全的防篡改设备，用于存储数字身份信息，尤其是私钥。HSM可以本地连接到您的计算机或可通过网络访问。大多数HSM提供了使用私钥执行机载加密的功能，这样私钥就永远不会离开HSM。</p><ul><li><p>HSM可以与任何钱包类型一起使用。在这种情况下，身份证书将存储在钱包中，私钥将存储在HSM中。</p></li><li><p>要启用使用HSM管理的身份，<code>IdentityProvider</code> 必须使用HSM连接信息配置并在钱包中注册。有关更多详细信息，请参阅《<a class="link" href="https://hyperledger.github.io/fabric-sdk-node/main/tutorial-wallet.html">使用钱包管理身份<i class="fas fa-external-link-alt"></i></a>》教程。</p></li></ul><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>单个钱包可以保存多个身份，每个身份由特定的证书颁发机构颁发。每个身份具有一个标准结构，该标准结构包括<strong>描述性标签</strong>，<strong>公钥</strong>，<strong>私钥</strong>和某些特定于Fabric的<strong>metadata的X.509证书</strong>。不同的<a class="link" href="https://hyperledger-fabric.readthedocs.io/en/latest/developapps/wallet.html#types">钱包类型<i class="fas fa-external-link-alt"></i></a>将此结构适当地映射到其存储机制。</p><p><img src="/2021/03/19/fabric-Tutorials/develop.diagram.11.png" alt="develop.diagram.11"></p><ul><li>Fabric钱包可以使用由不同证书颁发机构颁发的证书来保存多个身份。<ul><li>身份包括<strong>证书</strong>，<strong>私钥</strong>和<strong>结构元数据</strong>。</li></ul></li></ul><p>生成钱包：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> identity: X509Identity = &#123;</span><br><span class="line">    credentials: &#123;</span><br><span class="line">        certificate: certificatePEM,</span><br><span class="line">        privateKey: privateKeyPEM,</span><br><span class="line">    &#125;,</span><br><span class="line">    mspId: <span class="string">&#x27;Org1MSP&#x27;</span>,</span><br><span class="line">    type: <span class="string">&#x27;X.509&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// const identityLabel = &#x27;isabella&#x27;;</span></span><br><span class="line"><span class="keyword">await</span> wallet.put(identityLabel, identity);</span><br></pre></td></tr></table></figure><p>获取身份：</p><ul><li><code>Gateway</code> 类只需要 <code>mspId</code> 和 <code>type</code> 来标识一个身份，它使用MSP ID在连接配置文件中识别一个对等方</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">organizations:</span></span><br><span class="line">  <span class="attr">Org1:</span></span><br><span class="line">    <span class="attr">mspid:</span> <span class="string">Org1MSP</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">peers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">peer0.org1.example.com</span></span><br></pre></td></tr></table></figure><ul><li>通过 <code>get()</code> 方法获得身份 <code>fabric-network.Identit</code>，没有则返回 <code>undefined</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// const identityLabel = &#x27;isabella&#x27;;</span></span><br><span class="line"><span class="keyword">const</span> userExists = <span class="keyword">await</span> wallet.get(<span class="string">&#x27;identityLabel&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="运行方式"><a href="#运行方式" class="headerlink" title="运行方式"></a>运行方式</h2><p>不同的钱包类型都实现了一个通用的<a class="link" href="https://hyperledger.github.io/fabric-sdk-node/main/module-fabric-network.Wallet.html">电子钱包<i class="fas fa-external-link-alt"></i></a>接口，该接口提供了一组标准的API来管理身份。</p><p><strong>生命周期</strong>：可以创建或打开钱包，并且可以读取，添加和删除身份。</p><p><strong>示例代码</strong>：<code>commercial-paper/organization/magnetocorp/application/addToWallet.js </code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wallet = <span class="keyword">await</span> Wallets.newFileSystemWallet(<span class="string">&#x27;../identity/user/isabella/wallet&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cert = fs.readFileSync(path.join(credPath, <span class="string">&#x27;.../User1@org1.example.com-cert.pem&#x27;</span>)).toString();</span><br><span class="line"><span class="keyword">const</span> key = fs.readFileSync(path.join(credPath, <span class="string">&#x27;.../_sk&#x27;</span>)).toString();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> identityLabel = <span class="string">&#x27;User1@org1.example.com&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> identity = &#123;</span><br><span class="line">    credentials: &#123;</span><br><span class="line">        certificate: cert,</span><br><span class="line">        privateKey: key,</span><br><span class="line">    &#125;,</span><br><span class="line">    mspId: <span class="string">&#x27;Org1MSP&#x27;</span>,</span><br><span class="line">    type: <span class="string">&#x27;X.509&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> wallet.put(identityLabel, identity);</span><br></pre></td></tr></table></figure><ul><li>首次运行该程序时，会在本地文件系统上创建一个钱包 <code>.../isabella/wallet</code>。</li><li>证书<code>cert</code>和私有<code>key</code>文件是从文件系统加载的。</li><li>新的X.509身份使用 <code>cert</code>，<code>key</code> 和 <code>Org1MSP</code> 来创建。</li><li>使用 <code>wallet.put()</code> 将带有标签 <code>User1@org1.example.com</code> 的新身份添加到钱包中</li></ul><h1 id="Gateway"><a href="#Gateway" class="headerlink" title="Gateway"></a>Gateway</h1><p>网关代表应用程序管理网络交互，使其专注于业务逻辑。应用程序连接到网关，然后使用该网关的配置管理所有后续交互。</p><p><strong>使用方式：</strong></p><ol><li><strong>静态</strong>：网关配置完全在<a class="link" href="https://hyperledger-fabric.readthedocs.io/en/latest/developapps/connectionprofile.html">连接配置文件中<i class="fas fa-external-link-alt"></i></a>定义。<ul><li>应用程序可用的所有<strong>对等方</strong>，<strong>订购者</strong>和<strong>CA</strong>在用于配置网关的连接配置文件中静态定义。例如，对于对等方来说，包括其作为 endorsing peer 或event notification hub的角色。</li><li>SDK将结合网关<a class="link" href="https://hyperledger-fabric.readthedocs.io/en/latest/developapps/connectionoptions">连接选项<i class="fas fa-external-link-alt"></i></a>来使用此静态拓扑来管理交易的提交和通知过程。连接配置文件必须包含足够的网络拓扑，以允许网关代表应用程序与网络交互；这包括网络渠道，组织，订购者，对等方及其角色。</li></ul></li></ol><ol start="2"><li><strong>动态</strong>：网关配置只在连接配置文件中最少定义。<ul><li>通常，指定来自应用程序组织的一个或两个对等方，并且它们使用<a class="link" href="https://hyperledger-fabric.readthedocs.io/en/latest/discovery-overview.html">服务发现<i class="fas fa-external-link-alt"></i></a>来发现可用的网络拓扑。这包括对等方，订购者，渠道，已部署的智能合约及其认可策略。（在生产环境中，网关配置应至少指定两个对等方以确保可用性。）</li><li>SDK将使用文件中所有的静态定义部分和发现的拓扑信息以及网关连接选项来管理交易的提交和通知过程。作为其一部分，它还将智能地使用发现的拓扑。例如，它将使用发现的智能合约背书策略计算所需的最少背书对等体。</li></ul></li></ol><blockquote><p>静态或动态网关是否更好？权衡是在可预测性和响应性之间。静态网络始终会以相同的方式运行，因为它们将网络视为不变的。从这种意义上讲，它们是可预测的–如果可用，它们将始终使用相同的对等方和订购方。当动态网络了解网络的变化时，它们的响应速度更快–它们可以使用新添加的对等点和订购者，从而带来额外的弹性和可扩展性，但可能会在可预测性方面付出一些代价。通常，使用动态网络是可以的，实际上，这是网关的默认模式。</p><ul><li>请注意，可以静态或动态使用同一连接配置文件。显然，如果要静态使用配置文件，则它必须是全面的，而动态使用仅需要稀疏的填充即可。</li><li>两种样式的网关对应用程序都是透明的。无论使用静态还是动态网关，应用程序设计都不会改变。这也意味着某些应用程序可以使用服务发现，而其他应用程序则可以不使用。通常，使用动态发现意味着SDK的定义更少，情报更多。这是默认值。</li></ul></blockquote><p><strong>连接：</strong>（前面有详细的）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> gateway.connect(connectionProfile, connectionOptions);</span><br></pre></td></tr></table></figure><ul><li><p><strong>连接配置文件</strong>：<code>connectionProfile</code> 是网关配置，它将用于SDK的静态或动态交易处理。尽管可以在传递给网关时将其转换为JSON对象，但是可以使用<strong>YAML</strong>或<strong>JSON</strong>指定它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> connectionProfile = yaml.safeLoad(fs.readFileSync(<span class="string">&#x27;../gateway/paperNet.yaml&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>));</span><br></pre></td></tr></table></figure></li></ul><ul><li><strong>连接选项</strong>：<code>connectionOptions</code> 允许应用程序<strong>声明</strong>而不是实现所需的事务处理行为。SDK会解释连接选项，以控制与网络组件的交互模式，例如，选择要与之连接的身份或用于事件通知的对等对象。这些选项可在不影响功能的情况下显着降低应用程序的复杂性。这是可能的，因为SDK已实现了许多应用程序原本需要的低层逻辑。连接选项控制此逻辑流。</li></ul><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>静态网关定义网络的<strong>固定视图</strong>。</p><p>在MagnetoCorp <a class="link" href="https://hyperledger-fabric.readthedocs.io/en/latest/developapps/gateway.html#scenario">方案中<i class="fas fa-external-link-alt"></i></a>，网关可能会标识MagnetoCorp的单个对等方，DigiBank的单个对等方和MagentoCorp订购者。或者，网关可以定义MagnetCorp和DigiBank的 <em>所有</em> 对等方和订购方。在这两种情况下，网关都必须定义足以使商业票据交易获得认可和分发的网络视图。</p><ul><li>通过在API <code>gateway.connect()</code> 上显式指定connect选项 <code>discovery: &#123; enabled:false &#125;</code>，应用程序可以静态使用网关。或者，环境变量设置 <code>FABRIC_SDK_DISCOVERY=false</code> 将始终覆盖应用程序选择。</li><li>检查 MagnetoCorp的 <code>issue.js</code> 应用程序使用的<a class="link" href="https://github.com/hyperledger/fabric-samples/blob/main/commercial-paper/organization/magnetocorp/gateway/networkConnection.yaml">连接配置文件<i class="fas fa-external-link-alt"></i></a>。查看如何在此文件中指定所有对等方，订购者甚至CA，包括它们的角色。</li></ul><blockquote><p>注意：静态网关代表某个<strong>时刻</strong>的网络视图。随着网络的变化，将其反映在网关文件的变化中可能很重要。当应用程序重新加载网关文件时，它们将自动获取这些更改。</p></blockquote><h2 id="dynamic"><a href="#dynamic" class="headerlink" title="dynamic"></a>dynamic</h2><p>动态网关为网络定义了一个最小的<strong>固定起点</strong>。</p><p>在MagnetoCorp<a class="link" href="https://hyperledger-fabric.readthedocs.io/en/latest/developapps/gateway.html#scenario">方案中<i class="fas fa-external-link-alt"></i></a>，动态网关可能仅识别MagnetoCorp中的单个对等方。一切都会被发现！（为了预防单点故障，最好定义两个这样的引导对等点）</p><ul><li>如果应用程序选择了<a class="link" href="https://hyperledger-fabric.readthedocs.io/en/latest/discovery-overview.html">服务发现<i class="fas fa-external-link-alt"></i></a>，则网关文件中定义的拓扑将使用此过程生成的拓扑进行扩充。<ul><li>服务发现从网关定义开始，并使用<a class="link" href="https://hyperledger-fabric.readthedocs.io/en/latest/gossip.html"> gossip 协议<i class="fas fa-external-link-alt"></i></a>在MagnetoCorp组织中找到所有连接的对等方和订购方。</li><li>如果已为通道定义了<a class="link" href="https://hyperledger-fabric.readthedocs.io/en/latest/glossary.html#anchor-peer">anchor peer<i class="fas fa-external-link-alt"></i></a>，则服务发现将使用跨组织的 gossip 协议来发现连接的组织内的组件。此过程还将发现在对等方安装的智能合约及其在渠道级别定义的认可策略。</li><li>与静态网关一样，发现的网络必须足以批准和分发商业票据交易。</li></ul></li><li>动态网关是Fabric应用程序的默认设置。可以使用API <code>gateway.connect()</code> 上的连接选项 <code>discovery: &#123; enabled:true &#125;</code> 明确指定它们。或者，环境变量设置 <code>FABRIC_SDK_DISCOVERY=true</code> 将始终覆盖应用程序选择。</li></ul><blockquote><p>注意：动态网关代表网络的最新视图。随着网络的变化，服务发现将确保网络视图正确反映了应用程序可见的拓扑。应用程序将自动获取这些更改；他们甚至不需要重新加载网关文件。</p></blockquote><h2 id="multiple"><a href="#multiple" class="headerlink" title="multiple"></a>multiple</h2><p>对于应用程序而言，定义相同或不同网络的多个网关非常简单。此外，应用程序可以静态和动态使用名称网关。</p><p>拥有多个网关可能会有所帮助。原因如下：</p><ul><li>代表不同用户处理请求。</li><li>同时连接到不同的网络。</li><li>通过同时比较其行为与现有配置来测试网络配置。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本部分详细介绍了Hyperledger Fabric中的客户端应用程序和智能合约开发的关键功能。对功能的深入了解将帮助您设计和实施高效的解决</summary>
      
    
    
    
    <category term="notebook" scheme="https://jieyang-wei.github.io/categories/notebook/"/>
    
    <category term="blockchain" scheme="https://jieyang-wei.github.io/categories/notebook/blockchain/"/>
    
    <category term="fabric" scheme="https://jieyang-wei.github.io/categories/notebook/blockchain/fabric/"/>
    
    
    <category term="fabric" scheme="https://jieyang-wei.github.io/tags/fabric/"/>
    
    <category term="blockchain" scheme="https://jieyang-wei.github.io/tags/blockchain/"/>
    
  </entry>
  
  <entry>
    <title>fabric-Developing Application</title>
    <link href="https://jieyang-wei.github.io/2021/03/16/fabric-Developing%20Application/"/>
    <id>https://jieyang-wei.github.io/2021/03/16/fabric-Developing%20Application/</id>
    <published>2021-03-16T09:08:51.000Z</published>
    <updated>2021-03-22T07:54:12.823Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本部分主要讲解只能合约的部署，已经commercial paper部分的使用和代码解析</p><ol><li><p>end users通过调用智能合约与区块链分类账进行交互。在Hyperledger Fabric中，智能合约部署在称为chaincode的程序包中。想要验证交易或查询分类帐的组织需要在其peer上安装chaincode。在已加入channel的peer上安装 chaincode后，通道成员可以将链码部署到通道，并使用链码中的智能合约在通道分类帐上创建或更新资产。</p></li><li><p>使用称为Fabric chaincode lifecycle的程序将链码部署到通道。Fabric chaincode lifecycle允许多个组织在使用链码创建事务之前就如何操作链码达成共识。例如，虽然背书策略指定哪些组织需要执行链码以验证交易，但渠道成员需要使用Fabric链码生命周期来同意链码背书策略。</p></li></ol><h1 id="示例教程"><a href="#示例教程" class="headerlink" title="示例教程"></a>示例教程</h1><p>使用 fabric-sample 中的示例 commercial-paper 和 asset-transfer-basic 来进行演示</p><p>首先要先启动测试网络 test-network ，并创建通道 mychannel</p><p>网络中将有两个组织org1和org2以及一个排序节点oeder</p><h2 id="日志监控"><a href="#日志监控" class="headerlink" title="日志监控"></a>日志监控</h2><p>在开始进行完整的商业流程实现之前，需要Logspout工具以便监控过程中所有的日志信息</p><ul><li>启动</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> fabric-sample/commercial-paper/organization/digibank/configuration/cli/monitordocker.sh</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./monitordocker.sh fabric_test</span></span><br></pre></td></tr></table></figure><h2 id="chaincode"><a href="#chaincode" class="headerlink" title="chaincode"></a>chaincode</h2><h3 id="打包智能合约"><a href="#打包智能合约" class="headerlink" title="打包智能合约"></a>打包智能合约</h3><p>此处以go语言为例，使用目录 <code>fabric-samples/asset-transfer-basic/chaincode-go</code> 下的智能合约</p><ul><li>go.mod：列出合约依赖项<ul><li>将Fabric合约API导入到智能合约包中。</li><li>可以<code>asset-transfer-basic/chaincode-go/chaincode/smartcontract.go</code>在文本编辑器中打开以查看如何<code>SmartContract</code>在智能合约开始时使用合约API定义类型</li></ul></li></ul><ol><li>安装合约依赖关系</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> fabric-samples/asset-transfer-basic/chaincode-go</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> GO111MODULE=on go mod vendor</span></span><br></pre></td></tr></table></figure><ol start="2"><li>使用 <code>peer</code> 指令创建所需链码包</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> PATH=<span class="variable">$&#123;PWD&#125;</span>/../../bin:<span class="variable">$PATH</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> FABRIC_CFG_PATH=<span class="variable">$PWD</span>/../../config/</span></span><br></pre></td></tr></table></figure><ul><li>主要是指出bin和config两个二进制文件夹所在的位置（fabric-sample目录下）</li><li>根据你的当前位置写路径</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> peer lifecycle chaincode package basic.tar.gz --path ./ --lang golang --label basic_1.0</span></span><br></pre></td></tr></table></figure><ul><li>参数：<ul><li>basic.tar.gz：打包后的文件名</li><li><strong>–path</strong>：提供智能合约代码的位置<ul><li>当前位置 <code>fabric-sample/asset-transfer-basic/chaincode-go</code> 的相对路径</li></ul></li><li><strong>–lang</strong>：指定链码语言</li><li><strong>–label</strong>：指定一个链码标签，该标签将在安装后识别您的链码。<ul><li>建议您的标签包含链码名称和版本</li></ul></li></ul></li><li>此时已在当前路径下创建了一个链码包（basic.tar.gz），之后可以使用此包安装链码</li></ul><h3 id="部署智能合约到channel"><a href="#部署智能合约到channel" class="headerlink" title="部署智能合约到channel"></a>部署智能合约到channel</h3><h4 id="安装chaincode包"><a href="#安装chaincode包" class="headerlink" title="安装chaincode包"></a>安装chaincode包</h4><ol><li>设置环境变量，让 <code>peer</code> 以Org1 admin用户的身份操作CLI</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> CORE_PEER_TLS_ENABLED=<span class="literal">true</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> CORE_PEER_LOCALMSPID=<span class="string">&quot;Org1MSP&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> CORE_PEER_TLS_ROOTCERT_FILE=<span class="variable">$&#123;PWD&#125;</span>/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> CORE_PEER_MSPCONFIGPATH=<span class="variable">$&#123;PWD&#125;</span>/organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> CORE_PEER_ADDRESS=localhost:7051</span></span><br></pre></td></tr></table></figure><ol start="2"><li>使用 <code>peer chaincode install</code> 命令在对等方上安装链码</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> peer lifecycle chaincode install basic.tar.gz</span></span><br></pre></td></tr></table></figure><ul><li>如果命令成功，则对等方将生成并返回包标识符</li><li>此程序包ID将用于批准链码</li></ul><ol start="3"><li>根据fabric的背书策略，链码需要mychannel上认可交易的每个对等方安装链码，所以我们切换 <code>peer</code> 到Org2 admin用户</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置环境变量</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> CORE_PEER_LOCALMSPID=<span class="string">&quot;Org2MSP&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> CORE_PEER_TLS_ROOTCERT_FILE=<span class="variable">$&#123;PWD&#125;</span>/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> CORE_PEER_TLS_ROOTCERT_FILE=<span class="variable">$&#123;PWD&#125;</span>/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> CORE_PEER_MSPCONFIGPATH=<span class="variable">$&#123;PWD&#125;</span>/organizations/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> CORE_PEER_ADDRESS=localhost:9051</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装链码包</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> peer lifecycle chaincode install basic.tar.gz</span></span><br></pre></td></tr></table></figure><h4 id="批准chaincode包"><a href="#批准chaincode包" class="headerlink" title="批准chaincode包"></a>批准chaincode包</h4><p>注意：</p><ul><li>在部署链码之前需要批准链码的一组通道成员受 <code>/Channel/Application/LifecycleEndorsement</code> 策略控制。<ul><li>默认情况下，此策略要求大多数频道成员需要批准链码后才能在频道上使用。因为渠道上只有两个组织，而2个中的大多数是2个，所以我们需要批准资产转移（基本）的链码定义为Org1和Org2。</li></ul></li><li>如果组织已在其对等方上安装了链码，则他们需要在其组织批准的链码定义中包括packageID。程序包ID用于将对等方上安装的链码与批准的链码定义相关联，并允许组织使用链码对交易进行背书。您可以使用对 <code>peer lifecycle chaincode queryinstalled</code> 命令来查询对等节点，从而找到链代码的程序包ID 。</li></ul><ol><li>查询安装的链码包的 <code>PACKEDGE_ID</code></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> peer lifecycle chaincode queryinstalled</span></span><br><span class="line">Installed chaincodes on peer:</span><br><span class="line">Package ID: basic_1.0:(一串数字即为package id)</span><br></pre></td></tr></table></figure><ol start="2"><li>在org2组织上批准链码包</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置环境变量</span></span><br><span class="line">$ <span class="built_in">export</span> CC_PACKAGE_ID=basic_1.0:(那串package id的数字)</span><br><span class="line"><span class="comment"># 批准</span></span><br><span class="line">$ peer lifecycle chaincode approveformyorg -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --channelID mychannel --name basic --version 1.0 --package-id <span class="variable">$CC_PACKAGE_ID</span> --sequence 1 --tls --cafile <span class="string">&quot;<span class="variable">$&#123;PWD&#125;</span>/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem&quot;</span></span><br></pre></td></tr></table></figure><ul><li>参数：<ul><li><strong>–package-id</strong>：在链码定义中包含程序包标识符</li><li><strong>–sequence</strong>：一个整数，用于跟踪已定义或更新链码的次数<ul><li>由于链码是第一次部署到通道，因此序列号为1。升级链码时，序列号将增加为2。</li><li><strong>–init-required</strong>：如果使用的是提供的低级API通过Fabric Chaincode Shim API，您可以使用此标志传递给上面的命令，以请求执行Init函数来初始化链码。</li><li><strong>–isInit</strong>：链代码的第一次调用需要以Init函数为目标并包括该<code>--isInit</code>标志，然后才能使用链代码中的其他函数与分类帐进行交互。</li></ul></li><li>-<strong>-signature-policy / –channel-config-policy</strong>：指定链码背书策略<ul><li>默认背书策略是需要得到channel上的大多数成员的认可</li></ul></li></ul></li></ul><ol start="3"><li>切换 <code>peer</code> 到Org1 admin用户来批准之前安装的链码包</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> CORE_PEER_LOCALMSPID=<span class="string">&quot;Org1MSP&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> CORE_PEER_MSPCONFIGPATH=<span class="variable">$&#123;PWD&#125;</span>/organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> CORE_PEER_TLS_ROOTCERT_FILE=<span class="variable">$&#123;PWD&#125;</span>/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> CORE_PEER_ADDRESS=localhost:7051</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> peer lifecycle chaincode approveformyorg -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --channelID mychannel --name basic --version 1.0 --package-id <span class="variable">$CC_PACKAGE_ID</span> --sequence 1 --tls --cafile <span class="string">&quot;<span class="variable">$&#123;PWD&#125;</span>/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem&quot;</span></span></span><br></pre></td></tr></table></figure><blockquote><p>虽然只有大多数组织需要批准链码定义（具有默认策略），但是所有组织都需要批准链码定义才能在其对等方启动链码。</p><p>如果您在渠道成员批准链码之前提交定义，则组织将无法批准交易。所以，建议所有通道成员在提交链码定义之前批准链码。</p></blockquote><h4 id="提交链码定义"><a href="#提交链码定义" class="headerlink" title="提交链码定义"></a>提交链码定义</h4><p>在足够多的组织批准了链码定义之后，一个组织可以将链码定义提交给渠道。如果大多数通道成员已批准该定义，则提交事务将成功，并且链码定义中同意的参数将在该通道上实现。</p><ol><li>查看channel成员是否已经批准了此链码</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ peer lifecycle chaincode checkcommitreadiness --channelID mychannel --name basic --version 1.0 --sequence 1 --tls --cafile <span class="string">&quot;<span class="variable">$&#123;PWD&#125;</span>/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem&quot;</span> --output json</span><br></pre></td></tr></table></figure><ul><li><p>此命令标志与批准链码的标志 <code>approveformyorg</code> 相同，所以不需要 <code>--package-id</code> 标志。</p></li><li><p>该命令将生成一个JSON映射，显示通道成员是否批准链码</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;Approvals&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;Org1MSP&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;Org2MSP&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>当多数人都批准了之后，管理员就可以将链码定义提交到channel</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> peer lifecycle chaincode commit -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --channelID mychannel --name basic --version 1.0 --sequence 1 --tls --cafile <span class="string">&quot;<span class="variable">$&#123;PWD&#125;</span>/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem&quot;</span> --peerAddresses localhost:7051 --tlsRootCertFiles <span class="string">&quot;<span class="variable">$&#123;PWD&#125;</span>/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt&quot;</span> --peerAddresses localhost:9051 --tlsRootCertFiles <span class="string">&quot;<span class="variable">$&#123;PWD&#125;</span>/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt&quot;</span></span></span><br></pre></td></tr></table></figure><ul><li><strong>–peerAddresses</strong>：上面标示<code>peer0.org1.example.com</code>从Org1和<code>peer0.org2.example.com</code>Org2进行定位。</li><li>该<code>commit</code>交易被提交到加入该频道来查询被批准经营的同行组织的chaincode定义的peer。该命令需要针对足够数量的组织中的对等方，以满足部署链码的策略。由于批准是在每个组织内分配的，因此您可以定位属于渠道成员的任何对等方。</li><li>通道成员对链码定义的 <code>approve</code> 将提交给ordering service，以添加到区块中并分发给通道。然后，通道上的对等方将验证是否有足够的组织批准了链码定义。<code>peer lifecycle chaincode commit</code>命令将在返回响应之前等待对等方的验证。</li></ul><ol start="3"><li>确认chaincode定义已提交给channel</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> peer lifecycle chaincode querycommitted --channelID mychannel --name basic --cafile <span class="string">&quot;<span class="variable">$&#123;PWD&#125;</span>/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem&quot;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回 sequence 和 version</span></span><br><span class="line">Committed chaincode definition for chaincode &#x27;basic&#x27; on channel &#x27;mychannel&#x27;:</span><br><span class="line">Version: 1.0, Sequence: 1, Endorsement Plugin: escc, Validation Plugin: vscc, Approvals: [Org1MSP: true, Org2MSP: true]</span><br></pre></td></tr></table></figure><h3 id="调用链码"><a href="#调用链码" class="headerlink" title="调用链码"></a>调用链码</h3><ol><li>调用链码 <code>InitLedger</code> 方法</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> peer chaincode invoke -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile <span class="string">&quot;<span class="variable">$&#123;PWD&#125;</span>/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem&quot;</span> -C mychannel -n basic --peerAddresses localhost:7051 --tlsRootCertFiles <span class="string">&quot;<span class="variable">$&#123;PWD&#125;</span>/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt&quot;</span> --peerAddresses localhost:9051 --tlsRootCertFiles <span class="string">&quot;<span class="variable">$&#123;PWD&#125;</span>/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt&quot;</span> -c <span class="string">&#x27;&#123;&quot;function&quot;:&quot;InitLedger&quot;,&quot;Args&quot;:[]&#125;&#x27;</span></span></span><br></pre></td></tr></table></figure><ol start="2"><li>查询集合</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> peer chaincode query -C mychannel -n basic -c <span class="string">&#x27;&#123;&quot;Args&quot;:[&quot;GetAllAssets&quot;]&#125;&#x27;</span></span></span><br></pre></td></tr></table></figure><h3 id="eg-Commercial-Paper"><a href="#eg-Commercial-Paper" class="headerlink" title="eg.Commercial Paper"></a>eg.Commercial Paper</h3><h4 id="启动网络"><a href="#启动网络" class="headerlink" title="启动网络"></a>启动网络</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> fabric-samples/commercial-paper</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./network-starter.sh</span></span><br></pre></td></tr></table></figure><ul><li>可以使用 <code>docker ps</code> 命令查看本地计算机上运行的Fabric节点</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> commercial-paper/organization/magnetocorp</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./monitordocker.sh fabric_test &lt;port_number&gt;</span></span><br></pre></td></tr></table></figure><ul><li>在新的窗口下监视 MagnetoCorp 的日志信息</li></ul><h4 id="部署智能合约"><a href="#部署智能合约" class="headerlink" title="部署智能合约"></a>部署智能合约</h4><p>在<code>papercontract</code>被应用程序调用之前，必须将其安装到测试网络的适当对等节点上，然后使用 <code>peer lifecycle</code> 在通道上进行定义。Fabric链码生命周期允许多个组织在将链码部署到通道之前就链码的参数达成一致。因此，我们需要以MagnetoCorp和DigiBank的管理员身份安装和批准链式代码。</p><ol><li>打包智能合约为文件 <code>cp.tar.gz</code></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> commercial-paper/organization/magnetocorp</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> magnetocorp.sh</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> peer lifecycle chaincode package cp.tar.gz --lang node --path ./contract --label cp_0</span></span><br></pre></td></tr></table></figure><ul><li>在 magnetocorp 的目录下，第二条命令用来设置示例所需的环境变量</li></ul><ol start="2"><li>在channel上安装智能合约</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> peer lifecycle chaincode install cp.tar.gz</span></span><br></pre></td></tr></table></figure><ol start="3"><li>批准合约</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查询package id</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> peer lifecycle chaincode queryinstalled</span></span><br><span class="line">Installed chaincodes on peer:</span><br><span class="line">Package ID: cp_0:(一串数字即为package id)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置package id环境变量</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> PACKAGE_ID=cp_0:(那串package id的数字)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行命令批准合约</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> peer lifecycle chaincode approveformyorg --orderer localhost:7050 --ordererTLSHostnameOverride orderer.example.com --channelID mychannel --name papercontract -v 0 --package-id <span class="variable">$PACKAGE_ID</span> --sequence 1 --tls --cafile <span class="variable">$ORDERER_CA</span></span></span><br></pre></td></tr></table></figure><ol start="4"><li>再以 DigiBank 的身份部署合约</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 打包合约</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> commercial-paper/organization/digibank/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装合约</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> digibank.sh</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> peer lifecycle chaincode package cp.tar.gz --lang node --path ./contract --label cp_0</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> peer lifecycle chaincode install cp.tar.gz</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查询设置package id</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> peer lifecycle chaincode queryinstalled</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> PACKAGE_ID=cp_0:...</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 批准合约</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> peer lifecycle chaincode approveformyorg --orderer localhost:7050 --ordererTLSHostnameOverride orderer.example.com --channelID mychannel --name papercontract -v 0 --package-id <span class="variable">$PACKAGE_ID</span> --sequence 1 --tls --cafile <span class="variable">$ORDERER_CA</span></span></span><br></pre></td></tr></table></figure><h4 id="提交链码到channel"><a href="#提交链码到channel" class="headerlink" title="提交链码到channel"></a>提交链码到channel</h4><ol><li>当 MagnetoCorp 和 DigiBank 均批准了链码之后，我们就可以提交链码定义了</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> peer lifecycle chaincode commit -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --peerAddresses localhost:7051 --tlsRootCertFiles <span class="variable">$&#123;PEER0_ORG1_CA&#125;</span> --peerAddresses localhost:9051 --tlsRootCertFiles <span class="variable">$&#123;PEER0_ORG2_CA&#125;</span> --channelID mychannel --name papercontract -v 0 --sequence 1 --tls --cafile <span class="variable">$ORDERER_CA</span> --waitForEvent</span></span><br></pre></td></tr></table></figure><h4 id="应用结构及代码"><a href="#应用结构及代码" class="headerlink" title="应用结构及代码"></a>应用结构及代码</h4><blockquote><p>每次运行 Application 前，都需要删除 identity 文件夹，清除上次运行分发的身份，重新enroll当前网络</p></blockquote><h5 id="MagnetoCorp"><a href="#MagnetoCorp" class="headerlink" title="MagnetoCorp"></a>MagnetoCorp</h5><p>目录：<code>fabric-samples/commercial-paper/organization/magnetocorp/application</code></p><ol><li>安装依赖</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install</span></span><br></pre></td></tr></table></figure><ol start="2"><li>注册用户，生成用户钱包</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> node enrollUser.js</span></span><br></pre></td></tr></table></figure><ol start="2"><li>发行commercial paper</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> node issue.js</span></span><br></pre></td></tr></table></figure><h5 id="DigiBank"><a href="#DigiBank" class="headerlink" title="DigiBank"></a>DigiBank</h5><p>目录：<code>fabric-samples/commercial-paper/organization/digibank/application</code></p><ol><li>安装依赖</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install</span></span><br></pre></td></tr></table></figure><ol start="2"><li>注册用户，生成用户钱包</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> node enrollUser.js</span></span><br></pre></td></tr></table></figure><ol start="3"><li>购买commercial paper</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> node buy.js</span></span><br></pre></td></tr></table></figure><ol start="4"><li>赎回</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> node reedem.js</span></span><br></pre></td></tr></table></figure><h5 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h5><p>应用程序<strong>提交交易</strong>步骤：</p><ul><li>（前提是用户已经加入到网络中，拥有了一个身份）</li><li>从钱包中选择一个身份</li><li>连接到网关</li><li>访问所需的网络</li><li>构建智能合约的交易请求</li><li>将交易提交到网络</li><li>处理回应</li></ul><p><strong>代码框架</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Wallets, Gateway &#125; = <span class="built_in">require</span>(<span class="string">&#x27;fabric-network&#x27;</span>);</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 得到钱包</span></span><br><span class="line">    <span class="keyword">const</span> wallet = <span class="keyword">await</span> Wallets.newFileSystemWallet(<span class="string">&#x27;../identity/user/isabella/wallet&#x27;</span>);</span><br><span class="line">    <span class="comment">// 接入网关</span></span><br><span class="line"><span class="keyword">const</span> gateway = <span class="keyword">new</span> Gateway();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> userName = <span class="string">&#x27;isabella.issuer@magnetocorp.com&#x27;</span>;</span><br><span class="line">        <span class="keyword">let</span> connectionProfile = yaml.safeLoad(fs.readFileSync(<span class="string">&#x27;../gateway/connection-org2.yaml&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>));</span><br><span class="line">        <span class="keyword">let</span> connectionOptions = &#123;</span><br><span class="line">    identity: userName,</span><br><span class="line">     wallet: wallet,</span><br><span class="line">    discovery: &#123; <span class="attr">enabled</span>:<span class="literal">true</span>, <span class="attr">asLocalhost</span>: <span class="literal">true</span> &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">await</span> gateway.connect(connectionProfile, connectionOptions); </span><br><span class="line">        ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>Wallet</strong><ul><li>钱包包含一组身份（X.509数字证书），可用于访问PaperNet或任何其他Fabric网络</li></ul></li></ol><ol start="2"><li><p><strong>Gateway</strong></p><ul><li><p>网关标识一个或多个对等网络，这些对等网络提供对网络的访问权限 - 示例中的PaperNet</p></li><li><p>负责使用<strong>连接配置文件</strong>和<strong>连接选项</strong>将交易建议发送到网络中正确的对等节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> gateway.connect(connectionProfile, connectionOptions); </span><br></pre></td></tr></table></figure><ul><li><p><strong>connectionProfile</strong>：<strong>连接配置文件</strong>的系统位置，该配置文件将一组对等方标识为PaperNet的网关</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载并转换为JSON对象</span></span><br><span class="line"><span class="keyword">let</span> connectionProfile = yaml.safeLoad(fs.readFileSync(<span class="string">&#x27;../gateway/connection-org2.yaml&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>));</span><br></pre></td></tr></table></figure></li><li><p><strong>connectionOptions</strong>：用于控制 <code>issue.js</code> 与PaperNet<strong>交互方式</strong>的一组选项</p></li></ul></li></ul></li></ol><h5 id="Contract"><a href="#Contract" class="headerlink" title="Contract"></a>Contract</h5><p>目录结构：</p><img src="/2021/03/16/fabric-Developing%20Application/截屏2021-03-18 下午6.21.17.png" alt="截屏2021-03-18 下午6.21.17" style="zoom:50%;"><ul><li><p>lib：主要的paper相关操作</p><ul><li><p><strong>paper.js</strong>：定义 commercial paper 相关属性的set、get、is…和相关静态方法（序列化、反序列化等）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommercialPaper</span> <span class="keyword">extends</span> <span class="title">State</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>papercontract.js</strong>：定义了交易逻辑（此处包括issue、buy、redeem、transfer等）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommercialPaperContext</span> <span class="keyword">extends</span> <span class="title">Context</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommercialPaperContract</span> <span class="keyword">extends</span> <span class="title">Contract</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>CommercialPaperContext：创建并维护 paperList，用来定位到所需操作的paper</li><li>CommercialPaperContract：定义交易主要逻辑，在交易中完成paper的状态转移</li></ul></li><li><p><strong>paperlist.js</strong>：维护 paperList 相关的方法 - add、get、update</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaperList</span> <span class="keyword">extends</span> <span class="title">StateList</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>ledger-api：</p><ul><li><p><strong>state.js</strong>：主要控制 paper 的 stateClass 和 keyParts</p></li><li><p><strong>statelist.js</strong>：根据paper的state和key来控制paperlist的状态，并调用fabric-contract-api与区块链交互</p><blockquote><p>该类不存储任何单个状态或者状态列表，而是委派给Fabric数据库</p><ul><li>这是一种重要的设计模式–减少了Hyperledger Fabric中分类账<strong>MVCC冲突</strong>的机会。</li></ul></blockquote><ul><li><pre><code class="javascript">async addState(state) &#123;    let key = this.ctx.stub.createCompositeKey(this.name, state.getSplitKey());    let data = State.serialize(state);    await this.ctx.stub.putState(key, data);&#125;</code></pre></li></ul></li><li><p><strong>分类账</strong>：每个状态数据都需要以下两个基本元素</p><ol><li><strong>密钥</strong>：<code>key</code> 是 <code>createCompositeKey()</code> 使用固定名称和 <code>state</code> 的密钥形成的。<ul><li><code>this.name</code> 是在 <code>PaperList</code> 构造对象时分配的</li><li><code>state.getSplitKey()</code>确定每个状态的唯一键。</li></ul></li><li><strong>数据</strong>：<code>data </code>只是使用 <code>State.serialize()</code> 实用程序方法创建的commercial paper状态的序列化形式。<ul><li> <code>State</code> 类使用JSON来序列化和反序列化数据，state的对象类需要，在我们的例子<code>CommercialPaper</code>中， <code>PaperList</code> 对象构建时需要重定义。</li></ul></li></ol></li></ul></li></ul><h2 id="CouchDB"><a href="#CouchDB" class="headerlink" title="CouchDB"></a>CouchDB</h2><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><h3 id="建立通道"><a href="#建立通道" class="headerlink" title="建立通道"></a>建立通道</h3><h3 id="添加组织到通道"><a href="#添加组织到通道" class="headerlink" title="添加组织到通道"></a>添加组织到通道</h3><h3 id="更新通道配置"><a href="#更新通道配置" class="headerlink" title="更新通道配置"></a>更新通道配置</h3><h1 id="代码工具"><a href="#代码工具" class="headerlink" title="代码工具"></a>代码工具</h1><p><a class="link" href="http://cw.hubwiz.com/card/c/fabric-command-manual/1/1/27/">工具使用<i class="fas fa-external-link-alt"></i></a></p><h2 id="peer"><a href="#peer" class="headerlink" title="peer"></a>peer</h2><p>子命令</p><p>peer channel list：列出当前组织所属的所有通道列表</p><h3 id="peer-lifecycle-chaincode"><a href="#peer-lifecycle-chaincode" class="headerlink" title="peer lifecycle chaincode"></a>peer lifecycle chaincode</h3><p>包含以下<strong>子命令</strong>:</p><ul><li><p>package：                            打包链码<br>* </p></li><li><p>install：                                安装链码<br>* </p></li><li><p>queryinstalled：                 查询指定peer节点上已经安装的链码</p><ul><li></li></ul></li><li><p>approveformyorg：           批准链码定义<br>* </p></li><li><p>checkcommitreadiness： 检查链码是否可以向通道提交<br>* </p></li><li><p>commit：                             向通道提交链码定义<br>* </p></li><li><p>querycommitted：             按通道查询已经提交的链码定义<br>* </p></li><li><p>getinstalledpackage：       从peer节点获取已经安装的链码包</p><ul><li></li></ul></li></ul><p>可用<strong>标志</strong>:</p><ul><li>–cafile string                       PEM编码的CA证书文件路径</li><li>–certfile string                     双向TLS通讯所需的PEM编码的X509证书文件路径</li><li>–clientauth                          与排序节点的通讯是否启用双向TLS</li><li>–connTimeout duration    客户端连接超时，默认值：3秒</li><li>-h, –help                               帮助信息</li><li>–keyfile string                      双向TLS通讯所需的PEM编码的私钥文件</li><li>-o, –orderer string               排序节点地址</li><li>–ordererTLSHostnameOverride string     验证TLS连接时使用的排序节点主机名</li><li>–tls                                         与排序节点通信时是否启用TLS</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本部分主要讲解只能合约的部署，已经commercial paper部分的使用和代码解析&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;end users通</summary>
      
    
    
    
    <category term="notebook" scheme="https://jieyang-wei.github.io/categories/notebook/"/>
    
    <category term="blockchain" scheme="https://jieyang-wei.github.io/categories/notebook/blockchain/"/>
    
    <category term="fabric" scheme="https://jieyang-wei.github.io/categories/notebook/blockchain/fabric/"/>
    
    
    <category term="fabric" scheme="https://jieyang-wei.github.io/tags/fabric/"/>
    
    <category term="blockchain" scheme="https://jieyang-wei.github.io/tags/blockchain/"/>
    
  </entry>
  
  <entry>
    <title>fabric-Getting Start</title>
    <link href="https://jieyang-wei.github.io/2021/03/14/fabric-Getting%20Start/"/>
    <id>https://jieyang-wei.github.io/2021/03/14/fabric-Getting%20Start/</id>
    <published>2021-03-14T04:08:44.000Z</published>
    <updated>2021-03-22T07:05:54.802Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本部分主要设计fabric环境安装，已经 <code>fabric-sample</code> 中 <code>test-network</code> 和 <code>asset-transfer-basic</code> 样例的运行</p><p>Fabric应用程序堆栈有五层：</p><img src="/2021/03/14/fabric-Getting%20Start/getting_started_image2.png" alt="织物应用堆栈" style="zoom: 20%;"><ul><li>必备软件：运行该软件所需的基础层，例如Docker。</li><li>Fabric和Fabric示例：Fabric可执行文件与示例代码一起运行Fabric网络。</li><li>合约API：开发在Fabric网络上执行的智能合约。</li><li>应用程序SDK：开发您的区块链应用程序。</li><li>应用程序：您的区块链应用程序将利用应用程序SDK调用在Fabric网络上运行的智能合约。</li></ul><p><strong>fabric核心模块</strong></p><table><thead><tr><th align="center">模块名词</th><th align="center">功能</th><th align="center">类型</th></tr></thead><tbody><tr><td align="center">peer</td><td align="center">主节点模块，负责存储区块链数据，运行维护代码</td><td align="center">系统模块</td></tr><tr><td align="center">order</td><td align="center">交易打包，排序模块</td><td align="center">系统模块</td></tr><tr><td align="center">cryptogen</td><td align="center">组织和证书生成模块</td><td align="center">工具模块</td></tr><tr><td align="center">configtxgen</td><td align="center">区块和交易生成模块</td><td align="center">工具模块</td></tr><tr><td align="center">configtxlator</td><td align="center">区块和交易解析模块</td><td align="center">工具模块</td></tr></tbody></table><ul><li>工具模块负责证书文件，区块链创始块，通道创始块等相关文件和证书的生成工作，不参与系统的运行。</li><li><strong>cryptogen</strong>：模块主要用于生成组织结构和账号相关文件，任何fabric系统的开发都是从cryptogen模块开始，在系统设计完成后首要工作就是根据系统设计编写cryptogen的配置文件。</li></ul><h1 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h1><p><a class="link" href="https://hyperledger-fabric.readthedocs.io/en/latest/getting_started.html">官方文档<i class="fas fa-external-link-alt"></i></a></p><p>系统：MacOS</p><h2 id="必备软件"><a href="#必备软件" class="headerlink" title="必备软件"></a>必备软件</h2><p>Prerequisites - 先决条件</p><ul><li><strong>Homebrew</strong>：仅mac系统需要，用来管理下面所需要的软件包</li><li><strong>git</strong>：<strong>版本管理</strong>工具</li><li><strong>cURL</strong>：curl命令是个功能强大的<strong>网络工具</strong>，支持通过http、ftp等方式下载文件、上传文件</li><li><strong>Docker &amp; Docker-compose</strong>：一个开源的<strong>应用容器引擎</strong>，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化</li><li><strong>Go</strong>：Docker是基于go语言的<ul><li>(only required if you will be writing Go chaincode or SDK applications)</li></ul></li><li><strong>JQ</strong>：既JQuery，一个优秀的javascript类库<ul><li>(only required for the tutorials related to channel configuration transactions)</li></ul></li></ul><h3 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a>Homebrew</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> /bin/bash -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)</span>&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> brew --version</span></span><br><span class="line">Homebrew 3.0.4</span><br><span class="line">Homebrew/homebrew-core (git revision 89d933; last commit 2020-04-01)</span><br></pre></td></tr></table></figure><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><blockquote><img src="/2021/03/14/fabric-Getting%20Start/截屏2021-03-07 下午5.22.32.png" alt="截屏2021-03-07 下午5.22.32" style="zoom:50%;"><ol><li>Error: Unknown command: cask<ul><li>Homebrew 2.5.x 之后删掉了<code>brew cask</code></li><li>直接使用<code>brew</code>，或者<code>brew --cask</code>即可</li></ul></li></ol><img src="/2021/03/14/fabric-Getting%20Start/截屏2021-03-07 下午5.21.56.png" alt="截屏2021-03-07 下午5.21.56" style="zoom:50%;"><ol start="2"><li><p>升级后核心不可用<code>homebrew-core is a shallow clone</code></p><ul><li>先按照提示执行<code>git -C /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core fetch --unshallow</code></li></ul><img src="/2021/03/14/fabric-Getting%20Start/截屏2021-03-07 下午7.57.58.png" alt="截屏2021-03-07 下午7.57.58" style="zoom:50%;"><ul><li>如果系统不支持<code>unshallow</code>，则删掉核心后再update</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rm -rf /usr/<span class="built_in">local</span>/Homebrew/Library/Taps/homebrew/homebrew-core</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> brew update</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew install git</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git --version</span></span><br><span class="line">git version 2.24.3 (Apple Git-128)</span><br></pre></td></tr></table></figure><h3 id="cURL"><a href="#cURL" class="headerlink" title="cURL"></a>cURL</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew install curl</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl --version</span></span><br><span class="line">curl 7.63.0 (x86_64-apple-darwin13.4.0) libcurl/7.63.0 OpenSSL/1.1.1b zlib/1.2.11 libssh2/1.8.0</span><br><span class="line">Release-Date: 2018-12-12</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><ul><li>Since Docker Desktop is a UI application on Mac, use <code>cask</code> to install it.</li></ul><p>Homebrew v2.x:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew cask install --appdir=<span class="string">&quot;/Applications&quot;</span> docker</span></span><br></pre></td></tr></table></figure><p>Homebrew v3.x:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew install --cask --appdir=<span class="string">&quot;/Applications&quot;</span> docker</span></span><br></pre></td></tr></table></figure><ul><li>Docker Desktop must be launched to complete the installation so be sure to open the application after installing it:</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> open /Applications/Docker.app</span></span><br></pre></td></tr></table></figure><ul><li>Once installed, confirm the latest versions of both <code>docker</code> and <code>docker-compose</code> executables were installed.</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker --version</span></span><br><span class="line">Docker version 20.10.5, build 55c4c88</span><br><span class="line"><span class="meta">$</span><span class="bash"> docker-compose --version</span></span><br><span class="line">docker-compose version 1.28.5, build c4eb3a1f</span><br></pre></td></tr></table></figure><h4 id="加速"><a href="#加速" class="headerlink" title="加速"></a>加速</h4><ul><li><p>docker镜像在国外，为了后续下载加速，配置文件将镜像换成国内的</p><ul><li><p>在<code>/etc/docker/daemon.json</code>文件中配置或者如下图所示在软件中配置：</p></li><li><p><code>&#123;&quot;registry-mirrors&quot;:[&quot;https://reg-mirror.qiniu.com/&quot;]&#125;</code></p><p>![截屏2021-03-07 下午9.55.31](fabric-Getting Start/截屏2021-03-07 下午9.55.31.png)</p></li></ul></li></ul><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew install go</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> go version</span></span><br><span class="line">go version go1.16 darwin/amd64</span><br></pre></td></tr></table></figure><ul><li>可以根据喜好设置项目目录，下面为推荐目录结构</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> GOPATH:<span class="variable">$Home</span>/&lt;user-defined-workspace&gt;/go</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> go env GOPATH</span></span><br><span class="line">/Users/weijieyang/go</span><br></pre></td></tr></table></figure><h3 id="JQ"><a href="#JQ" class="headerlink" title="JQ"></a>JQ</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew install jq</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> jq --version</span></span><br><span class="line">jq-1.6</span><br></pre></td></tr></table></figure><h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><blockquote><img src="/2021/03/14/fabric-Getting%20Start/截屏2021-03-08 下午1.26.23.png" alt="截屏2021-03-08 下午1.26.23" style="zoom:50%;"><ol><li>python版本问题<ul><li>按照给出的指令顺序操作</li><li><code>--overwrite</code> 表示强制</li></ul></li></ol><img src="/2021/03/14/fabric-Getting%20Start/截屏2021-03-08 下午1.32.00.png" alt="截屏2021-03-08 下午1.32.00" style="zoom:50%;"></blockquote><h2 id="fabric-sample"><a href="#fabric-sample" class="headerlink" title="fabric-sample"></a>fabric-sample</h2><p>github源码：</p><ul><li><p><a class="link" href="https://github.com/hyperledger/fabric.git">fabric<i class="fas fa-external-link-alt"></i></a></p></li><li><p><a class="link" href="https://github.com/hyperledger/fabric-samples.git">fabric-samples<i class="fas fa-external-link-alt"></i></a></p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir -p <span class="variable">$HOME</span>/go/src/github.com/&lt;your_github_userid&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> <span class="variable">$HOME</span>/go/src/github.com/&lt;your_github_userid&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl -sSL https://bit.ly/2ysbOFE | bash -s</span></span><br></pre></td></tr></table></figure><ul><li>创建go项目目录并使用curl下载sample文件</li></ul><ul><li><p>上面的curl命令将会执行以下步骤：</p><ol><li><p>克隆<a class="link" href="https://github.com/hyperledger/fabric-samples.git">hyperledger / fabric-samples<i class="fas fa-external-link-alt"></i></a>存储库。</p></li><li><p>下载最新的Hyperledger Fabric Docker映像并将其标记为 <code>latest</code></p></li><li><p>将以下特定于平台<strong>编译好的</strong>的Hyperledger Fabric CLI工具<strong>二进制文件</strong>和<strong>配置文件</strong>下载到<code>fabric-samples</code> <code>/bin</code>和<code>/config</code>目录中。这些二进制文件将帮助您与测试网络进行交互。</p><img src="/2021/03/14/fabric-Getting%20Start/截屏2021-03-09 下午10.05.11.png" alt="截屏2021-03-09 下午10.05.11" style="zoom:50%;"></li></ol></li></ul><h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h3><blockquote><p><strong>报错</strong>：</p><img src="/2021/03/14/fabric-Getting%20Start/截屏2021-03-08 下午8.49.03.png" alt="截屏2021-03-08 下午8.49.03" style="zoom:50%;"><ul><li>此处网站 <code>https://bit.ly/2ysbOFE</code> 需要科学上网，在国内访问不了</li></ul><p>（针对Ubuntu / CentOS系统）</p><ol><li><p>如果无法访问上述github文件，可以考虑添加docker镜像源</p><img src="/2021/03/14/fabric-Getting%20Start/截屏2021-03-08 下午9.29.57.png" alt="截屏2021-03-08 下午9.29.57" style="zoom:50%;"><ul><li><p>在文件 <code>/etc/docker/daemon.json</code> 中添加镜像源：</p><p><code>&quot;registry-mirrors&quot;:[&quot;https://registry.docker-cn.com&quot;]</code></p></li><li><p>查看镜像源：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker info|grep Mirrors -A 1</span></span><br><span class="line"> Registry Mirrors:</span><br><span class="line">  https://registry.docker-cn.com/</span><br></pre></td></tr></table></figure></li><li><p>重启网络</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Ubuntu</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo /etc/init.d/networking restart</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> CentOS</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo /etc/init.d/network restart</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Mac</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo ifconfig en0 down/up</span></span><br></pre></td></tr></table></figure></li><li><p>再次执行curl指令</p></li></ul></li></ol><p>（还是无法链接网站）</p><ol start="2"><li>上面的网站主要是为了获得一个<code>bootstrap.sh</code>的脚本文件并执行</li></ol><ul><li><p>我们只需要去fabric中下载<a class="link" href="https://github.com/hyperledger/fabric/blob/master/scripts/bootstrap.sh">bootstrap.sh源码<i class="fas fa-external-link-alt"></i></a>即可</p><ul><li>需要先下载zip <code>https://github.com/hyperledger/fabric.git</code> (master分支)</li><li>再将文件<code>fabric/scripts/bootstrap.sh</code> 移动到目录<code>$HOME/go/src/github.com/&lt;your_github_userid&gt;</code>下</li><li>或者使用github单个文件下载工具<a class="link" href="https://minhaskamal.github.io/DownGit/#/home">DownGit<i class="fas fa-external-link-alt"></i></a></li><li>之后在此脚本目录下执行下面的指令即可</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat bootstrap.sh |bash -s</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>注意文件版本，根据自己的系统选择，darwin（=MacOS）、linux、win等</p></blockquote><ul><li><p>运行 bootstrap.sh 时如果发现无法下载fabric的<strong>二进制可执行文件</strong>和<strong>配置文件</strong>，如下图：</p><img src="/2021/03/14/fabric-Getting%20Start/截屏2021-03-09 下午3.39.33.png" alt="截屏2021-03-09 下午3.39.33" style="zoom:50%;"><ul><li><p>可能是因为网络不稳定，换一个好点的网络重新运行</p></li><li><p>也可以将这部分的代码单独拉出来执行</p><ol><li><p>点击下面两个链接即可自动下载</p><ul><li><a class="link" href="https://github.com/hyperledger/fabric/releases/download/v2.3.1/hyperledger-fabric-darwin-amd64-2.3.1.tar.gz">fabric-darwin-amd64-2.3.1.tar.gz<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" href="https://github.com/hyperledger/fabric-ca/releases/download/v1.4.9/hyperledger-fabric-ca-darwin-amd64-1.4.9.tar.gz">fabric-ca-darwin-amd64-1.4.9.tar.gz<i class="fas fa-external-link-alt"></i></a></li></ul></li><li><p>或者在终端中执行下面的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 失败重复5次，重复间隔时间为3s，并保存为 .tar.gz 形式</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl -L --retry 5 --retry-delay 3 <span class="string">&quot;https://github.com/hyperledger/fabric/releases/download/v2.3.1/hyperledger-fabric-darwin-amd64-2.3.1.tar.gz&quot;</span> | tar xz</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl -L --retry 5 --retry-delay 3 <span class="string">&quot;https://github.com/hyperledger/fabric-ca/releases/download/v1.4.9/hyperledger-fabric-ca-darwin-amd64-1.4.9.tar.gz&quot;</span> | tar xz</span></span><br></pre></td></tr></table></figure></li><li><p>或者自行编译<a class="link" href="https://github.com/hyperledger/fabric.git">fabric<i class="fas fa-external-link-alt"></i></a>和<a class="link" href="https://github.com/hyperledger/fabric-ca.git">fabric-ca<i class="fas fa-external-link-alt"></i></a>源码得到，需要go环境依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 编译fabric</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> fabric</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make release</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/hyperledger/fabric/release/linux-amd64/bin/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译fabric-ca</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> fabric-ca</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make fabric-ca-server</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make fabric-ca-client</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> bin</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>解压后得到两个bin文件夹和一个config文件夹，合并bin文件夹后将两者放到fabric-sample中</p><ul><li>这些二进制文件将帮助您与测试网络进行交互</li></ul></li></ul></li></ul></blockquote><h1 id="sample测试"><a href="#sample测试" class="headerlink" title="sample测试"></a>sample测试</h1><h2 id="运行测试网络"><a href="#运行测试网络" class="headerlink" title="运行测试网络"></a>运行测试网络</h2><h3 id="普通网络"><a href="#普通网络" class="headerlink" title="普通网络"></a>普通网络</h3><p>运行脚本 <code>network.sh</code> 来启动测试网络，该脚本使用本地计算机上的Docker映像站立在Fabric网络上</p><ul><li>到目录 <code>fabric-samples/test-network</code> 下执行命令</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./network.sh up</span><br></pre></td></tr></table></figure><ul><li>启动网络</li><li>此命令创建一个结构网络，该结构网络由<strong>两个对等节点</strong>，<strong>一个订购节点</strong>组成。您在运行时不会创建任何渠道，如果命令成功完成，您将看到正在创建的节点的日志</li></ul><p>![截屏2021-03-09 下午10.13.09](fabric-Getting Start/截屏2021-03-09 下午10.13.09.png)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./network.sh down</span><br></pre></td></tr></table></figure><ul><li>从以前的任何运行中删除任何容器或工件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE                               COMMAND             CREATED              STATUS              PORTS                                            NAMES</span><br><span class="line">fcb443d2c66a   hyperledger/fabric-tools:latest     <span class="string">&quot;/bin/bash&quot;</span>         About a minute ago   Up About a minute                                                    cli</span><br><span class="line">bd07774d282d   hyperledger/fabric-orderer:latest   <span class="string">&quot;orderer&quot;</span>           About a minute ago   Up About a minute   0.0.0.0:7050-&gt;7050/tcp, 0.0.0.0:7053-&gt;7053/tcp   orderer.example.com</span><br><span class="line">5257b92a5b00   hyperledger/fabric-peer:latest      <span class="string">&quot;peer node start&quot;</span>   About a minute ago   Up About a minute   0.0.0.0:7051-&gt;7051/tcp                           peer0.org1.example.com</span><br><span class="line">8a8cd2ea75e4   hyperledger/fabric-peer:latest      <span class="string">&quot;peer node start&quot;</span>   About a minute ago   Up About a minute   7051/tcp, 0.0.0.0:9051-&gt;9051/tcp                 peer0.org2.example.com</span><br></pre></td></tr></table></figure><ul><li>列出计算机上运行的所有Docker容器<ul><li>网络中的每个对等方都必须属于一个组织。在测试网络中，每个组织各自运营一个对等方，<code>peer0.org1.example.com</code> 和 <code>peer0.org2.example.com</code>。</li><li>每个Fabric网络还包括订购服务，可以看到订购节点 <code>orderer.example.com</code>。</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./network.sh createChannel -c channelName</span></span><br></pre></td></tr></table></figure><ul><li>创建Channel，系统默认命名为 <code>mychannel</code> </li><li>channel名称限制<ul><li>仅包含小写ASCII字母数字，点“。”和破折号“-”</li><li>少于250个字符</li><li>以字母开头</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./network.sh deployCC -ccn basic -ccp ../asset-transfer-basic/chaincode-go -ccl go</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> deployCC = deploy chaincode</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -ccn <span class="built_in">set</span> chaincode name</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -ccp <span class="built_in">set</span> chaincode path</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -ccl <span class="built_in">set</span> chaincode language</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -c 指定部署链码的通道名称，默认在 mychannel 上部署</span></span><br></pre></td></tr></table></figure><ul><li>在channel上启动链码（此链码将在名为 <code>mychannel</code> 的通道上执行）</li><li>可以在 <code>fabric-sample</code> 的 <code>asset-transfer-basic</code> 文件夹中找到资产转移的示例代码</li><li>第一次部署链码的话，该脚本将安装链码依赖项</li></ul><hr><p><strong>报错</strong></p><ol><li><p>第一次部署时无法下载依赖</p><img src="/2021/03/14/fabric-Getting%20Start/截屏2021-03-15 上午10.56.46.png" alt="截屏2021-03-15 上午10.56.46" style="zoom:50%;"><ul><li><p>只需要执行两个命令更改GO为国内代理即可，再此执行将成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go env -w GOPROXY=https://goproxy.io,direct</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> go env -w GO111MODULE=on</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><ol start="2"><li><p>无法下载组建 InstallChaincode</p><img src="/2021/03/14/fabric-Getting%20Start/截屏2021-03-15 上午11.15.27.png" alt="截屏2021-03-15 上午11.15.27" style="zoom:50%;"><ul><li><p>网络问题，重启网络，再重新创建myChannel即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./network.sh down</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./network.sh up</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./network.sh createChannel</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./network.sh deployCC -ccn basic -ccp ../asset-transfer-basic/chaincode-go -ccl go</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><hr><p><strong>与网络互动，配置peer指令</strong></p><ul><li>均在 <code>test-network</code> 文件夹下执行</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将fabroc-sample/bin下的二进制文件添加到CLI路径中（）</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> PATH=<span class="variable">$&#123;PWD&#125;</span>/../bin:<span class="variable">$PATH</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置FABRIC_CFG_PATH指向fabric-sample中的core.yaml文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> FABRIC_CFG_PATH=<span class="variable">$PWD</span>/../config/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Environment variables <span class="keyword">for</span> Org1</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> CORE_PEER_TLS_ENABLED=<span class="literal">true</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> CORE_PEER_LOCALMSPID=<span class="string">&quot;Org1MSP&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> CORE_PEER_TLS_ROOTCERT_FILE=<span class="variable">$&#123;PWD&#125;</span>/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> CORE_PEER_MSPCONFIGPATH=<span class="variable">$&#123;PWD&#125;</span>/organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> CORE_PEER_ADDRESS=localhost:7051</span></span><br></pre></td></tr></table></figure><ul><li>该 <code>CORE_PEER_TLS_ROOTCERT_FILE</code> 和 <code>CORE_PEER_MSPCONFIGPATH</code> 环境变量指向的ORG1加密材料 <code>organizations</code> 文件夹。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> peer channel list</span></span><br></pre></td></tr></table></figure><ul><li>列出网络中所有的channel</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> peer chaincode invoke -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile <span class="string">&quot;<span class="variable">$&#123;PWD&#125;</span>/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem&quot;</span> -C mychannel -n basic --peerAddresses localhost:7051 --tlsRootCertFiles <span class="string">&quot;<span class="variable">$&#123;PWD&#125;</span>/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt&quot;</span> --peerAddresses localhost:9051 --tlsRootCertFiles <span class="string">&quot;<span class="variable">$&#123;PWD&#125;</span>/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt&quot;</span> -c <span class="string">&#x27;&#123;&quot;function&quot;:&quot;InitLedger&quot;,&quot;Args&quot;:[]&#125;&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 成功的日志信息</span></span><br><span class="line">2021-03-15 11:30:18.970 CST [chaincodeCmd] chaincodeInvokeOrQuery -&gt; INFO 001 Chaincode invoke successful. result: status:200 </span><br></pre></td></tr></table></figure><ul><li>使用资产初始化分类帐</li><li>成功后就可以使用CLI来查询分类账</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> peer chaincode query -C mychannel -n basic -c <span class="string">&#x27;&#123;&quot;Args&quot;:[&quot;GetAllAssets&quot;]&#125;&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 成功查询后的输出</span></span><br><span class="line">[</span><br><span class="line">&#123;&quot;ID&quot;:&quot;asset1&quot;,&quot;color&quot;:&quot;blue&quot;,&quot;size&quot;:5,&quot;owner&quot;:&quot;Tomoko&quot;,&quot;appraisedValue&quot;:300&#125;,</span><br><span class="line">  &#123;&quot;ID&quot;:&quot;asset2&quot;,&quot;color&quot;:&quot;red&quot;,&quot;size&quot;:5,&quot;owner&quot;:&quot;Brad&quot;,&quot;appraisedValue&quot;:400&#125;,</span><br><span class="line">&#123;&quot;ID&quot;:&quot;asset3&quot;,&quot;color&quot;:&quot;green&quot;,&quot;size&quot;:10,&quot;owner&quot;:&quot;Jin Soo&quot;,&quot;appraisedValue&quot;:500&#125;,</span><br><span class="line">&#123;&quot;ID&quot;:&quot;asset4&quot;,&quot;color&quot;:&quot;yellow&quot;,&quot;size&quot;:10,&quot;owner&quot;:&quot;Max&quot;,&quot;appraisedValue&quot;:600&#125;,</span><br><span class="line">&#123;&quot;ID&quot;:&quot;asset5&quot;,&quot;color&quot;:&quot;black&quot;,&quot;size&quot;:15,&quot;owner&quot;:&quot;Adriana&quot;,&quot;appraisedValue&quot;:700&#125;,</span><br><span class="line">&#123;&quot;ID&quot;:&quot;asset6&quot;,&quot;color&quot;:&quot;white&quot;,&quot;size&quot;:15,&quot;owner&quot;:&quot;Michel&quot;,&quot;appraisedValue&quot;:800&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>获取已添加到渠道分类帐中的资产的列表</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> peer chaincode invoke -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile <span class="string">&quot;<span class="variable">$&#123;PWD&#125;</span>/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem&quot;</span> -C mychannel -n basic --peerAddresses localhost:7051 --tlsRootCertFiles <span class="string">&quot;<span class="variable">$&#123;PWD&#125;</span>/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt&quot;</span> --peerAddresses localhost:9051 --tlsRootCertFiles <span class="string">&quot;<span class="variable">$&#123;PWD&#125;</span>/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt&quot;</span> -c <span class="string">&#x27;&#123;&quot;function&quot;:&quot;InitLedger&quot;,&quot;Args&quot;:[]&#125;&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 成功的日志信息</span></span><br><span class="line">2021-03-15 11:36:04.958 CST [chaincodeCmd] chaincodeInvokeOrQuery -&gt; INFO 001 Chaincode invoke successful. result: status:200 </span><br></pre></td></tr></table></figure><ul><li>当网络成员要转移或更改分类帐上的资产时，将调用链码。</li><li>此命令通过调用 <code>asset-transfer-basic</code> 链码来更改分类帐上资产的所有者</li></ul><p>调用链代码后，我们可以使用另一个查询来查看该调用如何更改了区块链分类账上的资产。由于我们已经查询过Org1对等体，因此我们可以借此机会查询Org2对等体上运行的链码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Environment variables <span class="keyword">for</span> Org2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> CORE_PEER_TLS_ENABLED=<span class="literal">true</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> CORE_PEER_LOCALMSPID=<span class="string">&quot;Org2MSP&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> CORE_PEER_TLS_ROOTCERT_FILE=<span class="variable">$&#123;PWD&#125;</span>/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> CORE_PEER_MSPCONFIGPATH=<span class="variable">$&#123;PWD&#125;</span>/organizations/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> CORE_PEER_ADDRESS=localhost:9051</span></span><br></pre></td></tr></table></figure><ul><li>设置环境变量以作为Org2进行操作</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> peer chaincode query -C mychannel -n basic -c <span class="string">&#x27;&#123;&quot;Args&quot;:[&quot;ReadAsset&quot;,&quot;asset6&quot;]&#125;&#x27;</span></span></span><br></pre></td></tr></table></figure><ul><li><p>查询运行在 mychannel 上的 <code>asset-transfer-basic</code> 链码 <code>peer0.org2.example.com</code></p></li><li><p>结果显示 <code>&quot;asset6&quot;</code> 已转移到Christopher：</p><img src="/2021/03/14/fabric-Getting%20Start/截屏2021-03-15 上午11.39.59.png" alt="截屏2021-03-15 上午11.39.59" style="zoom:50%;"></li></ul><h3 id="与证书颁发机构建立网络"><a href="#与证书颁发机构建立网络" class="headerlink" title="与证书颁发机构建立网络"></a>与证书颁发机构建立网络</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./network.sh up -ca</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> tree命令并不是默认安装的，如果没有该命令，先安装</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> brew install tree</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在 fabric-sample/test-network 下执行</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tree organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/</span></span><br></pre></td></tr></table></figure><ul><li><p>显示MSP文件夹的结构和配置文件：</p><img src="/2021/03/14/fabric-Getting%20Start/截屏2021-03-14 下午1.15.18.png" alt="截屏2021-03-14 下午1.15.18" style="zoom:50%;"></li></ul><h2 id="运行结构应用程序"><a href="#运行结构应用程序" class="headerlink" title="运行结构应用程序"></a>运行结构应用程序</h2><h3 id="资产转移"><a href="#资产转移" class="headerlink" title="资产转移"></a>资产转移</h3><p><code>asset-transfer-basic</code> 样本演示了如何使用资产初始化分类帐，查询那些资产，创建新资产，基于资产ID查询单个资产，更新现有资产以及将资产转移给新所有者。它涉及以下两个组件：</p><ol><li><p><strong>示例应用程序</strong>：调用区块链网络，调用以链码（智能合约）实现的交易。该应用程序位于以下<code>fabric-samples</code>目录中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asset-transfer-basic&#x2F;application-javascript</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p><strong>智能合约本身</strong>，实现涉及与分类账交互的交易。智能合约（链码）位于以下<code>fabric-samples</code>目录中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asset-transfer-basic&#x2F;chaincode-(javascript, java, go, typescript)</span><br></pre></td></tr></table></figure></li></ol><p>请注意，在本教程中，术语链码和智能合约可互换使用。在此示例中，我们将使用javascript链码。</p><p>主要步骤：</p><ol><li><p><strong>建立开发环境。</strong>我们的应用程序需要与之交互的网络，因此我们将为我们的智能合约和应用程序部署一个基本的网络。<img src="/2021/03/14/fabric-Getting%20Start/AppConceptsOverview.png" alt="AppConceptsOverview" style="zoom:25%;"></p></li><li><p><strong>探索样本智能合约。</strong> 我们将检查示例assetTransfer（javascript）智能合约，以了解其中的交易以及应用程序如何使用它们查询和更新分类账。</p></li><li><p><strong>通过示例应用程序与智能合约进行交互。</strong>我们的应用程序将使用assetTransfer智能合约在分类账上创建，查询和更新资产。我们将深入研究应用程序及其创建的交易的代码，包括使用资产初始化分类账，查询资产，查询一系列资产，创建新资产以及将资产转让给新所有者。</p></li></ol><h4 id="启动网络"><a href="#启动网络" class="headerlink" title="启动网络"></a>启动网络</h4><ul><li>根据运行测试网络的步骤</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> open /Applications/Docker.app  <span class="comment"># mac上启动docker desktop的方式</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> fabric-samples/test-network</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./network.sh down</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./network.sh up createChannel -c mychannel -ca</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./network.sh deployCC -ccn basic -ccp ../asset-transfer-basic/chaincode-javascript/ -ccl javascript</span></span><br></pre></td></tr></table></figure><h4 id="申请样本"><a href="#申请样本" class="headerlink" title="申请样本"></a>申请样本</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> PATH=<span class="variable">$&#123;PWD&#125;</span>/../bin:<span class="variable">$PATH</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> FABRIC_CFG_PATH=<span class="variable">$PWD</span>/../config/</span></span><br></pre></td></tr></table></figure><ul><li>设置peer指令环境变量</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> fabric-sample/asset-transfer-basic/application-javascript</span></span><br></pre></td></tr></table></figure><ul><li>打开一个新的终端，进入到示例代码文件中，</li><li>该目录包含使用Fabric SDK for Node.js开发的示例程序。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> node app.js</span></span><br></pre></td></tr></table></figure><ul><li><p>运行 npm 命令以安装应用程序依赖项。最多可能需要一分钟才能完成。</p></li><li><p>此过程将安装在的应用程序中定义的关键应用程序依赖项 <code>package.json</code>。其中最重要的是 <code>fabric-network</code> Node.js模块；它使应用程序能够使用身份，钱包和网关来连接到渠道，提交交易并等待通知</p></li><li><p>运行完成后将得到以下文件</p><img src="/2021/03/14/fabric-Getting%20Start/截屏2021-03-16 上午11.23.37.png" alt="截屏2021-03-16 上午11.23.37" style="zoom:50%;"></li></ul><h4 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h4><p><code>fabric-sample/asset-transfer-basic/application-javascript/app.js</code></p><ul><li>仅调用方法<ul><li>方法定义在 <code>fabric-sample/test-application/javascript/</code> 的 <code>CAUtil.js</code> 和 <code>AppUtil.js</code> 中</li></ul></li></ul><h5 id="app-js："><a href="#app-js：" class="headerlink" title="app.js："></a>app.js：</h5><p>当我们启动Fabric测试网络时，创建了一个管理员用户（字面上称为<code>admin</code>）作为证书颁发机构（CA）的<strong>注册商</strong>。</p><img src="/2021/03/14/fabric-Getting%20Start/code.png" alt="截屏2021-03-16 下午3.01.28" style="zoom:50%;"><ol><li>调用函数 <code>enrollAdmin()</code> 生成 admin 的私钥，公钥和X.509证书。<ul><li>此过程使用<strong>证书签名请求</strong>（CSR）-专用密钥和公用密钥首先在本地生成，然后将公用密钥发送到CA，CA返回编码的证书供应用程序使用。</li><li>这些凭证然后存储在 <code>application-javascript/wallet</code> 中，使我们能够充当CA的管理员。</li><li>可以在<code>wallet/admin.id</code> 文件中找到管理员的证书和私钥</li></ul></li></ol><blockquote><p><strong>注意</strong></p><p>如果您决定通过断开网络并重新启动来重新开始，则必须<code>wallet</code>在重新运行javascript应用程序之前删除该文件夹及其标识，否则会出现错误。发生这种情况的原因是，在关闭测试网络时，关闭了证书颁发机构及其数据库，但是原始钱包仍保留在application-javascript目录中，因此必须将其删除。当您重新运行示例javascript应用程序时，将生成一个新的钱包和凭据。</p></blockquote><ol start="2"><li>调用 <code>registerAndEnrollUser()</code> 来注册并加入一个应用程序用户 <code>appUser</code>，该用户将用于与区块链网络进行交互<ul><li>与管理员注册类似，此功能使用<strong>CSR</strong>来注册，注册 <code>appUser</code> 和存储其凭据以及<code>admin</code>钱包中的凭据。</li><li>现在，我们拥有两个独立用户的身份，<code>admin</code>并且<code>appUser</code>该身份可以由我们的应用程序使用</li></ul></li></ol><img src="/2021/03/14/fabric-Getting%20Start/截屏2021-03-16 下午3.20.50.png" alt="截屏2021-03-16 下午3.20.50" style="zoom:50%;"><ol start="3"><li><p>应用程序正在通过网关 gateway 使用 <code>chaincodeName</code> 和 <code>channelName</code> 名称来引用合约</p><ul><li><p>（本例是在 mychannel 中使用 asset-transfer-basic 合约）</p></li><li><p>当链码包包含多个智能合约时，可以在<a class="link" href="https://hyperledger.github.io/fabric-sdk-node/release-2.2/module-fabric-network.Network.html#getContract">getContract（）API<i class="fas fa-external-link-alt"></i></a>上指定链码包的名称和要定位的特定智能合约。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> contract = <span class="keyword">await</span> network.getContract(<span class="string">&#x27;chaincodeName&#x27;</span>, <span class="string">&#x27;smartContractName&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>asLocalhost</code> set <code>true</code> 告知它以localhost连接。在不将客户端与其他结构节点在同一网络上运行的部署中，该 <code>asLocalhost</code> 选项将设置为 <code>false</code>。</p></li></ul></li></ol><img src="/2021/03/14/fabric-Getting%20Start/截屏2021-03-16 下午3.20.58.png" alt="截屏2021-03-16 下午3.20.58" style="zoom:50%;"><ol start="4"><li><code>SubmitTransaction()</code> 函数用于调用chaincode的 <code>InitLedger</code> 函数，以使用一些样本数据填充分类帐。<ul><li>在幕后，<code>submitTransaction()</code> 函数将使用服务发现来为链码找到一组所需的认可对等体，在所需数目的对等体上调用链码，从这些对等体收集链码认可的结果，最后将事务提交给订购服务。</li><li>对等体在assets中指定，然后使用 <code>ctx.stub.putState(...)</code> 来验证（chaincode-javascript中）</li></ul></li></ol><img src="/2021/03/14/fabric-Getting%20Start/截屏2021-03-16 下午3.45.11.png" alt="截屏2021-03-16 下午3.45.11" style="zoom:50%;"><img src="/2021/03/14/fabric-Getting%20Start/截屏2021-03-16 下午3.35.33.png" alt="截屏2021-03-16 下午3.35.33" style="zoom:50%;"><ol start="5"><li></li></ol><blockquote><p>require(‘fabric-network’); 模块中，定义在文件 fabric-network/lib/transaction.js 中</p></blockquote><p><strong>evaluateTransaction()</strong></p><ul><li>代表了区块链网络中与智能合约最简单的交互之一。只是查询账本内容而已</li><li>它只是选择一个在连接配置文件中定义的对等体，然后将请求发送到该对等体，并在此对其进行评估。智能合约查询对等方账本副本上的资产，并将结果返回给应用程序。</li><li>这种交互不会导致分类账的更新。</li></ul><p><strong>submitTransaction()</strong></p><ul><li>比 <code>evaluateTransaction()</code> 复杂得多，是一个完整的共识流程（提交-背书-检验）</li><li>SDK不会与单个peer进行交互，而是根据chaincode的背书政策，向区块链网络中每个需要的组织对等方发送 <code>proposal</code>。这些对等方中的每一个都将使用该 <code>proposal</code> 执行所请求的智能合约，以生成交易响应，该交易响应将对其背书（签署）并返回到SDK。SDK将所有已背书的交易响应收集到一个交易中，然后将其提交给oderer。oderer将来自各种应用程序客户端的交易收集并排序为一个交易块。这些块被分发到网络中的每个对等点，在此对每个事务进行验证和提交。最后，通过事件通知SDK，使其可以将控制权返回给应用程序。</li></ul><h5 id="CAUtil-js"><a href="#CAUtil-js" class="headerlink" title="CAUtil.js"></a>CAUtil.js</h5><p><strong>enrollAdmin</strong></p><p><strong>registerAndEnrollUser</strong></p><ul><li></li></ul><h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><p><a class="link" href="https://www.jianshu.com/p/248530bf31b8">https://www.jianshu.com/p/248530bf31b8<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本部分主要设计fabric环境安装，已经 &lt;code&gt;fabric-sample&lt;/code&gt; 中 &lt;code&gt;test-network&lt;/</summary>
      
    
    
    
    <category term="notebook" scheme="https://jieyang-wei.github.io/categories/notebook/"/>
    
    <category term="blockchain" scheme="https://jieyang-wei.github.io/categories/notebook/blockchain/"/>
    
    <category term="fabric" scheme="https://jieyang-wei.github.io/categories/notebook/blockchain/fabric/"/>
    
    
    <category term="fabric" scheme="https://jieyang-wei.github.io/tags/fabric/"/>
    
    <category term="blockchain" scheme="https://jieyang-wei.github.io/tags/blockchain/"/>
    
  </entry>
  
  <entry>
    <title>go</title>
    <link href="https://jieyang-wei.github.io/2021/03/10/go/"/>
    <id>https://jieyang-wei.github.io/2021/03/10/go/</id>
    <published>2021-03-10T04:24:29.000Z</published>
    <updated>2021-03-10T08:07:07.407Z</updated>
    
    <content type="html"><![CDATA[<h3 id><a href="#" class="headerlink" title></a></h3><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h2><ol><li>Mac下使用Homebrew安装</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew install go</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> go version</span></span><br><span class="line">go version go1.16 darwin/amd64</span><br></pre></td></tr></table></figure><ol start="2"><li>或者在官网下载安装文件</li></ol><p>安装包下载地址为：<a class="link" href="https://golang.org/dl/">https://golang.org/dl/<i class="fas fa-external-link-alt"></i></a></p><p>如果打不开可以使用这个地址：<a class="link" href="https://golang.google.cn/dl/">https://golang.google.cn/dl/<i class="fas fa-external-link-alt"></i></a></p><ol start="3"><li>解压下载文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tar -C /usr/<span class="built_in">local</span> -xzf go1.4.linux-amd64.tar.gz</span></span><br></pre></td></tr></table></figure><ul><li>Mac用户直接双击<code>.pkg</code>文件，安装目录为<code>/usr/local/go</code></li></ul><ol start="4"><li>安装完成后将 <code>/usr/local/go/bin</code> 目录添加至PATH环境变量：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/go/bin</span></span><br></pre></td></tr></table></figure><h2 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h2><p>Go采用的是UTF-8编码的文本文件存放源代码，理论上使用任何一款文本编辑器都可以做Go语言开发，这里推荐使用<code>VS Code</code>和<code>Goland</code>。 <code>VS Code</code>是微软开源的编辑器，而<code>Goland</code>是jetbrains出品的付费IDE。</p><ol><li><strong>GoLand</strong></li></ol><p>GoLand 是 Jetbrains 家族的 Go 语言 IDE，有 30 天的免费试用期。</p><p>安装也很简单访问 <a class="link" href="https://www.jetbrains.com/go/">Gogland 的下载页面<i class="fas fa-external-link-alt"></i></a>，根据你当期的系统环境三大平台（Mac、Linux、Windows）下载对应的软件。</p><ol start="2"><li><strong>LiteIDE</strong></li></ol><p>LiteIDE 是一款开源、跨平台的轻量级 Go 语言集成开发环境（IDE）。</p><p>支持的 操作系统</p><ul><li>Windows x86 (32-bit or 64-bit)</li><li>Linux x86 (32-bit or 64-bit)</li></ul><p>下载地址 ：<a class="link" href="http://sourceforge.net/projects/liteide/files/">http://sourceforge.net/projects/liteide/files/<i class="fas fa-external-link-alt"></i></a></p><p>源码地址 ：<a class="link" href="https://github.com/visualfc/liteide">https://github.com/visualfc/liteide<i class="fas fa-external-link-alt"></i></a></p><ol start="3"><li><strong>VS Code</strong>(本人使用)</li></ol><p>VS Code的<a class="link" href="https://code.visualstudio.com/Download">官方下载地址<i class="fas fa-external-link-alt"></i></a></p><p>安装Go插件</p><img src="/2021/03/10/go/截屏2021-03-10 下午1.56.48.png" alt="截屏2021-03-10 下午1.56.48" style="zoom:40%;"><ul><li><p>配置包管理</p><ol><li>进入项目根目录<code>$GOPATH/src</code>，运行命令<code>$ go mode init</code> 生成**<code>go.mod</code><strong>包管理文件，此时在vs code中点击右上角的三角形即可成功运行（</strong>推荐**）</li><li>或者手动执行以下命令来添加</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">go get -u -v github.com/nsf/gocode</span><br><span class="line">go get -u -v github.com/rogpeppe/godef</span><br><span class="line">go get -u -v github.com/golang/lint/golint</span><br><span class="line">go get -u -v github.com/lukehoban/go-find-references</span><br><span class="line">go get -u -v github.com/lukehoban/go-outline</span><br><span class="line">go get -u -v sourcegraph.com/sqs/goreturns</span><br><span class="line">go get -u -v golang.org/x/tools/cmd/gorename</span><br><span class="line">go get -u -v github.com/tpng/gopkgs</span><br><span class="line">go get -u -v github.com/newhook/go-symbols</span><br></pre></td></tr></table></figure></li></ul><ol start="4"><li><strong>Idea</strong></li></ol><p>在plugins中安装go插件</p><p>打开项目目录<code>$GOPATH/src</code></p><p>创建一个项目文件夹<code>hello</code>，并添加第一个程序main.go</p><p>右上角设置运行环境<code>edit configurations</code></p><p>根据红框更改配置</p><img src="/2021/03/10/go/截屏2021-03-10 下午3.41.22.png" alt="截屏2021-03-10 下午3.41.22" style="zoom:50%;"><p>最后在终端中进入上面设置的 <code>/Users/weijieyang/go/src</code> 目录，运行命令<code>$ go mode init</code> 生成**<code>go.mod</code>**包管理文件</p><p>进入idea，点击右上角的三角形即可成功运行</p><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看环境变量</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> go env NAME</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置环境变量</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> NAME=<span class="variable">$Home</span>/&lt;user-defined-workspace&gt;/go</span></span><br></pre></td></tr></table></figure><p>下图为本机环境变量：</p><img src="/2021/03/10/go/B73C0FB2855C12EA5F08CF4CBD86DFD5.png" alt="B73C0FB2855C12EA5F08CF4CBD86DFD5" style="zoom:50%;"><p><strong>GO111MODULE</strong></p><ul><li>GO111MODULE=<strong>off</strong><ul><li>go命令行将不会支持module功能，寻找依赖包的方式将会沿用旧版本那种通过vendor目录或者GOPATH模式来查找。</li></ul></li><li>GO111MODULE=<strong>on</strong><ul><li>go命令行会使用modules，而一点也不会去GOPATH目录下查找。</li><li>1.12后，无论在<code>$GOPATH/src</code>里还是在外面，都会使用go.mod 里 require的包</li></ul></li><li>GO111MODULE=<strong>auto</strong><ul><li>默认值，go命令行将会根据当前目录来决定是否启用module功能。</li><li>项目在 <code>$GOPATH/src</code> 里会使用 <code>$GOPATH/src</code> 的依赖包</li><li>在 <code>$GOPATH/src</code> 外，就使用go.mod 里 require的包</li></ul></li></ul><p><strong>GOROOT</strong></p><ul><li>go的安装路径</li><li>默认为 <code>/usr/local/Cellar/go/1.16/libexec</code></li></ul><p><strong>GOPATH</strong></p><ul><li><code>go install</code> /。<code>go get</code>和 go的工具等会用到 <code>GOPATH</code> 环境变量. </li><li><code>GOPATH</code> 是作为编译后二进制的存放目的地和import包时的搜索路径 (其实也是你的工作目录, 你可以在src下创建你自己的go源文件, 然后开始工作)。<ol><li><code>GOPATH</code> 之下主要包含三个目录: bin、pkg、src</li><li><strong>bin</strong>目录主要存放可执行文件; </li><li><strong>pkg</strong>目录存放编译好的库文件, 主要是*.a文件;</li><li><strong>src</strong>目录下主要存放go的源文件</li></ol></li><li>不要把 <code>GOPATH</code> 设置成go的安装路径，一般可以设置为 <code>$HOME/go</code></li></ul><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>在进行Go语言开发的时候，我们的代码总是会保存在<code>$GOPATH/src</code>目录下。在工程经过<code>go build</code>、<code>go install</code>或<code>go get</code>等指令后，会将下载的第三方包源代码文件放在<code>$GOPATH/src</code>目录下， 产生的二进制可执行文件放在 <code>$GOPATH/bin</code>目录下，生成的中间缓存文件会被保存在 <code>$GOPATH/pkg</code> 下。</p><p>如果我们使用版本管理工具（Version Control System，VCS。常用如Git）来管理我们的项目代码时，我们只需要添加<code>$GOPATH/src</code>目录的源代码即可。<code>bin</code> 和 <code>pkg</code> 目录的内容无需版本控制。</p><p><strong>个人开发者</strong></p><p>我们知道源代码都是存放在<code>GOPATH</code>的<code>src</code>目录下，那我们可以按照下图来组织我们的代码</p><img src="/2021/03/10/go/1300537-20190325205527275-638377643.png" alt="1300537-20190325205527275-638377643" style="zoom: 90%;"><p>目前流行的项目框架</p><ul><li><p>Go语言中也是通过包来组织代码文件，我们可以引用别人的包也可以发布自己的包，但是为了防止不同包的项目名冲突，我们通常使用<code>顶级域名</code>来作为包名的前缀，这样就不担心项目名冲突的问题了。</p></li><li><p>因为不是每个个人开发者都拥有自己的顶级域名，所以目前流行的方式是使用个人的<code>github用户名</code>来区分不同的包。</p></li><li><p>以后我们从github上下载别人包的时候，如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go get github.com/username/package</span></span><br><span class="line">import &quot;github.com/username/package&quot;</span><br></pre></td></tr></table></figure></li></ul><img src="/2021/03/10/go/1300537-20190325205546430-23281384.png" alt="1300537-20190325205546430-23281384" style="zoom:80%;"><p><strong>企业开发者</strong></p><img src="/2021/03/10/go/1300537-20190325205654857-1473178176.png" alt="1300537-20190325205654857-1473178176" style="zoom:40%;"><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><h2 id="go-mod"><a href="#go-mod" class="headerlink" title="go.mod"></a>go.mod</h2><p>go 会自动查找代码中的包，下载依赖包，并且把具体的依赖关系和版本写入到go.mod和go.sum文件中。<br>查看go.mod，它会变成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module test</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">github.com&#x2F;gohouse&#x2F;gorose v1.0.5</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>require 关键字是引用，后面是包，最后v1.11.1 是引用的版本号</li><li>使用Go的包管理方式，依赖的第三方包被下载到了 <code>$GOPATH/pkg/mod</code> 路径下。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;/h3&gt;&lt;h1 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h1&gt;&lt;h2 id=&quot;运行环境&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="notebook" scheme="https://jieyang-wei.github.io/categories/notebook/"/>
    
    
    <category term="编程语言" scheme="https://jieyang-wei.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="go" scheme="https://jieyang-wei.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>ssh证书登陆</title>
    <link href="https://jieyang-wei.github.io/2021/03/08/ssh%E8%AF%81%E4%B9%A6%E7%99%BB%E9%99%86/"/>
    <id>https://jieyang-wei.github.io/2021/03/08/ssh%E8%AF%81%E4%B9%A6%E7%99%BB%E9%99%86/</id>
    <published>2021-03-08T06:07:39.000Z</published>
    <updated>2021-03-18T06:45:57.956Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文基于ubuntu20.04 LST版本，通过在mac上使用VMware安装linux虚拟机实现。</p><h1 id="SSH证书登陆"><a href="#SSH证书登陆" class="headerlink" title="SSH证书登陆"></a>SSH证书登陆</h1><p>Secure Shell(SSH) 是由 IETF(The Internet Engineering Task Force) 制定的建立在应用层基础上的安全网络协议。它是专为远程登录会话(甚至可以用Windows远程登录Linux服务器进行文件互传)和其他网络服务提供安全性的协议，可有效弥补网络中的漏洞。通过SSH，可以把所有传输的数据进行加密，也能够防止DNS欺骗和IP欺骗。还有一个额外的好处就是传输的数据是经过压缩的，所以可以加快传输的速度。目前已经成为Linux系统的标准配置。（<a class="link" href="https://blog.csdn.net/li528405176/article/details/82810342">摘自百度<i class="fas fa-external-link-alt"></i></a>）</p><p>SSH外壳安全协议，是一种可以用来远程登陆操作系统的协议，包括使用<code>密码登陆</code>和<code>证书登陆</code>，本文着重讲解证书登陆的实现过程（但这里其实应该是密钥登陆，真正的证书CA登陆可自行去百度）</p><h2 id="密码登陆"><a href="#密码登陆" class="headerlink" title="密码登陆"></a>密码登陆</h2><p>使用操作系统所在ip地址和此操作系统下的<code>用户账号</code>和<code>用户密码</code>进行远程登陆，但这样是不安全的，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh username@ip</span></span><br><span class="line"> * -o StrictHostKeyChecking=no：降低安全级别</span><br><span class="line"> * -p 输入密码</span><br></pre></td></tr></table></figure><h2 id="密钥登陆"><a href="#密钥登陆" class="headerlink" title="密钥登陆"></a>密钥登陆</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li>将客户端生成的公钥上传到服务器的配置文件中，使服务端允许此设备链接</li><li>此时当拥有私钥的客户端进行密钥登陆时，将会通过算法匹配此设备锁包含的私钥是否与服务器端的公钥相匹配，以便来验证登录信息。</li><li>如果需要了解详细的算法（rsa）过程可自行百度</li></ul><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><h4 id="客户机"><a href="#客户机" class="headerlink" title="客户机"></a>客户机</h4><ol><li>生成本机的公私钥</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen -t rsa</span></span><br><span class="line"> * -t 指定密钥生成算法，一般均使用rsa</span><br></pre></td></tr></table></figure><p>上面的命令将会默认在当前用户的家目录<code>～</code>/<code>$HOME</code>（一般是<code>/home/username</code>）下生成一个隐藏文件夹<code>.ssh</code>，里面包括了两个密钥文件</p><ul><li><code>id_rsa</code>：私钥，保存在自己手里，不要让别人知道</li><li><code>id_rsa.pub</code>：公钥，一般提交给各个服务器，用来进行权限配置<img src="/2021/03/08/ssh%E8%AF%81%E4%B9%A6%E7%99%BB%E9%99%86/login.png" alt="在这里插入图片描述" style="zoom:50%;"></li><li>生成密钥时将会询问文件生成目录，默认为<code>/home/usernam/.ssh</code>，当然也可以在此处自己指定</li><li>之后会让用户设置<code>passphrase</code>，即密钥的密码；如果此处设置了密码，在之后的密钥远程登陆的过程将会需要输入密码；如果不需要密码直接登录即可（为了安全考虑，此处建议设置密码）</li></ul><ol start="2"><li>配置私钥选择路径<br>上面提到，每次登陆需要匹配服务器出提前配置的公钥和客户端的私钥，所以需要知道客户端私钥存放路径，此时有两种方法：</li></ol><ul><li>如果默认放在家目录下，路径固定，可以不用更改</li></ul><ol><li>在登陆时使用<code>-i</code>指定私钥文件绝对路径</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh -i ～/.ssh/id_rsa blue@&lt;ssh_server_ip&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>到<code>etc/ssh/ssh_config</code>文件下配置默认路径</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 其实默认id_rsa就已经加入私钥的路径了,这里只是示例而已</span></span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果有其他的私钥，还要再加入其他私钥的路径</span></span><br><span class="line">IdentityFile ~/.ssh/blue_rsa</span><br></pre></td></tr></table></figure><p>到此客户端的配置就完成了</p><h4 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h4><ol><li>配置允许登陆的客户端到文件<code>~/.ssh/authorized_keys</code>下<ul><li>当然你也可以直接复制粘贴到文件末尾</li></ul></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> scp ～/.ssh/id_ras.pub username@ip:~</span>        </span><br><span class="line"><span class="meta">#</span><span class="bash"> 将文件传到服务器上</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat id_rsa.pub &gt;&gt; ～/.ssh/authorized_keys</span>   </span><br><span class="line"><span class="meta">#</span><span class="bash"> 在服务器端将文件内容写入文件末尾</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /etc/init.d/ssh restart</span>                    </span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启ssh服务</span></span><br></pre></td></tr></table></figure><ol start="2"><li>进行登陆配置<code>/etc/ssh/ssh_config</code>（也可能是文件<code>/etc/ssh/sshd_config</code>）</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PermitRootLogin no</span><br><span class="line"><span class="meta">#</span><span class="bash"> 取消root管理员用户的登陆权限，使得客户端只能登陆到服务器允许的用户账号上</span></span><br><span class="line"></span><br><span class="line">RSAAuthentication yes  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 是否允许用户自行使用成对的密钥系统进行登入行为 version 2</span></span><br><span class="line">PubkeyAuthentication yes  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 是否允许用户自行使用成对的密钥系统进行登入行为</span></span><br><span class="line">AuthorizedKeysFile   %h/.ssh/authorized_keys</span><br><span class="line"><span class="meta">#</span><span class="bash"> 公钥数据路径</span></span><br><span class="line"></span><br><span class="line">PasswordAuthentication no</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在确认证书登陆成功后，再关闭密码登陆</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果直接关闭，可能因为证书登陆配置失败导致再也无法登陆到服务器上</span></span><br></pre></td></tr></table></figure><ol start="3"><li>使用场景</li></ol><p>当多人协同服务一个大项目时，为了方便管理每个人所拥有的权限，所产生的信息，以及服务器安全等，我们可以为每个人设置一个服务器用户，单独为此用户分配权限，之后将该员工的公钥配置到对应用户的家目录下。这样与此员工相关的信息均与该服务器用户相关联，当删除用户时，与员工相关的所有信息都将被删除，同时公钥被删除了也就取消了该员工的登陆权限。</p><h2 id="证书登陆-CA"><a href="#证书登陆-CA" class="headerlink" title="证书登陆 CA"></a>证书登陆 CA</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文基于ubuntu20.04 LST版本，通过在mac上使用VMware安装linux虚拟机实现。&lt;/p&gt;
&lt;h1 id=&quot;SSH证书登陆</summary>
      
    
    
    
    <category term="course" scheme="https://jieyang-wei.github.io/categories/course/"/>
    
    
    <category term="密码学" scheme="https://jieyang-wei.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>fabric</title>
    <link href="https://jieyang-wei.github.io/2021/03/07/fabric/"/>
    <id>https://jieyang-wei.github.io/2021/03/07/fabric/</id>
    <published>2021-03-07T14:12:46.000Z</published>
    <updated>2021-03-19T03:37:37.458Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>由IBM贡献的超级账本框架。它是一个利用现有成熟的技术来组合而成的一个区块链技术的实现。它是一种允许可插拔实现各种功能的的模块化架构。它具有强大的容器技术，来承载各种主流语言来编写的智能合约。</li><li>Fabric 是一个 Python (2.5-2.7) 的库和命令行工具，用来提高基于 SSH 的应用部署和系统管理效率<ul><li>一个让你通过 <strong>命令行</strong> 执行 <strong>无参数 Python 函数</strong> 的工具；</li><li>一个让通过 SSH 执行 Shell 命令更加<strong>容易</strong> 、 <strong>更符合 Python 风格</strong> 的命令库（建立于一个更低层次的库）。</li></ul></li></ul><ul><li>fabric和比特币与以太坊的最大的区别在于其身份识别能力，<strong>fabric是权限区块链</strong>，而后两者是匿名的非权限区块链</li></ul><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><strong>基本结构</strong>：</p><ul><li><img src="/2021/03/07/fabric/截屏2021-03-04 下午4.52.42-4848273.png" alt="截屏2021-03-04 下午4.52.42" style="zoom:35%;"></li></ul><p><strong>资产 Assets</strong></p><ul><li>理解为任何具有货币价值的东西，它们都可以通过网络进行交易，无论是有形资产还是无形资产都属于资产，Hyperledger Fabric提供了使用链码交易修改资产的功能。</li><li>资产在Fabric中以<code>键-值对集合</code>的形式存在，在通道（Channel）中各本地账本可以对其状态提交变更</li><li>资产可以用<strong>二进制</strong>或<strong>JSON</strong>形式表示</li><li></li></ul><p><strong>账本 ledger</strong></p><ul><li>Hyperledger Fabric具有一个账本子系统，该子系统包括两个组件：<strong>世界状态</strong>和<strong>事务日志</strong>。</li><li>每个参与者都有一份账本到他们所属的每个Hyperledger Fabric网络的副本。</li><li>分类帐是世界状态数据库和事务日志历史记录的组合。</li></ul><p><strong>世界状态</strong></p><ul><li>版本号：从0开始，每当状态更新时版本号就递增。状态更新时会首先检查版本号，以确保当前状态的版本与背书时的版本一致（避免并发更新）</li><li>描述分类帐在给定时间点的状态。这是分类帐的<strong>数据库</strong>。</li></ul><p><strong>事务日志</strong></p><ul><li>记录所有导致当前世界状态值的事务；这是世界状态的<strong>更新历史</strong>。</li></ul><p><strong>分类账功能</strong></p><ul><li><p>分类帐是结构中<strong>所有状态转换</strong>的有序，防篡改记录。状态转换是参与方提交的链码调用（“交易”）的结果。每笔交易都会产生一组资产键值对，这些键值对会在创建，更新或删除时提交到分类账。</p></li><li><p>分类帐由一个<strong>区块链</strong>（“ chain”）和一个<strong>状态数据库</strong>组成，该区块链将不可变的顺序记录存储在块中，该状态数据库用于维护当前的结构状态。每个频道有一个分类帐。每个对等方都为其所属的每个通道维护一个分类帐的副本。</p></li></ul><p>Fabric分类帐的一些功能：</p><ul><li>使用基于键的查找，范围查询和组合键查询来查询和更新分类帐</li><li>使用丰富查询语言的只读查询（如果使用CouchDB作为状态数据库）</li><li>只读历史记录查询—查询密钥的分类帐历史记录，从而启用数据出处场景</li><li>事务包括以链码（读集）读取的键/值的版本和以链码（写集）写入的键/值的版本。</li><li>交易包含每个背书对等方的签名，并提交给订购服务</li><li>交易被分为几大块，并从订购服务“交付”到渠道上的对等方</li><li>对等方根据背书政策验证交易并执行政策</li><li>在附加块之前，执行版本检查，以确保自链码执行以来，已读取资产的状态未发生变化。</li><li>交易一旦经过验证并提交，便具有不变性</li><li>通道的分类帐包含一个配置块，用于定义策略，访问控制列表和其他相关信息</li><li>通道包含<a class="link" href="https://hyperledger-fabric.readthedocs.io/en/latest/glossary.html#msp">成员资格服务提供程序<i class="fas fa-external-link-alt"></i></a>实例，允许从不同的证书颁发机构派生加密材料</li></ul><h2 id="区块结构"><a href="#区块结构" class="headerlink" title="区块结构"></a>区块结构</h2><ol><li><p><strong>区块头</strong>：包含三个属性（<strong>区块号</strong>、<strong>当前区块哈希</strong>、<strong>前一个区块的哈希</strong>），当一个区块被创建时写入。</p></li><li><p><strong>区块数据</strong>：包含的是<strong>排序后的交易列表</strong>。当区块被ordering service创建时写入。</p></li><li><p><strong>区块元数据</strong>：包括区块的<strong>写入时间</strong>，以及<strong>区块写入者的证书</strong>、<strong>公钥</strong>和<strong>签名。</strong></p></li></ol><p><strong>状态</strong></p><ul><li>整个区块链的状态可以看作是一个 versioned KVS（带有版本的 key-value store，类似于git仓库），这些kv通过chaincode（智能合约）进行更新，它只提供了put和get方法，所有的状态变更都有日志记录。</li></ul><h2 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h2><p>在fabric中指的就是对<strong>链代码（即智能合约）的操作</strong>，交易分为两种</p><ol><li><p><strong>部署交易（deploy transaction）</strong>：</p><ul><li>指的是<strong>创建新的链代码</strong>（chaincode），并且用一个程序作为参数，当一个部署交易成功执行时，链代码就被安装到区块链上了。</li></ul></li><li><p><strong>调用交易（invoke transaction）</strong>：</p><ul><li><p>指的是<strong>运行链代码</strong>，链代码执行时可能会修改相应的状态并返回输出。下图是一个交易的详细结构：</p><img src="/2021/03/07/fabric/15873283-087e0d4d80b57ca1.png" alt="15873283-087e0d4d80b57ca1" style="zoom:70%;"><ul><li><strong>交易头 H4</strong>：包含交易的元数据，如<strong>链码名称、版本</strong>等</li><li><strong>交易签名 S4</strong>：包含由客户端应用程序创建的<strong>加密签名</strong>，作用是判断交易是否被篡改</li><li><strong>交易提案 P4</strong>：作用是对由应用程序提供给智能合约的输入参数进行编码。当智能合约运行时，提案<strong>负责将参数传递过去</strong></li><li><strong>交易响应 R4</strong>：是<strong>智能合约的输出</strong>，包含的是世界状态在交易前后的值，以读写集的形式展示。</li></ul></li></ul></li><li><p>其实还可能存在query transaction（v1版本加入）和cross-chaincode transaction（v1之后的版本会加入），此处不做讨论</p></li></ol><h3 id="交易流程"><a href="#交易流程" class="headerlink" title="交易流程"></a>交易流程</h3><p>前提假设是各节点已经提前颁发好证书，且已正常启动，并加入已经创建好的通道。此流程介绍的是在<strong>已经实例化了</strong>的链码通道上从发起一个<strong>调用交易到最终结账的全过程</strong>。</p><img src="/2021/03/07/fabric/截屏2021-03-14 上午10.43.57.png" alt="截屏2021-03-14 上午10.43.57" style="zoom:45%;"><ol><li><strong>提交交易提案</strong><ul><li>应用程序（客户端节点）构造好<strong>交易提案</strong>（交易提案中包含本次交易要调用的<strong>合约标识</strong>、<strong>合约方法</strong>和<strong>参数信息</strong>以及<strong>客户端签名</strong>等）请求后，根据背书策略选择背书节点（多个）执行交易提案并进行背书签名。</li><li>背书节点是链代码中背书策略指定的节点。正常情况下背书节点执行后的结果是一致的，只有背书节点对结果的签名不一样。</li></ul></li><li><strong>模拟执行提案并进行背书</strong><ul><li>背书节点在收到交易提案后会进行一些验证，验证通过后，<strong>背书节点会根据当前账本数据模拟执行链码中的业务逻辑并生成读写集（RwSet）。</strong></li><li>模拟执行时不会更新账本数据。<strong>然后背书节点对这些读写集进行签名生成提案响应（proposal response）</strong>，然后返回给应用程序。</li></ul></li><li><strong>收集交易的背书</strong>（返回模拟执行结果）<ul><li>应用程序收到proposal response后会对背书节点的签名进行验证<strong>（所有节点接收到任何消息时都需要先验证消息的合法性）。</strong>如果链码只进行账本查询操作，应用程序只需要检查查询响应，并不会将交易提交给排序服务节点。如果链码对账本进行了invoke操作，则需要提交交易给排序服务进行账本更新（提交前会判断背书策略是否满足）。</li></ul></li><li><strong>构造交易请求并发送给排序服务节点</strong><ul><li>应用程序接收到所有背书节点的签名后，<strong>根据背书签名调用SDK生成交易，并广播给排序服务节点。</strong>其中生成交易的过程很简单，只需要确认所有背书节点的执行结果完全一致，再将<strong>交易提案</strong>、<strong>提案响应</strong>和<strong>背书签名</strong>打包生成交易即可。</li></ul></li><li><strong>排序服务节点对交易进行排序并生成区块</strong><ul><li>排序服务节点接收到网络中所有通道发出的交易信息，读取交易信封获取通道名称，按各个通道上交易的接收<strong>时间顺序</strong>对交易信息进行排序（多通道隔离），生成区块。（在这个过程中，排序服务节点不会关心交易是否正确，只是负责排序和打包。交易的有效性在第7步进行验证）</li></ul></li><li><strong>排序服务节点广播区块给主节点</strong><ul><li>排序服务节点生成区块后会广播给通道上不同组织的<strong>主节点</strong>。</li></ul></li><li><strong>记账节点验证区块内容并写入到账本</strong><ul><li>所有的peer节点都是记账节点，记录的是节点已加入通道的账本数据。记账节点接收到的排序服务节点生成的区块后，会<strong>验证区块交易的有效性</strong>，然后提交到本地账本并产生一个生成区块的事件，监听区块事件的应用程序会进行后续的处理。（如果接收的是配置区块，则会更新缓存的配置信息）</li></ul></li><li><strong>主节点在组织内部同步最新的区块</strong><ul><li>如果交易是无效的，也会更新区块，但不会更新世界状态。（<strong>区块存储的是操作语句，而世界状态存储的是被处理的数据</strong>）</li></ul></li></ol><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>区块链的通信实体，是一个逻辑概念，不同类型的多个节点可以运行在同一个物理服务器上。</p><ol><li><p><strong>客户端节点 client</strong></p><ul><li>客户端必须连接到某一个<strong>peer节点</strong>或<strong>排序服务节点</strong>上才能与区块链网络进行通信。</li></ul><ul><li>客户端<strong>向背书节点</strong>（endorser）<strong>提交交易提案</strong>（transaction proposal），当收集到足够背书后，<strong>向排序服务节点广播交易提案</strong>，进行排序，生成区块。</li></ul></li><li><p><strong>排序服务节点 orderer</strong></p><ul><li>接收包含背书签名的交易，对未打包的交易进行排序生成区块，广播给peer节点。</li></ul><ul><li>排序服务提供的是<strong>原子广播</strong>，保证同一个链上的节点接收到相同的信息，并且有相同的逻辑顺序。</li></ul><hr><p>orderer特性：</p><ol><li><strong>一致性</strong>：经过orderer deliver的交易，seqno一定时，blob和prevhash都一样</li><li><strong>hash链的完整性</strong>：对于deliver(seqno, hash0, blob0)和deliver(seqno-1, hash1, blob1)，HASH(seqno-1, hash1, blob1) == hash0</li><li><strong>不会凭空创造交易</strong>：每一次deliver，都是由于一次boardcast产生的。</li><li><strong>不会缺失交易</strong>：如果一个deliver(seqno, hash, blob)已经发生，那么一定有deliver(seqno-1, hash0, blob0) … deliver(0, default-hash, blob)</li><li><strong>不会重复交易</strong>：如果产生了两次 boardcast(blob)，boardcast(blob1)，则deliver(seqno1, hash, blob1)和deliver(seqno, hash0, blob)中，seqno1==seqno，<br>hash==hash0，blob==blob1</li></ol><hr></li><li><p><strong>CA节点：</strong></p><ul><li>fabric1.0的证书颁发机构，由服务器和客户端组成。</li></ul><ul><li>CA节点接收客户端的注册申请，返回注册密码用于用户登录，以便获取身份证书。</li><li>区块链上的所有操作都需要验证用户身份。</li></ul></li><li><p><strong>普通节点 peer</strong>：peer节点根据所承担的角色又可以分为记账节点（committer）、背书节点（endorser）、主节点（leader）和锚节点（anchor）。</p><hr><ul><li><strong>记账节点 Committer</strong><ul><li>所有的peer节点都是记账节点（committer）</li><li>负责<strong>验证排序服务节点区块里的交易</strong>，<strong>维护状态和总账（Ledger）的副本。</strong></li><li>该节点会定期从<strong>orderer节点</strong>获取包含交易的区块，在对这些区块进行核发验证之后，会把这些区块加入到区块链中。</li><li>记账节点无法通过配置文件配置，<strong>需要在当前客户端或者命令行发起交易请求的时候手动指定相关的committer节点</strong>。</li><li>记账节点可以有多个。</li></ul></li><li><strong>背书节点 endorser</strong><ul><li>部分节点还会<strong>执行交易并对结果进行签名背书</strong>，充当背书节点（endorser）的角色。</li><li>背书节点是<strong>动态</strong>的角色，是与具体链码绑定的。每个链码在实例化的时候都会设置<strong>背书策略</strong>，指定哪些节点对交易背书后交易才是有效的。</li><li>并且<strong>只有应用程序向它发起交易背书请求的时候才是背书节点</strong>，其他时候都是普通的记账节点，只负责验证交易并记账。</li><li>背书节点也无法通过配置文件指定，而是<strong>由发起交易请求的客户端指定</strong>。</li><li>背书节点可以有多个。</li></ul></li><li><strong>锚节点 anchor</strong><ul><li>锚节点主要<strong>负责代表组织和其他组织进行信息交换。</strong>每个组织都有一个锚节点，锚节点对于组织来说非常重要，如果锚节点出现问题，当前组织就会与其他组织失去联系。</li><li>锚节点的配置信息是<strong>在configtxgen模块的配置文件configtx.yaml中配置</strong>的。</li><li>锚节点只能有一个。</li></ul></li><li><strong>主节点 leader</strong><ul><li>能<strong>与排序服务节点通信</strong>，<strong>负责从排序服务节点获取最新的区块并在组织内部同步。</strong></li><li>主节点在整个组织中只能有一个。</li></ul></li></ul><hr></li></ol><h2 id="数据设计"><a href="#数据设计" class="headerlink" title="数据设计"></a>数据设计</h2><p>分类账状态</p><p>状态键 state key</p><p>多种状态</p><p>使用DNS命名法则：org.papernet.paper</p><ul><li>逻辑状态：维护一个paper list，将发行交易结果产生的新文件放进去</li></ul><ul><li>物理状态：使用org.papernet.paper、Issuer和paper的特性串行形成key值<ul><li>org.papernet.MagnetoCorp0001 + value（properties）</li><li>使得状态从标量变成向量</li></ul></li></ul><h2 id="系统逻辑结构"><a href="#系统逻辑结构" class="headerlink" title="系统逻辑结构"></a>系统逻辑结构</h2><img src="/2021/03/07/fabric/15873283-70ae13534abcc893.png" alt="15873283-70ae13534abcc893" style="zoom:80%;"><h3 id="org"><a href="#org" class="headerlink" title="org"></a>org</h3><ul><li>fabric系统是通过组织来划分的<strong>，每个组织内都有承担不同功能的peer节点，同时每个组织都有自己对应的fabric-ca服务器，fabric系统中所有的组织共用一个orderer集群。</strong></li><li>fabric中的组织在现实世界中可以是一个公司、一个企业，或者一个协会。在fabric中，组织是承担着数据信用责任的区块链系统参与方。</li><li>在设计一个fabric系统时，第一步就是要确定系统的参与方，然后从这些参与者中选出组织（生成对应的组织编号、域名、证书等），然后再确认组织的管理方式。组织的管理方式是指组织在遇到问题时的协作方式（如新组织的加入）。</li></ul><h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><ul><li>fabric的数据存储结构被设计成<strong>多账本体系</strong>，每个账本在fabric中被称为channel。每个channel中都有一个完全独立的账本。同一个channel中的所有peer节点都保存一份相同的数据。</li><li>通道由成员（组织）、每个成员的锚节点、账本、链码应用程序和排序服务节点定义。<ul><li>基本上，一个链由1个通道+ 1个账本+ N个成员组成</li></ul></li><li>网络上的每个交易都是在一个通道上执行的，在该通道上，每一方都必须经过身份验证和授权才能在该通道上进行交易。加入通道的每一个peer都有其自己的身份，由成员服务提供者（MSP）提供。</li></ul><h3 id="chaincode"><a href="#chaincode" class="headerlink" title="chaincode"></a>chaincode</h3><ul><li>链代码是一个按照一定规范实现的应用程序，运行于容器中，chaincode可以被安装到peer上，应用程序（客户端）通过发起交易请求，endsorer peer执行chaincode并进行签名，经过orderer的验证后，下发到对应的channel中，对账本进行更新。</li></ul><h3 id="PKI"><a href="#PKI" class="headerlink" title="PKI"></a>PKI</h3><p>Public Key Infrastructure，公钥基础结构</p><ul><li><p>Internet技术的集合，这些技术在网络中提供安全的通信。注意是PKI将 <strong>s</strong> 放入 <strong>https</strong> 中的</p></li><li><p>一种遵循标准的利用公钥加密技术为电子商务的开展提供一套安全基础平台的技术和规范。</p></li><li><p>底层采用P2P网络和gRPC协议实现对<strong>分布式账本结构的连通</strong>。通过Gossip协议<strong>进行状态同步、数据分发和成员探测。</strong></p></li></ul><p>公钥基础结构（PKI）的元素。PKI由证书颁发机构组成，证书颁发机构向各方（例如，服务的用户，服务提供商）颁发数字证书，然后由他们使用它们在环境中交换的消息中对自己进行身份验证。CA的证书吊销列表（CRL）构成了不再有效的证书的参考。吊销证书的原因有很多。例如，由于与证书关联的加密专用材料已被暴露，因此证书可能被吊销。</p><p>尽管区块链网络不只是通信网络，但它依赖于PKI标准来确保各种网络参与者之间的<strong>安全通信</strong>，并确保对发布在区块链上的消息进行正确的身份验证。因此，重要的是要了解PKI的基础知识，然后理解MSP为何如此重要。</p><p>PKI有四个关键要素：</p><ul><li><strong>数字证书</strong>：最常见的证书类型是符合<a class="link" href="https://en.wikipedia.org/wiki/X.509">X.509标准<i class="fas fa-external-link-alt"></i></a>的证书，该证书允许在其结构中对参与方的标识详细信息进行编码。<ul><li>只要CA安全地保存某些密码信息（即其自己的<strong>专用签名密钥</strong>），任何阅读证书的人都可以确保有关证书所有人的信息未被篡改 - 它始终具有证书所有人的那些特定属性。</li><li>即可视证书为无法更改的数字身份证</li></ul></li><li><strong>公钥和私钥</strong>：份验证和消息完整性是安全通信中的重要概念</li><li><strong>证书颁发机构</strong>：为组织的参与者提供了可验证的数字身份提供了基础。<ul><li>CA的有两种形式：<strong>根CA</strong>和<strong>中间CA</strong>。</li><li>由于<strong>根CA</strong>（赛门铁克，Geotrust等）必须<strong>安全地</strong>向互联网用户<strong>分发</strong>数亿个证书，因此有必要将此过程<strong>分散到</strong>所谓的<strong>中间CA中</strong>。这些中间CA的证书由根CA或其他中间机构颁发，从而可以为链中任何CA颁发的任何证书建立“信任链”。</li><li>追溯到根CA的能力不仅可以扩展CA的功能，同时仍提供安全性-允许使用证书的组织放心地使用中间CA-它限制了根CA的暴露，如果受到损害，这将使根CA暴露危害整个信任链。另一方面，如果中级CA受到威胁，则风险会小得多。</li></ul></li><li><strong>证书吊销列表</strong>：只是CA已知由于某种原因而吊销的证书引用列表。CRL就像一张被盗信用卡的清单。</li></ul><h3 id="MSP"><a href="#MSP" class="headerlink" title="MSP"></a>MSP</h3><p>Membership Service Provider</p><ul><li>负责联盟链成员的证书管理，<strong>它定义了哪些RCA以及ICA在链里是可信任的</strong>，包括<strong>定义了channel上的合作者。</strong></li><li>每个组织都有自己的证书管理（CA）及MSP，CA给每个peer颁发证书，MSP授权，赋予相应权限策略。</li><li>对于peer和client来说，对于交易的结果和交易本身，都需要进行授权</li><li>Peer ，applications，end users, administrators orders 必须拥有CA和MSP才能访问链网。</li></ul><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>Hyperledger Fabric 项目中，目前可以支持的状态数据库有两种：</p><ol><li><p>LevelDB：LevelDB 是嵌入在 Peer 中的默认键值对（key-value）状态数据库。</p></li><li><p>CouchDB：CouchDB 是一种可选的替代 levelDB 的状态数据库。与 LevelDB 键值存储一样，CouchDB 不仅可以根据 key 进行相应的查询，<strong>还可以根据不同的应用场景需求实现复杂查询。</strong></p></li></ol><h1 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h1><p>fabric的底层主要由四种服务构成，分别是：身份服务、策略服务、区块链服务、智能合约服务。在这些基础服务之上，通过一些API、SDK、CLI为上层业务应用提供一些可以编程的接口服务。 </p><p><img src="/2021/03/07/fabric/20180523213138295.png" alt="20180523213138295"></p><h2 id="身份服务"><a href="#身份服务" class="headerlink" title="身份服务"></a>身份服务</h2><p>首先明确一点，fabric和比特币与以太坊的最大的区别在于其身份识别能力，<strong>fabric是权限区块链</strong>，而后两者是匿名的非权限区块链。明确这一点后，fabric的身份识别主要表现在fabric的账本中的各类事件个交易中，参与者和对象都具有明确的身份信息。这些信息主要包括参与者的组织、验证者、交易者，账本中的资产和智能合约，以及系统组件包括网络和服务器、运行环境等等这些信息。验证者在fabric网络建立的时候就可以确定参加交易的权限级别。 </p><h2 id="策略服务"><a href="#策略服务" class="headerlink" title="策略服务"></a>策略服务</h2><p>策略是Fabric工作方式的基础，因为策略允许将与请求相关联的身份（或一组身份）与与满足请求所需的资源相关联的策略进行检查。</p><ul><li>背书策略用于确定交易是否已得到适当背书。</li><li>通道配置中定义的策略以及访问控制都称为修改策略，并且在通道配置本身中定义。</li></ul><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><ol><li><strong>Signature策略</strong></li></ol><p>表明需要得到那些特定用户的签名才能采用</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Policies:</span></span><br><span class="line">  <span class="attr">MyPolicy:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">Signature</span></span><br><span class="line">    <span class="attr">Rule:</span> <span class="string">&quot;OR(&#x27;Org1.peer&#x27;, &#x27;Org2.peer&#x27;)&quot;</span></span><br></pre></td></tr></table></figure><ul><li>一个名叫 <code>MyPolicy</code> 的策略。只能通过具有“ Org1的对等方”或“ Org2的对等方”角色的身份签名来满足所命名的策略</li><li>签名政策支持任意组合 <code>AND</code>，<code>OR</code> 以及 <code>NOutOf</code><ul><li>允许极其强大的规则建设：“组织A的管理员和其他两名管理员，或20组织的管理员11”。</li></ul></li></ul><ol start="2"><li><strong>ImplicitMeta策略</strong></li></ol><p><code>ImplicitMeta</code> 策略聚合配置层次结构中更深层次的策略结果，这些策略最终由<strong>签名策略</strong>定义。</p><ul><li><p>他们支持默认规则，比如“组织中大多数管理员”。</p></li><li><p>这些策略使用的语法和 <code>Signature</code> 策略不同但是依旧很简单： <code>&lt;ALL|ANY|MAJORITY&gt; &lt;sub_policy&gt;</code> 。比如： <code>ANY</code> <code>Readers</code> 或者 <code>MAJORITY</code> <code>Admins</code> 。</p><blockquote><p>注意<strong>默认策略</strong>配置中：</p><ul><li><code>Admins</code> 具有操作角色。指定仅管理员（或管理员的某些子集）有权访问资源的策略往往是针对网络的敏感或可操作方面（例如，实例化通道上的链码）。</li><li><code>Writers</code> 能够提交账本更新（例如交易），但没有管理权限。</li><li><code>Readers</code> 拥有被动角色。他们可以访问信息，但没有权利提交账本更新，也不能执行管理任务。</li><li>这些默认策略可以被<strong>添加</strong>，<strong>编辑</strong>或<strong>补充</strong>，例如通过新的 <code>peer</code> 和 <code>client</code> 角色（如果您有 <code>NodeOU</code> 支持）。</li></ul></blockquote></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Policies:</span></span><br><span class="line">  <span class="attr">AnotherPolicy:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">ImplicitMeta</span></span><br><span class="line">    <span class="attr">Rule:</span> <span class="string">&quot;MAJORITY Admins&quot;</span></span><br></pre></td></tr></table></figure><ul><li>名为 <code>AnotherPolicy</code> 的策略，表明可以通过 <code>MAJORITY Admins</code>（大多数管理员同意）的方式来满足</li><li>其中 <code>Admins</code> 是通过 <code>Signature</code> 策略来满足的。</li></ul><h3 id="背书策略"><a href="#背书策略" class="headerlink" title="背书策略"></a>背书策略</h3><h2 id="区块链服务"><a href="#区块链服务" class="headerlink" title="区块链服务"></a>区块链服务</h2><h2 id="智能合约服务"><a href="#智能合约服务" class="headerlink" title="智能合约服务"></a>智能合约服务</h2><h1 id="系统链码"><a href="#系统链码" class="headerlink" title="系统链码"></a>系统链码</h1><p>链码中定义的智能合约为一群区块链组织共同认可的业务流程编码了领域相关规则。然而，链码还可以定义低级别程序代码，这些代码符合无关于领域的<em>系统</em>交互，但与业务流程的智能合约无关。</p><p>以下是不同类型的系统链码及其相关缩写：</p><ul><li><strong>_lifecycle</strong>：在所有 Peer 节点上运行，它负责管理节点上的链码安装、批准组织的链码定义、将链码定义提交到通道上。<ul><li>你可以在<a class="link" href="https://hyperledger-fabric.readthedocs.io/zh_CN/release-1.4/chaincode4noah.html#chaincode-lifecycle">这里<i class="fas fa-external-link-alt"></i></a>阅读更多关于 <code>_lifecycle</code> 如何实现 Fabric 链码生命周期的内容。</li></ul></li><li><strong>生命周期系统链码（LSCC）</strong>：负责为1.x版本的 Fabric 管理链码生命周期。<ul><li>该版本的生命周期要求在通道上实例化或升级链码。你可以阅读更多关于LSCC如何实现这一<a class="link" href="https://hyperledger-fabric.readthedocs.io/zh_CN/release-1.4/chaincode4noah.html#chaincode-lifecycle">过程<i class="fas fa-external-link-alt"></i></a>。</li><li>如果你的 V1_4_x 或更低版本设有通道应用程序的功能，那么你也可以使用LSCC来管理链码。</li></ul></li><li><strong>配置系统链码（CSCC）</strong>：在所有 Peer 节点上运行，以处理通道配置的变化，比如策略更新。<ul><li>你可以在<a class="link" href="https://hyperledger-fabric.readthedocs.io/zh_CN/release-1.4/configtx.html#configuration-updates">这里<i class="fas fa-external-link-alt"></i></a>阅读更多 CSCC 实现的内容。</li></ul></li><li><strong>查询系统链码（QSCC）</strong>：在所有 Peer 节点上运行，以提供账本 API（应用程序编码接口），其中包括区块查询、交易查询等。<ul><li>你可以在交易场景<a class="link" href="https://hyperledger-fabric.readthedocs.io/zh_CN/release-1.4/developapps/transactioncontext.html">主题<i class="fas fa-external-link-alt"></i></a>中查阅更多这些账本 API 的信息。</li></ul></li><li><strong>背书系统链码（ESCC）</strong>：在背书节点上运行，对一个交易响应进行密码签名。<ul><li>你可以在<a class="link" href="https://hyperledger-fabric.readthedocs.io/zh_CN/release-1.4/peers/peers.html#phase-1-proposal">这里<i class="fas fa-external-link-alt"></i></a>阅读更多 ESCC 实现的内容。</li></ul></li><li><strong>验证系统链码（VSCC）</strong>验证一个交易，包括检查背书策略和读写集版本。<ul><li>你可以在<a class="link" href="https://hyperledger-fabric.readthedocs.io/zh_CN/release-1.4/peers/peers.html#phase-3-validation">这里<i class="fas fa-external-link-alt"></i></a>阅读更多 LSCC 实现的内容。</li></ul></li></ul><h1 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h1><ul><li><strong>smart contract</strong>：智能合约，定义业务对象的不同状态，并控制在这些不同状态之间移动对象的流程。<ul><li>智能合约之所以重要，是因为它们使架构师和智能合约开发人员能够定义关键业务流程和数据，这些关键业务流程和数据是在区块链网络中进行协作的不同组织之间共享的。</li></ul></li></ul><ul><li><strong>chaincode：</strong> 链码，Fabric的<strong>智能合约</strong>写在链码里并在区块链外部应用程序要和账本发生交易的时候被外部应用程序调用。<ul><li>在大多数情况下，链码只和账本的数据库组件（<strong>世界状态</strong>）交互，而不和交易日志交互。</li></ul></li></ul><blockquote><p><strong>链码与智能合约的区别：</strong></p><ul><li><strong>链码</strong> - chaincode：是一种用于部署代码到 Hyperledger Fabric 区块链网络中的<strong>通用容器</strong>。链码中定义一个或多个相关联的智能合约。每个智能合约在链码中有一个唯一的标识名。应用程序通过合约名称去访问链码容器内的指定的智能合约<ul><li>通常在构造类时分配名称，如果没有明确指明合约名，则会分配一个默认的名字–类名。建议使用<strong>显式的 DNS 样式</strong>命名方法，对组织清晰、有意义的名称有帮助；</li><li>例如：peer0.org1.example.com</li></ul></li><li><strong>智能合约</strong> - contract：是一种<strong>高级编程抽象</strong>的例子，可以在链码容器中定义智能合约。当一个链码被安装和实例化时，则链码内所有的智能合约对于相关联的通道（Channel）来说都是可用的</li></ul></blockquote><ul><li><strong>账本</strong>：Fabric有一个账本子系统包含两个组件：<strong>世界状态和交易日志</strong>。每一个参与者有一份他们参与的每个Fabric网络的账本的副本。<ul><li>世界状态组件描述了一个给定时间点的账本状态。它是账本的数据库，存储的是<strong>账本当前值</strong>。</li><li>交易日志组件记录所有导致世界状态当前值的交易。<strong>它是世界状态的更新历史</strong>。这样，账本就是世界状态数据库和交易日志历史的组合体。</li></ul></li></ul><h1 id="共识机制"><a href="#共识机制" class="headerlink" title="共识机制"></a>共识机制</h1><p>Fabric区块链的网络节点本质上是<strong>互相复制的状态机</strong>，节点之间需要保持相同的账本状态。为了实现分布式节点的一致性，各个节点需要<strong>通过共识过程，对账本状态的变化达成一致性的认同。</strong></p><p><strong>共识过程</strong></p><img src="/2021/03/07/fabric/15873283-02a9f2f1bb4d0bfd.png" alt="15873283-02a9f2f1bb4d0bfd" style="zoom:55%;"><ol><li><strong>背书（endorsement）阶段</strong><ul><li><strong>背书节点</strong>对客户端发来的交易提案进行<strong>合法性校验</strong>，然后模拟执行链码得到交易结果，最后根据设定的背书逻辑判断是否支持该交易提案。如果背书逻辑决定支持交易提案，会把交易提案签名后发回给客户端。</li><li>客户端通常需要根据链码的<strong>背书策略</strong>，向一个或者多个成员的背书节点发出背书请求。背书策略会定义需要哪些节点背书交易才有效，例如需要5个成员的背书节点中至少3个同意；或者某个特殊身份的成员支持等。</li><li>客户端只有在收集<strong>足够多</strong>的背书节点的交易提案签名，交易才能被视为有效。</li></ul></li><li><strong>排序（ordering）阶段</strong><ul><li>由<strong>排序服务节点对</strong>交易进行排序，确定交易之间的时序关系。排序服务把一段时间内收到的交易进行排序，然后把排序后的批量交易<strong>打包成数据块</strong>（区块），再把区块<strong>广播</strong>给通道中的成员。</li><li>采用<strong>排序共识</strong>方式，各个成员收到的是一组发生顺序相同的交易，从而保证了所有节点的<strong>数据一致性。</strong>目前，Hyperledger Fabric有三种交易排序算法：Solo、Kafka、SBFT。<ol><li><strong>Solo</strong>：只有一个排序服务节点负责接收交易信息并排序，是最简单的一种排序算法，一般用于开发测试环境中。Solo共识模式属于<strong>中心化的处理</strong>方式，<strong>不支持</strong>拜占庭容错。</li><li><strong>Kafka</strong>：Kafka是Apache的一个开源项目，主要提供分布式的消息处理／分发服务，每个Kafka集群由多个服务节点组成。Hyperledger Fabric利用Kafka对交易信息进行排序处理，提供高吞吐、低延时的处理能力，并且在集群内部<strong>支持节点故障容错，但不支持拜占庭容错。</strong></li><li><strong>SBFT</strong>：简单拜占庭算法，<strong>支持拜占庭容错的可靠排序算法，包括容忍节点故障以及一定数量的恶意节点。</strong></li><li>排序服务是共识机制中重要的一环，所有交易都要通过排序服务的排序才可以达成全网共识，因此排序服务要避免成为网络上的性能瓶颈。</li></ol></li></ul></li><li><strong>校验（Validation）阶段</strong><ul><li>节点对排序后的交易进行一系列的检验，包括<strong>交易数据的完整性</strong>检查、是否<strong>重复交易</strong>、背书签名<strong>是否符合背书策略</strong>的要求、交易的<strong>读写集是否符合MVCC</strong>（Multiversion Concurrency Control，多版本并发控制）的校验等。</li><li>当交易通过了所有校验后，将被标注为合法并写入账本中。因为所有的确认节点都按照相同的顺序检验交易，并且把合法的交易依次写入账本中，因此不同确认节点的状态能够始终保持一致。</li></ul></li></ol><h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><p>Kafka共识模块是可以用于生产环境的，它可以支持崩溃容错， 但无法对抗恶意攻击。</p><ul><li>多个排序节点通过Kafka实现<strong>同步</strong>， 而Kafka本身并不是排序节点，它只是将排序节点通过流连接起来</li></ul><p>Kafka本质上是一个消息处理系统，它使用的是经典的<strong>发布-订阅模型</strong>。消息的消费者订阅特定的主题，以便收到新消息的通知，生产者则负责消息的发布。</p><p>在fabric中的<strong>运行逻辑</strong>：</p><ul><li>对于每一条链，都有一个对应的分区</li><li>每个链对应一个单一的分区主题</li><li>排序节点负责将来自特定链的交易（通过广播RPC接收）中继到对应的分区</li><li>排序节点可以读取分区并获得在所有排序节点间达成一致的排序交易列表</li><li>一个链中的交易是定时分批处理的，也就是说当一个新的批次的第一个交易进来时，开始计时</li><li>当交易达到最大数量时或超时后进行批次切分，生成新的区块</li><li>定时交易是另一个交易，由上面描述的定时器生成</li><li>每个排序节点为每个链维护一个本地日志，生成的区块保存在本地账本中</li><li>交易区块通过分发RPC返回客户端</li><li>当发生崩溃时，可以利用不同的排序节点分发区块，因为所有的排序节点都维护有本地日志</li></ul><h3 id="崩溃容错"><a href="#崩溃容错" class="headerlink" title="崩溃容错"></a>崩溃容错</h3><p><strong>崩溃容错机制</strong>：通过在多个Kafka代理之间<strong>复制分区</strong>来实现的。因此如果一个代理由于软件或硬件故障挂掉，数据也不会丢失。</p><p><strong>领导-跟随机制</strong>：领导者持有分区， 跟随者则进行分区的复制。当领导者挂掉后，会有某个跟随者转变为新的领导者。</p><p><strong>注意</strong>：虽然在Hyperledger Fabric中Kafka被称为共识（Consensus），但是其核心是交易排序服务以及额外的崩溃容错能力。</p><h3 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h3><p>zookeeper是一个分布式key-value存储库，通常用于存储元数据及集群机制的实现。</p><p>zookeeper 允许服务（Kafka代理）的客户端订阅变化并获得实时通知。这就是代理如何确定应当使用哪个分区领导者的原因。</p><p>zookeeper有超强的故障容错能力，因此Kafka的运行严重依赖于它。</p><p>在zookeeper中存储的元数据包括：</p><ul><li>消费者分组在每个分区的读取偏移量</li><li>访问控制清单，用于访问授权与限制</li><li>生产者及消费者配额，每秒最多消息数量</li><li>分区领导者及健康信息</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;由IBM贡献的超级账本框架。它是一个利用现有成熟的技术来组合而成的一个区块链技术的实现。它是一种允许可插拔实现各种功能的的模块化</summary>
      
    
    
    
    <category term="notebook" scheme="https://jieyang-wei.github.io/categories/notebook/"/>
    
    <category term="blockchain" scheme="https://jieyang-wei.github.io/categories/notebook/blockchain/"/>
    
    <category term="fabric" scheme="https://jieyang-wei.github.io/categories/notebook/blockchain/fabric/"/>
    
    
    <category term="fabric" scheme="https://jieyang-wei.github.io/tags/fabric/"/>
    
    <category term="blockchain" scheme="https://jieyang-wei.github.io/tags/blockchain/"/>
    
  </entry>
  
  <entry>
    <title>区块链应用</title>
    <link href="https://jieyang-wei.github.io/2021/03/04/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8/"/>
    <id>https://jieyang-wei.github.io/2021/03/04/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8/</id>
    <published>2021-03-04T06:48:09.000Z</published>
    <updated>2021-03-10T04:29:42.820Z</updated>
    
    <content type="html"><![CDATA[<h1 id="crypto-currency，加密货币"><a href="#crypto-currency，加密货币" class="headerlink" title="crypto-currency，加密货币"></a>crypto-currency，加密货币</h1><ul><li><p>区块链是一种数据结构，而比特币和以太坊都是使用区块链这种数据结构实现的应用</p></li><li><p><a class="link" href="https://bitcoin.org/bitcoin.pdf">比特币白皮书<i class="fas fa-external-link-alt"></i></a></p></li><li><p><a class="link" href="https://www.cnblogs.com/coderzjz/p/13788649.html">别人好的笔记<i class="fas fa-external-link-alt"></i></a></p></li></ul><h1 id="比特币-BTC"><a href="#比特币-BTC" class="headerlink" title="比特币 BTC"></a>比特币 BTC</h1><p><strong>前提：</strong>大部分算力掌握在诚实的矿工手里</p><h2 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h2><h3 id="1-crypto-graphic-hash-function"><a href="#1-crypto-graphic-hash-function" class="headerlink" title="1. crypto graphic hash function"></a>1. crypto graphic hash function</h3><p>特性：</p><ol><li><p>collision resistance：抗碰撞性</p></li><li><p>hiding：x可以算出H(x)，但H(x)不能反推出x，即这个hash函数不会泄露x</p><ul><li><p>需要满足，不然可以通过蛮力求解</p><ol><li><p>输入空间大</p></li><li><p>均匀分布</p></li></ol></li><li><p>digital commitment / digital equivalent of a sealed envelope：密封预测结果</p></li></ul></li><li><p>puzzle friendly：H(x)是事先不可预测的</p></li></ol><p>H(block header) &lt;= target 目标域值（nBits：目标域值编码）</p><p>proof of work POW，工作证明</p><p>difficult to solve, but easy to verify</p><h3 id="2-签名"><a href="#2-签名" class="headerlink" title="2. 签名"></a><strong>2. 签名</strong></h3><p>账户 - public key, private key</p><ul><li>来源于非对称加密：asymmetric encryption algorithm</li><li>最早期是对称加密，symmetric encryption algorithm，但这样密钥分发是一个问题，所以有了公私钥</li></ul><p>a good source of randomness：使得生成的公钥相同的几率微乎其微</p><p><strong>SHA-256</strong>（Secure Hash Algorithm）</p><ul><li><a class="link" href="https://blog.csdn.net/u011583927/article/details/80905740">原理简介<i class="fas fa-external-link-alt"></i></a></li><li>和md5加密的效果一样，但是SHA-256更加的安全</li><li>都只能算是签名，加密算法是既能加密也能解密的算法，而签名就仅仅是起到校验和的作用</li></ul><hr><p>Mac, Linux hash命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> md5 file.txt    <span class="comment"># md5校验和</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> shasum -a 1 /tmp/hello.txt      <span class="comment"># SHA-1校验和</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> shasum -a 256 /tmp/hello.txt    <span class="comment"># SHA-256校验和</span></span></span><br><span class="line"><span class="meta"> #</span><span class="bash"> -a --algorithm</span></span><br></pre></td></tr></table></figure><img src="/2021/03/04/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8/截屏2020-12-27 上午10.44.14.png" alt="截屏2020-12-27 上午10.44.png" style="zoom:60%;"> <hr><h2 id="BTC-数据结构"><a href="#BTC-数据结构" class="headerlink" title="BTC 数据结构"></a>BTC 数据结构</h2><blockquote><p>区块链仅仅是一个<strong>数据结构</strong>，BTC是使用区块链这种数据结构实现的应用</p></blockquote><h3 id="hash-point"><a href="#hash-point" class="headerlink" title="hash point"></a>hash point</h3><ul><li>无环链表都可以用 hash point 代替普通的point</li></ul><ol><li>区块链</li></ol><p><img src="/2021/03/04/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8/IMG_0230-7744726.jpg" alt="IMG_0230"></p><ul><li><p>block chain is a linked list using hash pointers：用hash point 代替普通的指针</p><ul><li><p>genesis block：创世区块            most recent blcok：最近产生的区块      </p><p>H( )：hash point</p></li><li><p>tamper-evident log：最后一个hash值就能检查整个链表是否被修改过</p></li></ul></li></ul><blockquote><p>Merkle tree 不是区块链的信息存储结构，而是BTC使用过程中用到的数据结构，在节点验证交易正确性时，使用到的一个结构而已</p></blockquote><ol start="2"><li>Merkle tree<ul><li>与binary tree的区别<ol><li>用hash point代替普通的指针</li><li>只要记录<code>root hash</code>，就能检测对整棵树的修改</li></ol></li><li>block header：只保存<code>root hash</code>，</li><li>block body：保存所有的交易信息<code>tx</code>等</li><li>作用：<ul><li>提供<code>merkle proof</code></li></ul></li></ul></li></ol><blockquote><p><img src="/2021/03/04/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8/IMG_231E499E57D8-1.jpeg" alt="IMG_231E499E57D8-1"></p><ul><li><strong>proof of membership</strong>：轻节点想知道黄色交易是否在<code>merkle tree</code>上，只有一个<code>root hash</code>(在<code>block header</code>里面)</li></ul><ol><li>轻节点向某个全节点发出证明请求，请求一个能证明黄色交易包括在<code>merkle tree</code>里面的一个<code>merkle proof</code></li><li>全节点收到请求，会将图中红色的三个<code>hash值</code>发送给这个轻节点</li><li><strong>从下往上</strong>：轻节点会算出黄色交易的hash值绿1，绿1和红1一起算出hash值绿2，绿2和红2算出绿3，绿3和红3一起算出<code>root hash</code></li><li>轻节点比较这个算出来的<code>root hash</code>和<code>block header</code>的hash值</li></ol><blockquote><p><strong>注意</strong>：我们只能验证绿色的部分，不能验证红色部分的hash值</p></blockquote><blockquote><ul><li>如果考虑通过调整红色的部分，使得被篡改后的绿色的部分算出来hash不变，是不实际的</li><li>因为<code>Collision resistance</code>性质，这样的操作相当于人为的制造hash碰撞</li></ul></blockquote><ul><li><strong>proof of non-memership</strong>：轻节点想证明某个交易不存在</li></ul><ol><li></li></ol></blockquote><h2 id="数字货币"><a href="#数字货币" class="headerlink" title="数字货币"></a>数字货币</h2><ul><li>使用公私钥，非对成加密算法<ol><li>Double spending attack，双花攻击 - 花两次攻击：数字货币本质上是一个文件，带签名的数字货币可以复制</li></ol></li><li>每个数字货币上带编号（防范DSA，但是是中心化的）<ul><li>bank维护一个数据库，每个编号的数字货币在谁手里</li><li>每次验证数字货币的签名和编号，这个货币有没有发过，被谁花过</li></ul></li></ul><p><strong>BTC安全性</strong></p><ol><li><strong>密码学</strong>：别人没有私钥，不能伪造签名<ul><li>前提：系统中拥有大多数算力的矿工是好的，是遵守协议的，不会接受没有合法签名的交易</li></ul></li><li><strong>共识机制</strong>：</li></ol><h3 id="BTC解决去中心化的数字货币发行问题"><a href="#BTC解决去中心化的数字货币发行问题" class="headerlink" title="BTC解决去中心化的数字货币发行问题"></a>BTC解决去中心化的数字货币发行问题</h3><ul><li><img src="/2021/03/04/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8/IMG_9CCCEC7F3445-1.jpeg" alt="IMG_9CCCEC7F3445-1"><ul><li>交易中A的公钥表明是钱是哪儿来的，但是要将A和他的公钥联系在一起，不然E可以用自己的公钥冒充A的，再用自己的私钥签名<ul><li><strong>coinbase tx</strong>：需要验证A-&gt;B的钱的前一个交易（金币来源）中A的公钥，即金币来源的输出脚本，和交易中提供的A的公钥，即交易的输入脚本拼在一起合成一个程序，看能不能顺利执行</li></ul></li></ul></li></ul><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><h5 id="区块结构"><a href="#区块结构" class="headerlink" title="区块结构"></a>区块结构</h5><img src="/2021/03/04/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8/IMG_9EF94BC347FE-1.jpeg" alt="IMG_9EF94BC347FE-1" style="zoom:70%;"> <ul><li><strong>Block Header</strong><ul><li>区块信息：<ul><li>version：比特币版本</li><li>时间戳等</li></ul></li><li>hash of previous block header：指向前一个区块的指针（只算header的hash）<ul><li>创世区块的<code>previous hash</code>为0</li></ul></li><li>merkle root hash：整棵merkle tree的根hash值<ul><li>保证了<code>transaction list</code>是无法被篡改的</li></ul></li><li>nonce：随机数，256bits<ul><li>target：挖矿难度目标域值</li></ul></li></ul></li><li><strong>Block Body</strong><ul><li>transaction list</li><li>只存交易信息</li></ul></li></ul><h5 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h5><ul><li>full node（fully validating node，全节点）：</li><li>light node（light weight node，轻节点）：<ul><li>一般无法验证交易的合法性，只是利用区块链的信息做一个查询</li></ul></li></ul><h4 id="Consensus-in-BitCoin，比特币共识"><a href="#Consensus-in-BitCoin，比特币共识" class="headerlink" title="Consensus in BitCoin，比特币共识"></a>Consensus in BitCoin，比特币共识</h4><p>distributed consensus，分布式共识</p><ul><li>impossibility result：<ul><li>FLP：在一个异步的系统里（asynchronous），网络时延没有上线，哪怕系统中只要有一个用户是faulty的，都没有办法达成共识</li><li>CAP Theorem：以下三个性质中，最多满足两种<ul><li>一致性Consistency、可用性Availability、分区容错性Partition tolerance</li></ul></li></ul></li></ul><p>membership</p><p>hyperledger</p><p>联盟链 - fabric</p><p>sybil attacl，女巫攻击：找一个超级计算机，不停的产生用户节点，当总数超过一半时，就得到了这个链的控制权</p><ul><li>coinbase transaction：<ul><li>coinbase域：可以在里面写东西，永久保存，但只有获得记账权的节点才能使用</li><li>通过算例投票 puzzle friendly</li><li>hash rate</li><li>nonce</li></ul></li></ul><p>mining - 挖矿：比特币争夺记账权</p><ul><li>digital gold</li><li>miner</li></ul><h4 id="BTC系统实现"><a href="#BTC系统实现" class="headerlink" title="BTC系统实现"></a>BTC系统实现</h4><h5 id="transaction-based-ledger，基于交易的账本模式"><a href="#transaction-based-ledger，基于交易的账本模式" class="headerlink" title="transaction-based ledger，基于交易的账本模式"></a>transaction-based ledger，基于交易的账本模式</h5><ul><li>每个交易需要说清楚，币是从哪儿来的，它没有账户的概念</li></ul><p>全节点维护一个数据结构：</p><ul><li><p>UTXO，unspent Transaction Output：还没有被花掉的交易的输出集合</p><img src="/2021/03/04/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8/IMG_1019233284AC-1 .jpeg" alt="IMG_1019233284AC-1" style="zoom:50%;"><ul><li><strong>包括</strong> 2个数据就能定位UTXO的输出：<ol><li>产生这个输出的交易的hash 值</li><li>这个输出是交易中的第几个输出</li></ol></li><li><strong>作用</strong>：检测Double Spending<ul><li>total inputs = total outputs：i可以略大于o，中间的<code>transaction fee</code>可能给了拥有记账权的区块</li><li>transaction fee：大约只有零点零几个币</li></ul></li></ul></li></ul><p>account-based ledger，基于账户的模式</p><ul><li>系统需要显示的记录每个账户有多少个币，如以太坊ß</li></ul><h5 id="Bernoulli-trial"><a href="#Bernoulli-trial" class="headerlink" title="Bernoulli trial"></a>Bernoulli trial</h5><ul><li><p>a random experiment with binary outcome</p></li><li><p>每次求解nonce可以看作是Bernoulli trial</p></li></ul><p><strong>Bernoulli process</strong>：a sequence of independent Bernoulli</p><ul><li>大量实践的Bernoulli trial就组成了</li><li>性质：<ul><li>memoryless，无记忆的：实验结果和之前的实验结果是没有关系的</li></ul></li></ul><p>Poisson process：</p><p>exponential distribution，出块时间：服从指数分布</p><img src="/2021/03/04/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8/IMG_9A528FE35443-1.jpeg" alt="IMG_9A528FE35443-1" style="zoom:40%;"><ul><li>无记忆性：<ul><li>memory less：将来挖多少时间与之前已经挖了多少时间没有关系，即使等了10mins，下一挖到矿的时间仍然指数分布，平均是10mins</li><li>process free：过去的process是没用的，对挖矿公平性的保证</li></ul></li></ul><p>出块奖励</p><p>geometric series 几何级数</p><ul><li>BTC总数：21万 * 50 + 21万 * 25 + 21万 * 12.5 + ····<ul><li>= 21万 * 50 *（1 + 1/2 + 1/4 + ····）[等比求和，逐年减半]</li><li>= 2100万 [过去到未来的BTC总数]</li></ul></li></ul><p>Bitcoin is secured by mining</p><p>分岔攻击</p><p>回滚交易 - Double Spending Attack</p><ul><li>多等几个区块/确认 confirmation</li></ul><p>irrevocable ledger，不可篡改的账本</p><ul><li>不可篡改是该旅行的保证</li></ul><p>zero confirmation</p><ul><li>交易刚发出去，没有写进区块</li></ul><p>selfish mining</p><ul><li>我先不发布，等到挖到足够多的区块了，再一起发布，盖过其他的 - 分岔攻击</li><li>自己挖到两个的时候，不发布，等别人挖到一个，再一起发布，别人的那个就白发了</li><li>风险：<ul><li>不一定抢的赢别人</li></ul></li></ul><h4 id="BTC网络"><a href="#BTC网络" class="headerlink" title="BTC网络"></a>BTC网络</h4><p>BTC所有节点平等，没有super/master node</p><p>协议：</p><ul><li>application layer：BitCoin Block chain</li><li>network layer：P2P Overlay Network</li></ul><p>设计原则：simple简单，robot鲁棒，but not efficient不是高效</p><ul><li><p>消息节点：flooding方式</p></li><li><p>邻居节点：选取是随机的，不考虑底层的拓扑结构</p><ul><li>增强了鲁棒性，但是牺牲了效率</li></ul></li><li><p>每个节点维护一个等待上链的消息集合</p><ul><li>冲突交易</li></ul></li></ul><p>best effort，</p><blockquote><p>区块链是一种数据结构，而节点是在基于网络应用时，每一个连入区块的设备，比如手机就是轻节点，而矿池(后面有讲)就是一个全节点，保存所有的信息 - 现在BTC大约有100多G</p></blockquote><p><strong>全节点</strong>：保存所有的信息</p><ul><li>一直在线</li><li>在本地硬盘上维护完整的区块链信息</li><li>在内存里维护UTXO集合，以便快速检验交易的正确性</li><li>监听比特币网络上的交易信息，验证每个交易的合法性</li><li>决定哪些交易会被打包到区块里</li><li>监听别的矿工挖出来的区块，验证其合法性</li><li>挖矿：<ul><li>决定沿着那条链挖下去<ul><li>缺省情况下选择最长的链</li></ul></li><li>当出现等长的分岔的时候，选择哪一个分岔<ul><li>缺省情况下选择第一个发现的</li></ul></li></ul></li></ul><p><strong>轻节点</strong>：只保存block header（如手机上）</p><ul><li>不是一直在线</li><li>不用保存整个区块链，只要保存每个区块的块头</li><li>不用保存全部交易，只保存与自己相关的交易</li><li>无法检测大多数交易的合法性，只能检验与自己相关的那些交易的合法性</li><li>无法检测网上发布的区块的正确性<ul><li>因为无法知道区块里的交易是不是合法的</li></ul></li><li>可以验证挖矿的难度<ul><li>挖矿时计算hash值只需要用到块头的信息</li></ul></li><li>只能检测那个是最长的链，不知道哪个是最长的合法链<ul><li>只能知道这个链上的区块挖矿难度时符合要求的，但是无法验证每个区块里交易的合法性</li></ul></li></ul><h2 id="挖矿"><a href="#挖矿" class="headerlink" title="挖矿"></a>挖矿</h2><p>H(block header) &lt;= target</p><ul><li>target越小，难度越大</li><li>需要调整target值，使得出块时间保持稳定（BTC大约为10mins）</li></ul><p>hash算法：SHA-256</p><ul><li>取值空间：2^256</li><li>block header里面存nBits，只有4字节<ul><li>target有256位，32字节</li></ul></li></ul><h3 id="挖矿难度"><a href="#挖矿难度" class="headerlink" title="挖矿难度"></a>挖矿难度</h3><img src="/2021/03/04/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8/IMG_3A7CCA25FE75-1.jpeg" alt="IMG_3A7CCA25FE75-1" style="zoom:50%;"><ul><li>difficulty_1_target：挖矿难度等于1时的目标域值</li><li>1是最低难度</li><li>不调整target的话，出块时间会越来越短<ul><li>分岔，几个用户同时出块</li><li>系统不容易统一</li><li>51% attack：将大部分算力用来放在攻击的回滚区块的链上</li></ul></li></ul><p>orphan block</p><p>uncle reward</p><h3 id="难度调整"><a href="#难度调整" class="headerlink" title="难度调整"></a>难度调整</h3><p>每2016个区块调整目标域值，大约为2周（2016 * 10 / 60 * 24 = 14）</p><ul><li>调整公式：<img src="/2021/03/04/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8/IMG_E4D6502FBD91-1.jpeg" alt="IMG_E4D6502FBD91-1" style="zoom:40%;"><ul><li>如果实际时间超过了2周，那么平均出块时间超过了10mins，这个时候出块难度需要调整的低一点（右边分式大于1，target变大）</li></ul></li><li><img src="/2021/03/04/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8/IMG_D3AE8A16D3B4-1.jpeg" alt="IMG_D3AE8A16D3B4-1" style="zoom:70%;"></li></ul><h3 id="设备"><a href="#设备" class="headerlink" title="设备"></a>设备</h3><p><strong>早期1代 - CPU</strong>：</p><ul><li>随着挖矿难度增加，性价比极低</li><li>计算机中大部分内存都是闲置的，挖矿只用到了其中很少一部分内存</li><li>大部分不见也是闲置的，挖矿中hash值的计算只用到了通用计算机cpu中很少一部分指令</li><li>硬盘和其他资源也是闲置的</li></ul><blockquote><p> GPU主要用于大规模的并行计算，如深度学习</p></blockquote><p><strong>2代 - GPU</strong>：</p><ul><li>效率得到了很大的提高</li><li>但gpu主要是为了并行计算设计的，其中仍然有很多部件是闲置的，所以也不划算<ul><li>如用于浮点数运算的部件</li></ul></li><li>对于现在的挖矿的难度，GPU的算力已经不够了</li></ul><blockquote><p>ASIC：Application Specific Integrated  Circuit</p></blockquote><p><strong>现在 - ASIC芯片</strong></p><ul><li>专门为了BTC挖矿<strong>计算hash值</strong>所设计的，生产周期长（不能做全节点其他工作）</li><li>为某种加密货币设计的芯片，只能挖着一种货币（除非两种货币用同一个mining puzzle）<ul><li>merge mining：一个新的货币发行时，为了解决冷启动问题，吸引更多的用户，故意用一个已有的mining puzzle</li></ul></li><li><strong>Alternative mining puzzle</strong><ul><li>有的货币会设计这种puzzle，达到下面的效果</li><li>ASIC resistance：抗ASIC芯片化，为了让通用CPU也能参与挖矿</li></ul></li></ul><h3 id="矿池"><a href="#矿池" class="headerlink" title="矿池"></a>矿池</h3><ul><li>一个全节点去驱动很多的矿机（一个矿工负责全部的工作比较累）</li></ul><img src="/2021/03/04/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8/IMG_FFBC17D6F168-1.jpeg" alt="IMG_FFBC17D6F168-1" style="zoom:60%;"><ul><li><p>矿主：其他全节点的指责</p><ul><li>监听网上的交易，将这些交易组织打包成候选区块</li><li>同时关注是否有其他节点抢先发布了区块，如果有就需要作出调整等</li></ul></li><li><p>矿工：只负责计算hash值</p></li><li><p><strong>好处</strong>：</p><ul><li><p>减轻了矿工的工作量</p></li><li><p>解决单个矿工收入不稳定问题，以下两种方式</p><ol><li>像大型数据中心一样，矿池下有成千上万的矿机，属于一个机构，好分配</li><li>分布式，矿机来自不用的厂商，需要通过通讯协议与矿主联系，之后一起分红</li></ol><blockquote><p>如何解决矿工分红问题 - 工作量证明：</p><ul><li>降低挖矿难度，矿工提交 - share，almost valid block - 只能用来证明做了多少工作</li></ul></blockquote></li></ul></li><li><p>大型矿池的<strong>弊病</strong>：使得51%的攻击更加容易了</p><ul><li><strong>分叉攻击</strong>：对已经经过6次确认的交易分叉，利用51%算力将交易记录回滚。<ul><li>矿工只能计算哈希值，并不知道区块包含哪些交易，区块链状况是什么。所以，这些“群众”是无知的，容易被利用（《乌合之众》当中提出的观点，大多数人真的就能掌握真理吗？）。</li><li>此外，51%攻击只是一个概率问题，并非达到51%算力就能发动攻击，不能达到就无法发动攻击。此外，矿池本身算力也是在不断变化的。</li></ul></li><li><strong>封锁交易（Boycott）</strong>：<ul><li>假如攻击者不喜欢某个账户A，不想让A的交易上区块链，在监听到有其他人将A的交易发布到区块链上时，立刻发动分叉攻击，使A所在链无法成为”最长合法链“。这样，便实现了对A账户的封锁。</li><li>像不像即当裁判又当运动员？”堂下何人状告本官“？</li></ul></li><li><strong>盗币</strong>（将他人账户BTC转走）<ul><li>这个是<strong>不可能</strong>的，因为其并没有他人账户私钥。如果依仗算力强，强行将没有签名的转账发布到区块链，正常节点不会认为其合法，这样，即使这条链再长，其他人也不会认为其是最长合法链。</li></ul></li><li>on demand computing  -&gt;  on demand mining（潜在危害）</li></ul></li></ul><h2 id="BTC-使用的脚本语言"><a href="#BTC-使用的脚本语言" class="headerlink" title="BTC 使用的脚本语言"></a>BTC 使用的脚本语言</h2><ul><li>基于栈的编程语言：很简单，只有一个堆栈</li></ul><h3 id="交易结构"><a href="#交易结构" class="headerlink" title="交易结构"></a>交易结构</h3><img src="/2021/03/04/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8/IMG_0280.jpg" alt="IMG_0280" style="zoom:35%;"> <p><strong>交易的输入</strong></p><img src="/2021/03/04/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8/IMG_0281-9908278.jpg" alt="IMG_0281" style="zoom:38%;"> <p><strong>交易的输出</strong></p><img src="/2021/03/04/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8/IMG_0282.jpg" alt="IMG_0282" style="zoom:55%;"> <h3 id="交易验证"><a href="#交易验证" class="headerlink" title="交易验证"></a>交易验证</h3><img src="/2021/03/04/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8/IMG_0262.jpg" alt="IMG_0262" style="zoom:36%;"> <ul><li>早期是将输入输出脚本拼接到一起执行</li><li>后面处于安全考虑，输入输出两者分别执行，都为非0(True)则成功</li></ul><h4 id="脚本形式"><a href="#脚本形式" class="headerlink" title="脚本形式"></a>脚本形式</h4><blockquote><p>注：下面的脚本中，省略了<code>OP_</code>前缀</p><ul><li>如CHECKSIG -&gt; OP_CHECKSIG；DUP -&gt; OP_DUP；</li></ul></blockquote><ol><li><p><strong>P2PK ，Pay to Public Key</strong></p><ul><li>input script<ol><li><strong>PUSHDATA(SIG)**：将输入里提供的</strong><code>签名</code>**压入栈</li></ol></li><li>output script<ol start="2"><li><strong>PUSHDATA(PubKey)**：将输出里提供的</strong><code>公钥</code>**压入栈</li><li><strong>CHECKSIG</strong>：将栈顶的两个元素弹出来，用公钥检查签名是否正确<ul><li>正确则返回True，验证通过，否则执行出错，交易是非法的</li></ul></li></ol></li></ul></li><li><p><strong>P2PKH，Pay to Public Key Hash</strong></p><ul><li>input script<ol><li><strong>PUSHDATA(SIG)**：将输入里提供的</strong><code>签名</code>**压入栈</li><li><strong>PUSHDATA(PubKey)**：将</strong><code>公钥</code>**压入栈</li></ol></li><li>output script<ol start="3"><li><strong>DUP</strong>：将栈顶的元素复制一遍<ul><li>栈顶多了一个**<code>公钥</code>**</li></ul></li><li><strong>HASH160</strong>：将栈顶元素弹出，取hash，再将此hash值压入栈<ul><li>此时栈顶是**<code>公钥的hash-1</code>**</li></ul></li><li><strong>PUSHDATA(PubKeyHash)**：将输出中提供的</strong><code>公钥的hash-2</code>**值压入栈<ul><li>此时栈顶有两个公钥的hash</li></ul></li><li><strong>EQUALVERIFY</strong>：弹出栈顶的两个元素，比较是否相等<ul><li>防止有人冒名顶替，用自己的公钥冒充收款人的公钥</li><li>相等的话栈顶的两个**<code>PubKeyHash</code>**就消失了</li></ul></li><li><strong>CHECKSIG</strong>：将栈顶的两个元素弹出来，用公钥检查签名是否正确<ul><li>正确则返回True，验证通过，否则执行出错，交易是非法的</li></ul></li></ol></li></ul><blockquote><p>区别：第二种没有在输出中直接给出收款人的公钥，而是给出公钥的hash。公钥则是在输入脚本中给出的，其他的操作都是为了验证正确性。</p><p>第二种更常用</p></blockquote></li><li><p><strong>P2SH，Pay to Script Hash</strong></p><blockquote><p><strong>采用BIP16的方案</strong></p><p>输出脚本不提供收款人公钥的hash，而是收款人提供的脚本的hash</p><ul><li>redeemScript：赎回脚本</li><li>常见应用场景：对多重签名的支持-防止私钥的泄露</li></ul></blockquote><p><strong>验证分两步：</strong></p><ul><li>input script要给出一些签名（数目不定）及一段序列化的redeemScript<ol><li>验证序列化的<strong>redeemScript</strong>是否与<strong>output script</strong>中的hash值匹配</li><li>将输入脚本中给出的序列化的<strong>redeemScript</strong>反序列化并执行<strong>redeemScript</strong>，验证<strong>input script</strong>中给出的签名是否正确</li></ol></li></ul><blockquote><p>此处脚本中redeemScript内容采用<strong>P2PK形式</strong></p></blockquote><ul><li><p><strong>第一阶段</strong></p><ul><li><p>input script</p><ol><li><p><strong>PUSHDATA(Sig)**：将输入的</strong><code>签名</code>**压入栈</p></li><li><p><strong>PUSHDATA(serialized redeemScript)**：将赎回脚本</strong><code>seriRS</code>**压入栈</p></li></ol></li><li><p>output script</p><ol start="3"><li><strong>HASH160</strong>：将栈顶元素**<code>seriRS</code>**弹出，取hash，再将此hash值压入栈<ul><li>此时栈顶为**<code>RSH-1</code>**</li></ul></li><li><strong>PUSHDATA(redeemScriptHash)**：将输出脚本中给出的hash值</strong><code>RSH-2</code>**压入栈<ul><li>栈顶为两个<strong>RSH</strong></li></ul></li><li><strong>EQUAL</strong>：比较栈顶的两个RSH是否相等<ul><li>相等的话栈顶的两个**<code>RSH</code><strong>就消失了，栈中只剩一个</strong><code>Sig</code>**</li></ul></li></ol></li></ul></li><li><p><strong>第二阶段</strong></p><ul><li>执行反序列化之后的redeemScript<ol><li><strong>PUSHDATA(PubKey)**：将</strong><code>公钥</code>**压入栈</li><li><strong>CHECKSIG</strong>：检查输入给出的**<code>签名</code>**的正确性</li></ol></li></ul></li></ul></li></ol><h4 id="redeemScript"><a href="#redeemScript" class="headerlink" title="redeemScript"></a>redeemScript</h4><ol><li><p>P2PK形式</p><ul><li>PUSHDATA(PubKey)：将**<code>公钥</code>**压入栈</li><li>CHECKSIG：验证栈顶的**<code>公钥</code><strong>和</strong><code>签名</code>**是否匹配</li></ul></li><li><p>P2PKH形式</p></li><li><p>多重签名形式 - 下面的P2SH实现多重签名</p><blockquote><p><img src="/2021/03/04/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8/IMG_C6B93A3357A1-1.jpeg" alt="IMG_C6B93A3357A1-1" style="zoom:45%;">   <img src="/2021/03/04/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8/IMG_56F89D5B4A1F-1-9752549.jpeg" alt="IMG_56F89D5B4A1F-1" style="zoom:45%;"></p><ul><li>输出脚本提供N个公钥和一个域值M，输入脚本只需要提供这N个签名中任意M个合法的签名就能通过验证<ul><li>**<code>CHECKMULTISIG</code>**：验证堆栈中是否有N个签名中的M个</li></ul></li></ul></blockquote></li></ol><p>1、<strong>P2SH实现多重签名</strong> - 现在普遍采用的形式</p><ul><li><img src="/2021/03/04/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8/IMG_0272.jpg" alt="IMG_0272" style="zoom:30%;"> </li><li><strong>本质</strong>：将复杂度从输出脚本转移到了输入脚本 -&gt; 赎回脚本里面</li><li>赎回脚本在输入里面，由<strong>收款人</strong>提供，输出脚本只需要提供赎回脚本的hash值即可<ul><li>实际应用中，收款人不需要公布多重签名的公钥hash值，直接提供赎回脚本的hash值就可以了。则收款人采用什么形式的多重签名就可以隐藏起来</li></ul></li></ul><p>2、<strong>Proof of Burn</strong></p><ul><li>特殊的输出脚本形式，是销毁比特币的方法</li><li>output script，被称为<code>provably Unspendable/Prunable Outputs</code><ul><li><img src="/2021/03/04/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8/IMG_0279.jpg" alt="IMG_0279" style="zoom: 25%;"> </li><li>假如一个交易的input指向这个output，不论这个input里的input script如何设计，执行到<code>RETUEN</code>命令之后会直接返回false，不会执行后面的其他指令，所以这个output无法再被花出去，其对应的UTXO也就可以被剪枝了，无需保存</li></ul></li><li>应用场景<ol><li>一些小的币种(AltCoin，Alternative Coin)需要销毁一定数量的比特币来实现</li><li>向其中添加一些无法篡改的内容<ul><li>example - digital commitment，证明在某个时间知道某些事情：如将知识产权取hash之后存在<code>RETUEN</code>之后，之后可以证明你在这个时间知道某些事</li></ul></li></ol></li></ul><h2 id="fork-分岔"><a href="#fork-分岔" class="headerlink" title="fork, 分岔"></a>fork, 分岔</h2><p>state fork</p><p>forking attack</p><h1 id="以太坊-ETC"><a href="#以太坊-ETC" class="headerlink" title="以太坊 ETC"></a>以太坊 ETC</h1><h2 id="Consensus-Algorithm"><a href="#Consensus-Algorithm" class="headerlink" title="Consensus Algorithm"></a>Consensus Algorithm</h2><p>通过挖矿得到区块，算法分为一下两种</p><p>1、Ethash：及PoW，找nonce以生成区块</p><p>2、Clique：及PoA，投票选出权威节点Authority，由权威节点来验证区块的正确性</p><h1 id="Conflux"><a href="#Conflux" class="headerlink" title="Conflux"></a>Conflux</h1><p>Conflux共识机制是在比特币源代码基础上实现的。</p><p>Conflux的框架和比特币的矿机类似</p><ul><li>GossipNetwork：实现P2P网络交互</li><li>节点：维护TxPool，生成区块（Block Generator），以及维护区块状态</li></ul><p>GHost协议</p><p>epoch</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;crypto-currency，加密货币&quot;&gt;&lt;a href=&quot;#crypto-currency，加密货币&quot; class=&quot;headerlink&quot; title=&quot;crypto-currency，加密货币&quot;&gt;&lt;/a&gt;crypto-currency，加密货币&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="notebook" scheme="https://jieyang-wei.github.io/categories/notebook/"/>
    
    <category term="blockchain" scheme="https://jieyang-wei.github.io/categories/notebook/blockchain/"/>
    
    
    <category term="blockchain" scheme="https://jieyang-wei.github.io/tags/blockchain/"/>
    
    <category term="BTC" scheme="https://jieyang-wei.github.io/tags/BTC/"/>
    
    <category term="Ethereum" scheme="https://jieyang-wei.github.io/tags/Ethereum/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统</title>
    <link href="https://jieyang-wei.github.io/2021/03/04/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    <id>https://jieyang-wei.github.io/2021/03/04/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/</id>
    <published>2021-03-04T06:11:00.000Z</published>
    <updated>2021-03-18T06:44:39.963Z</updated>
    
    <content type="html"><![CDATA[<h1 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h1><h2 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h2><p><a class="link" href="https://blog.csdn.net/moakun/article/details/83043493">CAP理论概述<i class="fas fa-external-link-alt"></i></a></p><ul><li>一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。</li></ul><h3 id="强-一致性-Consistency"><a href="#强-一致性-Consistency" class="headerlink" title="(强)一致性 Consistency"></a>(强)一致性 Consistency</h3><ul><li>一致性指“all nodes see the same data at the same time”，即更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致，所以，一致性，说的就是数据一致性。分布式的一致性</li><li>一致性是因为有<strong>并发读写才</strong>有的问题，因此在理解一致性的问题时，一定要注意结合考虑并发读写的场景。</li><li>对于一致性，可以分为从客户端和服务端两个不同的视角。</li><li><ul><li>从客户端来看，一致性主要指的是多并发访问时更新过的数据如何获取的问题。多进程并发访问时，更新过的数据在不同进程如何获取的不同策略，决定了不同的一致性。</li><li>从服务端来看，则是更新如何复制分布到整个系统，以保证数据最终一致。</li></ul></li></ul><p>三种一致性</p><ol><li>对于关系型数据库，要求更新过的数据能被后续的访问都能看到，这是<strong>强一致性</strong>。<ul><li>CAP中说，不可能同时满足的这个一致性指的是这个<strong>强一致性</strong></li></ul></li><li>如果能容忍后续的部分或者全部访问不到，则是<strong>弱一致性</strong>。</li><li>如果经过一段时间后要求能访问到更新后的数据，则是<strong>最终一致性</strong>。</li></ol><h3 id="可用性-Availability"><a href="#可用性-Availability" class="headerlink" title="可用性 Availability"></a>可用性 Availability</h3><ul><li>可用性指“Reads and writes always succeed”，即服务一直可用，而且是正常响应时间。</li><li>对于一个可用性的分布式系统，每一个非故障的节点必须对每一个请求作出响应。所以，一般我们在衡量一个系统的可用性的时候，都是通过停机时间来计算的。</li></ul><img src="/2021/03/04/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/1.png" alt="1" style="zoom:75%;"><ul><li>通常我们描述一个系统的可用性时，我们说淘宝的系统可用性可以达到5个9，意思就是说他的可用水平是99.999%，即全年停机时间不超过 (1-0.99999)<em>365</em>24*60 = 5.256 min，这是一个极高的要求。</li></ul><ul><li>好的可用性主要是指系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。一个分布式系统，上下游设计很多系统如负载均衡、WEB服务器、应用代码、数据库服务器等，任何一个节点的不稳定都可以影响可用性。</li></ul><h3 id="分区容错性-Partition-tolerance"><a href="#分区容错性-Partition-tolerance" class="headerlink" title="分区容错性 Partition tolerance"></a>分区容错性 Partition tolerance</h3><ul><li>分区容错性指“the system continues to operate despite arbitrary message loss or failure of part of the system”，即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。</li><li><strong>分区容错性</strong>和<strong>扩展性</strong>紧密相关。在分布式应用中，可能因为一些分布式的原因导致系统无法正常运转。好的分区容错性要求能够使应用虽然是一个分布式系统，而看上去却好像是在一个可以运转正常的整体。比如现在的分布式系统中有某一个或者几个机器宕掉了，其他剩下的机器还能够正常运转满足系统需求，或者是机器之间有网络异常，将分布式系统分隔未独立的几个部分，各个部分还能维持分布式系统的运作，这样就具有好的分区容错性。 </li><li>简单点说，就是在网络中断，消息丢失的情况下，系统如果还能正常工作，就是有比较好的分区容错性。</li></ul><h3 id="如何取舍"><a href="#如何取舍" class="headerlink" title="如何取舍"></a>如何取舍</h3><ol><li>CA: 优先保证一致性和可用性，放弃分区容错。 这也意味着放弃系统的扩展性，系统不再是分布式的，有违设计的初衷。</li><li>CP: 优先保证一致性和分区容错性，放弃可用性。在数据一致性要求比较高的场合(譬如:zookeeper,Hbase) 是比较常见的做法，一旦发生网络故障或者消息丢失，就会牺牲用户体验，等恢复之后用户才逐渐能访问。</li><li>AP: 优先保证可用性和分区容错性，放弃一致性。NoSQL中的Cassandra 就是这种架构。跟CP一样，放弃一致性不是说一致性就不保证了，而是逐渐的变得一致。</li></ol><h3 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h3><p>eureka、zookeeper、consul、nacos等</p><p>注册中心作用：</p><ol><li>微服务数量众多，要进行远程调用就需要知道服务端的ip地址和端口，注册中心帮助我们管理这些服务的ip和端口。</li><li>微服务会实时上报自己的状态，注册中心统一管理这些微服务的状态，将存在问题的服务踢出服务列表，客户端获取到可用的服务进行调用。</li><li></li></ol><h4 id="eureka"><a href="#eureka" class="headerlink" title="eureka"></a>eureka</h4><ul><li><p>服务发现框架</p></li><li><p>本身是一个基于REST的服务，主要用于定位运行在AWS域中的中间层服务，以达到负载均衡和中间层服务故障转移的目的。</p></li><li><p>Spring Cloud Eureka 是对Netflix公司的Eureka（它实现了服务治理的功能）的二次封装，集成在自己的子项目spring-cloud-netflix中，以实现SpringCloud的服务发现功能。</p></li><li><p>为什么要用eureka呢，因为分布式开发架构中，任何单点的服务都不能保证不会中断，因此需要服务发现机制，某个节点中断后，服务消费者能及时感知到保证服务高可用。</p></li></ul><p><a class="link" href="https://www.cnblogs.com/jing99/p/11576133.html">https://www.cnblogs.com/jing99/p/11576133.html<i class="fas fa-external-link-alt"></i></a></p><p><a class="link" href="https://blog.csdn.net/qq_18153015/article/details/108415307">https://blog.csdn.net/qq_18153015/article/details/108415307<i class="fas fa-external-link-alt"></i></a></p><p>【原理解析】</p><ul><li>Eureka包含两个组件，分为客户端和服务端</li><li><ul><li>客户端提供服务注册与注销、服务发现的功能</li><li><ul><li>Eureka Client是一个java客户端，用于简化与Eureka Server的交互，<strong>客户端同时也具备一个内置的、使用轮询(round-robin)负载算法的负载均衡器。在应用启动后</strong>，将会向Eureka Server发送心跳,<strong>默认周期为30秒</strong>，如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，Eureka Server将会从服务注册表中把这个**服务节点移除(默认90秒)**。</li><li>Eureka Client分为两个角色，分别是：</li><li><ol><li><strong>Application Service</strong>(Service Provider)： 服务提供方，是注册到Eureka Server中的服务。</li><li><strong>Application Client</strong>(Service Consumer)： 服务消费方，通过Eureka Server发现服务，并消费。</li><li>Application Service和Application Client不是绝对上的定义，因为Provider在提供服务的同时，也可以消费其他Provider提供的服务；Consumer在消费服务的同时，也可以提供对外服务。</li></ol></li></ul></li><li>服务端提供服务治理的功能。</li><li><ul><li>Eureka Server提供服务注册服务，各个节点启动后，会在Eureka Server中进行注册，这样Eureka Server中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观的看到。</li><li>Eureka Server本身也是一个服务，默认情况下会自动注册到Eureka注册中心。</li><li>如果<strong>搭建单机版的Eureka Server注册中心，则需要配置取消Eureka Server的自动注册逻辑。</strong>毕竟当前服务注册到当前服务代表的注册中心中是一个说不通的逻辑。</li><li>Eureka Server通过<strong>Register、Get、Renew</strong>等接口提供服务的<strong>注册、发现和心跳检测</strong>等服务。</li></ul></li></ul></li></ul><h5 id="1、Eureka架构"><a href="#1、Eureka架构" class="headerlink" title="1、Eureka架构"></a>1、Eureka架构</h5><p><strong>a、Eureka Server架构原理：</strong></p><img src="/2021/03/04/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/2.png" alt="1" style="zoom:75%;"><ul><li>Register(服务注册)：把自己的IP和端口注册给Eureka。</li><li>Renew(服务续约)：发送心跳包，每30秒发送一次。告诉Eureka自己还活着。</li><li>Cancel(服务下线)：当provider关闭时会向Eureka发送消息，把自己从服务列表中删除。防止consumer调用到不存在的服务。</li><li>Get Registry(获取服务注册列表)：获取其他服务列表。</li><li>Replicate(集群中数据同步)：eureka集群中的数据复制与同步。</li><li>Make Remote Call(远程调用)：完成服务的远程调用。</li></ul><p><strong>b、Eureka Server缓存架构</strong></p><img src="/2021/03/04/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/3.png" alt="1" style="zoom:75%;"><ul><li>为避免读写冲突，Eureka采用多层缓存的架构。</li><li>服务注册时，Eureka服务端会将服务实例更新到注册实例列表缓存（register）和读写缓存（readWriteCacheMap）中，然后Eureka服务端每隔30秒会将读写缓存（readWriteCacheMap）的数据更新到只读缓存（readOnlyCacheMap）中。</li><li>消费者从Eureka服务端获取实例列表时，是直接从只读缓存（readOnlyCacheMap）中获取。</li></ul><p><strong>c、Eureka健康检查，自我保护机制</strong></p><ul><li>为防止因为Eureka服务器网络问题，导致大部分服务实例被踢除，Eureka在进行服务定时更新时，会进行健康检查。</li><li>健康检查流程：</li><li><ul><li>当过期的服务数量比例超过阈值（可配置，默认为0.85）时，Eureka会启动自我保护机制，不会进行服务踢除操作</li></ul></li></ul><p><strong>d、Eureka分区</strong></p><p>为避免跨机房调用的网络消耗，Eureka支持通过配置实现优先使用本机房服务实例，当本机房实例不可用时，再使用其它机房的服务实例。</p><img src="/2021/03/04/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/4.png" alt="1" style="zoom:90%;"><ul><li>Eureka的分区概念分为区域（region）和机房（zone）。</li></ul><ul><li>如上图，区域（region）是北京，机房分为zone-1和zone-2。消费者（Consumer-1）调用服务时，会优先调用zone-1里面的服务提供者（Service-1），只有zone-1里面的服务提供者（Service-1）不可用，才会去调用zone-2里面的服务提供者（Service-2）。</li></ul><h5 id="2、功能原理"><a href="#2、功能原理" class="headerlink" title="2、功能原理"></a>2、功能原理</h5><p><strong>a、服务发现原理</strong></p><ul><li>eureka server可以集群部署，多个节点之间会进行（异步方式）数据同步，保证数据最终一致性，</li><li>Eureka Server作为一个开箱即用的服务注册中心，提供的功能包括：服务注册、接收服务心跳、服务剔除、服务下线等。</li><li>需要注意的是，Eureka Server同时也是一个Eureka Client，在不禁止Eureka Server的客户端行为时，它会向它配置文件中的其他Eureka Server进行拉取注册表、服务注册和发送心跳等操作。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* eureka server端通过appName和instanceInfoId来唯一区分一个服务实例，服务实例信息是保存在哪里呢？其实就是一个Map中：*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 第一层的key是appName，第二层的key是instanceInfoId */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt; registry</span><br><span class="line">   = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt;();</span><br></pre></td></tr></table></figure><p><strong>b、服务注册</strong></p><ul><li><p>Service Provider启动时会将服务信息（InstanceInfo）发送给eureka server，eureka server接收到之后会写入registry中，服务注册默认过期时间DEFAULT_DURATION_IN_SECS = 90秒。InstanceInfo写入到本地registry之后，然后同步给其他peer节点，对应方法：</p><p><code>com.netflix.eureka.registry.peerawareinstanceregistryimpl#replicateToPeers</code></p></li></ul><p><strong>c、写入本地registry</strong></p><ul><li><p>服务信息（InstanceInfo）保存在Lease中，写入本地registry对应方法：</p><p><code>com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl#register</code></p></li><li><p>Lease统一保存在内存的<strong>ConcurrentHashMap</strong>中，在服务注册过程中，首先加个读锁，然后从registry中判断该Lease是否已经存在，如果存在则比较<strong>lastDirtyTimestamp时间戳</strong>，取二者最大的服务信息，避免发生数据覆盖。使用<strong>InstanceInfo</strong>创建一个新的<strong>InstanceInfo</strong></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (existingLastDirtyTimestamp &gt; registrationLastDirtyTimestamp) &#123;</span><br><span class="line">  <span class="comment">// 已存在Lease则比较时间戳，取二者最大值</span></span><br><span class="line">  registrant = existingLease.getHolder();</span><br><span class="line">&#125;</span><br><span class="line">Lease&lt;InstanceInfo&gt; lease = <span class="keyword">new</span> Lease&lt;InstanceInfo&gt;(registrant, leaseDuration);</span><br><span class="line"><span class="keyword">if</span> (existingLease != null) &#123;</span><br><span class="line">  <span class="comment">// 已存在Lease则取上次up时间戳</span></span><br><span class="line">  lease.setServiceUpTimestamp(existingLease.getServiceUpTimestamp());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Lease</span><span class="params">(T r, <span class="keyword">int</span> durationInSecs)</span> </span>&#123;</span><br><span class="line">  holder = r;</span><br><span class="line">  registrationTimestamp = System.currentTimeMillis(); <span class="comment">// 当前时间</span></span><br><span class="line">  lastUpdateTimestamp = registrationTimestamp;</span><br><span class="line">  duration = (durationInSecs * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>d、同步给其他peer节点</strong></p><ul><li><p>InstanceInfo写入到本地registry之后，然后同步给其他peer节点，对应方法：</p><p><code>com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl#replicateToPeers</code></p></li><li><p>如果当前节点接收到的<strong>InstanceInfo</strong>本身就是另一个节点同步来的，则不会继续同步给其他节点，避免形成“广播效应”；<strong>InstanceInfo</strong>同步时会排除当前节点。</p></li><li><p>InstanceInfo的状态有依以下几种：</p></li><li><p>Heartbeat, Register, Cancel, StatusUpdate, DeleteStatusOverride，默认情况下同步操作是批量异步执行的，同步请求首先缓存到Map中，key为requestType+appName+id，然后由发送线程将请求发送到peer节点。</p></li><li><p>Peer之间的状态是采用异步的方式同步的，所以不保证节点间的状态一定是一致的，不过基本能保证最终状态是一致的。结合服务发现的场景，实际上也并不需要节点间的状态强一致。在一段时间内（比如30秒），节点A比节点B多一个服务实例或少一个服务实例，在业务上也是完全可以接受的（Service Consumer侧一般也会实现错误重试和负载均衡机制）。所以按照CAP理论，Eureka的选择就是放弃C，选择AP。</p></li><li><p>如果同步过程中，出现了异常怎么办呢，这时会根据异常信息做对应的处理，如果是读取超时或者网络连接异常，则稍后重试；如果其他异常则打印错误日志不再后续处理。</p></li></ul><p><strong>e、服务续约</strong></p><ul><li>Renew（服务续约）操作由Service Provider定期调用，类似于heartbeat。主要是用来告诉Eureka Server Service Provider还活着，避免服务被剔除掉。</li><li>renew接口实现方式和register基本一致：首先更新自身状态，再同步到其它Peer，服务续约也就是把过期时间设置为当前时间加上duration的值。</li><li>注意：服务注册如果InstanceInfo不存在则加入，存在则更新；而服务预约只是进行更新，如果InstanceInfo不存在直接返回false。</li></ul><p><strong>f、服务下线</strong></p><ul><li><p>Cancel（服务下线）一般在Service Provider shutdown的时候调用，用来把自身的服务从Eureka Server中删除，以防客户端调用不存在的服务，eureka从本地”删除“（设置为删除状态）之后会同步给其他peer，对应方法：</p><p><code>com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl#cancel</code></p></li></ul><p><strong>g、服务失效剔除</strong></p><ul><li><p>Eureka Server中有一个EvictionTask，用于检查服务是否失效。</p></li><li><p>Eviction（失效服务剔除）用来定期（默认为每60秒）在Eureka Server检测失效的服务，检测标准就是超过一定时间没有Renew的服务。默认失效时间为90秒，也就是如果有服务超过90秒没有向Eureka Server发起Renew请求的话，就会被当做失效服务剔除掉。</p></li><li><ul><li>失效时间可以通过<code>eureka.instance.leaseExpirationDurationInSeconds</code>进行配置，</li><li>定期扫描时间可以通过<code>eureka.server.evictionIntervalTimerInMs</code>进行配置。</li></ul></li><li><p>服务剔除#evict方法中有很多限制，都是为了保证Eureka Server的可用性：</p></li><li><p>比如自我保护时期不能进行服务剔除操作、过期操作是分批进行、服务剔除是随机逐个剔除，剔除均匀分布在所有应用中，防止在同一时间内同一服务集群中的服务全部过期被剔除，以致大量剔除发生时，在未进行自我保护前促使了程序的崩溃</p></li></ul><h5 id="3、Eureka-Server-Client流程"><a href="#3、Eureka-Server-Client流程" class="headerlink" title="3、Eureka Server/Client流程"></a>3、Eureka Server/Client流程</h5><p><strong>a、服务信息拉取</strong></p><ul><li>Eureka consumer服务信息的拉取分为<strong>全量式拉取</strong>和<strong>增量式拉取</strong>，eureka consumer启动时进行全量拉取，运行过程中由定时任务进行增量式拉取，如果网络出现异常，可能导致先拉取的数据被旧数据覆盖（比如上一次拉取线程获取结果较慢，数据已更新情况下使用返回结果再次更新，导致数据版本落后），产生脏数据。对此，eureka通过类型AtomicLong的<strong>fetchRegistryGeneration</strong>对数据版本进行跟踪，版本不一致则表示此次拉取到的数据已过期。</li><li><strong>fetchRegistryGeneration</strong>过程是在拉取数据之前，执行fetchRegistryGeneration.get获取当前版本号，获取到数据之后， 通过<code>fetchRegistryGeneration.compareAndSet</code>来判断当前版本号是否已更新</li><li>注意：如果增量式更新出现意外，会再次进行一次全量拉取更新。</li></ul><p><strong>b、Eureka Server的伸缩容</strong></p><ul><li><p>Eureka Server是怎么知道有多少Peer的呢？</p><ul><li>Eureka Server在启动后会调用<code>EurekaClientConfig.getEurekaServerServiceUrls</code>来获取所有的Peer节点，并且会定期更新。</li><li>定期更新频率可以通过<code>eureka.server.peerEurekaNodesUpdateIntervalMs</code>配置。</li></ul></li><li><p>这个方法的默认实现是从配置文件读取，所以如果Eureka Server节点相对固定的话，可以通过在配置文件中配置来实现。</p></li><li><p>如果希望能更灵活的控制Eureka Server节点，比如动态扩容/缩容，那么可以override <code>getEurekaServerServiceUrls</code>方法，提供自己的实现，比如我们的项目中会通过数据库读取Eureka Server列表。</p></li><li><p>eureka server启动时把自己当做是Service Consumer从其它Peer Eureka获取所有服务的注册信息。然后对每个服务信息，在自己这里执行<code>Register，isReplication=true</code>从而完成初始化。</p></li></ul><p><strong>c、Service Provider</strong></p><ul><li>Service Provider启动时首先时注册到Eureka Service上，这样其他消费者才能进行服务调用，除了在启动时之外，只要实例状态信息有变化，也会注册到Eureka Service。<ul><li>需要注意的是，需要确保配置<code>eureka.client.registerWithEureka=true</code>。register逻辑在方法<code>AbstractJerseyEurekaHttpClient.register</code>中，Service Provider会依次注册到配置的Eureka Server Url上，如果注册出现异常，则会继续注册其他的url。</li></ul></li><li>Renew操作会在Service Provider端定期发起，用来通知Eureka Server自己还活着。<ul><li>这里<code>instance.leaseRenewalIntervalInSeconds</code>属性表示Renew频率。默认是30秒，也就是每30秒会向Eureka Server发起Renew操作。这部分逻辑在HeartbeatThread类中。</li><li>在Service Provider服务shutdown的时候，需要及时通知Eureka Server把自己剔除，从而避免客户端调用已经下线的服务，逻辑本身比较简单，通过对方法标记<code>@PreDestroy</code>，从而在服务shutdown的时候会被触发。</li></ul></li></ul><p><strong>d、Service Consumer</strong></p><ul><li>Service Consumer这块的实现相对就简单一些，因为它只涉及到从Eureka Server获取服务列表和更新服务列表。</li><li>Service Consumer在启动时会从Eureka Server获取所有服务列表，并在本地缓存。需要注意的是，需要确保配置<code>eureka.client.shouldFetchRegistry=true</code>。由于在本地有一份Service Registries缓存，所以需要定期更新，定期更新频率可以通过<code>eureka.client.registryFetchIntervalSeconds</code>配置。</li></ul><h5 id="4、属性值"><a href="#4、属性值" class="headerlink" title="4、属性值"></a>4、属性值</h5><p><strong>a、客户端 eureka.client</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、RegistryFetchIntervalSeconds</span><br><span class="line"><span class="comment">// 从eureka服务器注册表中获取注册信息的时间间隔（s），默认为30秒</span></span><br><span class="line"><span class="number">2</span>、InstanceinfoReplicationIntervalSeconds</span><br><span class="line"><span class="comment">// 复制实例变化信息到eureka服务器所需要的时间间隔（s），默认为30秒</span></span><br><span class="line"><span class="number">3</span>、InitialInstanceInfoReplicationIntervalSeconds</span><br><span class="line"><span class="comment">// 最初复制实例信息到eureka服务器所需的时间（s），默认为40秒</span></span><br><span class="line"><span class="number">4</span>、EurekaServiceUrlPollIntervalSeconds</span><br><span class="line"><span class="comment">// 询问Eureka服务url信息变化的时间间隔（s），默认为300秒</span></span><br><span class="line"><span class="number">5</span>、ProxyHost</span><br><span class="line"><span class="comment">// 获取eureka服务的代理主机，默认为null</span></span><br><span class="line"><span class="number">6</span>、ProxyProxyPort</span><br><span class="line"><span class="comment">// 获取eureka服务的代理端口,默认为null</span></span><br><span class="line"><span class="number">7</span>、ProxyUserName</span><br><span class="line"><span class="comment">// 获取eureka服务的代理用户名，默认为null</span></span><br><span class="line"><span class="number">8</span>、ProxyPassword</span><br><span class="line"><span class="comment">// 获取eureka服务的代理密码，默认为null</span></span><br><span class="line"><span class="number">9</span>、GZipContent</span><br><span class="line"><span class="comment">// eureka注册表的内容是否被压缩，默认为true，并且是在最好的网络流量下被压缩</span></span><br><span class="line"><span class="number">10</span>、EurekaServerReadTimeoutSeconds</span><br><span class="line"><span class="comment">// eureka需要超时读取之前需要等待的时间，默认为8秒</span></span><br><span class="line"><span class="number">11</span>、EurekaServerConnectTimeoutSeconds</span><br><span class="line"><span class="comment">// eureka需要超时连接之前需要等待的时间，默认为5秒</span></span><br><span class="line"><span class="number">12</span>、BackupRegistryImpl</span><br><span class="line"><span class="comment">// 获取实现了eureka客户端在第一次启动时读取注册表的信息作为回退选项的实现名称</span></span><br><span class="line"><span class="number">13</span>、EurekaServerTotalConnections</span><br><span class="line"><span class="comment">// eureka客户端允许所有eureka服务器连接的总数目，默认是200</span></span><br><span class="line"><span class="number">14</span>、EurekaServerTotalConnectionsPerHost</span><br><span class="line"><span class="comment">// eureka客户端允许eureka服务器主机连接的总数目，默认是50</span></span><br><span class="line"><span class="number">15</span>、EurekaServerURLContext</span><br><span class="line"><span class="comment">// 表示eureka注册中心的路径，如果配置为eureka，则为http://x.x.x.x:x/eureka/，在eureka的配置文件中加入此配置表示eureka作为客户端向注册中心注册，从而构成eureka集群。此配置只有在eureka服务器ip地址列表是在DNS中才会用到，默认为null</span></span><br><span class="line"><span class="number">16</span>、EurekaServerPort</span><br><span class="line"><span class="comment">// 获取eureka服务器的端口，此配置只有在eureka服务器ip地址列表是在DNS中才会用到。默认为null</span></span><br><span class="line"><span class="number">17</span>、EurekaServerDNSName</span><br><span class="line"><span class="comment">// 获取要查询的DNS名称来获得eureka服务器，此配置只有在eureka服务器ip地址列表是在DNS中才会用到。默认为null</span></span><br><span class="line"><span class="number">18</span>、UseDnsForFetchingServiceUrls</span><br><span class="line"><span class="comment">// eureka客户端是否应该使用DNS机制来获取eureka服务器的地址列表，默认为false</span></span><br><span class="line"><span class="number">19</span>、RegisterWithEureka</span><br><span class="line"><span class="comment">// 实例是否在eureka服务器上注册自己的信息以供其他服务发现，默认为true</span></span><br><span class="line"><span class="number">20</span>、PreferSameZoneEureka</span><br><span class="line"><span class="comment">// 实例是否使用同一zone里的eureka服务器，默认为true，理想状态下，eureka客户端与服务端是在同一zone下</span></span><br><span class="line"><span class="number">21</span>、AllowRedirects</span><br><span class="line"><span class="comment">// 服务器是否能够重定向客户端请求到备份服务器。如果设置为false，服务器将直接处理请求，如果设置为true，它可能发送HTTP重定向到客户端。默认为false</span></span><br><span class="line"><span class="number">22</span>、LogDeltaDiff</span><br><span class="line"><span class="comment">// 是否记录eureka服务器和客户端之间在注册表的信息方面的差异，默认为false</span></span><br><span class="line"><span class="number">23</span>、DisableDelta(*)</span><br><span class="line"><span class="comment">// 默认为false</span></span><br><span class="line"><span class="number">24</span>、fetchRegistryForRemoteRegions</span><br><span class="line"><span class="comment">// eureka服务注册表信息里的以逗号隔开的地区名单，如果不这样返回这些地区名单，则客户端启动将会出错。默认为null</span></span><br><span class="line"><span class="number">25</span>、Region</span><br><span class="line"><span class="comment">// 获取实例所在的地区。默认为us-east-1</span></span><br><span class="line"><span class="number">26</span>、AvailabilityZones</span><br><span class="line"><span class="comment">// 获取实例所在的地区下可用性的区域列表，用逗号隔开。</span></span><br><span class="line"><span class="number">27</span>、EurekaServerServiceUrls</span><br><span class="line"><span class="comment">// Eureka服务器的连接，默认为http：//XXXX：X/eureka/,但是如果采用DNS方式获取服务地址，则不需要配置此设置。</span></span><br><span class="line"><span class="number">28</span>、FilterOnlyUpInstances（*）</span><br><span class="line"><span class="comment">// 是否获得处于开启状态的实例的应用程序过滤之后的应用程序。默认为true</span></span><br><span class="line"><span class="number">29</span>、EurekaConnectionIdleTimeoutSeconds</span><br><span class="line"><span class="comment">// Eureka服务的http请求关闭之前其响应的时间，默认为30秒</span></span><br><span class="line"><span class="number">30</span>、FetchRegistry</span><br><span class="line"><span class="comment">// 此客户端是否获取eureka服务器注册表上的注册信息，默认为true</span></span><br><span class="line"><span class="number">31</span>、RegistryRefreshSinglevipAddress</span><br><span class="line"><span class="comment">// 此客户端只对一个单一的VIP注册表的信息感兴趣。默认为null</span></span><br><span class="line"><span class="number">32</span>、HeartbeatExecutorThreadPoolSize(*)</span><br><span class="line"><span class="comment">// 心跳执行程序线程池的大小,默认为5</span></span><br><span class="line"><span class="number">33</span>、HeartbeatExecutorExponentialBackOffBound(*)</span><br><span class="line"><span class="comment">// 心跳执行程序回退相关的属性，是重试延迟的最大倍数值，默认为10</span></span><br><span class="line"><span class="number">34</span>、CacheRefreshExecutorThreadPoolSize(*)</span><br><span class="line"><span class="comment">// 执行程序缓存刷新线程池的大小，默认为5</span></span><br><span class="line"><span class="number">35</span>、CacheRefreshExecutorExponentialBackOffBound</span><br><span class="line"><span class="comment">// 执行程序指数回退刷新的相关属性，是重试延迟的最大倍数值，默认为10</span></span><br><span class="line"><span class="number">36</span>、DollarReplacement</span><br><span class="line"><span class="comment">// eureka服务器序列化/反序列化的信息中获取“$”符号的的替换字符串。默认为“_-”</span></span><br><span class="line"><span class="number">37</span>、EscapeCharReplacement</span><br><span class="line"><span class="comment">// eureka服务器序列化/反序列化的信息中获取“_”符号的的替换字符串。默认为“__”</span></span><br><span class="line"><span class="number">38</span>、OnDemandUpdateStatusChange（*）</span><br><span class="line"><span class="comment">// 如果设置为true,客户端的状态更新将会点播更新到远程服务器上，默认为true</span></span><br><span class="line"><span class="number">39</span>、EncoderName</span><br><span class="line"><span class="comment">// 这是一个短暂的编码器的配置，如果最新的编码器是稳定的，则可以去除，默认为null</span></span><br><span class="line"><span class="number">40</span>、DecoderName</span><br><span class="line"><span class="comment">// 这是一个短暂的解码器的配置，如果最新的解码器是稳定的，则可以去除，默认为null</span></span><br><span class="line"><span class="number">41</span>、ClientDataAccept（*）</span><br><span class="line"><span class="comment">// 客户端数据接收</span></span><br><span class="line"><span class="number">42</span>、Experimental（*）</span><br><span class="line"><span class="comment">// 当尝试新功能迁移过程时，为了避免配置API污染，相应的配置即可投入实验配置部分，默认为null</span></span><br></pre></td></tr></table></figure><p><strong>b、服务端 eureka.server</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、AWSAccessId</span><br><span class="line"><span class="comment">// 获取aws访问的id，主要用于弹性ip绑定，此配置是用于aws上的，默认为null</span></span><br><span class="line"><span class="number">2</span>、AWSSecretKey</span><br><span class="line"><span class="comment">// 获取aws私有秘钥，主要用于弹性ip绑定，此配置是用于aws上的，默认为null</span></span><br><span class="line"><span class="number">3</span>、EIPBindRebindRetries</span><br><span class="line"><span class="comment">// 获取服务器尝试绑定到候选的EIP的次数，默认为3</span></span><br><span class="line"><span class="number">4</span>、EIPBindingRetryIntervalMsWhenUnbound(*)</span><br><span class="line"><span class="comment">// 服务器检查ip绑定的时间间隔，单位为毫秒，默认为1 * 60 * 1000</span></span><br><span class="line"><span class="number">5</span>、EIPBindingRetryIntervalMs</span><br><span class="line"><span class="comment">// 与上面的是同一作用，仅仅是稳定状态检查，默认为5 * 60 * 1000</span></span><br><span class="line"><span class="number">6</span>、SelfPreservation模式，</span><br><span class="line"><span class="comment">// SelfPreservation模式，当出现出现网络分区、eureka在短时间内丢失过多客户端时，会进入SelfPreservation模式，即一个服务长时间没有发送心跳，eureka也不会将其删除，默认为true</span></span><br><span class="line"><span class="number">7</span>、RenewalPercentThreshold(*)</span><br><span class="line"><span class="comment">// 阈值因子，默认是0.85，如果阈值比最小值大，则SelfPreservation模式开启</span></span><br><span class="line"><span class="number">8</span>、RenewalThresholdUpdateIntervalMs</span><br><span class="line"><span class="comment">// 阈值更新的时间间隔，单位为毫秒，默认为15 * 60 * 1000</span></span><br><span class="line"><span class="number">9</span>、PeerEurekaNodesUpdateIntervalMs(*)</span><br><span class="line"><span class="comment">// 集群里eureka节点的变化信息更新的时间间隔，单位为毫秒，默认为10 * 60 * 1000</span></span><br><span class="line"><span class="number">10</span>、EnableReplicatedRequestCompression</span><br><span class="line"><span class="comment">// 复制的数据在发送请求时是否被压缩，默认为false</span></span><br><span class="line"><span class="number">11</span>、NumberOfReplicationRetries</span><br><span class="line"><span class="comment">// 获取集群里服务器尝试复制数据的次数，默认为5</span></span><br><span class="line"><span class="number">12</span>、PeerEurekaStatusRefreshTimeIntervalMs</span><br><span class="line"><span class="comment">// 服务器节点的状态信息被更新的时间间隔，单位为毫秒，默认为30 * 1000</span></span><br><span class="line"><span class="number">13</span>、WaitTimeInMsWhenSyncEmpty(*)</span><br><span class="line"><span class="comment">// 在Eureka服务器获取不到集群里对等服务器上的实例时，需要等待的时间，单位为毫秒，默认为1000 * 60 * 5</span></span><br><span class="line"><span class="number">14</span>、PeerNodeConnectTimeoutMs</span><br><span class="line"><span class="comment">// 连接对等节点服务器复制的超时的时间，单位为毫秒，默认为200</span></span><br></pre></td></tr></table></figure><p><strong>c、实例微服务端配置</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、InstanceId</span><br><span class="line"><span class="comment">// 此实例注册到eureka服务端的唯一的实例ID,其组成为$&#123;spring.application.name&#125;:$&#123;spring.application.instance_id:$&#123;random.value&#125;&#125;</span></span><br><span class="line"><span class="number">2</span>、Appname</span><br><span class="line"><span class="comment">// 获得在eureka服务上注册的应用程序的名字，默认为unknow</span></span><br><span class="line"><span class="number">3</span>、AppGroupName</span><br><span class="line"><span class="comment">// 获得在eureka服务上注册的应用程序组的名字，默认为unknow</span></span><br><span class="line"><span class="number">4</span>、InstanceEnabledOnit（*）</span><br><span class="line"><span class="comment">// 实例注册到eureka服务器时，是否开启通讯，默认为false</span></span><br><span class="line"><span class="number">5</span>、NonSecurePort</span><br><span class="line"><span class="comment">// 获取该实例应该接收通信的非安全端口。默认为80</span></span><br><span class="line"><span class="number">6</span>、SecurePort</span><br><span class="line"><span class="comment">// 获取该实例应该接收通信的安全端口，默认为443</span></span><br><span class="line"><span class="number">7</span>、NonSecurePortEnabled</span><br><span class="line"><span class="comment">// 该实例应该接收通信的非安全端口是否启用，默认为true</span></span><br><span class="line"><span class="number">8</span>、SecurePortEnabled</span><br><span class="line"><span class="comment">// 该实例应该接收通信的安全端口是否启用，默认为false</span></span><br><span class="line"><span class="number">9</span>、LeaseRenewalIntervalInSeconds</span><br><span class="line"><span class="comment">// eureka客户需要多长时间发送心跳给eureka服务器，表明它仍然活着,默认为30秒</span></span><br><span class="line"><span class="number">10</span>、LeaseExpirationDurationInSeconds</span><br><span class="line"><span class="comment">// Eureka服务器在接收到实例的最后一次发出的心跳后，需要等待多久才可以将此实例删除，默认为90秒</span></span><br><span class="line"><span class="number">11</span>、VirtualHostName</span><br><span class="line"><span class="comment">// 此实例定义的虚拟主机名，其他实例将通过使用虚拟主机名找到该实例。</span></span><br><span class="line"><span class="number">12</span>、SecureVirtualHostName</span><br><span class="line"><span class="comment">// 此实例定义的安全虚拟主机名</span></span><br><span class="line"><span class="number">13</span>、ASGName（*）</span><br><span class="line"><span class="comment">// 与此实例相关联AWS自动缩放组名称。此项配置是在AWS环境专门使用的实例启动，它已被用于流量停用后自动把一个实例退出服务。</span></span><br><span class="line"><span class="number">14</span>、HostName</span><br><span class="line"><span class="comment">// 与此实例相关联的主机名，是其他实例可以用来进行请求的准确名称</span></span><br><span class="line"><span class="number">15</span>、MetadataMap(*)</span><br><span class="line"><span class="comment">// 获取与此实例相关联的元数据(key,value)。这个信息被发送到eureka服务器，其他实例可以使用。</span></span><br><span class="line"><span class="number">16</span>、DataCenterInfo（*）</span><br><span class="line"><span class="comment">// 该实例被部署在数据中心</span></span><br><span class="line"><span class="number">17</span>、IpAddress</span><br><span class="line"><span class="comment">// 获取实例的ip地址</span></span><br><span class="line"><span class="number">18</span>、StatusPageUrlPath（*）</span><br><span class="line"><span class="comment">// 获取此实例状态页的URL路径，然后构造出主机名，安全端口等，默认为/info</span></span><br><span class="line"><span class="number">19</span>、StatusPageUrl(*)</span><br><span class="line"><span class="comment">// 获取此实例绝对状态页的URL路径，为其他服务提供信息时来找到这个实例的状态的路径，默认为null</span></span><br><span class="line"><span class="number">20</span>、HomePageUrlPath（*）</span><br><span class="line"><span class="comment">// 获取此实例的相关主页URL路径，然后构造出主机名，安全端口等，默认为/</span></span><br><span class="line"><span class="number">21</span>、HomePageUrl(*)</span><br><span class="line"><span class="comment">// 获取此实例的绝对主页URL路径，为其他服务提供信息时使用的路径,默认null</span></span><br><span class="line"><span class="number">22</span>、HealthCheckUrlPath</span><br><span class="line"><span class="comment">// 获取此实例的相对健康检查URL路径，默认为/health</span></span><br><span class="line"><span class="number">23</span>、HealthCheckUrl</span><br><span class="line"><span class="comment">// 获取此实例的绝对健康检查URL路径,默认为null</span></span><br><span class="line"><span class="number">24</span>、SecureHealthCheckUrl</span><br><span class="line"><span class="comment">// 获取此实例的绝对安全健康检查网页的URL路径，默认为null</span></span><br><span class="line"><span class="number">25</span>、DefaultAddressResolutionOrder</span><br><span class="line"><span class="comment">// 获取实例的网络地址，默认为[]</span></span><br><span class="line"><span class="number">26</span>、Namespace</span><br><span class="line"><span class="comment">// 获取用于查找属性的命名空间，默认为eureka</span></span><br></pre></td></tr></table></figure><h2 id="FLP-impossibility"><a href="#FLP-impossibility" class="headerlink" title="FLP impossibility"></a>FLP impossibility</h2><p><strong>FLP不可能原理</strong>：在网络可靠，存在节点失效（即便只有一个）的最小化异步模型系统中，不存在一个可以解决一致性问题的确定性算法。</p><ul><li>1985年 FLP 原理实际上说明对于允许节点失效情况下，纯粹异步系统无法确保一致性在有限时间内完成。</li><li> 科学告诉你什么是不可能的；工程则告诉你，付出一些代价，我可以把它变成可能。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;理论&quot;&gt;&lt;a href=&quot;#理论&quot; class=&quot;headerlink&quot; title=&quot;理论&quot;&gt;&lt;/a&gt;理论&lt;/h1&gt;&lt;h2 id=&quot;CAP&quot;&gt;&lt;a href=&quot;#CAP&quot; class=&quot;headerlink&quot; title=&quot;CAP&quot;&gt;&lt;/a&gt;CAP&lt;/h2&gt;&lt;p</summary>
      
    
    
    
    <category term="notebook" scheme="https://jieyang-wei.github.io/categories/notebook/"/>
    
    
    <category term="理论知识" scheme="https://jieyang-wei.github.io/tags/%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/"/>
    
    <category term="distributed system" scheme="https://jieyang-wei.github.io/tags/distributed-system/"/>
    
  </entry>
  
  <entry>
    <title>植物大战僵尸破解</title>
    <link href="https://jieyang-wei.github.io/2021/02/23/%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8%E7%A0%B4%E8%A7%A3/"/>
    <id>https://jieyang-wei.github.io/2021/02/23/%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8%E7%A0%B4%E8%A7%A3/</id>
    <published>2021-02-23T08:46:34.000Z</published>
    <updated>2021-03-08T06:04:48.225Z</updated>
    
    <content type="html"><![CDATA[<p><a class="link" href="https://pan.baidu.com/s/16ub4mIS-JaPH-K7nytCQew">植物大战僵尸95单机中文版，提取码4ni2<i class="fas fa-external-link-alt"></i></a></p><h1 id="目录构成"><a href="#目录构成" class="headerlink" title="目录构成"></a>目录构成</h1><img src="/2021/02/23/%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8%E7%A0%B4%E8%A7%A3/5C20B17C1811FAAC73E63331E1FB2AFA.png" alt="5C20B17C1811FAAC73E63331E1FB2AFA" style="zoom:80%;"><ul><li>images、reanim、particles：均为图片等素材文件</li><li>main.pak：游戏素材包</li><li>base.dll：库文件</li></ul><h1 id="本地数据文件"><a href="#本地数据文件" class="headerlink" title="本地数据文件"></a>本地数据文件</h1><p>游戏数据路径：<code>C:\ProgramData\PopCap Games\PlantsVsZombies</code></p><ul><li><p><strong>注意</strong>：每次需要关闭游戏后再对文件进行改动，不然不生效</p></li><li><p>cache：游戏缓存</p></li><li><p>userdata：用户数据文件夹，内容如下</p><ul><li><img src="/2021/02/23/%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8%E7%A0%B4%E8%A7%A3/829EB5D66DE961B5BBFCB81752AFD1C2.png" alt="829EB5D66DE961B5BBFCB81752AFD1C2" style="zoom:90%;">* users.bat：用户列表，仅存储用户名字和顺序* user[n].bat：第n个创建的用户的游戏相关参数缓存  * 包括关卡、金钱数、道具等，但不存储用户名* game[n_0].bat：游戏进度存储</li></ul></li></ul><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><p>二进制文件编辑：Hex</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a class=&quot;link&quot; href=&quot;https://pan.baidu.com/s/16ub4mIS-JaPH-K7nytCQew&quot;&gt;植物大战僵尸95单机中文版，提取码4ni2&lt;i class=&quot;fas fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;</summary>
      
    
    
    
    <category term="course" scheme="https://jieyang-wei.github.io/categories/course/"/>
    
    
    <category term="binary" scheme="https://jieyang-wei.github.io/tags/binary/"/>
    
  </entry>
  
  <entry>
    <title>WebSocket</title>
    <link href="https://jieyang-wei.github.io/2021/01/25/WebSocket/"/>
    <id>https://jieyang-wei.github.io/2021/01/25/WebSocket/</id>
    <published>2021-01-25T06:37:08.000Z</published>
    <updated>2021-03-18T06:45:56.200Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>WebSocket API 是 HTML5 标准的一部分， 但这并不代表 WebSocket 一定要用在 HTML 中，或者只能在基于浏览器的应用程序中使用。</p><p>实际上，许多语言、框架和服务器都提供了 WebSocket 支持：</p><ul><li>基于 <strong>C</strong> 的 libwebsocket.org</li><li>基于 <strong>Node.js</strong> 的 Socket.io</li><li>基于 <strong>Python</strong> 的 ws4py</li><li>基于 <strong>C++</strong> 的 WebSocket++</li><li><strong>Apache</strong> 对 WebSocket 的支持： Apache Module mod_proxy_wstunnel</li><li><strong>Nginx</strong> 对 WebSockets 的支持： NGINX as a WebSockets Proxy 、 NGINX Announces Support for WebSocket Protocol 、WebSocket proxying</li><li><strong>lighttpd</strong> 对 WebSocket 的支持：mod_websocket</li></ul><h2 id="nodejs"><a href="#nodejs" class="headerlink" title="nodejs"></a>nodejs</h2><h2 id="java"><a href="#java" class="headerlink" title="java"></a>java</h2><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><p>c++下没有原生的websocket低矮用，但是可以使用一些开源库实现，如<a class="link" href="https://download.csdn.net/download/weixin_34196559/10750141">websocketpp<i class="fas fa-external-link-alt"></i></a>等，下面讲解的是socket通信相关的实现</p><h3 id="IOS"><a href="#IOS" class="headerlink" title="IOS"></a>IOS</h3><p><a class="link" href="https://blog.csdn.net/xuqiang918/article/details/16841343?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-10&spm=1001.2101.3001.4242">IOS网络通信<i class="fas fa-external-link-alt"></i></a></p><p><a class="link" href="https://github.com/ok-fine/Socket-Cpp.git">代码 - master分支<i class="fas fa-external-link-alt"></i></a></p><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p><code>sockaddr</code>和<code>sockaddr_in</code>在字节长度上都为16个BYTE，可以进行转换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 通用的socket地址 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span>&#123;</span>  </span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> sa_family;    <span class="comment">//2 </span></span><br><span class="line">  <span class="keyword">char</span> sa_data[<span class="number">14</span>];            <span class="comment">//14</span></span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Internet socket */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>&#123;</span></span><br><span class="line">  <span class="keyword">short</span> <span class="keyword">int</span> sin_family;        <span class="comment">//2</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> sin_port; <span class="comment">//2</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>     <span class="comment">//4</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="number">8</span>];   <span class="comment">//8</span></span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 表示32位的IPv4地址 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span> u_char s_b1,s_b2,s_b3,s_b4; &#125; S_un_b;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span> u_short s_w1,s_w2; &#125; S_un_w;</span><br><span class="line">    u_long S_addr; </span><br><span class="line">  &#125; S_un;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> s_addr  S_un.S_addr</span></span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 或者 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>&#123;</span></span><br><span class="line">  <span class="keyword">in_addr_t</span> s_addr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>**inet_addr(“192.168.0.1”)**：将一个点分制的IP地址(如192.168.0.1)转换为上述结构中需要的32位二进制方式的IP地址</li></ul><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line"><span class="keyword">int</span> server_socket = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>domain</strong>（IOS系统使用 <code>AT_</code> ）<ul><li>PF_UNIX          Unix IPC通信 </li><li>PF_INET           IPV4通信（默认）</li><li>PF_INET6         IPV6 </li><li>PF_IPX              Novell IPX </li><li>PF_NETLINK    Kernel用户接口驱动程序 </li><li>PF_X25             X.25 </li><li>PF_AX25          AX.25 </li><li>PF_ATMPVC    ATM PVC </li><li>PF_APPLETALK    AppleTalk协议 </li><li>PF_PACKET     低级包接口 </li></ul></li><li><strong>type</strong><ul><li>SOCK_STREAM          使用TCP面向连接的通信包（默认）</li><li>SOCK_DGRAM           使用UDP无连接的通信包</li><li>SOCK_SEQPACKET    使用有固定最大长度的面向连接的通信包 </li><li>SOCK_RAW                 使用原IP包 </li><li>SOCK_RDM                 使用不保证次序的可靠数据报 </li></ul></li><li><strong>Protocol</strong><ul><li>一般使用与type对应的默认协议，用0表示。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recv</span><span class="params">(SOCKET socket, <span class="keyword">char</span> *buf, <span class="keyword">int</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="keyword">char</span> recv_msg[<span class="number">1024</span>];</span><br><span class="line">bzero(recv_msg, <span class="number">1024</span>);</span><br><span class="line"><span class="keyword">long</span> byte_num = recv(client_socket, recv_msg, <span class="number">1024</span>, <span class="number">0</span>);</span><br><span class="line">recv_msg[byte_num] = <span class="string">&#x27;\0&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>参数：<ul><li><strong>socket</strong>：已建立连接的套接字；</li><li><strong>buf</strong>：存放接收到的数据的缓冲区指针；</li><li><strong>len</strong>：buf的长度</li><li><strong>flags</strong>：调用方式： <ul><li><strong>0</strong>：接收的是正常数据，无特殊行为。 </li><li><strong>MSG_PEEK</strong>：系统缓冲区数据复制到提供的接收缓冲区，但是系统缓冲区内容并没有删除。 </li><li><strong>MSG_OOB</strong>：表示处理带外数据。 </li></ul></li></ul></li><li>返回值：接收成功时返回接收到的数据长度，连接结束时返回0，连接失败时返回SOCKET_ERROR。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">send</span><span class="params">(SOCKET socket, <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> len, <span class="keyword">int</span> flags)</span></span></span><br><span class="line">char send_msg[1024];</span><br><span class="line">bzero(send_msg, <span class="number">1024</span>);</span><br><span class="line">send(client_socket, send_msg, <span class="number">1024</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><ul><li>参数<ul><li><strong>socket</strong>：已建立连接的套接字</li><li><strong>buf</strong>：存放将要发送的数据的缓冲区指针；</li><li><strong>len</strong>：发送缓冲区中的字符数</li><li><strong>flags</strong>：控制数据传输方式： <ul><li><strong>0</strong>：接收的是正常数据，无特殊行为。 </li><li><strong>MSG_DONTROUTE</strong>：表示目标主机就在本地网络中，无需路由选择。 </li><li><strong>MSG_OOB</strong>：表示处理带外数据。 </li></ul></li></ul></li><li>返回值：发送成功时返回发送的数据长度，连接结束时返回0，连接失败时返回SOCKET_ERROR。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">bzero</span><span class="params">(<span class="keyword">void</span> *s, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="keyword">char</span> msg[<span class="number">1024</span>];</span><br><span class="line">bzero(msg, <span class="number">1024</span>);  </span><br><span class="line"><span class="comment">/* 相当于 */</span></span><br><span class="line"><span class="built_in">memset</span>(msg, <span class="number">0</span>, <span class="number">1024</span>);</span><br></pre></td></tr></table></figure><ul><li>头文件：#include &lt;string.h&gt;</li><li>功能：置字节字符串s的前n个字节为零且包括‘\0’</li><li>描述：<ul><li>string.h曾经是posix标准的一部分，但是在POSIX.1-2001标准里面，这些函数被标记为了遗留函数而不推荐使用。在POSIX.1-2008标准里已经没有这些函数了。推荐使用<code>memset</code>替代<code>bzero</code>。</li><li>bzero函数TC和VC中都没有，gcc中提供了</li></ul></li><li>无返回值</li></ul><blockquote><p>使用无阻塞的I/O方法 </p><p>什么是阻塞?<br>比如使用recv(),如果函数接受不到数据，就会阻塞程序的继续执行。 </p><p>如何防止阻塞?<br>使用fcntl()函数，把套接字设置为无阻塞模式。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">int</span> newsocket; </span><br><span class="line">&gt;newsocket = socket(PF_INET, SOCK_STREAM, <span class="number">0</span> ); </span><br><span class="line">&gt;fcntl( newsocket, F_SETEL, O_NONBLOCK ); </span><br></pre></td></tr></table></figure><p>以后使用recv()就不会阻塞了。 </p><p>另一种方式是使用多路套接字<code>select()</code> </p></blockquote><h5 id="select"><a href="#select" class="headerlink" title="select"></a>select</h5><p>select这个系统调用，是一种多路复用IO方案，可以同时对多个文件描述符进行监控，从而知道哪些<a class="link" href="https://blog.csdn.net/test1280/article/details/80293294">文件描述符(File Descriptor，FD)<i class="fas fa-external-link-alt"></i></a>可读，可写或者出错，不过select方法是阻塞的，可以设定超时时间。 </p><p>select使用的步骤如下:</p><ol><li>创建一个<code>fd_set</code>变量（fd_set实为包含了一个整数数组的结构体），用来存放所有的待检查的文件描述符</li><li>清空<code>fd_set</code>变量，并将需要检查的所有文件描述符加入<code>fd_set</code></li><li>调用select。若返回-1，则说明出错;返回0,则说明超时，返回正数，则为发生状态变化的文件描述符的个数</li><li>若select返回大于0,则依次查看哪些文件描述符变的可读，并对它们进行处理</li><li>返回步骤2，开始新一轮的检测</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfd, fd_set *rdset, fd_set *wrset, fd_set *exset, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>参数：<ul><li>maxfd：需要监视的最大的文件描述符值+1；</li><li>rdset：需要检测的可读文件描述符的集合</li><li>wrset：可写文件描述符的集合</li><li>exset：异常文件描述符的集合</li><li>timeval：用于描述一段时间长度，如果在这个时间内，需要监视的描述符没有事件发生则函数返回，返回值为0。</li></ul></li></ul><p><code>fd_set</code>类型通过下面四个宏来操作：</p><ol><li><code>FD_ZERO(fd_set *fdset);</code>将指定的文件描述符集清空，在对文件描述符集合进行设置前，必须对其进行初始化，如果不清空，由于在系统分配内存空间后，通常并不作清空处理，所以结果是不可知的。</li><li><code>FD_SET(fd_set *fdset);</code>用于在文件描述符集合中增加一个新的文件描述符。</li><li><code>FD_CLR(fd_set *fdset);</code>用于在文件描述符集合中删除一个文件描述符。 </li><li><code>FD_ISSET(int fd, fd_set *fdset);</code>用于测试指定的文件描述符是否在该集合中。</li></ol><h5 id="kqueue"><a href="#kqueue" class="headerlink" title="kqueue"></a>kqueue</h5><p>Mac是基于BSD的内核，所使用的是kqueue（kernel event notification mechanism，详细内容可以Mac中 <code>man 2 kqueue</code>）</p><ul><li>kqueue比select先进的地方就在于使用<strong>事件触发</strong>的机制，且其调用无需每次对所有的文件描述符进行遍历，返回的时候只返回需要处理的事件，而不像select中需要自己去一个个通过FD_ISSET检查。</li><li>kqueue默认的触发方式是level 水平触发，可以通过设置event的flag为<code>EV_CLEAR</code> 使得这个事件变为边沿触发,可能epoll的触发方式无法细化到单个event，需要查证。</li><li></li></ul><p>kqueue中涉及两个系统调用，kqueue()和kevent()</p><ul><li><code>kqueue()</code>创建kernel级别的事件队列，并返回队列的文件描述符</li><li><code>kevent()</code>往事件队列中加入订阅事件，或者返回相关的事件数组</li></ul><p>kqueue使用的流程一般如下：</p><ul><li>创建kqueue</li><li>创建<code>struct kevent</code>变量（注意这里的kevent是结构体类型名），可以通过<code>EV_SET</code>这个宏提供的快捷方式进行创建</li><li>通过kevent系统调用将创建好的kevent结构体变量加入到kqueue队列中，完成对指定文件描述符的事件的订阅</li><li>通过kevent系统调用获取满足条件的事件队列，并对每一个事件进行处理</li></ul><h4 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h4><img src="/2021/01/25/WebSocket/1.png" alt="截屏2021-01-31 下午2.57.07" style="zoom:45%;"> <p><strong>1. sever</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 绑定server socket的ip、端口等信息 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">server_addr.sin_len = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">server_addr.sin_family = AF_INET;<span class="comment">//Address families AF_INET互联网地址簇</span></span><br><span class="line">server_addr.sin_port = htons(<span class="number">11332</span>);</span><br><span class="line">server_addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">bzero(&amp;(server_addr.sin_zero),<span class="number">8</span>);</span><br></pre></td></tr></table></figure><ul><li><p>一般情况下都用<code>server_addr.sin_addr.s_addr = htonl(INADDR_ANY)</code></p><blockquote><p>比如你的机器有三个ip<br> 192.168.1.1<br> 202.202.202.202<br> 61.1.2.3  </p><p> 如果你serv.sin_addr.s_addr=inet_addr(“192.168.1.1”);  </p><p> 然后监听100端口  </p><p> 这时其他机器只有connect  192.168.1.1:100端口才能成功。<br> connect  202.202.202.202:100和connect  61.1.2.3:100都会失败。  </p><p> 如果serv.sin_addr.s_addr=htonl(INADDR_ANY);  的话，无论连接哪个ip都可以连上的，这就是为什么这样选择的理由</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* server socket工作流程 */</span></span><br><span class="line"><span class="comment">//创建socket</span></span><br><span class="line"><span class="keyword">int</span> server_socket = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);<span class="comment">//SOCK_STREAM 有连接</span></span><br><span class="line"><span class="keyword">if</span> (server_socket == <span class="number">-1</span>) &#123;</span><br><span class="line">  perror(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//绑定socket</span></span><br><span class="line"><span class="comment">//将创建的socket绑定到本地的IP地址和端口，此socket是半相关的，只是负责侦听客户端的连接请求，并不能用于和客户端通信</span></span><br><span class="line"><span class="keyword">int</span> bind_result = bind(server_socket, (struct sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line"><span class="keyword">if</span> (bind_result == <span class="number">-1</span>) &#123;</span><br><span class="line">  perror(<span class="string">&quot;bind error&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//listen侦听</span></span><br><span class="line"><span class="comment">//第一个参数是套接字</span></span><br><span class="line"><span class="comment">//第二个参数为等待接受的连接的队列的大小，在connect请求过来的时候,完成三次握手后先将连接放到这个队列中，直到被accept处理。如果这个队列满了，且有新的连接的时候，对方可能会收到出错信息。</span></span><br><span class="line"><span class="keyword">if</span> (listen(server_socket, <span class="number">5</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">  perror(<span class="string">&quot;listen error&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//accept接收来自客户端的链接请求(使用下面的select不需要这一部分)</span></span><br><span class="line"><span class="comment">//返回的client_socket为一个全相关的socket，其中包含client的地址和端口信息，通过client_socket可以和客户端进行通信。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>;</span></span><br><span class="line"><span class="keyword">socklen_t</span> address_len;</span><br><span class="line"><span class="keyword">int</span> client_socket = accept(server_socket, (struct sockaddr *)&amp;client_address, &amp;address_len);</span><br><span class="line"><span class="keyword">if</span> (client_socket == <span class="number">-1</span>) &#123;</span><br><span class="line">  perror(<span class="string">&quot;accept error&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 信息交流 */</span></span><br><span class="line">fd_set server_fd_set;</span><br><span class="line"><span class="keyword">int</span> max_fd = <span class="number">-1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">tv.tv_sec = <span class="number">20</span>;  <span class="comment">// seconds</span></span><br><span class="line">tv.tv_usec = <span class="number">0</span>;  <span class="comment">// microseconds</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">  FD_ZERO(&amp;server_fd_set);</span><br><span class="line">  <span class="comment">//标准输入</span></span><br><span class="line">  FD_SET(STDIN_FILENO, &amp;server_fd_set);</span><br><span class="line">  <span class="keyword">if</span> (max_fd &lt; STDIN_FILENO) &#123;</span><br><span class="line">    max_fd = STDIN_FILENO;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//服务器端socket</span></span><br><span class="line">  FD_SET(server_sock_fd, &amp;server_fd_set);</span><br><span class="line">  <span class="keyword">if</span> (max_fd &lt; server_sock_fd) &#123;</span><br><span class="line">    max_fd = server_sock_fd;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//客户端连接</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CONCURRENT_MAX; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (client_fds[i]!=<span class="number">0</span>) &#123;</span><br><span class="line">      FD_SET(client_fds[i], &amp;server_fd_set);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (max_fd &lt; client_fds[i]) &#123;</span><br><span class="line">        max_fd = client_fds[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> ret = select(max_fd+<span class="number">1</span>, &amp;server_fd_set, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;tv);</span><br><span class="line">  <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;select 出错\n&quot;</span>);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;select 超时\n&quot;</span>);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//ret为未状态发生变化的文件描述符的个数</span></span><br><span class="line">    <span class="keyword">if</span> (FD_ISSET(STDIN_FILENO, &amp;server_fd_set)) &#123;</span><br><span class="line">      <span class="comment">//标准输入</span></span><br><span class="line">      bzero(input_msg, BUFFER_SIZE);</span><br><span class="line">      fgets(input_msg, BUFFER_SIZE, <span class="built_in">stdin</span>);</span><br><span class="line">      <span class="comment">//输入 &quot;.quit&quot; 则退出服务器</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strcmp</span>(input_msg, QUIT_CMD) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;CONCURRENT_MAX; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (client_fds[i]!=<span class="number">0</span>) &#123;</span><br><span class="line">          send(client_fds[i], input_msg, BUFFER_SIZE, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (FD_ISSET(server_sock_fd, &amp;server_fd_set)) &#123;</span><br><span class="line">      <span class="comment">//有新的连接请求</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>;</span></span><br><span class="line">      <span class="keyword">socklen_t</span> address_len;</span><br><span class="line">      <span class="keyword">int</span> client_socket_fd = accept(server_sock_fd, (struct sockaddr *)&amp;client_address, &amp;address_len);</span><br><span class="line">      <span class="keyword">if</span> (client_socket_fd &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CONCURRENT_MAX; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (client_fds[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            index = i;</span><br><span class="line">            client_fds[i] = client_socket_fd;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;新客户端(%d)加入成功 %s:%d \n&quot;</span>,index,inet_ntoa(client_address.sin_addr),ntohs(client_address.sin_port));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          bzero(input_msg, BUFFER_SIZE);</span><br><span class="line">          <span class="built_in">strcpy</span>(input_msg, <span class="string">&quot;服务器加入的客户端数达到最大值,无法加入!\n&quot;</span>);</span><br><span class="line">          send(client_socket_fd, input_msg, BUFFER_SIZE, <span class="number">0</span>);</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;客户端连接数达到最大值，新客户端加入失败 %s:%d \n&quot;</span>,inet_ntoa(client_address.sin_addr),ntohs(client_address.sin_port));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;CONCURRENT_MAX; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (client_fds[i]!=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(client_fds[i], &amp;server_fd_set)) &#123;</span><br><span class="line">          <span class="comment">//处理某个客户端过来的消息</span></span><br><span class="line">          bzero(recv_msg, BUFFER_SIZE);</span><br><span class="line">          <span class="keyword">long</span> byte_num = recv(client_fds[i],recv_msg,BUFFER_SIZE,<span class="number">0</span>);</span><br><span class="line">          <span class="keyword">if</span> (byte_num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (byte_num &gt; BUFFER_SIZE) &#123;</span><br><span class="line">              byte_num = BUFFER_SIZE;</span><br><span class="line">            &#125;</span><br><span class="line">            recv_msg[byte_num] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端(%d):%s\n&quot;</span>,i,recv_msg);</span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span>(byte_num &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;从客户端(%d)接受消息出错.\n&quot;</span>,i);</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            FD_CLR(client_fds[i], &amp;server_fd_set);</span><br><span class="line">            client_fds[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端(%d)退出了\n&quot;</span>,i);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. client</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建需要通信的server socket的IP、端口等信息 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">server_addr.sin_len = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">server_addr.sin_family = AF_INET;</span><br><span class="line">server_addr.sin_port = htons(<span class="number">11332</span>);</span><br><span class="line">server_addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">bzero(&amp;(server_addr.sin_zero),<span class="number">8</span>);</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建socket通信连接 */</span></span><br><span class="line"><span class="comment">//创建socket</span></span><br><span class="line"><span class="keyword">int</span> client_socket = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (client_socket == <span class="number">-1</span>) &#123;</span><br><span class="line">  perror(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接client和server的通信道路</span></span><br><span class="line"><span class="keyword">int</span> connect_result = connect(client_socket, (struct sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(struct sockaddr_in));</span><br><span class="line"></span><br><span class="line"><span class="comment">//connect 成功之后，其实系统将你创建的socket绑定到一个系统分配的端口上，且其为全相关，包含服务器端的信息，可以用来和服务器端进行通信。</span></span><br><span class="line"><span class="keyword">char</span> recv_msg[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">char</span> reply_msg[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">if</span> (connect_result == <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    bzero(recv_msg, <span class="number">1024</span>);</span><br><span class="line">    bzero(reply_msg, <span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">long</span> byte_num = recv(client_socket, recv_msg, <span class="number">1024</span>, <span class="number">0</span>);</span><br><span class="line">    recv_msg[byte_num] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;server said:%s\n&quot;</span>,recv_msg);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client reply:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,reply_msg);</span><br><span class="line">    <span class="keyword">if</span> (send(client_socket, reply_msg, <span class="number">1024</span>, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">      perror(<span class="string">&quot;send error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="WIN"><a href="#WIN" class="headerlink" title="WIN"></a>WIN</h3><p>模仿Unix Socket技术实现</p><h4 id="操作流程-1"><a href="#操作流程-1" class="headerlink" title="操作流程"></a>操作流程</h4><img src="/2021/01/25/WebSocket/2.png" alt="截屏2021-01-31 下午2.57.07" style="zoom:45%;"> <h2 id="php"><a href="#php" class="headerlink" title="php"></a>php</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;h1 id=&quot;使用&quot;&gt;&lt;a href=&quot;#使用&quot; class=&quot;headerlink&quot; title=&quot;使用&quot;&gt;&lt;/a&gt;使用&lt;/h1&gt;&lt;p&gt;Web</summary>
      
    
    
    
    <category term="course" scheme="https://jieyang-wei.github.io/categories/course/"/>
    
    <category term="network" scheme="https://jieyang-wei.github.io/categories/course/network/"/>
    
    
    <category term="socket" scheme="https://jieyang-wei.github.io/tags/socket/"/>
    
  </entry>
  
  <entry>
    <title>C++</title>
    <link href="https://jieyang-wei.github.io/2021/01/23/C++/"/>
    <id>https://jieyang-wei.github.io/2021/01/23/C++/</id>
    <published>2021-01-23T10:13:55.000Z</published>
    <updated>2021-03-18T06:45:23.003Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h1 id="语法教程"><a href="#语法教程" class="headerlink" title="语法教程"></a>语法教程</h1><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><h3 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h3><p><strong>bool</strong></p><p><strong>char</strong></p><p><strong>int</strong></p><p><strong>float</strong></p><p><strong>double</strong></p><p><strong>void</strong></p><p><strong>wchar_t</strong></p><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p><a class="link" href="https://www.cnblogs.com/wuruofeng/p/10412559.html">char,char*,string转换<i class="fas fa-external-link-alt"></i></a></p><h3 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h3><p>枚举类型</p><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ofstream outfile;</span><br><span class="line"><span class="comment">/* 打开文件 */</span></span><br><span class="line">outfile.open(<span class="string">&quot;file.txt&quot;</span>, ios::out | ios::trunc ); <span class="comment">//模式结合</span></span><br><span class="line"><span class="comment">/* 关闭文件*/</span></span><br><span class="line">outfile.close();</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, ios::openmode mode)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>filename：要打开的文件的名称和位置（绝对路径）</p><blockquote><p>相对路径的位置取得是可执行文件的位置，而不是代码文件所在位置</p><ul><li><strong>xcode</strong>：<code>/Users/username/Library/Developer/Xcode/DerivedData/区块链-cwiqijiormracofndmvocmukooxi/Build/Products/Debug</code></li></ul></blockquote></li><li><p>mode：文件的打开模式（早期c++用ios代替ios_base）</p><ul><li><strong>ios::app</strong>      追加模式。所有写入都追加到文件末尾。</li><li><strong>ios::ate</strong>       文件打开后定位到文件末尾</li><li><strong>ios::in</strong>          打开文件用于读取（ifstream默认）</li><li><strong>ios::out</strong>       打开文件用于写入（ofstream默认）</li><li><strong>ios::trunc</strong>   如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0</li></ul><blockquote><p>ios是C++的一个类，ios_base是有关输入输出流的类的公共基类，<strong>ios</strong>继承了basic_ios类，而basic_ios又继承了<strong>ios_base</strong>，所以说ios_base也是ios类的间接基类。</p><ul><li>其中ios_base类具有静态常量in、out、binary等（在VS中ios_base类还有一个叫_Iosb的基类，这些静态成员在_Iosb中，但是C++标准没有这种说法），</li><li>ios_base类也是basic_ostream、basic_istream等多个类的直接或间接基类。从这个意义上，写ostream::binary什么的可能也没什么问题，但是习惯上都用ios::in、ios::binary，或者ios_base::in、ios_base::binary之类的。</li><li>所以，综上，ios类继承了ios_base类的静态成员变量in、out、binary等，所以既可以用ios，也可以用ios_base。望采纳。</li></ul></blockquote></li></ul><h3 id="ostream"><a href="#ostream" class="headerlink" title="ostream"></a>ostream</h3><p>该数据类型表示输出文件流，用于创建文件并向文件写入信息。</p><h3 id="istream"><a href="#istream" class="headerlink" title="istream"></a>istream</h3><p>该数据类型表示输入文件流，用于从文件读取信息。</p><h3 id="fstream"><a href="#fstream" class="headerlink" title="fstream"></a>fstream</h3><p>该数据类型通常表示文件流，且同时具有 ofstream 和 ifstream 两种功能</p><h3 id="文件夹"><a href="#文件夹" class="headerlink" title="文件夹"></a>文件夹</h3><p><a class="link" href="https://blog.csdn.net/nuptwanglei/article/details/43051643">函数说明<i class="fas fa-external-link-alt"></i></a></p><p><strong>opendir</strong>（打开目录）</p><ul><li>相关函数：open，readdir，closedir，rewinddir，seekdir，telldir，scandir </li><li>表头文件：<code>#include&lt;dirent.h&gt; </code></li><li>定义函数：<code>DIR * opendir(const char * name); </code></li><li>函数说明：<ul><li>opendir()用来打开参数name指定的目录，并返回DIR*形态的目录流，和open()类似，接下来对目录的读取和搜索都要使用此返回值。 </li></ul></li><li>返回值：成功则返回 *<em>DIR**</em> 型态的目录流，打开失败则返回NULL。 </li><li>错误代码<ul><li>EACCESS   权限不足</li><li>EMFILE      已达到进程可同时打开的文件数上限</li><li>ENFILE       已达到系统可同时打开的文件数上限</li><li>ENOTDIR   参数name非真正的目录 </li><li>ENOENT    参数name 指定的目录不存在，或是参数name 为一空字符串</li><li>ENOMEM  核心内存不足。</li></ul></li></ul><p><strong>readdir（读取目录）</strong></p><ul><li><p>相关函数：open，opendir，closedir，rewinddir，seekdir，telldir，scandir </p></li><li><p>表头文件：<code>#include&lt;dirent.h&gt; </code></p></li><li><p>定义函数：<code>struct dirent * readdir(DIR * dir); </code></p></li><li><p>函数说明：</p><ul><li><p>readdir()返回参数dir目录流的下个目录进入点。 </p></li><li><pre><code class="c++">struct dirent&#123;  ino_t d_ino;   //此目录进入点的inode  ff_t d_off;    //目录文件开头至此目录进入点的位移，当前目录下为0  signed short int d_reclen;  //d_name的长度，不包含NULL字符  unsigned char d_type;       //d_name 所指的文件类型  //DT_REG 文件    DT_DIR 文件夹  har d_name[256];  //文件名&#125;;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>返回值：成功则返回下个目录进入点。有错误发生或读取到目录文件尾则返回NULL。</p></li><li><p>错误代码</p><ul><li>EBADF   参数dir为无效的目录流</li></ul></li></ul><p><strong>closedir（关闭目录）</strong></p><ul><li>相关函数：opendir</li><li>表头文件：<code>#include&lt;dirent.h&gt; </code></li><li>定义函数：<code>int closedir(DIR *dir);</code></li><li>函数说明：closedir()关闭参数dir所指的目录流。</li><li>返回值：关闭成功则返回0，失败返回-1，错误原因存于errno 中</li><li>错误代码<ul><li>EBADF   参数dir为无效的目录流</li></ul></li></ul><p><strong>示例</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getFiles</span><span class="params">(<span class="keyword">char</span> *path, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; files)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dirp</span>;</span></span><br><span class="line">    DIR* dir = opendir(path);</span><br><span class="line">    <span class="keyword">while</span> ((dirp = readdir(dir)) != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dirp-&gt;d_type == DT_REG) &#123;</span><br><span class="line">            <span class="comment">// 文件</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, dirp-&gt;d_name);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dirp-&gt;d_type == DT_DIR) &#123;</span><br><span class="line">            <span class="comment">// 文件夹</span></span><br><span class="line">            <span class="comment">// getFiles(dirp-&gt;d_name, files);  //迭代</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    closedir(dir);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p><a class="link" href="https://blog.csdn.net/touzani/article/details/1637776">教程<i class="fas fa-external-link-alt"></i></a></p><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h1 id="资源库"><a href="#资源库" class="headerlink" title="资源库"></a>资源库</h1><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><h2 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h2><h3 id="lt-time-h-gt"><a href="#lt-time-h-gt" class="headerlink" title="&lt;time.h&gt;"></a>&lt;time.h&gt;</h3><p><strong>struct timespec</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">time_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _TIMESPEC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _TIMESPEC</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span></span><br><span class="line"><span class="keyword">time_t</span> tv_sec;  <span class="comment">// seconds </span></span><br><span class="line"><span class="keyword">long</span> tv_nsec;   <span class="comment">// nanoseconds, 纳秒</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>一般由函数<code>int clock_gettime(clock id_t, struct timespec*)</code>获取特定时钟的时间</p><ul><li><p>常用clock有如下4种：</p><ul><li><strong>CLOCK_REALTIME</strong>   统当前时间，从1970年1.1日算起</li><li><strong>CLOCK_MONOTONIC</strong>   系统的启动时间，不能被设置</li><li><strong>CLOCK_PROCESS_CPUTIME_ID</strong>   本进程运行时间</li><li><strong>CLOCK_THREAD_CPUTIME_ID</strong>     本线程运行时间</li></ul></li><li><p>函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct tm* <span class="title">localtime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">time_t</span>* clock)</span></span>;  <span class="comment">//线程不安全</span></span><br><span class="line"><span class="function">struct tm* <span class="title">localtime_r</span><span class="params">(<span class="keyword">const</span> <span class="keyword">time_t</span>* timer, struct tm* result )</span></span>;<span class="comment">//线程安全</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">strftime</span><span class="params">(<span class="keyword">char</span>* ptr, <span class="keyword">size_t</span> maxsize, <span class="keyword">const</span> <span class="keyword">char</span>* format, <span class="keyword">const</span> struct tm* timeptr )</span></span>;</span><br></pre></td></tr></table></figure></li></ul><p><strong>struct timeval</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line"><span class="keyword">time_t</span> tv_sec;  <span class="comment">// seconds </span></span><br><span class="line"><span class="keyword">long</span> tv_usec;   <span class="comment">// microseconds </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timezone</span>&#123;</span> </span><br><span class="line"><span class="keyword">int</span> tz_minuteswest; <span class="comment">//miniutes west of Greenwich </span></span><br><span class="line"><span class="keyword">int</span> tz_dsttime; <span class="comment">//type of DST correction </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一般由函数<code>int gettimeofday(struct timeval* tv, struct timezone* tz)</code>获取系统的时间 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;h1 id=&quot;语法教程&quot;&gt;&lt;a href=&quot;#语法教程&quot; class=&quot;headerlink&quot; title=&quot;语法教程&quot;&gt;&lt;/a&gt;语法教程&lt;/h</summary>
      
    
    
    
    <category term="notebook" scheme="https://jieyang-wei.github.io/categories/notebook/"/>
    
    
    <category term="C++" scheme="https://jieyang-wei.github.io/tags/C/"/>
    
    <category term="编程语言" scheme="https://jieyang-wei.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>毕业设计</title>
    <link href="https://jieyang-wei.github.io/2021/01/04/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    <id>https://jieyang-wei.github.io/2021/01/04/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/</id>
    <published>2021-01-04T11:03:58.000Z</published>
    <updated>2021-03-16T02:25:08.002Z</updated>
    
    <content type="html"><![CDATA[<h1 id="例会"><a href="#例会" class="headerlink" title="例会"></a>例会</h1><h2 id="2021-1-4-A"><a href="#2021-1-4-A" class="headerlink" title="2021.1.4 - A"></a>2021.1.4 - A</h2><h3 id="A-Mixing-Scheme-Using-a-Decentralized-Signature-Protocol-for-Privacy-Protection-in-Bitcoin-Blockchain"><a href="#A-Mixing-Scheme-Using-a-Decentralized-Signature-Protocol-for-Privacy-Protection-in-Bitcoin-Blockchain" class="headerlink" title="A Mixing Scheme Using a Decentralized Signature Protocol for Privacy Protection in Bitcoin Blockchain"></a>A Mixing Scheme Using a Decentralized Signature Protocol for Privacy Protection in Bitcoin Blockchain</h3><p>BTC的匿名性保证 - 混币服务器</p><p>现有</p><ul><li><p><strong>Coinjoin</strong></p></li><li><p><strong>Coin Shuffle</strong>：Cut the connection between input address and output address</p></li><li><p><strong>Altcoin</strong></p></li><li><p><strong>Blind token</strong></p></li></ul><blockquote><p>现在的BTC系统，因为服务器节点远近问题，一个交易发布后会先被距离近的节点捕捉到，此时可以通过交易的时间未知等细节信息，定位到交易的ip地址，最后根据ip地址可以在线下找出交易双方的真实身份信息</p></blockquote><p>通过协商实现交易</p><h3 id="Differential-Privacy-Based-Blockchain-for-Industrial-Internet-of-Things"><a href="#Differential-Privacy-Based-Blockchain-for-Industrial-Internet-of-Things" class="headerlink" title="Differential Privacy-Based Blockchain for Industrial Internet-of-Things"></a>Differential Privacy-Based Blockchain for Industrial Internet-of-Things</h3><p>区块链边缘计算应用在物联网上的隐私保护</p><ul><li>边缘节点</li><li>拆分隐私处理</li></ul><h2 id="2021-1-11-A-B"><a href="#2021-1-11-A-B" class="headerlink" title="2021.1.11 - A + B"></a>2021.1.11 - A + B</h2><h3 id="自主可控区块链关键技术"><a href="#自主可控区块链关键技术" class="headerlink" title="自主可控区块链关键技术"></a>自主可控区块链关键技术</h3><p>区块链上升国家战略</p><p><strong>挑战</strong></p><ul><li>如何解决高效自主共识协议的一致性问题，缩短区块链网络中共识时间延时</li><li>数据自主存储的空间问题，在公有链环境下，比特币2019年已达到240G的存储空间，每年以50GB的增长</li><li>多链的跨链的自主交互问题，各种不同类型的区块链平台产生数据孤岛和价值孤岛问题</li></ul><p><strong>三大技术</strong></p><ol><li>数据保全 - 密码算法</li><li>共识算法<ol><li>PoW</li><li>新型共识机制 - 易构共识</li></ol></li><li>智能合约</li></ol><h3 id="预言机"><a href="#预言机" class="headerlink" title="预言机"></a>预言机</h3><p>4种推拉方式</p><h1 id="研读论文"><a href="#研读论文" class="headerlink" title="研读论文"></a>研读论文</h1><h2 id="1、Conflux共识机制"><a href="#1、Conflux共识机制" class="headerlink" title="1、Conflux共识机制"></a>1、Conflux共识机制</h2><p>Scaling Nakamoto Consensus to Thousands of Transactions per Second</p><p>最近arXiv上发现一篇论文（2018/8/2发表，”Scaling Nakamoto Consensus to Thousands of Transactions per Second”），作者来自清华大学，卡内基梅隆大学，以及多伦多大学，提出了<strong>Conflux共识机制</strong></p><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>本文提出了一个快速、可扩展和去中心化的区块链系统Conflux，它乐观地处理并发块而不丢弃任何as叉。conflux共识协议将块之间的关系表示为一个直接的非循环图，并在块的总顺序上达成共识。然后，Conflux从区块顺序确定地推导出transactiontotal顺序作为区块链分类帐。我们在Amazon EC2集群上评估了高达20k的全节点的Con-flux。Conflux在4.5-7.4分钟内实现了5.76GB/h的事务吞吐量。对于典型的比特币交易来说，其吞吐量相当于每秒6400笔交易。我们的结果还表明，<strong>当运行Conflux时，共识协议不再是吞吐量的瓶颈。相反，瓶颈在于单个节点的处理能力</strong></p><h2 id="2、区块链共识算法效能优化研究进展"><a href="#2、区块链共识算法效能优化研究进展" class="headerlink" title="2、区块链共识算法效能优化研究进展"></a>2、区块链共识算法效能优化研究进展</h2><h3 id="摘要-1"><a href="#摘要-1" class="headerlink" title="摘要"></a>摘要</h3><p>近年来，区块链及其相关技术发展迅速，区块链也迅速成为了学术界的热门领域。然而，<strong>区块链的共识算法在资源花销、能源耗费和性能上都饱受诟病，因此需要制定一个能衡量其执行效率的指标，以评价其设计是否优良</strong>。由于共识算法的资源花销、能源耗费以及性能之间相互关联且关系复杂，因此有必要从“效能”的角度对现有区块链的共识算法加以分析，并总结 研究思路。文中总结了区块链共识算法的效能优化研究进展。首先定义区块链共识算法的效能为“在正确性和有效性的前提 下计算的共识算法<strong>性能、所需资源和能源消耗</strong>”，并分析这3个影响因素的关联;然后从公有链与联盟链两方面对共识算法的效 能优化进行整理与总结;最后从多链区块链、多个区块链与 BaS这3个方面提出关于共识算法的资源共享问题，以供研究人员 参考。</p><h2 id="3、区块链共识机制综述"><a href="#3、区块链共识机制综述" class="headerlink" title="3、区块链共识机制综述"></a>3、区块链共识机制综述</h2><h3 id="摘要-2"><a href="#摘要-2" class="headerlink" title="摘要"></a>摘要</h3><p>区块链能够有效融合物联网、5G、大数据和人工智能等技术，在新型基础设施建设中具有重要作用。共识机制作为区块链的核心技术，能够保障区块链数据库的一致性和正确性，从而决定区块链的安全性、扩展性、吞吐量等相关性能。根据区块链共识机制的技术路线，将其细分为 3 类单一共识机制和 6 类混合共识机制。从原理实现角度，系 统描述共识机制的理论技术，归纳节点达成一致所需的运算操作并评价共识机制的优缺点。从工程应用角度，具体分 析共识机制的应用情况，介绍区块链项目并对比共识机制的关键性能。针对现有共识机制研究中存在的能耗与效率 问题给出相应的解决方案，并对其奖惩制度、网络分片与存储分片技术等下一步研究方向进行展望</p><h2 id="4、-区块链技术及应用研究综述"><a href="#4、-区块链技术及应用研究综述" class="headerlink" title="4、 区块链技术及应用研究综述"></a>4、 区块链技术及应用研究综述</h2><h3 id="摘要-3"><a href="#摘要-3" class="headerlink" title="摘要"></a>摘要</h3><p>针对区块链可构建信任和传递价值特性，从数据层面、财务层面、应用层面、体制 层面等多角度研究区块链技术及应用价值重构，对利用区块链技术在数字资产存证、保护 用户隐私、 数字资源流通、 <strong>跨部门信息系统互联与数据可信共享</strong>等应用场景研究进行综述，形成基于区块链的安全可信、稳定可靠、高效便捷的应用场景和模式，为区块链技术与各领域深度融合的技术路径创新与数据价值重构提供一定的借鉴参考。</p><p>共识机制解决全网节点之间数据验证同步和激励相融问题。 目前主流的共识机制有四种:PoW、 PoS，DPoS、PBFT。</p><ol><li>PoW 机制<ul><li>PoW 是最经典的共识机制. 基于给定难度值在 最快时间通过迭代计算得到一个随机数 Nonce 以 争夺记账权， 对获得优先记账权的节点给予一定激 励。 PoW 共识流程如图 4 所示。</li></ul></li><li>PoS 机制<ul><li>PoS 通过计算全网节点的持有币量和持币时间 来决定投票权和打包权。 拥有打包权的节点打包交 易后对全网广播， 拥有投票权的节点投票决定最终上链的区块， 根据每个节点持有币量和持币时间等 比例降低计算随机数的难度。</li></ul></li><li>DPoS 机制<ul><li>DPoS 是 PoS 的升级版， 由全网普通节点投票 选出一些代理节点进行交易验证和记账， 代理节点 完成共识后会获得一定数量的激励， 不合格的代理 节点会被投票替换。</li></ul></li><li>PBFT 算法<ul><li>PBFT 广泛使用于联盟链，是一种能容忍全网 1 / 3 节点出现错误或异常的分布式系统共识算法， 该算法依赖节点对同一信息的多次重复确认， 从而 达到全网共识。</li></ul></li></ol><p><strong>电子政务领域</strong>：</p><p>通过区块链技术将数据、信息上链，实现对数据的记录和追踪， 能缩短行政办公周期， 加快资金流动， 对于提升政府公共服务管理水平和政府办公效率具有重要的意义。 目前基于区块链的电子政务场 景主要集中在政务服务、综合监管、智慧法院、数字 身份等领域。</p><h2 id="5、物联网中区块链的轻量级共识机制"><a href="#5、物联网中区块链的轻量级共识机制" class="headerlink" title="5、物联网中区块链的轻量级共识机制"></a>5、物联网中区块链的轻量级共识机制</h2><p>A lightweight consensus mechanism for blockchain in IoT</p><h3 id="摘要-4"><a href="#摘要-4" class="headerlink" title="摘要"></a>摘要</h3><p>在物联网应用中，区块链消除了对单一可信权威的依赖，增强了潜在的可伸缩性和可靠性。区块链中使用的现有共识方法需要较高的能量消耗、具有可信权威的巨大计算能力或挖掘区块的证据。资源受限的物联网设备需要一种轻量级和低延迟的共识机制。与绝对共识方法相比，无信任概率共识方法允许每个节点都参与共识，增强了事务的鲁棒性和可靠性。对于物联网环境中的非合作区块链，我们提出了一种轻量级的耗时工作和运气(PoEWAL)一致性证明方法。PoEWAL消耗更少的能量，需要更少的计算能力和低延迟。我们利用康智奇库雅模拟器分析了PoEWAL在资源受限设备中的适用性。实验结果表明，在不同的难度水平下，能量消耗都很低，证明了PoEWAL的可行性。将PoEWAL与现有的概率共识方法如工作证明、权益证明、活动证明、algorand、权威证明等在能量、共识时间、网络延迟等方面进行比较，确认PoEWAL是适用于物联网区块链的共识方法。</p><h2 id="6、一种基于改进遗传算法的共识机制"><a href="#6、一种基于改进遗传算法的共识机制" class="headerlink" title="6、一种基于改进遗传算法的共识机制"></a>6、一种基于改进遗传算法的共识机制</h2><p>A Consensus Mechanism Based on an Improved Genetic Algorithm</p><h3 id="摘要-5"><a href="#摘要-5" class="headerlink" title="摘要"></a>摘要</h3><p><strong>区块链技术的一个重要特点是所有参与者共同维护事务数据，无需集成控制就可以实现相互信任关系，这依赖于分布式共识算法</strong>。实用拜占庭容错算法(PBFT)是一种基于状态机复制的容错算法，它解决了拜占庭错误，即节点的恶意行为。在PBFT中，所有参与节点分为主节点和备份节点。当这个主节点提交错误或失败时，它将再次选择一个主节点进行消息通信。遗传算法(GA)是受自然生物遗传进化准则“自然选择，生存拟合检验”启发而提出的一种计算机模拟研究方法。遗传算法实际上是一种寻找最优解的方法。据此，在PBFT算法中选择最佳主节点，以提高一致性效率。<strong>共识算法是区块链技术中去中心化特性的保证</strong>。PBFT算法是一种常用的共识算法。但该算法存在如下问题:当主节点发生故障时，必须重新选择该节点，导致协商效率降低。提出了一种基于改进遗传算法的一致性机制，利用改进的遗传算法来选择主节点。根据遗传算法选择最佳的主节点，使其与其他备份节点的交易效率达到最高。改进的一致性算法可以有效地减少系统延迟，提高一致性效率。</p><h2 id="7、pbft启发的区块链共识和Neo-dBFT增强的挑战"><a href="#7、pbft启发的区块链共识和Neo-dBFT增强的挑战" class="headerlink" title="7、pbft启发的区块链共识和Neo dBFT增强的挑战"></a>7、pbft启发的区块链共识和Neo dBFT增强的挑战</h2><p>Challenges of PBFT-Inspired Consensus for Blockchain and Enhancements over Neo dBFT</p><h3 id="摘要-6"><a href="#摘要-6" class="headerlink" title="摘要"></a>摘要</h3><p><strong>共识机制是处理谈判和协议的核心特征</strong>。区块链技术已经引入了不同类型的共识机制，从繁重的计算任务到错综复杂的数学证明协议。本文从实际的拜占庭容错(PBFT)中得到启发，提出了Neo区块链的先驱代理拜占庭容错(dBFT)协议。除了介绍它的历史，本研究描述了证明和说教的例子，以及新颖的设计和扩展Neo dBFT与多个区块的建议。最后，我们讨论了在处理强大的拜占庭对手时所面临的挑战，并针对当前的弱同步问题和增强系统抗攻击的鲁棒性提出了PBFT启发的解决方案。<strong>主要贡献</strong>:概述了pbft启发的区块链共识的历史，强调了其目前在文献、挑战和假设方面的重要性。在分布式共识领域做出贡献，提出了Neo dBFT (dBFT 2.0+、dBFT 3.0和dBFT 3.0+)的新扩展，对创新共识机制有新的见解。</p><h2 id="8、区块链原理及关键技术"><a href="#8、区块链原理及关键技术" class="headerlink" title="8、区块链原理及关键技术"></a>8、区块链原理及关键技术</h2><h3 id="摘要-7"><a href="#摘要-7" class="headerlink" title="摘要"></a>摘要</h3><p>区块链是综合运用密码学、分布式数据库、P2P 通信、智能合约等的技术，在一个去中心化、去信任网络中，利用加密算法在链式数据结构中验证和存储数据。区块链技术是一项具有普适性的底层技术架构，它通过共识机制在分布式节点上生成和同步数据，借助可编程脚本实现合约条款的自动执行和数据操作。对区块链进行系统梳理并对其关键技术元素进行解构，在此前提下，从体系结构和实现协议入手分析了区块链系统的基础架构，以区块链技术的应用发展为脉络，主要结合比特币、以太坊和超级账本应用场景，对其技术原理、 实现路径、应用现状和存在的挑战进行了阐述。力求为读者在系统学习区块链技术的基础上致力于更深入的 研究提供帮助和借鉴。</p><h2 id="9、区块链技术发展综述及其政务领域应用研究"><a href="#9、区块链技术发展综述及其政务领域应用研究" class="headerlink" title="9、区块链技术发展综述及其政务领域应用研究"></a>9、区块链技术发展综述及其政务领域应用研究</h2><h3 id="摘要-8"><a href="#摘要-8" class="headerlink" title="摘要"></a>摘要</h3><p>区块链是密码技术应用发展的重要里程碑,其技术特点及优势颠覆了传统管理思维与治理模式,有助于推动信任模式与管理机制的重构与优化,为建立新型的政府数据治理体系提供经验与启示.全面评述了区块链技术的起源、演进、发展和兴起历程,审视其核心思想与设计理念,对其核心技术、要素规则、基础架构分别作了比较与概括;从用例设计角度阐述了区块链技术在机关公文运转、信息资源目录、网上政务服务等政务领域典型场景的应用;总结了区块链技术在政务领域应用的愿景、问题与原因,并提出一些方向性的思考与展望</p><h2 id="————-New-———"><a href="#————-New-———" class="headerlink" title="————- New ———-"></a>————- New ———-</h2><h2 id="1、一种基于USBKey的区块链云存储方法-梁宵"><a href="#1、一种基于USBKey的区块链云存储方法-梁宵" class="headerlink" title="1、一种基于USBKey的区块链云存储方法_梁宵"></a>1、一种基于USBKey的区块链云存储方法_梁宵</h2><p>将共享数据拆分成多分，分别存放在多个云端，同时将拆分索引加密后上链</p><p>使得数据的存储位置信息可靠、可信</p><p>节点只需要请求链上的数据索引，即可根据索引目录获得云端数据</p><h2 id="2、基于区块链的可信数据交换技术与应用-梁伟"><a href="#2、基于区块链的可信数据交换技术与应用-梁伟" class="headerlink" title="2、基于区块链的可信数据交换技术与应用_梁伟"></a>2、基于区块链的可信数据交换技术与应用_梁伟</h2><p>将数据加密后的密文上链，客户端只能得到加密后的数据，客户端再通过数据双方协商的加解密格式对加密后的数据进行解密，便可得到原始数据</p><p>使得原始数据在链上是不可见的</p><h2 id="3、跨区块链的数据访问"><a href="#3、跨区块链的数据访问" class="headerlink" title="3、跨区块链的数据访问"></a>3、跨区块链的数据访问</h2><p>跨区块链的数据访问方法、装置、系统及计算机可读介质与流程</p><p><a class="link" href="http://mip.xjishu.com/zhuanli/62/201810091905.html">http://mip.xjishu.com/zhuanli/62/201810091905.html<i class="fas fa-external-link-alt"></i></a></p><h2 id="4、Achain-跨链技术实现区块链价值信息交"><a href="#4、Achain-跨链技术实现区块链价值信息交" class="headerlink" title="4、Achain:跨链技术实现区块链价值信息交"></a>4、Achain:跨链技术实现区块链价值信息交</h2><p><a class="link" href="https://www.sohu.com/a/243006457_100190787">https://www.sohu.com/a/243006457_100190787<i class="fas fa-external-link-alt"></i></a></p><p>以太坊创始人V神最早在R3联盟发言时表明目前主流的跨链技术包括：公证人机制（Notary schemes）；侧链/中继（Sidechains/relays）；哈希锁定（Hash-locking）；分布式私钥控制（Distributed private key control）</p><p>VEP（Value Exchange Protocol）是不同区块链网络之间链接的标准协议</p><p>假设我们把一个区块链网络当做节点，多个区块链网络之间形成连接，那么我们也需要一个新的共识机制。诚然区块链的可靠性体现在分布式的账本和分布式共识，很多人认为既然区块链已经做到公开透明，信息交互的跨链不需要其他的共识机制。</p><p>但大家往往忽略了其中最重要的一点：不同网络的平等性、可信度、利益诉求让网络协作变得困难，其次在区块链的运作模式中总会有坏节点存在。<strong>在有矛盾、有冲突需要讨论的地方，就需要一套新的共识，一套新的预定规则，这就如同现实世界中跨组织写作的法律、契约等约束。</strong></p><h2 id="5、An-Achieving-Data-Exchange-Cross-Chain-Alliance-Protocol"><a href="#5、An-Achieving-Data-Exchange-Cross-Chain-Alliance-Protocol" class="headerlink" title="5、An Achieving Data Exchange Cross-Chain Alliance Protocol"></a>5、An Achieving Data Exchange Cross-Chain Alliance Protocol</h2><ul><li>为区块链之间建立和通信跨链联盟提供了一种方法和系统</li><li>根据通信需求，为每个节点建立跨链联盟，建立跨链联盟智能合约，并配置跨链联盟中每个节点的身份证书和交易证书，从而实现跨链联盟的建立，即<strong>跨链联盟</strong><ol><li>获取多个区块链中各通信节点的通信需求</li><li>根据通信需求，为不同区块链上属于通信需求的每个节点建立跨链联盟，并为每个节点配置身份证书和交易证书。</li><li>根据通信需求，为跨链联盟建立跨链智能合约</li></ol></li></ul><ul><li>建立跨链联盟的方法包括:获取多个区块链中各通信节点的通信需求，各节点建立跨链联盟，配置身份证书和交易证书，建立跨链智能合约。</li><li>区块链跨链通信方法包括:利用上述建立的跨链联盟中的每个区块链获取通信请求，并为每个节点建立节点智能合约;如果发起了通信请求，首先对通信请求进行背书策略验证，然后对通信请求进行全序列签名验证和数据一致性验证，验证通信请求后，根据跨链智能合约实现节点间通信。</li></ul><h2 id="6、Cross-blockchain-protocol-for-public-registries"><a href="#6、Cross-blockchain-protocol-for-public-registries" class="headerlink" title="6、Cross-blockchain protocol for public registries"></a>6、Cross-blockchain protocol for public registries</h2><h2 id="7、A-Novel-Cross-Chain-Mechanism-for-Blockchains"><a href="#7、A-Novel-Cross-Chain-Mechanism-for-Blockchains" class="headerlink" title="7、A Novel Cross-Chain Mechanism for Blockchains"></a>7、A Novel Cross-Chain Mechanism for Blockchains</h2><p>主要是跨链的数据隐私保护模型</p><ul><li>提出了一种新型的跨链机制，通过添加到应用程序中的插件提供不同区块链之间的互连。</li><li>我们引入了膜的概念，便于描述交叉链的机理。</li></ul><p>提出一个区块链是一个网络膜（新概念），快链交互就是跨膜交互，给出一种机制帮助完成跨链</p><h1 id="弃-政务链上交易共识算法研究与应用"><a href="#弃-政务链上交易共识算法研究与应用" class="headerlink" title="(弃)政务链上交易共识算法研究与应用"></a>(弃)政务链上交易共识算法研究与应用</h1><h2 id="开题"><a href="#开题" class="headerlink" title="开题"></a>开题</h2><h3 id="1、任务书"><a href="#1、任务书" class="headerlink" title="1、任务书"></a>1、任务书</h3><h4 id="进度安排"><a href="#进度安排" class="headerlink" title="进度安排"></a>进度安排</h4><h4 id="任务目的与要求"><a href="#任务目的与要求" class="headerlink" title="任务目的与要求"></a>任务目的与要求</h4><h3 id="2、开题报告"><a href="#2、开题报告" class="headerlink" title="2、开题报告"></a>2、开题报告</h3><p>选择近五年的论文，或者是学术史上经典的论文参考</p><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>随着新基建技术的发展，区块链技术也得到日益广泛的应用。在现如今的网络大环境下，区块链凭着自己的去中心化、不可篡改等特点，在政务领域中逐步开始应用，而其中节点之间的共识算法成为政务链体系研究中的热门议题。<br>在政务链体系中各节点之间达成共识的特殊性，一个节点项目的产生，往往需要经过链上多方节点核实，各个独立的而有相互不可分割的部门都需要自动、高效地处理这一过程，从而达到共识。本课题的主要任务是针对政务链上节点共识的要求，设计出一款安全，可靠，高效的共识算法。</p><p>针对政务领域中节点之间的达成共识往往需要经过链上多方节点核实，但实时性要求较高，达成分歧较大的痛点问题；如何根据政务链应用的业务求，设计一款安全、高效的共识算法，使得各个独立而又相互不可分割的部门能自动、高效地处理这一过程，从而实现业务应用的有效执行</p><h4 id="现状和发展趋势"><a href="#现状和发展趋势" class="headerlink" title="现状和发展趋势"></a>现状和发展趋势</h4><p>共识机制是特殊节点的投票，在很短的时间内完成对交易的验证和确认；对一笔交易，如果利益不相干的若干个节点能够达成共识，我们就可以认为全网对此也能够达成共识。再通俗一点来讲，如果中国一名微博大V、美国一名虚拟币玩家、一名非洲留学生和一名欧洲旅行者互不相识，但他们都一致认为你是个好人，那么基本上就可以断定你这人还不坏。（摘自百度百科）</p><p>从本质上讲，公有、私有和联盟链并不矛盾，它们只是使用了不同的技术：</p><ul><li>精心设计的公有链在防审计性方面往往更具优势，但代价是速度和吞吐量较低。这些是对交易结算（或智能合约）提供安全性保证的最佳选择。</li><li>私有链可以优先考虑系统的速度，因为它无需像公共区块链那样担心核心故障。理想情况下，将私有链部署在个人或组织可控且信息保密的情况下。</li><li>联盟链可减轻私有链中交易对手的风险（通过消除集中控制），并且较少的节点数通常可使它们能够比公共链更有效率的运行。联盟链适合于彼此之间需要相互沟通的单位组织。</li></ul><h4 id="重难点和拟采用途径"><a href="#重难点和拟采用途径" class="headerlink" title="重难点和拟采用途径"></a>重难点和拟采用途径</h4><p>数图公链 -&gt; 政务联盟链</p><p>节点机</p><p>两个指针</p><p>交易所-效率高</p><p>达成共识-</p><p>服务于应用</p><p>模版</p><p>政务场景下达成共识设计</p><p><strong>项目招标：</strong></p><ul><li><p><strong>区块链底层基础平台</strong></p><ul><li>共识系统</li></ul></li><li><p><strong>区块链能力增强系统</strong></p><ul><li>高性能共识算法：针对现有共识系统吞吐量低下、交易确认时间长、应用场景受限等问题，突破区块链在交易共识过程中的性能瓶颈，提高全网交易吞吐量</li></ul></li></ul><h1 id="New-云链数据交换模型"><a href="#New-云链数据交换模型" class="headerlink" title="(New)云链数据交换模型"></a>(New)云链数据交换模型</h1><h2 id="开题-1"><a href="#开题-1" class="headerlink" title="开题"></a>开题</h2><p>提出、参考已有方法、自己解决的方法问题</p><p>复现别人的（跨链比较好找）</p><p>模型主要就是 - 数据存取</p><p>现有的区块链相关的数据交换都是通过区块链结构来完成可信数据交换，侧重点在于数据的可信度及隐私保护</p><p>本课题要讨论的则是一种使得链上(联盟链)数据可以安全交换的模型</p><p>设计一种前置机的东西，隔离政务内外网，隔离原始数据和链数据</p><p>如果存储数据索引，则可以攻击原始数据库</p><ul><li>所以根据链上数据不可篡改原则，考虑将数据索引和加密数据验证一同存储在链上，这样在取得数据后，还需要获得节点进行数据验证，以确保数据的准确性</li></ul><p>1、云链数据交换中，子链的前置节点机，存储的目录、索引，经常使用的数据（最近未使用替换算法），需要保障读数据的隐私保护（RSA，加密算法）；</p><p>2、基于政务业务的<strong>自组织政务链</strong>的智能合约，实时响应相关的业务需求；</p><p>主链：公信力（前置机如果只放在子链上，则没有公信力）</p><p>存日志信息</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>政务链：主侧链</p><p>业务给予web程序，链上只考虑数据流通和交换，考虑链上数据的不可篡改性，将数据操作存储在链上</p><p>真实的数据存储在云端，通过前置机与各节点间进行交换</p><p>通过智能合约的模式，使得原始数据不可见的，只返回业务执行结果</p><ul><li>需要证明结果确实是此数据跑出来的</li></ul><p>既节点1想要访问节点2管理的数据，需要</p><p>数据库的分布，需要维护数据的索引，</p><p>主链上的节点维护自己的CA，提供给节点所属侧链</p><p>主链上再维护一个给主链节点提供的CA</p><h2 id="论文撰写"><a href="#论文撰写" class="headerlink" title="论文撰写"></a>论文撰写</h2><h2 id="材料"><a href="#材料" class="headerlink" title="材料"></a>材料</h2><p><a class="link" href="https://www.jianshu.com/p/7d0a9b211de7">SmartBlock 2018区块链论文合集<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;例会&quot;&gt;&lt;a href=&quot;#例会&quot; class=&quot;headerlink&quot; title=&quot;例会&quot;&gt;&lt;/a&gt;例会&lt;/h1&gt;&lt;h2 id=&quot;2021-1-4-A&quot;&gt;&lt;a href=&quot;#2021-1-4-A&quot; class=&quot;headerlink&quot; title=&quot;2021.</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>计算机基础</title>
    <link href="https://jieyang-wei.github.io/2020/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    <id>https://jieyang-wei.github.io/2020/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/</id>
    <published>2020-12-23T01:18:40.000Z</published>
    <updated>2021-03-18T06:44:50.427Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机发展"><a href="#计算机发展" class="headerlink" title="计算机发展"></a>计算机发展</h1><p>专用计算机：凯撒密码徽章，算盘</p><p>1946：宾夕法尼亚研究的第一台电子计算机</p><p>求 pai</p><p>密码学：</p><h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><p>二进制编辑器：file info</p><p>Bmp：位图文件，没有压缩的原始文件</p><ul><li>jpg：是压缩之后的</li><li>文件前缀是BM(424d)，可以用二进编辑器打开</li><li>格式：（找到文档规范就能找到）<ul><li>源信息：BM 文件大小 空字节 … 宽 高 … </li><li>数据信息</li></ul></li></ul><p>文件类型：</p><ul><li>私有文件，不能对外交换信息</li><li>通用数据格式文件<ul><li>找到数据规范，就可以解析这个文件</li><li>去掉文件头，别人就打不开了</li><li>bmp，jpg，mp3等</li></ul></li></ul><p>vim -b  filename</p><p>:!xxde</p><h1 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h1><p>dapp：完全分布式的</p><p>中心服务器，单点故障</p><p>混合架构：查询/目录服务器</p><p><strong>完全分布式的</strong>：种子</p><ul><li>共享文件</li><li>种子会记录那些人的电脑里会有这些文件，<ul><li>雷达：主动搜索资源</li><li>种子：定向下载资源</li></ul></li><li>发布种子的人的网络地址，和发布的人对文件分片的每一篇的uri</li><li>唯一的uri标示一个唯一的资源，但可能很多个机器里都有<ul><li>bt://202.103.5.8:8909/asdas:00</li><li>bt://202.103.5.8:8909/asdas:01</li></ul></li><li>种子主要解决第一次连接的问题，一旦第一个连接了，就能知道还有其他那些可以连了</li><li>BT很特殊，不仅有ip等还有文件资源</li></ul><p> 广播：树/图/线/双向链/交叉链等</p><ul><li>线性：<strong>可控性</strong>强，效率低</li><li>非结构化的：可控性差</li><li><strong>结构化</strong>：基于hash，树的之类的</li></ul><h1 id="软件开发"><a href="#软件开发" class="headerlink" title="软件开发"></a>软件开发</h1><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p><strong>CLI</strong>：Command-Line interface - 命令行界面</p><p><strong>GUI</strong>：Graphical User Interface - 用户图形界面</p><h2 id="SDK"><a href="#SDK" class="headerlink" title="SDK"></a>SDK</h2><p>Software Development Kit - 软件开发工具包</p><ul><li>辅助开发某一类软件的相关文档、范例和工具的集合都可以叫做SDK。</li></ul><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><ul><li>我把软件A里你需要的功能打包好，写成一个函数。你按照我说的流程，把这个函数放在软件B里，就能直接用我的功能了！</li><li>软件A -&gt; 配置环境 -&gt; 构建函数 -&gt; 安装jar包 -&gt; 软件B中使用</li></ul><blockquote><p>如果把SDK想象成一个虚拟的程序包，在这个程序包中有一份做好的软件功能，这份程序包几乎是全封闭的，只有一个小小接口可以联通外界，这个接口就是API。</p></blockquote><h1 id="软件管理"><a href="#软件管理" class="headerlink" title="软件管理"></a>软件管理</h1><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><ul><li>一个开源的应用容器引擎，基于 Go 语言并遵从Apache2.0协议开源。</li><li>可以让开发者将应用和依赖包打包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</li><li>容器完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 App），更重要的是容器性能开销极低。</li></ul><p>Docker 包括三个基本概念:</p><ul><li><strong>镜像（Image）</strong>：相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。比如说nginx,mysql,redis等软件可以做成一个镜像。</li><li><strong>容器（Container）</strong>：容器可以被创建、启动、停止、删除、暂停等。</li><li><strong>仓库（Repository）</strong>：一个代码控制中心，用来保存镜像。DockerHub 是一个由 Docker 公司运行和管理的基于云的存储库。它是一个在线存储库，Docker 镜像可以由其他用户发布和使用。有两种库：公共存储库和私有存储库。如果你是一家公司，你可以在你自己的组织内拥有一个私有存储库，而公共镜像可以被任何人使用。</li></ul><p>刚开始使用，尽可能的会使用，了解其解决什么痛点，随着我们使用的深入，逐步了解其原理和结构是如何实现的。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol><li><p>使用Homebrew - for Mac</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Homebrew v2.x</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> brew cask install --appdir=<span class="string">&quot;/Applications&quot;</span> docker</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Homebrew v3.x:</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> brew install --cask --appdir=<span class="string">&quot;/Applications&quot;</span> docker</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> open it</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> open /Applications/Docker.app</span></span><br></pre></td></tr></table></figure></li><li><p>官方下载Docker Desktop for Mac</p></li><li><p>镜像下载dmg文件</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">http</span>://<span class="selector-tag">mirrors</span><span class="selector-class">.aliyun</span><span class="selector-class">.com</span>/<span class="selector-tag">docker-toolbox</span>/<span class="selector-tag">mac</span>/<span class="selector-tag">docker-for-mac</span>/</span><br></pre></td></tr></table></figure></li></ol><p>版本查看</p><h3 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h3><p>docker镜像在国外，为了后续下载加速，配置文件将镜像换成国内的</p><ul><li>在<code>/etc/docker/daemon.json</code>文件中配置或者如下图所示在软件中配置</li><li><code>&#123;&quot;registry-mirrors&quot;:[&quot;https://reg-mirror.qiniu.com/&quot;]&#125;</code>（可以在网上查找其他国内镜像源）</li></ul><img src="/2020/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/截屏2021-03-07 下午9.55.31.png" alt="截屏2021-03-07 下午9.55.31" style="zoom:60%;"><p>镜像源是否成功替换：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker info</span></span><br><span class="line"> Registry Mirrors:</span><br><span class="line">  https://reg-mirror.qiniu.com/</span><br></pre></td></tr></table></figure><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p><strong>镜像操作</strong></p><ol><li><strong>login</strong></li></ol><ol start="2"><li><strong>pull</strong></li></ol><ol start="3"><li><strong>push</strong></li></ol><h2 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a>Homebrew</h2><p>Mac OS下的强大的软件包管理工具</p><p><strong>下载</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew install name</span></span><br></pre></td></tr></table></figure><p><strong>更新</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew update</span></span><br></pre></td></tr></table></figure><p><strong>操作</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew --version   <span class="comment">#版本查看</span></span></span><br></pre></td></tr></table></figure><p><strong>加速</strong></p><ul><li><p>因为brew的镜像在国外，所以使用时下载更新速率都十分的缓慢</p></li><li><p>故可以将镜像源修改成国内的（下面为<a class="link" href="https://mirrors.tuna.tsinghua.edu.cn/help/homebrew/">清华镜像<i class="fas fa-external-link-alt"></i></a>）</p></li><li><p>更换：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/Homebrew</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git -C <span class="string">&quot;<span class="subst">$(brew --repo)</span>&quot;</span> remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git -C <span class="string">&quot;<span class="subst">$(brew --repo homebrew/core)</span>&quot;</span> remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git -C <span class="string">&quot;<span class="subst">$(brew --repo homebrew/cask)</span>&quot;</span> remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-cask.git</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> brew update</span></span><br></pre></td></tr></table></figure></li><li><p>复原：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/Homebrew</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git -C <span class="string">&quot;<span class="subst">$(brew --repo)</span>&quot;</span> remote set-url origin https://github.com/Homebrew/brew.git</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git -C <span class="string">&quot;<span class="subst">$(brew --repo homebrew/core)</span>&quot;</span> remote set-url origin https://github.com/Homebrew/homebrew-core.git</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git -C <span class="string">&quot;<span class="subst">$(brew --repo homebrew/cask)</span>&quot;</span> remote set-url origin https://github.com/Homebrew/homebrew-cask.git</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.5之后没有cask，下面的不一定要执行</span></span><br><span class="line">----------------------------</span><br><span class="line"><span class="meta">$</span><span class="bash"> git -C <span class="string">&quot;<span class="subst">$(brew --repo homebrew/cask-fonts)</span>&quot;</span> remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-cask-fonts.git</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git -C <span class="string">&quot;<span class="subst">$(brew --repo homebrew/cask-drivers)</span>&quot;</span> remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-cask-drivers.git</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git -C <span class="string">&quot;<span class="subst">$(brew --repo homebrew/cask-versions)</span>&quot;</span> remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-cask-versions.git</span></span><br><span class="line">----------------------------</span><br><span class="line"><span class="meta">$</span><span class="bash"> brew update-reset</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 更换上游后需重新设置 git 仓库 HEAD：</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="apt-get"><a href="#apt-get" class="headerlink" title="apt-get"></a>apt-get</h2><p>Linux下的包管理工具</p><h2 id="cURL"><a href="#cURL" class="headerlink" title="cURL"></a>cURL</h2><p>是常用的命令行工具，用来请求 Web 服务器。它的名字就是客户端（client）的 URL 工具的意思。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl https://www.example.com</span></span><br></pre></td></tr></table></figure><ul><li>上面命令向<code>www.example.com</code>发出 GET 请求，服务器返回的内容会在命令行输出。</li></ul><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p><strong>-o</strong></p><p>将服务器的回应保存成文件，等同于<code>wget</code>命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -o example.html https://www.example.com</span></span><br></pre></td></tr></table></figure><ul><li>上面命令将<code>www.example.com</code>保存成<code>example.html</code>。</li></ul><p><strong>-O</strong></p><p>将服务器回应保存成文件，并将 URL 的最后部分当作文件名。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -O https://www.example.com/foo/bar.html</span></span><br></pre></td></tr></table></figure><ul><li>上面命令将将服务器的回应保存成文件，文件名为<code>bar.html</code>。</li></ul><p><strong>-s</strong></p><p>参数将不输出错误和进度信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -s https://www.example.com</span></span><br></pre></td></tr></table></figure><ul><li><p>上面命令一旦发生错误，不会显示错误信息。不发生错误的话，会正常显示运行结果。</p></li><li><p>如果想让 curl 不产生任何输出，可以使用下面的命令。</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -s -o /dev/null https://google.com</span></span><br></pre></td></tr></table></figure><p><strong>-S</strong></p><p>参数指定只输出错误信息，通常与<code>-s</code>一起使用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -s -o /dev/null https://google.com</span></span><br></pre></td></tr></table></figure><ul><li>此处有错</li></ul><p><strong>-L</strong></p><p>参数会让 HTTP 请求跟随服务器的重定向。curl 默认不跟随重定向。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -L -d <span class="string">&#x27;tweet=hi&#x27;</span> https://api.twitter.com/tweet</span></span><br></pre></td></tr></table></figure><h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><h1 id="隐私保护"><a href="#隐私保护" class="headerlink" title="隐私保护"></a>隐私保护</h1><p>零知识证明</p><ul><li>证明知道答案，但却不泄漏答案的内容</li><li>阿里巴巴的洞</li></ul><p>安全多方计算技术</p><ul><li>无可信任第三方的情况下，安全地完成计算任务</li><li>应用：门限签名、电子拍卖等</li></ul><p>共享数据上链及存证</p><p>共享数据授权和使用</p><p>同态加密</p><p>可信硬件</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算机发展&quot;&gt;&lt;a href=&quot;#计算机发展&quot; class=&quot;headerlink&quot; title=&quot;计算机发展&quot;&gt;&lt;/a&gt;计算机发展&lt;/h1&gt;&lt;p&gt;专用计算机：凯撒密码徽章，算盘&lt;/p&gt;
&lt;p&gt;1946：宾夕法尼亚研究的第一台电子计算机&lt;/p&gt;
&lt;p&gt;求 pai&lt;</summary>
      
    
    
    
    <category term="notebook" scheme="https://jieyang-wei.github.io/categories/notebook/"/>
    
    <category term="theory" scheme="https://jieyang-wei.github.io/categories/notebook/theory/"/>
    
    
    <category term="理论知识" scheme="https://jieyang-wei.github.io/tags/%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>nodejs</title>
    <link href="https://jieyang-wei.github.io/2020/12/18/nodejs/"/>
    <id>https://jieyang-wei.github.io/2020/12/18/nodejs/</id>
    <published>2020-12-18T09:56:37.000Z</published>
    <updated>2021-03-20T02:22:43.853Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h2><ul><li>nodejs的包管理工具</li></ul><p><strong><a class="link" href="https://www.cnblogs.com/datiangou/p/10172994.html">package.json<i class="fas fa-external-link-alt"></i></a></strong></p><ul><li><a class="link" href="https://docs.npmjs.com/cli/v6/configuring-npm/package-json">官方文档<i class="fas fa-external-link-alt"></i></a></li></ul><p><code>npm init</code></p><ul><li>可以初始化一个package.json文件。在初始化的过程中，会叫用户输入name, version等等信息，当然，你都可以忽略。一路点回车，就生成了下面这样一个初始化的package.json。</li></ul><p><code>package.json</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;test&quot;</span>, <span class="comment">// 假如项目叫做test</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;this is my test&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;index.js&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;amp;&amp;amp; exit 1&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;author&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;license&quot;</span>: <span class="string">&quot;ISC&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>name</strong>: 这个很好理解，就是package的名称。不过需要注意的是，name有长度限制(虽然一般都不会超)，而且name不能以 【点】 或者 【下划线】开头，name中不能有大写字母。这个是每一个package必须的。在业务代码中，通过<code>require($&#123;name&#125;)</code>就可以引入对应的程序包了。</li><li><strong>version</strong>: package的版本。对于业务项目来说，这个往往不太重要，但是如果你要发布自己的项目，这个就显得十分重要了。name和version共同决定了唯一一份代码。npm是用[<a class="link" href="https://docs.npmjs.com/misc/semver.html">npm-semver]<i class="fas fa-external-link-alt"></i></a>来解析版本号的。我们一般见到的都是<code>大版本.次要版本.小版本</code>这种版本号，比如<code>16.1.0</code>。版本号的规则、含义其实蛮多的，可以参考<a class="link" href="https://segmentfault.com/a/1190000011368506">这篇文章<i class="fas fa-external-link-alt"></i></a>。</li><li><strong>desription</strong>：包的描述。开发组件库时必需，简明的向库的使用者介绍这个库是干嘛的。对于公司的业务项目，这个配置项一般无所谓。</li><li><strong>keywords</strong>：关键词。一个字符串数组，对这个npm包的介绍。组件库必需，便于使用者在npm中搜索。对于公司业务项目，这个配置一般无所谓。</li><li>homepage： 项目主页。对于开发组件库来说挺有用的。</li><li>bugs：开发者的联系方式，代码库的issues地址等。如果代码使用者发现了bug，可以通过这个配置项找到提bug的地方。</li><li><strong>license</strong>：开源协议。对于开源组件库，这个十分重要。之前react还因为这事儿没少被社区嫌弃。开源协议略微复杂，用<a class="link" href="http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html">阮一峰<i class="fas fa-external-link-alt"></i></a>前辈的一张图来说明一下吧。注：图里少了ISC, ISC和BSD差不多</li></ul><img src="/2020/12/18/nodejs/截屏2020-12-22 下午7.11.30.png" alt="截屏2020-12-22 下午7.11.30" style="zoom: 33%;"><ul><li><p>author：项目的作者。可以为字符串，对象。</p></li><li><p>contributors：项目的贡献者。author的数组。</p></li><li><p><strong>main</strong>：代码入口。这个十分重要，特别是对于组件库。当你想在node_modules中修改你使用的某个组件库的代码时，首先在node_modules中找到这个组件库，第一眼就是要看这个main，找到组件库的入口文件。在这个入口文件中再去修改代码吧。</p></li><li><p><strong>scripts</strong>：指定了运行脚本命令的npm命令行缩写。十分重要。</p><ul><li>在命令行输入：<code>npm run dev</code> , 对应的命令就会被执行。这里有一个地方需要注意，当执行<code>npm run xxx </code>的时候，<code>node_modules/.bin/</code>目录会在运行时被加入系统的PATH变量。</li><li>上面的例子，当我们在命令行输入：<code>npm run build</code>时，其实真正执行的命令是<code>node_modules/.bin/webpack</code>而不是<code>webpack</code>。所以，当你的webpack并未全局安装时，直接在命令行输入：<code>webpack</code>是会报错的。因为你的webapck是安装在<code>node_modules/.bin/</code>下面的。</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;dev&quot;: &quot;NODE_ENV=dev webpack-dev-server --progress --hot --host 0.0.0.0 --port 8089&quot;,</span><br><span class="line">    &quot;test&quot;: &quot;NODE_ENV=test webpack --config webpack.test.config.js --progress&quot;,</span><br><span class="line">    &quot;online&quot;: &quot;NODE_ENV=production webpack --config webpack.online.config.js --progress&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;webpack&quot;,</span><br><span class="line">    &quot;node&quot;: &quot;node server.js&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>directories：对整个代码结构的描述。告诉代码包使用者可以在哪里找到对应的文件。</p></li><li><p>files：数组。表示代码包下载安装完成时包括的所有文件。</p></li><li><p><strong>repository</strong>：对于组件库很有用。让组件库使用者找到你的代码库地址。这个配置项会直接在组件库的npm首页生效。例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;repository&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;git&quot;,</span><br><span class="line">    &quot;url&quot;: &quot;git+https:&#x2F;&#x2F;github.com&#x2F;CoyPan&#x2F;react-scroll-to-show-cb.git&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><p>config：用于添加命令行的环境变量。具体用法见<a class="link" href="https://docs.npmjs.com/misc/config">这里<i class="fas fa-external-link-alt"></i></a>。</p></li><li><p><strong>dependencies</strong>：项目的依赖。通过<code>npm install --save</code>安装的包会出现在这里。</p><ul><li>注意，<strong>不要把测试工具、代码转换器或者打包工具</strong>等放在这里。当你在命令行里面使用<code>npm install react --save</code>时，react就会出现在dependencies。默认是安装最新的版本。如果想安装某个特定的版本，可以<code>npm install react@15.6.2</code>。</li></ul></li></ul><hr><p>以下的dependencies，格式都是合法的，</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&quot;dependencies&quot; : &#123; </span><br><span class="line">    &quot;foo&quot; : &quot;1.0.0 - 2.9999.9999&quot;,</span><br><span class="line">    &quot;bar&quot; : &quot;&amp;gt;=1.0.2 &amp;lt;2.1.2&quot;,</span><br><span class="line">    &quot;baz&quot; : &quot;&amp;gt;1.0.2 &amp;lt;=2.3.4&quot;,</span><br><span class="line">    &quot;boo&quot; : &quot;2.0.1&quot;,    // 指定了就是2.0.1版本</span><br><span class="line">    &quot;qux&quot; : &quot;&amp;lt;1.0.0 || &amp;gt;=2.3.1 &amp;lt;2.4.5 || &amp;gt;=2.5.2 &amp;lt;3.0.0&quot;,</span><br><span class="line">    &quot;asd&quot; : &quot;http://asdf.com/asdf.tar.gz&quot;,</span><br><span class="line">    &quot;til&quot; : &quot;~1.2.2&quot;,   // 安装版本号不低于1.2.2的1.2.x的最新版本</span><br><span class="line">  <span class="comment">// 例如:1.2.3， 1.2.4等等。1.2.1 ，1.3.x 等就不行了</span></span><br><span class="line">    &quot;elf&quot; : &quot;^1.2.3&quot;,   // 安装版本号不低于1.2.2的1.x.x的最新版本</span><br><span class="line">  <span class="comment">// 例如: 1.2.7，1.7.8等,1.2.1 ，2.0.0 等就不行了。</span></span><br><span class="line">    <span class="comment">// 注意，如果配置是^0.x.x，则和~0.x.x的效果一样。  </span></span><br><span class="line">    &quot;two&quot; : &quot;2.x&quot;,</span><br><span class="line">    &quot;thr&quot; : &quot;3.3.x&quot;,</span><br><span class="line">    &quot;lat&quot; : &quot;latest&quot;,   // 安装最新版本</span><br><span class="line">    &quot;dyl&quot; : &quot;file:../dyl&quot;,</span><br><span class="line">  <span class="comment">//&quot;foo&quot;: &quot;git+ssh://git@github.com:foo/foo.git#v1.0.1&quot;   // 还可以这样</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>foo组件的地址为<code>git+ssh://&#123;foo代码库的ssh地址&#125;#v&#123;foo的版本号&#125;</code><ul><li>好处：组内的许多项目都有同一个功能，把这个功能抽出来做成组件是很自然的想法。但是每个项目都有自己的代码库，公司也没有内部的npm库，组件应该放在哪里呢？可以专门为组件新建一个代码仓库，将组件放在这里开发、迭代。这样，各个项目都可以引用该组件：只需要在dependencies中将组件配置成上述的形式。至于组件的版本，可以通过<code>git tag</code>来控制。</li></ul></li><li>dependencies还有其他的配置方式，具体在<a class="link" href="https://docs.npmjs.com/files/package.json.html#dependencies">这里<i class="fas fa-external-link-alt"></i></a>查看。</li></ul><hr><ul><li><strong>devDependencies</strong>：项目的依赖。通过<code>npm run install --save-dev</code>安装的包会出现在这里。主要是在<strong>开发过程</strong>中依赖的一些工具。用法与dependencies相似。</li><li>bundledDependencies：数组，打包时的依赖。如果配置了bundledDependencies，在项目中执行 <code>npm pack</code>将项目打包时，最后生成的<code>.tgz</code>包中，会包含bundledDependencies中配置的依赖。bundledDependencies中的依赖必须在devDependencies或者dependencies中声明过。</li><li>peerDependencies: 指定当前组件的依赖以其版本。如果组件使用者在项目中安装了其他版本的同一依赖，会提示报错。</li><li>engines：指定项目所依赖的node环境、npm版本等。</li><li>private：如果设为true，无法通过<code>npm publish</code>发布代码。</li><li>bin：用来指定各个内部命令对应的可执行文件的路径。具体用法这里不多讲了。详情可以点击<a class="link" href="https://docs.npmjs.com/files/package.json.html#bin">这里<i class="fas fa-external-link-alt"></i></a>。</li></ul><p><code>npm install</code></p><ul><li>根据配置文件<code>package.json</code>来安装环境</li><li>会在当前路径下自动创建文件夹<code>node_modules</code>，里面放所有下载的依赖包</li></ul><p><code>npm install name --save</code></p><ul><li>下载包name，同时加载到配置文件<code>package.json</code>的依赖<code>&quot;dependencies&quot;</code>里面</li></ul><h1 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123</span>; <span class="comment">// 整数123</span></span><br><span class="line"><span class="number">0.456</span>; <span class="comment">// 浮点数0.456</span></span><br><span class="line"><span class="number">1.2345e3</span>; <span class="comment">// 科学计数法表示1.2345x1000，等同于1234.5</span></span><br><span class="line">-<span class="number">99</span>; <span class="comment">// 负数</span></span><br><span class="line"><span class="literal">NaN</span>; <span class="comment">// NaN表示Not a Number，当无法计算结果时用NaN表示</span></span><br><span class="line"><span class="literal">Infinity</span>; <span class="comment">// Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity</span></span><br></pre></td></tr></table></figure><ul><li>JavaScript不区分整数和浮点数，统一用Number表示，以上都是合法的Number类型</li><li>Number的四则运算同数学</li><li><strong>注意</strong>：<ul><li><code>NaN</code>这个特殊的Number与所有其他值都不相等，包括它自己：<ul><li>NaN === NaN        //false</li><li>isNaN(NaN);          //true</li></ul></li></ul></li></ul><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p><strong>比较运算符</strong></p><ul><li><code>==</code>：它会<strong>自动转换数据类型</strong>再比较，很多时候，会得到非常诡异的结果；</li><li><code>===</code>：它<strong>不会</strong>自动转换数据类型，如果数据类型不一致，返回<code>false</code>，如果一致，再比较。<ul><li>由于JavaScript这个设计缺陷，<em>不要</em>使用<code>==</code>比较，始终坚持使用<code>===</code>比较。</li></ul></li></ul><p><strong>null和undefined：</strong></p><ul><li><code>null</code>表示一个“空”的值，它和<code>0</code>以及空字符串<code>&#39;&#39;</code>不同，<code>0</code>是一个数值，<code>&#39;&#39;</code>表示长度为0的字符串，而<code>null</code>表示“空”。</li><li>在其他语言中，也有类似JavaScript的<code>null</code>的表示，例如Java也用<code>null</code>，Swift用<code>nil</code>，Python用<code>None</code>表示。但是，在JavaScript中，还有一个和<code>null</code>类似的<code>undefined</code>，它表示“未定义”。</li><li>JavaScript的设计者希望用<code>null</code>表示一个空的值，而<code>undefined</code>表示值未定义。事实证明，这并没有什么卵用，区分两者的意义不大。</li><li>大多数情况下，我们都应该用<code>null</code>。<code>undefined</code>仅仅在判断函数参数是否传递的情况下有用。</li></ul><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p><strong>strict模式</strong></p><ul><li>JavaScript在设计之初，为了方便初学者学习，并不强制要求用<code>var</code>申明变量。这个设计错误带来了严重的后果：如果一个变量没有通过<code>var</code>申明就被使用，那么该变量就自动被申明为全局变量</li><li>为了修补JavaScript这一严重设计缺陷，ECMA在后续规范中推出了<code>strict模式</code>，在<code>strict模式</code>下运行的JavaScript代码，强制通过<code>var</code>申明变量，未使用<code>var</code>申明变量就使用的，将导致运行错误。</li></ul><h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><h5 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h5><h5 id="Iterable"><a href="#Iterable" class="headerlink" title="Iterable"></a>Iterable</h5><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul><li>变量名是大小写英文、数字、<code>$</code>和<code>_</code>的组合，且不能用数字开头。</li><li>变量名也不能是JavaScript的关键字，如<code>if</code>、<code>while</code>等。</li><li>申明一个变量用<code>var</code>语句</li></ul><p><strong>变量输出</strong></p><ul><li>console.log(x)</li><li>alert(x) –html弹窗</li></ul><p><strong>环境变量 process.env</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http_port = process.env.HTTP_PORT || <span class="number">3001</span>   <span class="comment">//默认设置为3001</span></span><br><span class="line"><span class="keyword">var</span> p2p_port = process.env.P2P_PORT || <span class="number">6001</span></span><br><span class="line"><span class="keyword">var</span> initialPeers = process.env.PEERS ? process.env.PEERS.split(<span class="string">&#x27;,&#x27;</span>) : []</span><br></pre></td></tr></table></figure><ul><li><p><strong>process</strong>：是一个 global （全局变量），提供有关信息，控制当前 Node.js 进程。<br>作为一个对象，它对于 Node.js 应用程序始终是可用的，故无需使用 require()。</p><ul><li>process（进程）其实就是存在nodejs中的一个全局变量，所有模块都可以调用。</li></ul></li><li><p>终端设置变量值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//win</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">set</span> HTTP_PORT=3002</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">set</span> P2P_PORT=6002</span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">set</span> PEERS=ws://localhost:6001</span></span><br><span class="line"></span><br><span class="line">//ios</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> HTTP_PORT=3002</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> P2P_PORT=6002</span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> PEERS=ws://localhost:6001</span></span><br><span class="line"></span><br><span class="line">//启动</span><br><span class="line"><span class="meta">$</span><span class="bash"> node file.js</span> </span><br></pre></td></tr></table></figure><ul><li>ios</li></ul></li></ul><h2 id="标准对象"><a href="#标准对象" class="headerlink" title="标准对象"></a>标准对象</h2><ul><li>在JavaScript的世界里，一切都是对象。</li><li>但是某些对象还是和其他对象不太一样。为了区分对象的类型，我们用<code>typeof</code>操作符获取对象的类型，它总是返回一个字符串</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">123</span>; <span class="comment">// &#x27;number&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span>; <span class="comment">// &#x27;number&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;str&#x27;</span>; <span class="comment">// &#x27;string&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>; <span class="comment">// &#x27;boolean&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>; <span class="comment">// &#x27;undefined&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Math</span>.abs; <span class="comment">// &#x27;function&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>; <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> []; <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;; <span class="comment">// &#x27;object&#x27;</span></span><br></pre></td></tr></table></figure><ul><li><code>number</code>、<code>string</code>、<code>boolean</code>、<code>function</code>和<code>undefined</code>有别于其他类型。</li><li><strong>特别注意</strong>：<code>null</code>的类型是<code>object</code>，<code>Array</code>的类型也是<code>object</code>，如果我们用<code>typeof</code>将无法区分出<code>null</code>、<code>Array</code>和通常意义上的object——<code>&#123;&#125;</code>。</li></ul><p><strong>包装对象</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>); <span class="comment">// 123,生成了新的包装类型</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>); <span class="comment">// true,生成了新的包装类型</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;str&#x27;</span>); <span class="comment">// &#x27;str&#x27;,生成了新的包装类型</span></span><br></pre></td></tr></table></figure><ul><li>类型为<code>object</code></li></ul><p>总结一下，有这么几条规则需要遵守：</p><ul><li><p>不要使用<code>new Number()</code>、<code>new Boolean()</code>、<code>new String()</code>创建包装对象；</p><ul><li>如果没写<code>new</code>，<code>Number()</code>、<code>Boolean</code>和<code>String()</code>被当做普通函数，把任何类型的数据转换为<code>number</code>、<code>boolean</code>和<code>string</code>类型（注意不是其包装类型）</li></ul></li><li><p>用<code>parseInt()</code>或<code>parseFloat()</code>来转换任意类型到<code>number</code>；</p></li><li><p>用<code>String()</code>来转换任意类型到<code>string</code>，或者直接调用某个对象的<code>toString()</code>方法；</p><ul><li><p><code>null</code>和<code>undefined</code>就没有<code>toString()</code>方法；Object一些情况下也不能使用</p></li><li><p><code>number</code>对象调用<code>toString()</code>报<strong>SyntaxError：</strong></p></li><li><pre><code class="javascript">123.toString();    // SyntaxError123..toString();   // &#39;123&#39;, 注意是两个点！(123).toString();  // &#39;123&#39;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 通常不必把任意类型转换为&#96;boolean&#96;再判断，因为可以直接写&#96;if (myVar) &#123;...&#125;&#96;；</span><br><span class="line"></span><br><span class="line">- &#96;typeof&#96;操作符可以判断出&#96;number&#96;、&#96;boolean&#96;、&#96;string&#96;、&#96;function&#96;和&#96;undefined&#96;；</span><br><span class="line"></span><br><span class="line">- 判断&#96;Array&#96;要使用&#96;Array.isArray(arr)&#96;；</span><br><span class="line"></span><br><span class="line">- 判断&#96;null&#96;请使用&#96;myVar &#x3D;&#x3D;&#x3D; null&#96;；</span><br><span class="line"></span><br><span class="line">- 判断某个全局变量是否存在用&#96;typeof window.myVar &#x3D;&#x3D;&#x3D; &#39;undefined&#39;&#96;；</span><br><span class="line"></span><br><span class="line">- 函数内部判断某个变量是否存在用&#96;typeof myVar &#x3D;&#x3D;&#x3D; &#39;undefined&#39;&#96;。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### Date</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### RegExp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### JSON</span><br><span class="line"></span><br><span class="line">* JSON实际上是JavaScript的一个子集。</span><br><span class="line">* JSON字符集必须是UTF-8</span><br><span class="line">* 为了统一解析JSON的字符串规定必须用双引号&#96;&quot;&quot;&#96;，Object的键也必须用双引号&#96;&quot;&quot;&#96;。</span><br><span class="line">* 在JSON中，一共就这么几种数据类型：</span><br><span class="line">  1. **number**：和JavaScript的&#96;number&#96;完全一致；</span><br><span class="line">  2. **boolean**：就是JavaScript的&#96;true&#96;或&#96;false&#96;；</span><br><span class="line">  3. **string**：就是JavaScript的&#96;string&#96;；</span><br><span class="line">  4. **nul**l：就是JavaScript的&#96;null&#96;；</span><br><span class="line">  5. **array**：就是JavaScript的&#96;Array&#96;表示方式——&#96;[]&#96;；</span><br><span class="line">  6. **object**：就是JavaScript的&#96;&#123; ... &#125;&#96;表示方式。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**序列化:** 对象 -&gt; JSON</span><br><span class="line"></span><br><span class="line">* &#96;JSON.stringfy(var, null, &#39; &#39;)&#96;：将nodejs对象输出成标准JSON格式</span><br><span class="line"></span><br><span class="line">  * 第二个参数用于控制如何筛选对象的键值，如果我们只想输出指定的属性，可以传入&#96;Array&#96;</span><br><span class="line"></span><br><span class="line">    * &#96;JSON.stringify(xiaoming, [&#39;name&#39;, &#39;skills&#39;], &#39;&#39;);  &#96;</span><br><span class="line">    * 只输出对象 xiaoming 的 name 和 skills 属性</span><br><span class="line"></span><br><span class="line">  * 第二个参数还能是一个函数，这样对象的每个键值对都会被函数先处理，</span><br><span class="line"></span><br><span class="line">    * &#96;&#96;&#96;javascript</span><br><span class="line">      function convert(key, value) &#123;</span><br><span class="line">          if (typeof value &#x3D;&#x3D;&#x3D; &#39;string&#39;) &#123;</span><br><span class="line">              return value.toUpperCase();</span><br><span class="line">          &#125;</span><br><span class="line">          return value;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      JSON.stringfy(xiaoming, convert, &#39;  &#39;);</span><br></pre></td></tr></table></figure></code></pre></li></ul><ul><li>第三个参数控制按缩进输出</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    age: <span class="number">14</span>,</span><br><span class="line">    gender: <span class="literal">true</span>,</span><br><span class="line">    height: <span class="number">1.65</span>,</span><br><span class="line">    grade: <span class="literal">null</span>,</span><br><span class="line">    <span class="string">&#x27;middle-school&#x27;</span>: <span class="string">&#x27;\&quot;W3C\&quot; Middle School&#x27;</span>,</span><br><span class="line">    skills: [<span class="string">&#x27;JavaScript&#x27;</span>, <span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;Lisp&#x27;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="built_in">JSON</span>.stringify(xiaoming);</span><br><span class="line"><span class="built_in">console</span>.log(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;小明&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">14</span>,<span class="string">&quot;gender&quot;</span>:<span class="literal">true</span>,<span class="string">&quot;height&quot;</span>:<span class="number">1.65</span>,<span class="string">&quot;grade&quot;</span>:<span class="literal">null</span>,<span class="string">&quot;middle-school&quot;</span>:<span class="string">&quot;\&quot;W3C\&quot; Middle School&quot;</span>,<span class="string">&quot;skills&quot;</span>:[<span class="string">&quot;JavaScript&quot;</span>,<span class="string">&quot;Java&quot;</span>,<span class="string">&quot;Python&quot;</span>,<span class="string">&quot;Lisp&quot;</span>]&#125;</span><br></pre></td></tr></table></figure><ul><li>如果我们还想要精确控制如何序列化小明，可以给<code>xiaoming</code>定义一个<code>toJSON()</code>的方法，直接返回JSON应该序列化的数据：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    age: <span class="number">14</span>,</span><br><span class="line">    gender: <span class="literal">true</span>,</span><br><span class="line">    height: <span class="number">1.65</span>,</span><br><span class="line">    grade: <span class="literal">null</span>,</span><br><span class="line">    <span class="string">&#x27;middle-school&#x27;</span>: <span class="string">&#x27;\&quot;W3C\&quot; Middle School&#x27;</span>,</span><br><span class="line">    skills: [<span class="string">&#x27;JavaScript&#x27;</span>, <span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;Lisp&#x27;</span>],</span><br><span class="line">    toJSON: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="comment">// 只输出name和age，并且改变了key：</span></span><br><span class="line">            <span class="string">&#x27;Name&#x27;</span>: <span class="built_in">this</span>.name,</span><br><span class="line">            <span class="string">&#x27;Age&#x27;</span>: <span class="built_in">this</span>.age</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify(xiaoming); <span class="comment">// &#x27;&#123;&quot;Name&quot;:&quot;小明&quot;,&quot;Age&quot;:14&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>反序列化:</strong> JSON -&gt; 对象</p><ul><li><code>JSON.parse()</code>：把JSON变成一个JavaScript对象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;[1,2,3,true]&#x27;</span>); <span class="comment">// [1, 2, 3, true]</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;&#123;&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:14&#125;&#x27;</span>); <span class="comment">// Object &#123;name: &#x27;小明&#x27;, age: 14&#125;</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;true&#x27;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;123.45&#x27;</span>); <span class="comment">// 123.45</span></span><br></pre></td></tr></table></figure><ul><li><code>JSON.parse()</code>还可以接收一个函数，用来转换解析出的属性：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">JSON</span>.parse(<span class="string">&#x27;&#123;&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:14&#125;&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key === <span class="string">&#x27;name&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value + <span class="string">&#x27;同学&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj)); <span class="comment">// &#123;name: &#x27;小明同学&#x27;, age: 14&#125;</span></span><br></pre></td></tr></table></figure><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>构造</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.type = <span class="string">&#x27;class&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;this is a func&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>();  <span class="comment">// 调用 father 的类构造函数</span></span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;this is a son func&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> Son(<span class="string">&#x27;cindy&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><h3 id="fs"><a href="#fs" class="headerlink" title="fs"></a>fs</h3><ul><li>文件系统模块，负责读写文件</li><li>和所有其它JavaScript模块不同的是，<code>fs</code>模块同时提供了异步和同步的方法。、</li></ul><p><strong>异步读文件</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">&#x27;sample.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>异步读取时，传入的回调函数接收两个参数，当正常读取时，<code>err</code>参数为<code>null</code>，<code>data</code>参数为读取到的String。当读取发生错误时，<code>err</code>参数代表一个错误对象，<code>data</code>为<code>undefined</code>。</li><li>这也是Node.js<strong>标准的</strong>回调函数：第一个参数代表错误信息，第二个参数代表结果。后面我们还会经常编写这种回调函数。</li></ul><p>读取图片</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">&#x27;sample.png&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">        <span class="built_in">console</span>.log(data.length + <span class="string">&#x27; bytes&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>当读取二进制文件时，不传入文件编码时，回调函数的<code>data</code>参数将返回一个<code>Buffer</code>对象。在Node.js中，<code>Buffer</code>对象就是一个包含零个或任意个字节的数组（注意和Array不同）。<ul><li><code>Buffer</code>对象可以和String作转换，例如，把一个<code>Buffer</code>对象转换成String：</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Buffer -&gt; String</span></span><br><span class="line"><span class="keyword">var</span> text = data.toString(<span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(text);</span><br></pre></td></tr></table></figure><ul><li>或者把一个String转换成<code>Buffer</code>：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String -&gt; Buffer</span></span><br><span class="line"><span class="keyword">var</span> buf = Buffer.from(text, <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(buf);</span><br></pre></td></tr></table></figure><p><strong>同步读文件</strong></p><ul><li>同步读取的函数和异步函数相比，多了一个<code>Sync</code>后缀，并且不接收回调函数，函数直接返回结果。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data = fs.readFileSync(<span class="string">&#x27;sample.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(data);</span><br></pre></td></tr></table></figure><ul><li>如果同步读取文件发生错误，则需要用<code>try...catch</code>捕获该错误：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data = fs.readFileSync(<span class="string">&#x27;sample.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="comment">// 出错了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h3><h3 id="http"><a href="#http" class="headerlink" title="http"></a>http</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入http模块:</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建http server，并传入回调函数:</span></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(req.method == <span class="string">&quot;GET&quot;</span>)&#123;</span><br><span class="line">        doGet(req, res)</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(req.method == <span class="string">&quot;POST&quot;</span>)&#123;</span><br><span class="line">        doPost(req, res)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        res.end();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 让服务器监听8080端口:</span></span><br><span class="line">server.listen(<span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doGet</span>(<span class="params">request, response</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 回调函数接收request和response对象,</span></span><br><span class="line">    <span class="comment">// 获得HTTP请求的method和url:</span></span><br><span class="line">    <span class="built_in">console</span>.log(request.method + <span class="string">&#x27;: &#x27;</span> + request.url);</span><br><span class="line">    <span class="comment">// 解析请求的Url，返回一个标准的对象</span></span><br><span class="line">    <span class="keyword">var</span> params = url.parse(request.url, <span class="literal">true</span>);   </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 向http请求返回一个表单</span></span><br><span class="line">    <span class="comment">// 协议头，将HTTP响应200写入response, 同时设置Content-Type: text/html:</span></span><br><span class="line">    response.writeHead(<span class="number">200</span>, &#123;<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/html&#x27;</span>&#125;);</span><br><span class="line">    response.write(<span class="string">&#x27;&lt;html&gt;&#x27;</span>);</span><br><span class="line">    response.write(<span class="string">&#x27;&lt;head&gt;&#x27;</span>);</span><br><span class="line">    response.write(<span class="string">&#x27;&lt;meta charset=&quot;utf-8&quot;&gt;&#x27;</span>);</span><br><span class="line">    response.write(<span class="string">&#x27;&lt;title&gt;&#x27;</span>);</span><br><span class="line">    response.write(<span class="string">&#x27;&lt;/title&gt;&#x27;</span>);</span><br><span class="line">    response.write(<span class="string">&#x27;&lt;/head&gt;&#x27;</span>);</span><br><span class="line">    response.write(<span class="string">&#x27;&lt;body&gt;&#x27;</span>);</span><br><span class="line">    response.write(<span class="string">&#x27;&lt;form method=&quot;post&quot;&gt;&#x27;</span>);  <span class="comment">//表单post输出传入下面的函数</span></span><br><span class="line">    response.write(<span class="string">&#x27;username:&lt;input name=&quot;username&quot;&gt;&#x27;</span>);</span><br><span class="line">    response.write(<span class="string">&#x27;password:&lt;input name=&quot;password&quot;&gt;&lt;input type=&quot;submit&quot;&gt;&#x27;</span>);</span><br><span class="line">    response.write(<span class="string">&#x27;&lt;/form&gt;&#x27;</span>);</span><br><span class="line">    response.write(<span class="string">&#x27;&lt;/body&gt;&#x27;</span>);</span><br><span class="line">    response.write(<span class="string">&#x27;&lt;/html&gt;&#x27;</span>);</span><br><span class="line">    <span class="comment">// 将HTTP响应的HTML内容写入response:</span></span><br><span class="line">    response.end()</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doPost</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> formDate = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 通过req的data事件监听函数，每当接受到请求体的数据，就累加到formDate变量中</span></span><br><span class="line">    req.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        formDate += data;</span><br><span class="line">        <span class="built_in">console</span>.log(data); </span><br><span class="line"><span class="comment">//&lt;Buffer 75 73 65 72 6e 61 6d 65 3d 25 45 39 25 41 44 25 38 46 25 45 36 25 42 34 25 38 31 25 45 36 25 39 44 25 41 38 26 70 61 73 73 77 6f 72 64 3d 34 35 36 37&gt;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 在end事件触发后，通过querystring.parse将formDate解析为真正的POST请求格式，然后向客户端返回。</span></span><br><span class="line">    req.on(<span class="string">&#x27;end&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> body = querystring.parse(formDate);</span><br><span class="line">    res.end(util.inspect(body));</span><br><span class="line">      <span class="comment">// [Object: null prototype] &#123; username: &#x27;wjy&#x27;, password: &#x27;456&#x27; &#125;</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Server is running at http://127.0.0.1:8080/&#x27;</span>);</span><br></pre></td></tr></table></figure><ul><li><code>request</code>：封装了HTTP请求，我们调用<code>request</code>对象的属性和方法就可以拿到所有HTTP请求的信息；<ul><li>{‘Content-Type’: ‘text/html’}：设置类型为html页面</li><li><strong>方法</strong><ul><li><code>req.on(&#39;data&#39;, function(data)&#123;&#125;)</code>：data为一个buffer数据，需要将所有数据包的字节都存储起来，再来分析</li><li><code>req.on(&#39;end&#39;, function(data)&#123;  res.end();  &#125;)</code>：在出发结束的函数后，再在他的function里面结束相应<code>res.end();</code></li></ul></li></ul></li><li><code>response</code>：封装了HTTP响应，我们操作<code>response</code>对象的方法，就可以把HTTP响应返回给浏览器。<ul><li><strong>方法</strong><ul><li><code>response.writeHead()</code>：设置http协议头，给浏览器看的</li><li><code>response.write()</code>：仅发送数据</li><li><code>response.end()</code>：发送并结束请求，必须有，可以发送空</li></ul></li></ul></li></ul><p><strong>编码模式</strong></p><ul><li>浏览器默认<code>urlencode</code>字符集编码，不支持中文<ul><li>接收浏览器的请求数据res，在nodejs中输出是中文适配的</li><li>但是如果直接将中文传到浏览器输出将会出现乱码，所以设置html页面属性meta为<code>utf-8</code></li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">res.write(<span class="string">&#x27;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;/&gt;&lt;/head&gt;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">------ urlcode 加解码 ------</span><br><span class="line"><span class="built_in">encodeURI</span>(<span class="string">&quot;魏洁杨&quot;</span>);    <span class="comment">// %E9%AD%8F%E6%B4%81%E6%9D%A8</span></span><br><span class="line"><span class="built_in">decodeURI</span>(<span class="string">&quot;%E9%AD%8F%E6%B4%81%E6%9D%A8&quot;</span>)   <span class="comment">//魏洁杨</span></span><br></pre></td></tr></table></figure><p><strong>请求内容</strong></p><ul><li>GET：<ul><li>由于GET请求直接被嵌入在路径中，URL是完整的请求路径，包括了?后面的部分，因此你可以手动解析后面的内容作为GET请求的参数。</li><li>下面 url 模块中的 <code>parse</code>函数提供了这个功能。</li></ul></li><li>POST：<ul><li>POST 请求的内容全部的都在请求体中，http.ServerRequest 并没有一个属性内容为请求体，原因是等待请求体传输可能是一件耗时的工作。</li><li>比如上传文件，而很多时候我们可能并不需要理会请求体的内容，恶意的POST请求会大大消耗服务器的资源，所以 node.js 默认是不会解析请求体的，当你需要的时候，需要手动来做。</li><li>下面的querystring和util模块提供了相应的处理</li></ul></li></ul><h4 id="url"><a href="#url" class="headerlink" title="url"></a>url</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(url.parse(<span class="string">&#x27;http://user:pass@host.com:8080/path/to/file?query=string#hash&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出 */</span></span><br><span class="line">Url &#123;</span><br><span class="line">  protocol: <span class="string">&#x27;http:&#x27;</span>,</span><br><span class="line">  slashes: <span class="literal">true</span>,</span><br><span class="line">  auth: <span class="string">&#x27;user:pass&#x27;</span>,</span><br><span class="line">  host: <span class="string">&#x27;host.com:8080&#x27;</span>,</span><br><span class="line">  port: <span class="string">&#x27;8080&#x27;</span>,</span><br><span class="line">  hostname: <span class="string">&#x27;host.com&#x27;</span>,</span><br><span class="line">  hash: <span class="string">&#x27;#hash&#x27;</span>,</span><br><span class="line">  search: <span class="string">&#x27;?query=string&#x27;</span>,</span><br><span class="line">  query: <span class="string">&#x27;query=string&#x27;</span>,</span><br><span class="line">  pathname: <span class="string">&#x27;/path/to/file&#x27;</span>,</span><br><span class="line">  path: <span class="string">&#x27;/path/to/file?query=string&#x27;</span>,</span><br><span class="line">  href: <span class="string">&#x27;http://user:pass@host.com:8080/path/to/file?query=string#hash&#x27;</span> &#125;</span><br></pre></td></tr></table></figure><h4 id="querystring"><a href="#querystring" class="headerlink" title="querystring"></a>querystring</h4><p>模块提供用于解析和格式化 URL 查询字符串的实用工具</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123; unescapeBuffer: [Function],</span></span><br><span class="line"><span class="comment">  unescape: [Function: qsUnescape],</span></span><br><span class="line"><span class="comment">  escape: [Function],</span></span><br><span class="line"><span class="comment">  encode: [Function],</span></span><br><span class="line"><span class="comment">  stringify: [Function],</span></span><br><span class="line"><span class="comment">  decode: [Function],</span></span><br><span class="line"><span class="comment">  parse: [Function] &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">console</span>.log(querystring);</span><br></pre></td></tr></table></figure><p><strong>序列化：url -&gt; 对象</strong></p><p><code>querystring.parse(str[, sep[, eq[, options]]])</code></p><ul><li><p>把一个URL查询字符串(str)解析成一个<strong>键值对的集合</strong></p></li><li><p>参数</p><ul><li><p><strong>str</strong>：要解析的 URL 查询字符串</p></li><li><p><strong>sep</strong>：用于在查询字符串中分隔键值对的子字符串。<strong>默认值:</strong> <code>&#39;&amp;&#39;</code></p></li><li><p><strong>eq</strong>：用于在查询字符串中分隔键和值的子字符串。<strong>默认值:</strong> <code>&#39;=&#39;</code>。</p></li><li><p><strong>Options</strong>：</p><ul><li><code>decodeURIComponent</code> <a href="http://url.nodejs.cn/ceTQa6"><Function></Function></a> 当解码查询字符串中的百分比编码字符时使用的函数。<strong>默认值:</strong> <code>querystring.unescape()</code>。</li><li><code>maxKeys</code> <a href="http://url.nodejs.cn/SXbo1v"><number></number></a> 指定要解析的键的最大数量。指定 <code>0</code> 可移除键的计数限制。<strong>默认值:</strong> <code>1000</code>。</li><li>注：默认情况下，会假定查询字符串中的百分比编码字符使用 UTF-8 编码。 如果使用其他的字符编码，则需要指定其他的 <code>decodeURIComponent</code> 选项</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;foo=bar&amp;abc=xyz&amp;abc=123&quot;</span></span><br><span class="line"><span class="keyword">var</span> body = querystring.parse(str)</span><br><span class="line"><span class="comment">//body = &#x27;&#123; foo: &#x27;bar&#x27;, abc: [ &#x27;xyz&#x27;, &#x27;123&#x27; ] &#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">querystring.parse(<span class="string">&#x27;w=%D6%D0%CE%C4&amp;foo=bar&#x27;</span>, <span class="literal">null</span>, <span class="literal">null</span>,</span><br><span class="line">                  &#123; <span class="attr">decodeURIComponent</span>: gbkDecodeURIComponent &#125;);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>注意：本方法返回的对象不继承自 JavaScript 的 Object。 这意味着典型的 Object 方法如 <code>obj.toString()</code>、<code>obj.hasOwnProperty()</code>等没有被定义且无法使用</p></li></ul><p><strong>反序列化：对象 -&gt; url</strong></p><p><code>querystring.stringify(obj[, sep][, eq][, options])</code></p><ul><li><p>通过遍历对象的自有属性，从一个给定的obj产生一个URL查询字符串</p></li><li><p>参数：</p><ul><li><p><strong>obj</strong>：要序列化为 URL 查询字符串的对象。</p></li><li><p><strong>sep</strong>：用于在查询字符串中分隔键值对的子字符串。<strong>默认值:</strong> <code>&#39;&amp;&#39;</code></p></li><li><p><strong>eq</strong>：用于在查询字符串中分隔键和值的子字符串。<strong>默认值:</strong> <code>&#39;=&#39;</code></p></li><li><p><strong>options</strong>：</p><ul><li><code>decodeURIComponent</code> <a href="http://url.nodejs.cn/ceTQa6"><Function></Function></a> 当解码查询字符串中的百分比编码字符时使用的函数。<strong>默认值:</strong> <code>querystring.unescape()</code>。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">querystring.stringify(&#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>: [<span class="string">&#x27;qux&#x27;</span>, <span class="string">&#x27;quux&#x27;</span>], <span class="attr">corge</span>: <span class="string">&#x27;&#x27;</span> &#125;);</span><br><span class="line"><span class="comment">// 返回 &#x27;foo=bar&amp;baz=qux&amp;baz=quux&amp;corge=&#x27;</span></span><br><span class="line"></span><br><span class="line">querystring.stringify(&#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>: <span class="string">&#x27;qux&#x27;</span> &#125;, <span class="string">&#x27;;&#x27;</span>, <span class="string">&#x27;:&#x27;</span>);</span><br><span class="line"><span class="comment">// 返回 &#x27;foo:bar;baz:qux&#x27;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>编码</strong></p><p><code>querystring.escape(str)</code></p><p><code>querystring.unescape(str)</code></p><ul><li><p>给定的 <code>str</code> 上执行 URL 百分比编码字符的解码</p></li><li><p><code>querystring.unescape()</code> 方法由 <code>querystring.parse()</code> 使用，通常不会被直接地使用。 它的导出主要是为了允许应用程序代码在需要时通过将 <code>querystring.unescape</code> 赋值给替代函数来提供替换的解码实现。</p><p>默认情况下， <code>querystring.unescape()</code> 方法将会尝试使用 JavaScript 内置的 <code>decodeURIComponent()</code> 方法进行解码。 如果失败，则将会使用更保险的不会因格式错误的 URL 而抛出异常的同类方法。</p></li></ul><h4 id="body-parser"><a href="#body-parser" class="headerlink" title="body-parser"></a>body-parser</h4><h4 id="util"><a href="#util" class="headerlink" title="util"></a>util</h4><h4 id="path"><a href="#path" class="headerlink" title="path"></a>path</h4><h3 id="socket-io"><a href="#socket-io" class="headerlink" title="socket.io"></a>socket.io</h3><h3 id="module-exports"><a href="#module-exports" class="headerlink" title="module  exports"></a>module  exports</h3><p><strong>模块规范</strong></p><ul><li><code>CommonJS</code>模块规范和<code>ES6</code>模块规范完全是两种不同的概念。</li><li><a class="link" href="http://javascript.ruanyifeng.com/nodejs/module.html">CommonJS规范<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" href="http://es6.ruanyifeng.com/#docs/module">ES6 Module 的语法<i class="fas fa-external-link-alt"></i></a></li></ul><p><strong>CommonJS</strong></p><ul><li><strong>Node</strong>应用由模块组成，采用CommonJS模块规范。</li><li>根据这个规范，每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。</li><li>CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。</li></ul><ul><li>下面代码通过module.exports输出变量x和函数addX。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> addX = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value + x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports.x = x;</span><br><span class="line"><span class="built_in">module</span>.exports.addX = addX;</span><br></pre></td></tr></table></figure><ul><li>require方法用于加载模块。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> example = <span class="built_in">require</span>(<span class="string">&#x27;./example.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(example.x); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(example.addX(<span class="number">1</span>)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><ul><li><strong>exports 与 module.exports</strong><ul><li>为了方便，Node为每个模块提供一个exports变量，指向module.exports。这等同在每个模块头部，有一行这样的命令。</li><li><code>var exports = module.exports;</code></li><li>于是我们可以直接在 exports 对象上添加方法，表示对外输出的接口，如同在module.exports 上添加一样。注意，不能直接将exports变量指向一个值，因为这样等于切断了exports与module.exports的联系。</li></ul></li></ul><p><strong>ES6</strong></p><ul><li>不同于CommonJS，ES6使用 export 和 import 来导出、导入模块。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// profile.js</span></span><br><span class="line"><span class="keyword">var</span> firstName = <span class="string">&#x27;Michael&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> lastName = <span class="string">&#x27;Jackson&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> year = <span class="number">1958</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;firstName, lastName, year&#125;;</span><br></pre></td></tr></table></figure><ul><li>需要特别注意的是，export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;m&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法三</span></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;n <span class="keyword">as</span> m&#125;;</span><br></pre></td></tr></table></figure><p><strong>export default</strong></p><ul><li>使用export default命令，为模块指定默认输出。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// export-default.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="crypto"><a href="#crypto" class="headerlink" title="crypto"></a>crypto</h3><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><h3 id="express"><a href="#express" class="headerlink" title="express"></a>express</h3><h3 id="Fabric"><a href="#Fabric" class="headerlink" title="Fabric"></a>Fabric</h3><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><h2 id="多人实时聊天服务器"><a href="#多人实时聊天服务器" class="headerlink" title="多人实时聊天服务器"></a>多人实时聊天服务器</h2><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p><code>npm install socket.io --save</code>    </p><ul><li><p>网络上的程序实现双向的数据链接，这个链接的一端成为socket。</p><p> 1.Socket是一个持久链接。</p><p> 2.Socket是双向通信的。</p></li></ul><p><strong>Socket VS ajax轮询</strong></p><ul><li>ajax轮询 ， 是利用客户端来发送请求，每隔几秒发送一个http请求，服务器压力大。</li><li>Socket不会，一旦链接不会断开，可以实现实时通信。 比如微信的朋友圈更新提示。即时聊天通讯。</li></ul><h2 id="p2p"><a href="#p2p" class="headerlink" title="p2p"></a>p2p</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;h2 id=&quot;NPM&quot;&gt;&lt;a href=&quot;#NPM&quot; class=&quot;headerlink&quot; title=&quot;NPM&quot;&gt;&lt;/a&gt;NPM&lt;/h2&gt;&lt;u</summary>
      
    
    
    
    <category term="notebook" scheme="https://jieyang-wei.github.io/categories/notebook/"/>
    
    
    <category term="编程语言" scheme="https://jieyang-wei.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="nodejs" scheme="https://jieyang-wei.github.io/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>ruby</title>
    <link href="https://jieyang-wei.github.io/2020/12/17/ruby/"/>
    <id>https://jieyang-wei.github.io/2020/12/17/ruby/</id>
    <published>2020-12-17T02:12:34.000Z</published>
    <updated>2021-03-07T08:44:19.900Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Ruby是一种纯粹的面向对象编程语言。它由日本的松本行弘（まつもとゆきひろ/Yukihiro Matsumoto）创建于1993年。</p><p>您可以在 <a class="link" href="http://www.ruby-lang.org/">www.ruby-lang.org<i class="fas fa-external-link-alt"></i></a> 的 Ruby 邮件列表上找到松本行弘（まつもとゆきひろ/Yukihiro Matsumoto）的名字。在 Ruby 社区，松本也被称为马茨（Matz）。</p><p><strong>Ruby 是”程序员的最佳朋友”。</strong></p><p>Ruby 的特性与 Smalltalk、Perl 和 Python 类似。Perl、Python 和 Smalltalk 是脚本语言。Smalltalk 是一个真正的面向对象语言。Ruby，与 Smalltalk 一样，是一个完美的面向对象语言。使用 Ruby 的语法比使用 Smalltalk 的语法要容易得多。</p><p><strong>Ruby历史</strong></p><p>Ruby明显比其他类似的编程语言（如Perl或Python）年轻，又因为Ruby是日本人发明的，所以早期的非日文资料和程序都比较贫乏，所以在网上仍然可以找到类似“Ruby的资料太少”之类的批评。约于2000年，Ruby开始进入美国，英文的资料开始发展。Ruby归根结底源于Perl和Python两类语言，与C，C++，C#，java是不同大类。</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>Ruby 是开源的，在 Web 上免费提供，但需要一个许可证。</li><li>Ruby 是一种通用的、解释的编程语言。</li><li>Ruby 是一种真正的面向对象编程语言。</li><li>Ruby 是一种类似于 Python 和 Perl 的服务器端脚本语言。</li><li>Ruby 可以用来编写通用网关接口（CGI）脚本。</li><li>Ruby 可以被嵌入到超文本标记语言（HTML）。</li><li>Ruby 语法简单，这使得新的开发人员能够快速轻松地学习 Ruby。</li><li>Ruby 与 C++ 和 Perl 等许多编程语言有着类似的语法。</li><li>Ruby 可扩展性强，用 Ruby 编写的大程序易于维护。</li><li>Ruby 可用于开发的 Internet 和 Intranet 应用程序。</li><li>Ruby 可以安装在 Windows 和 POSIX 环境中。</li><li>Ruby 支持许多 GUI 工具，比如 Tcl/Tk、GTK 和 OpenGL。</li><li>Ruby 可以很容易地连接到 DB2、MySQL、Oracle 和 Sybase。</li><li>Ruby 有丰富的内置函数，可以直接在 Ruby 脚本中使用。</li></ul><p><strong>语言特点</strong></p><ul><li>完全面向对象<ul><li>在Ruby语言中，任何东西都是对象，包括其他语言中的基本数据类型，比如整数</li></ul></li><li>变量没有类型</li><li>Ruby的变量可以保存任何类型的数据。</li><li>任何东西都有值</li><li>不管是数学或者逻辑表达式还是一个语句，都会有值。</li><li>ruby语言很优雅，可以做到不需要注释就可以读懂。</li></ul><p>Ruby是动态语言，你可以在程序中修改先前定义过的类。 也可以在某个类的实例中定义该实例特有的方法，这叫做单例方法。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">the_method</span></span></span><br><span class="line">        <span class="string">&quot;generalmethod&quot;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">mc=MyClass.new</span><br><span class="line">def mc.the_method</span><br><span class="line">    <span class="string">&quot;special for this instance.&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><strong>Homebrew:</strong></p><ul><li><a class="link" href="https://brew.sh/index_zh-cn">官网链接<i class="fas fa-external-link-alt"></i></a></li><li>Homebrew是一款Mac OS平台下的软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能。简单的一条指令，就可以实现包管理，而不用你关心各种依赖和文件路径的情况，十分方便快捷。</li><li>援引<a class="link" href="https://link.jianshu.com/?t=http://brew.sh/">官方<i class="fas fa-external-link-alt"></i></a>的一句话：又提示缺少套件啦？别担心，Homebrew 随时守候。Homebrew —— OS X 不可或缺的套件管理器。</li></ul><ul><li>安装路径：<code>/usr/local/Homebrew</code></li><li>大部分情况下，它把软件包安装到 <code>/usr/local/Cellar/程序名/版本号</code>目录 下，然后在 <code>/usr/local/bin</code> 下建立符号链接，没有其他的操作了。</li></ul><ul><li><strong>指令</strong><ul><li>brew –version：查看版本</li><li>brew –repo：查看路径</li></ul></li></ul><p><strong>Ruby:</strong></p><ul><li><a class="link" href="http://www.ruby-lang.org/zh_cn/">官网链接<i class="fas fa-external-link-alt"></i></a></li><li>Ruby，一种简单快捷的面向对象（面向对象程序设计）脚本语言</li><li>CocoaPods是用Ruby构建的，它可以使用macOS上的默认Ruby进行安装。您可以使用Ruby版本管理器(RVM)，但建议使用macOS上提供的标准Ruby。</li></ul><hr><p><strong>注意：</strong>Mac OS X 或 Linux，别在 Windows 上面搞，那是在浪费时间，两个原因</p><ol><li>Ruby 对 Unix 环境的需求非常高，这点 Mac OS X 和 Linux 系列的系统才能很好的满足；</li><li>Ruby 在 Windows 环境下面执行效率低。</li></ol><hr><p><strong>RubyGem:</strong></p><ul><li><a class="link" href="https://www.runoob.com/ruby/ruby-rubygems.html">菜鸟教程<i class="fas fa-external-link-alt"></i></a></li><li>RubyGems 是 Ruby 的一个包管理器，它提供一个分发 Ruby 程序和库的标准格式，还提供一个管理程序包安装的工具。</li><li>RubyGems 旨在方便地管理 gem 安装的工具，以及用于分发 gem 的服务器。这类似于 Ubuntu 下的apt-get, Centos 的 yum，Python 的 pip。</li><li>RubyGems大约创建于2003年11月，从Ruby 1.9版起成为Ruby标准库的一部分。</li><li>Gem 是 Ruby 模块 (叫做 Gems) 的包管理器。其包含包信息，以及用于安装的文件。</li><li>Gem通常是依照”.gemspec”文件构建的，包含了有关Gem信息的YAML文件。Ruby代码也可以直接建立Gem，这种情况下通常利用Rake来进行。</li><li>gem命令用于构建、上传、下载以及安装Gem包。</li></ul><ul><li><strong>指令</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ruby -v          <span class="comment"># 查看安装版本</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rvm -v</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gem sources -l   <span class="comment"># 查看默认镜像源</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> uby的默认源使用的是cocoapods.org，国内访问这个网址有时候会有问题，网上的一种解决方案是将远替换成淘宝的，替换方式如下</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gem <span class="built_in">source</span> -r https://rubygems.org/               <span class="comment"># 移除次镜像源</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gem <span class="built_in">source</span> -a/--add https://gems.ruby-china.org   <span class="comment"># 添加新的镜像源</span></span></span><br></pre></td></tr></table></figure><img src="/2020/12/17/ruby/截屏2020-12-18 上午9.17.40.png" alt="截屏2020-12-18 上午9.17.40" style="zoom:50%;"><p><strong>RVM:</strong></p><ul><li><a class="link" href="https://rvm.io/">官网链接<i class="fas fa-external-link-alt"></i></a></li><li>(Ruby Version Manager)Ruby的版本管理工具。</li><li>RVM 是一个命令行工具，可以让你简单的管理多种版本的Ruby，并在这些版本中切换。</li><li><a class="link" href="https://www.jianshu.com/p/c44ef74d99f9">简书教程<i class="fas fa-external-link-alt"></i></a></li></ul><ul><li><strong>指令</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rvm install 版本      <span class="comment"># 安装指定版本</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rvm install ruby --head  <span class="comment"># 安装最新版本</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> RVM其他常用命令</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rvm info                   <span class="comment"># rvm信息</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rvm list known             <span class="comment"># 列出已知的ruby版本</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rvm list                   <span class="comment"># 查询已经安装的 ruby</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rvm use [版本号] --default  <span class="comment"># 配置ruby使用版本</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rvm get head               <span class="comment"># 升级</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rvm remove 版本号           <span class="comment"># 移除ruby版本</span></span></span><br></pre></td></tr></table></figure><h2 id="Linux-Unix"><a href="#Linux-Unix" class="headerlink" title="Linux / Unix"></a>Linux / Unix</h2><p><strong>Mac</strong></p><ul><li>默认情况下，mac系统已经安装了Ruby, 安装在 <code>/System/Library/Frameworks/Ruby.framework/Versions/Current </code> 目录下。</li><li>但是，由于默认的 Ruby 安装在 <code>/System</code> 目录下，过深的、与 *nix 约定不同的目录结构对日常的开发、维护都带来许多不便。</li></ul><p><strong>Linux/Unix</strong></p><p><a class="link" href="https://www.runoob.com/ruby/ruby-installation-unix.html">Linux/Unix 上的 Ruby 安装<i class="fas fa-external-link-alt"></i></a></p><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p><a class="link" href="https://www.runoob.com/ruby/ruby-installation-windows.html">Windows 上的 Ruby 安装<i class="fas fa-external-link-alt"></i></a></p><p><a class="link" href="https://www.runoob.com/ruby/ruby-command-line-options.html">Ruby 命令行选项<i class="fas fa-external-link-alt"></i></a></p><p><a class="link" href="https://www.runoob.com/ruby/ruby-environment-variables.html">Ruby 环境变量<i class="fas fa-external-link-alt"></i></a></p><ul><li>Ruby 解释器使用下列环境变量来控制它的行为。</li><li>ENV 对象包含了所有当前设置的环境变量列表。</li></ul><table><thead><tr><th align="left">变量</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><strong>DLN_LIBRARY_PATH</strong></td><td align="left">动态加载模块搜索的路径。</td></tr><tr><td align="left"><strong>HOME</strong></td><td align="left">当没有参数传递给 Dir::chdir 时，要移动到的目录。也用于 File::expand_path 来扩展 “~”。</td></tr><tr><td align="left"><strong>LOGDIR</strong></td><td align="left">当没有参数传递给 Dir::chdir 且未设置环境变量 HOME 时，要移动到的目录。</td></tr><tr><td align="left"><strong>PATH</strong></td><td align="left">执行子进程的搜索路径，以及在指定 -S 选项后，Ruby 程序的搜索路径。每个路径用冒号分隔（在 DOS 和 Windows 中用分号分隔）。</td></tr><tr><td align="left"><strong>RUBYLIB</strong></td><td align="left">库的搜索路径。每个路径用冒号分隔（在 DOS 和 Windows 中用分号分隔）。</td></tr><tr><td align="left"><strong>RUBYLIB_PREFIX</strong></td><td align="left">用于修改 RUBYLIB 搜索路径，通过使用格式 path1;path2 或 path1path2，把库的前缀 path1 替换为 path2。</td></tr><tr><td align="left"><strong>RUBYOPT</strong></td><td align="left">传给 Ruby 解释器的命令行选项。在 taint 模式时被忽略（其中，$SAFE 大于 0）。</td></tr><tr><td align="left"><strong>RUBYPATH</strong></td><td align="left">指定 -S 选项后，Ruby 程序的搜索路径。优先级高于 PATH。在 taint 模式时被忽略（其中，$SAFE 大于 0）。</td></tr><tr><td align="left"><strong>RUBYSHELL</strong></td><td align="left">指定执行命令时所使用的 shell。如果未设置该环境变量，则使用 SHELL 或 COMSPEC。</td></tr></tbody></table><h2 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h2><p>Ruby 不需要 IDE，一个简单的文本编辑器就足够了，作为 Ruby 开发者，这个必须习惯。</p><ul><li><p>Mac 平台</p><ul><li><a class="link" href="https://github.com/textmate/textmate/releases">TextMate 2<i class="fas fa-external-link-alt"></i></a></li></ul></li><li><p>Linux / Mac / Windows</p><ul><li><p><a class="link" href="https://code.visualstudio.com/">Visual Studio Code<i class="fas fa-external-link-alt"></i></a></p></li><li><p><a class="link" href="https://atom.io/">Atom<i class="fas fa-external-link-alt"></i></a></p></li><li><p><a class="link" href="http://www.vim.org/">Vim<i class="fas fa-external-link-alt"></i></a> 或 <a class="link" href="http://emacs.org/">Emacs<i class="fas fa-external-link-alt"></i></a></p></li><li><p>如果用 Vim 的话也可以尝试用 <a class="link" href="https://github.com/carlhuda/janus">janus<i class="fas fa-external-link-alt"></i></a></p></li><li><p>Vim 的 Rails 插件 <a class="link" href="http://www.vim.org/scripts/script.php?script_id=1567">rails.vim<i class="fas fa-external-link-alt"></i></a></p></li><li><p><strong><a class="link" href="http://www.sublimetext.com/">Sublime Text<i class="fas fa-external-link-alt"></i></a></strong></p><ul><li>Sublime文件默认存储编码为UTF8，我们几乎不用修改这个选项。</li><li>在按快捷键<code>Control + B</code>执行代码的时候，所有输出都会被Python（Sublime是用Python开发的）接收，然后输出到控制台，输出的字符串编码必须是UTF8编码。</li></ul></li></ul></li></ul><hr><p><strong>设置编译环境</strong></p><p>Tool -&gt; Build System</p><p><strong>编译</strong></p><p>Tool -&gt; build</p><hr><h1 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><strong>空白</strong></p><p><strong>行尾</strong></p><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><h3 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h3><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="语言标准"><a href="#语言标准" class="headerlink" title="语言标准"></a>语言标准</h3><ul><li><p>$ 开头的一定是全局变量</p></li><li><p>@ 开头的都是实例变量</p></li><li><p>@@ 开头的是类变量</p></li><li><p>常数则以大写字母开头</p><ul><li>这种方法，对文本编辑器的命令补全很有帮助，如在vim下先键入$及开头字母，再敲击Ctrl+p，则可专门补全本文件以及关联文件中的全局变量，perl与php亦有此优点。</li></ul></li><li><p>已经定义的类可以在运行时修改</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;Ruby是一种纯粹的面向对象编程语言。它由日本的松本行弘（まつもとゆきひろ/Yukihiro Matsumoto）创建于1993年。&lt;/p&gt;</summary>
      
    
    
    
    <category term="notebook" scheme="https://jieyang-wei.github.io/categories/notebook/"/>
    
    
    <category term="编程语言" scheme="https://jieyang-wei.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="rugy" scheme="https://jieyang-wei.github.io/tags/rugy/"/>
    
  </entry>
  
  <entry>
    <title>编程语言学习</title>
    <link href="https://jieyang-wei.github.io/2020/12/16/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    <id>https://jieyang-wei.github.io/2020/12/16/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-12-16T08:18:33.000Z</published>
    <updated>2021-03-18T06:44:24.039Z</updated>
    
    <content type="html"><![CDATA[<p>最快掌握编程语言</p><ul><li><p>coder：</p><ul><li><strong>图灵完备</strong>：相互之间可以替代的，c的能做，java也能，bat不是</li></ul><blockquote></blockquote><ul><li>标记语言，不是编程语言，没有逻辑</li></ul></li></ul><hr><p>编译语言和脚本语言：</p><ol><li>脚本语言不需要编译器，省去编译过程；而编程语言需要编译器</li><li>脚本语言是动态的，可以实时更改代码；而编程语言不可以实时更改代码。</li><li>脚本语言易学，但缺乏系统性；编程语言较为成熟</li><li>一些语言既可以是脚本语言也可以是编译语言，取决于怎么使用（c#、Python等）</li></ol><p>脚本语言：bat</p><hr><ol><li><p>语言背景</p></li><li><p>程序逻辑</p><ul><li>编程语言环境<ul><li>强类型：<ul><li>定义a = “string”，就知道a是一个字符串类型</li><li>Java，python</li></ul></li><li>弱类型：<ul><li>需要定义 String a = “String”，才知道类型，像C需要程序猿去判定类型</li><li>C，PHP，js</li></ul></li></ul></li></ul></li><li><p>变量</p><ul><li>变量定义<ul><li>动态类型<ul><li>js</li></ul></li><li>静态类型<ul><li>java</li></ul></li></ul></li><li>变量类型<ul><li>值类型（基本类型）<ul><li>变量在栈里面声明，</li><li>C，C++，引用类型通过指针来实现</li></ul></li><li>引用类型（封装类型）<ul><li>变量是指针，指向了内存地址中变量的地址</li><li>python，js</li></ul></li><li>java - 即保留值类型，也保留引用类型</li><li>应用在比较变量中，引用类型需要重写equal方法，不然比较的是地址</li></ul></li></ul></li><li><p>容器对象</p><ul><li>简单操作</li><li>浅复制，深复制、序列化</li></ul></li><li><p>类接口、抽象类</p></li><li><p>函数</p></li><li><p>生态、依赖</p><ul><li>框架，包管理工具</li></ul></li><li><p>高级特性</p><ul><li>java - 并发、高性能处理</li><li>是否支持携程</li></ul></li></ol><p>训练任务：</p><ol><li>支持消息循环的交互程序，一个文字版RPG小游戏</li><li>比较机械的控制，比如二进制位控制，</li></ol><p>【python game】</p><p>fixupdate</p><p>显卡不给力：一帧一帧的出来</p><p>update</p><p>window.setAnimation</p><p>2D技术跟3D完全不一样</p><p>3D - 显卡实时渲染</p><p>nodejs</p><p>ECMAScript，ES标准：</p><ul><li>最早浏览器支持的是ES2的标准</li></ul><p>WebKit</p><p>alert():bomapi</p><p>nodejs、unity这种是js运行的环境</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最快掌握编程语言&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;coder：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;图灵完备&lt;/strong&gt;：相互之间可以替代的，c的能做，java也能，bat不是&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;ul&gt;</summary>
      
    
    
    
    <category term="notebook" scheme="https://jieyang-wei.github.io/categories/notebook/"/>
    
    <category term="theory" scheme="https://jieyang-wei.github.io/categories/notebook/theory/"/>
    
    
    <category term="编程语言" scheme="https://jieyang-wei.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="理论知识" scheme="https://jieyang-wei.github.io/tags/%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>python</title>
    <link href="https://jieyang-wei.github.io/2020/12/15/python/"/>
    <id>https://jieyang-wei.github.io/2020/12/15/python/</id>
    <published>2020-12-15T06:32:10.000Z</published>
    <updated>2021-03-20T05:40:21.272Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a>Anaconda</h1><ul><li><a class="link" href="https://www.jianshu.com/p/62f155eb6ac5">Anaconda部分原博客<i class="fas fa-external-link-alt"></i></a></li><li>Anaconda（<a class="link" href="https://link.jianshu.com/?t=https://www.anaconda.com/download/%23macos">官方网站<i class="fas fa-external-link-alt"></i></a>）就是可以便捷获取包且对包能够进行管理，同时对环境可以统一管理的发行版本。</li><li>Anaconda包含了conda、Python在内的超过180个科学包及其依赖项。</li><li>其特点的实现是因为包含：<ul><li> conda包</li><li>环境管理器</li><li>1000+开源库</li></ul></li></ul><p>特点：</p><ul><li>开源</li><li>安装过程简单</li><li>高性能使用python和R语言</li><li>免费的社区支持</li></ul><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><h3 id="1-Anaconda"><a href="#1-Anaconda" class="headerlink" title="1. Anaconda"></a>1. Anaconda</h3><ul><li>Anaconda是一个包含180+的科学包及其依赖项的发行版本。</li><li>其包含的科学包包括：<ul><li>conda, numpy, scipy, ipython notebook等。</li></ul></li></ul><h3 id="2-conda"><a href="#2-conda" class="headerlink" title="2. conda"></a>2. conda</h3><ul><li><p>conda是包及其依赖项和环境的管理工具。</p></li><li><p>适用语言：</p><ul><li>Python, R, Ruby, Lua, Scala, Java, JavaScript, C/C++, FORTRAN。</li></ul></li><li><p>适用平台：</p><ul><li>Windows, macOS, Linux</li></ul></li></ul><p><strong>用途</strong>：</p><ol><li>快速安装、运行和升级包及其依赖项。</li><li>在计算机中便捷地创建、保存、加载和切换环境。</li></ol><blockquote><p>如果你需要的包要求不同版本的Python，你无需切换到不同的环境，因为conda同样是一个环境管理器。仅需要几条命令，你可以创建一个完全独立的环境来运行不同的Python版本，同时继续在你常规的环境中使用你常用的Python版本。——<a class="link" href="https://link.jianshu.com/?t=https://conda.io/docs/">conda官方网站<i class="fas fa-external-link-alt"></i></a></p></blockquote><ul><li>onda为Python项目而创造，但可适用于上述的多种语言。</li><li>conda包和环境管理器包含于Anaconda的所有版本当中。</li></ul><h3 id="3-pip"><a href="#3-pip" class="headerlink" title="3. pip"></a>3. pip</h3><ul><li><p>pip是用于安装和管理软件包的包管理器。</p></li><li><p>pip编写语言：Python。</p></li><li><p>Python中默认安装的版本：</p><ul><li>Python 2.7.9及后续版本：默认安装，命令为<code>pip</code></li><li>Python 3.4及后续版本：默认安装，命令为<code>pip3</code></li></ul></li><li><p>pip名称的由来：pip采用的是<strong>递归缩写</strong>进行命名的。其名字被普遍认为来源于2处：</p><ul><li>“Pip installs Packages”（“pip安装包”）</li><li>“Pip installs Python”（“pip安装Python”）</li></ul></li></ul><h3 id="4-virtualenv"><a href="#4-virtualenv" class="headerlink" title="4.virtualenv"></a>4.virtualenv</h3><ul><li><p>virtualenv：用于创建一个<strong>独立的</strong>Python环境的工具。</p></li><li><p>解决问题：</p><ol><li>当一个程序需要使用Python 2.7版本，而另一个程序需要使用Python 3.6版本，如何同时使用这两个程序？</li><li>如果将所有程序都安装在系统下的默认路径，如：<code>/usr/lib/python2.7/site-packages</code>，当不小心升级了本不该升级的程序时，将会对其他的程序造成影响。</li><li>如果想要安装程序并在程序运行时对其库或库的版本进行修改，都会导致程序的中断。</li><li>在共享主机时，无法在全局<code>site-packages</code>目录中安装包。</li></ol></li><li><p>virtualenv将会为它自己的安装目录创建一个环境，这并<strong>不与</strong>其他virtualenv环境共享库；同时也可以<strong>选择性</strong>地不连接已安装的全局库。</p></li></ul><hr><p><strong>pip与conda比较</strong>：</p><ol><li><p><strong>依赖项检查</strong></p><ul><li>pip：<ul><li><strong>不一定</strong>会展示所需其他依赖包。</li><li>安装包时<strong>或许</strong>会直接忽略依赖项而安装，仅在结果中提示错误。</li></ul></li><li>conda：<ul><li>列出所需其他依赖包。</li><li>安装包时自动安装其依赖项。</li><li>可以便捷地在包的不同版本中自由切换。</li></ul></li></ul></li><li><p><strong>环境管理</strong></p><ul><li>pip：维护多个环境难度较大。</li><li>conda：比较方便地在不同环境之间进行切换，环境管理较为简单。</li></ul></li><li><p><strong>对系统自带Python的影响</strong></p><ul><li>pip：在系统自带Python中包的**更新/回退版本/卸载将影响其他程序。</li><li>conda：不会影响系统自带Python。</li></ul></li><li><p><strong>适用语言</strong></p><ul><li>pip：仅适用于Python。</li><li>conda：适用于Python, R, Ruby, Lua, Scala, Java, JavaScript, C/C++, FORTRAN。</li></ul></li></ol><p> <strong>conda与pip、virtualenv的关系</strong></p><ul><li>conda<strong>结合</strong>了pip和virtualenv的功能。</li></ul><hr><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>查看是否安装了python和anaconda：</p><img src="/2020/12/15/python/DF8274195F82F3A1713FE9FAB66C46B5.png" alt="DF8274195F82F3A1713FE9FAB66C46B5" style="zoom: 50%;">    <ol><li><p><code>$ conda list</code>：如果Anaconda被成功安装，则会显示已经安装的包名和版本号。</p></li><li><p><code>$ python</code>：进入python终端的命令行</p><ul><li>如果同时安装了Anaconda，则会显示上图红色的部分</li><li>exit() / quit()：退出</li></ul></li><li><p>终端输入<code>$ anaconda-navigator</code>将会打开anaconda-navigator图形界面</p></li></ol><p><strong>安装教程</strong>：自行百度，或者<a class="link" href="https://www.jianshu.com/p/62f155eb6ac5">原博客<i class="fas fa-external-link-alt"></i></a>有</p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="管理conda和环境"><a href="#管理conda和环境" class="headerlink" title="管理conda和环境"></a>管理conda和环境</h3><ul><li>验证conda已被安装</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda list              <span class="comment"># 显示已经安装的包名和版本号</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> conda --version         <span class="comment"># 查看conda版本号码</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> conda update conda      <span class="comment"># 更新conda至最新版本</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> conda --<span class="built_in">help</span>            <span class="comment"># 查看帮助信息</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rm -rf anaconda安装路径   <span class="comment"># 删除只需要删除安装目录即可（mac os）</span></span> </span><br></pre></td></tr></table></figure><p><strong>创建新环境</strong> </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda create --name &lt;env_name&gt; &lt;package_names&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;env_name&gt;</code>：即创建的环境名。建议以英文命名，且不加空格，名称两边不加尖括号“&lt;&gt;”。</li><li><code>&lt;package_names&gt;</code>：即安装在环境中的包名。名称两边不加尖括号“&lt;&gt;”。<ol><li>如果要安装指定的版本号，则只需要在包名后面以<code>=</code>和版本号的形式执行。如：<code>conda create --name python2 python=2.7</code>，即创建一个名为“python2”的环境，环境中安装版本为2.7的python。</li><li>如果要在新创建的环境中创建多个包，则直接在<code>&lt;package_names&gt;</code>后以<strong>空格</strong>隔开，添加多个包名即可。如：<code>conda create -n python3 python=3.5 numpy pandas</code>，即创建一个名为“python3”的环境，环境中安装版本为3.5的python，同时也安装了numpy和pandas。</li></ol></li><li>默认情况下，新创建的环境将会被保存在<code>/Users/&lt;user_name&gt;/anaconda3/env</code>目录下，其中，<code>&lt;user_name&gt;</code>为当前用户的用户名。</li></ul><p><strong>切换环境</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Linux 或macOS</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> activate &lt;env_name&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Windows</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> activate &lt;env_name&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>如果创建环境后安装Python时没有指定Python的版本，那么将会安装与Anaconda版本相同的Python版本，即如果安装Anaconda第2版，则会自动安装Python 2.x；如果安装Anaconda第3版，则会自动安装Python 3.x。</p></li><li><p>当成功切换环境之后，在该行行首将以“(env_name)”或“[env_name]”开头。其中，“env_name”为切换到的环境名。如：在macOS系统中执行<code>source active python2</code>，即切换至名为“python2”的环境，则行首将会以(python2)开头。</p></li></ul><p><strong>退出环境至root</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Linux 或macOS</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> deactivate</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Windows</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> deactivate</span></span><br></pre></td></tr></table></figure><ul><li>当执行退出当前环境，回到root环境命令后，原本行首以 “(env_name)” 或 “[env_name]” 开头的字符将不再显示。</li></ul><p><strong>显示已创建的环境</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda info -envs</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> conda info -e</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> conda env list</span></span><br></pre></td></tr></table></figure><img src="/2020/12/15/python/6349AECA-85FB-4EBA-82CE-CCBE8F84A59B.png" alt="6349AECA-85FB-4EBA-82CE-CCBE8F84A59B" style="zoom:50%;">    <ul><li>结果中星号<code>*</code>所在行即为当前所在环境。macOS系统中默认创建的环境名为<code>base</code>。</li></ul><p><strong>复制环境</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda create --name &lt;new_env_name&gt; --<span class="built_in">clone</span> &lt;copied_env_name&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;copied_env_name&gt;</code>即为被复制/克隆环境名。环境名两边不加尖括号“&lt;&gt;”</li><li><code>&lt;new_env_name&gt;</code>即为复制之后新环境的名称。环境名两边不加尖括号“&lt;&gt;”。<ul><li>如：<code>$ conda create --name py2 --clone python2</code>，即为克隆名为“python2”的环境，克隆后的新环境名为“py2”。此时，环境中将同时存在“python2”和“py2”环境，且两个环境的配置相同。</li></ul></li></ul><p><strong>删除环境</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda remove --name &lt;env_name&gt; --all</span></span><br></pre></td></tr></table></figure><p><strong>复制环境</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda create --name &lt;new_env_name&gt; --<span class="built_in">clone</span> &lt;copied_env_name&gt;</span></span><br></pre></td></tr></table></figure><h3 id="管理包"><a href="#管理包" class="headerlink" title="管理包"></a>管理包</h3><h4 id="1-查找可供安装的包版本"><a href="#1-查找可供安装的包版本" class="headerlink" title="1. 查找可供安装的包版本"></a>1. 查找可供安装的包版本</h4><ol><li>精确查找</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ conda search --full-name &lt;package_full_name&gt;</span><br></pre></td></tr></table></figure><ul><li><code>--full-name</code>：精确查找的参数。</li><li><code>&lt;package_full_name&gt;</code>：是被查找包的<strong>全名</strong>。包名两边不加尖括号“&lt;&gt;”。<ul><li>例如：<code>conda search --full-name python</code>即查找全名为“python”的包有哪些版本可供安装。</li></ul></li></ul><ol start="2"><li>模糊查找</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda search &lt;text&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;text&gt;</code>：查找含有<strong>此字段</strong>的包名。此字段两边不加尖括号“&lt;&gt;”。<ul><li>例如：<code>conda search py</code>即查找含有“py”字段的包，有哪些版本可供安装。</li></ul></li></ul><h4 id="2-获取当前环境中已安装的包信息"><a href="#2-获取当前环境中已安装的包信息" class="headerlink" title="2. 获取当前环境中已安装的包信息"></a>2. 获取当前环境中已安装的包信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda list</span></span><br></pre></td></tr></table></figure><ul><li>执行上述命令后将在终端显示当前环境已安装包的包名及其版本号。</li></ul><h4 id="3-安装包"><a href="#3-安装包" class="headerlink" title="3. 安装包"></a>3. 安装包</h4><ol><li><strong>在指定环境中安装包</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda install --name &lt;env_name&gt; &lt;package_name&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;env_name&gt;</code>：将包安装的指定环境名。环境名两边不加尖括号“&lt;&gt;”。</li><li><code>&lt;package_name&gt;</code>：要安装的包名。包名两边不加尖括号“&lt;&gt;”。<ul><li>例如：<code>conda install --name python2 pandas</code>即在名为“python2”的环境中安装pandas包。</li></ul></li></ul><ol start="2"><li><strong>在当前环境中安装包</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda install &lt;package_name&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;package_name&gt;</code>：要安装的包名。包名两边不加尖括号“&lt;&gt;”。</li><li>执行命令后在当前环境中安装包。<ul><li>例如：<code>conda install pandas</code>即在当前环境中安装pandas包。</li></ul></li></ul><ol start="3"><li><strong>使用pip安装包</strong></li></ol><p><strong>使用场景</strong>：</p><ul><li>当使用<code>conda install</code>无法进行安装时，可以使用pip进行安装。例如：see包。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> pip install &lt;package_name&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;pacage_name&gt;</code>：指定安装包的名称。包名两边不加尖括号“&lt;&gt;”。<ul><li>如：<code>pip install see</code>即安装see包。</li></ul></li></ul><p><strong>注意：</strong></p><ul><li>pip只是包管理器，无法对环境进行管理。因此如果想在指定环境中使用pip进行安装包，则需要先切换到指定环境中，再使用pip命令安装包。</li><li>pip无法更新python，因为pip并不将python视为包。</li><li>pip可以安装一些conda无法安装的包；conda也可以安装一些pip无法安装的包。因此当使用一种命令无法安装包时，可以尝试用另一种命令。</li></ul><ol start="4"><li><strong>从Anaconda.org安装包</strong></li></ol><p><strong>使用场景</strong></p><ul><li>当使用<code>conda install</code>无法进行安装时，可以考虑从Anaconda.org中获取安装包的命令，并进行安装。</li></ul><p><strong>注意</strong></p><ol><li>从Anaconda.org安装包时，无需注册。</li><li>在<strong>当前环境</strong>中安装来自于Anaconda.org的包时，需要通过输入要安装的包在Anaconda.org中的路径作为获取途径（channel）</li></ol><h4 id="4-卸载包"><a href="#4-卸载包" class="headerlink" title="4. 卸载包"></a>4. 卸载包</h4><ol><li>卸载指定环境中的包</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda remove --name &lt;env_name&gt; &lt;package_name&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;env_name&gt;</code>：卸载包所在指定环境的名称。环境名两边不加尖括号“&lt;&gt;”</li><li><code>&lt;package_name&gt;</code>：要卸载包的名称。包名两边不加尖括号“&lt;&gt;”。<ul><li>例如：<code>conda remove --name python2 pandas</code>即卸载名为“python2”中的pandas包。</li></ul></li></ul><ol start="2"><li>卸载当前环境中的包</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda remove &lt;package_name&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;package_name&gt;</code>：要卸载包的名称。包名两边不加尖括号“&lt;&gt;”。</li><li>执行命令后即在当前环境中卸载指定包。<ul><li>例如：<code>conda remove pandas</code>即在当前环境中卸载pandas包。</li></ul></li></ul><h4 id="5-更新包"><a href="#5-更新包" class="headerlink" title="5. 更新包"></a>5. 更新包</h4><ol><li>更新所有包</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda update --all</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> conda upgrade --all</span></span><br></pre></td></tr></table></figure><ul><li>建议：在安装Anaconda之后执行上述命令更新Anaconda中的所有包至最新版本，便于使用。</li></ul><ol start="2"><li>更新指定包</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda update &lt;package_name&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> conda upgrade &lt;package_name&gt;</span></span><br></pre></td></tr></table></figure><ul><li>注意：<ol><li><code>&lt;package_name&gt;</code>为指定更新的包名。包名两边不加尖括号“&lt;&gt;”。</li><li>更新多个指定包，则包名以<strong>空格</strong>隔开，向后排列。如：<code>conda update pandas numpy matplotlib</code>即更新pandas、numpy、matplotlib包。</li></ol></li></ul><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><p><a class="link" href="https://www.runoob.com/python/python-tutorial.html">菜鸟教程<i class="fas fa-external-link-alt"></i></a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>Python 是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言</li><li>Python 的设计具有很强的可读性，相比其他语言经常使用英文关键字，其他语言的一些标点符号，它具有比其他语言更有特色语法结构。<ul><li><strong>Python 是一种解释型语言：</strong>这意味着开发过程中没有了编译这个环节。类似于PHP和Perl语言。</li><li><strong>Python 是交互式语言：</strong>这意味着，您可以在一个 Python 提示符 <strong>&gt;&gt;&gt;</strong> 后直接执行代码。</li><li><strong>Python 是面向对象语言：</strong> 这意味着Python支持面向对象的风格或代码封装在对象的编程技术。</li><li><strong>Python 是初学者的语言：</strong>Python 对初级程序员而言，是一种伟大的语言，它支持广泛的应用程序开发，从简单的文字处理到 WWW 浏览器再到游戏。</li></ul></li></ul><p>特点：</p><ol><li><strong>易于学习：</strong>Python有相对较少的关键字，结构简单，和一个明确定义的语法，学习起来更加简单。</li><li><strong>易于阅读：</strong>Python代码定义的更清晰。</li><li><strong>易于维护：</strong>Python的成功在于它的源代码是相当容易维护的。</li><li><strong>一个广泛的标准库：</strong>Python的最大的优势之一是丰富的库，跨平台的，在UNIX，Windows和Macintosh兼容很好。</li><li><strong>互动模式：</strong>互动模式的支持，您可以从终端输入执行代码并获得结果的语言，互动的测试和调试代码片断。</li><li><strong>可移植：</strong>基于其开放源代码的特性，Python已经被移植（也就是使其工作）到许多平台。</li><li><strong>可扩展：</strong>如果你需要一段运行很快的关键代码，或者是想要编写一些不愿开放的算法，你可以使用C或C++完成那部分程序，然后从你的Python程序中调用。</li><li><strong>数据库：</strong>Python提供所有主要的商业数据库的接口。</li><li><strong>GUI编程：</strong>Python支持GUI可以创建和移植到许多系统调用。</li><li><strong>可嵌入：</strong>你可以将Python嵌入到C/C++程序，让你的程序的用户获得”脚本化”的能力。</li></ol><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><p>安装过程：自行百度云</p><p><strong>环境变量</strong></p><table><thead><tr><th>PYTHONPATH</th><th>PYTHONPATH是Python搜索路径，默认我们import的模块都会从PYTHONPATH里面寻找。</th></tr></thead><tbody><tr><td>PYTHONSTARTUP</td><td>Python启动后，先寻找PYTHONSTARTUP环境变量，然后执行此变量指定的文件中的代码。</td></tr><tr><td>PYTHONCASEOK</td><td>加入PYTHONCASEOK的环境变量, 就会使python导入模块的时候不区分大小写.</td></tr><tr><td>PYTHONHOME</td><td>另一种模块搜索路径。它通常内嵌于的PYTHONSTARTUP或PYTHONPATH目录中，使得两个模块库更容易切换。</td></tr></tbody></table><p><strong>集成开发环境（IDE, Integrated Development Environment）</strong>：PyCharm</p><ul><li>PyCharm 是由 JetBrains 打造的一款 Python IDE，支持 macOS、 Windows、 Linux 系统。</li><li>功能 : <ul><li>调试、语法高亮、Project管理、代码跳转、智能提示、自动完成、单元测试、版本控制……</li></ul></li><li><a class="link" href="https://www.jetbrains.com/pycharm/download/">下载地址<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" href="http://www.runoob.com/w3cnote/pycharm-windows-install.html](https://www.runoob.com/w3cnote/pycharm-windows-install.html)">安装地址<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="基础教程"><a href="#基础教程" class="headerlink" title="基础教程"></a>基础教程</h2><p><strong>中文编码</strong></p><img src="/2020/12/15/python/截屏2020-12-15 下午4.13.19.png" alt="截屏2020-12-15 下午4.13.19" style="zoom:60%;"><ul><li>python3.x源文件默认支持中文编码，无需制定</li><li>如果你使用编辑器，同时需要设置 py 文件存储的格式为 UTF-8，否则会出现错误信息<ul><li>进入 <strong>file &gt; Settings</strong>，在输入框搜索 <strong>encoding</strong>。</li><li>找到 <strong>Editor &gt; File encodings</strong>，将 <strong>IDE Encoding</strong> 和 <strong>Project Encoding</strong> 设置为utf-8。</li></ul></li></ul><h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> num     <span class="comment"># python2.x</span></span><br><span class="line"><span class="built_in">print</span> (num)   <span class="comment"># python3.x</span></span><br></pre></td></tr></table></figure><ul><li>默认换行输出，如果不需要换行，在末尾加入逗号<code>print x,</code>这样的话只会空格</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]: <span class="built_in">print</span> (x, end=<span class="string">&quot;。&quot;</span>)   <span class="comment"># 1。2。3。</span></span><br></pre></td></tr></table></figure><ul><li>指定以”。”为末尾输出，默认是”\n”换行</li></ul><p><strong>等待用户输入：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">str</span> = <span class="built_in">input</span>(<span class="string">&quot;\n\n按下 enter 键后退出。&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>两种输出值的方式：</strong></p><ol><li>表达式</li><li>print()</li><li>文件使用文件对象write()方法，标准输出文件可以用 sys.stdout 引用。</li></ol><ul><li>如果你希望输出的形式更加多样，可以使用 str.format() 函数来格式化输出值。</li><li>如果你希望将输出的值转成字符串，可以使用 repr() 或 str() 函数来实现。<ul><li><strong>str()：</strong> 函数返回一个用户易读的表达形式。 </li><li><strong>repr()：</strong> 产生一个解释器易读的表达形式。</li></ul></li></ul><p><strong>python2.x中使用python2.x的print函数</strong>：</p><ul><li><code>from __future__ import print_function</code></li><li>可以导入 <code>__future__</code>包，该包禁用 Python2.x 的 print 语句，采用 Python3.x 的 print 函数</li><li>Python3.x 与 Python2.x 的许多兼容性设计的功能可以通过  <code>__future__</code>这个包来导入</li></ul><p><strong>输出格式</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&quot;&#123;0:&lt;10&#125;&#123;1:&lt;10&#125;&#123;2:&gt;5&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&#x27;word&#x27;</span>, <span class="string">&#x27;len&#x27;</span>, <span class="string">&#x27;num&#x27;</span>))</span><br><span class="line"><span class="comment"># word      len         num</span></span><br></pre></td></tr></table></figure><ul><li>以标准格式输出</li></ul><h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h4><ul><li><p>标识符由字母、数字、下划线组成。</p></li><li><p>所有标识符可以包括英文、数字以及下划线(_)，但不能以数字开头。</p></li><li><p>Python 中的标识符是区分大小写的。</p></li><li><p>以<strong>下划线开头</strong>的标识符是有特殊意义的。</p><ul><li>以单下划线开头<code> _foo</code>的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用<code>from xxx import *</code>而导入。</li><li>以双下划线开头的<code>__foo</code>代表类的私有成员，以双下划线开头和结尾的 <code>__foo__</code>代表 Python 里特殊方法专用的标识<ul><li>如<code>__init__()</code>代表类的构造函数。</li></ul></li></ul></li><li><p>Python 可以同一行显示多条语句，方法是用分号 <strong>;</strong> 分开</p><ul><li><code>print (&#39;hello&#39;); print (&#39;world&#39;)</code></li></ul></li></ul><h4 id="保留字符"><a href="#保留字符" class="headerlink" title="保留字符"></a>保留字符</h4><ul><li>不能用作常数或变数，或任何其他标识符名称</li><li>所有 Python 的关键字只包含小写字母</li></ul><table><thead><tr><th>and</th><th>exec</th><th>not</th></tr></thead><tbody><tr><td>assert</td><td>finally</td><td>or</td></tr><tr><td>break</td><td>for</td><td>pass</td></tr><tr><td>class</td><td>from</td><td>print</td></tr><tr><td>continue</td><td>global</td><td>raise</td></tr><tr><td>def</td><td>if</td><td>return</td></tr><tr><td>del</td><td>import</td><td>try</td></tr><tr><td>elif</td><td>in</td><td>while</td></tr><tr><td>else</td><td>is</td><td>with</td></tr><tr><td>except</td><td>lambda</td><td>yield</td></tr></tbody></table><h4 id="行和缩进"><a href="#行和缩进" class="headerlink" title="行和缩进"></a>行和缩进</h4><ul><li>学习 Python 与其他语言最大的区别就是，Python 的代码块不使用大括号 <strong>{}</strong> 来控制类，函数以及其他逻辑判断。python 最具特色的就是用缩进来写模块。</li><li>缩进的空白数量是可变的，但是所有代码块语句必须包含相同的缩进空白数量，这个必须严格执行。<ul><li><img src="/2020/12/15/python/截屏2020-12-15 下午4.27.30.png" alt="截屏2020-12-15 下午4.27.30" style="zoom:50%;">    </li></ul></li></ul><p><strong>多行语句：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">total = item_one + \</span><br><span class="line">        item_two + \</span><br><span class="line">        item_three</span><br><span class="line"><span class="comment"># 和</span></span><br><span class="line">days = [<span class="string">&#x27;Monday&#x27;</span>, <span class="string">&#x27;Tuesday&#x27;</span>, <span class="string">&#x27;Wednesday&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Thursday&#x27;</span>, <span class="string">&#x27;Friday&#x27;</span>]</span><br></pre></td></tr></table></figure><p><strong>引号：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">word = <span class="string">&#x27;word&#x27;</span></span><br><span class="line">sentence = <span class="string">&quot;这是一个句子。&quot;</span></span><br><span class="line">paragraph = <span class="string">&quot;&quot;&quot;这是一个段落</span></span><br><span class="line"><span class="string">包含了多个语句&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">多行注释1</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">多行注释2</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><ul><li>三引号可以由多行组成，编写多行文本的快捷语法，常用于文档字符串，在文件的特定地点，被当做注释。</li></ul><p><strong>空行：</strong></p><ul><li>函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。</li><li>空行与代码缩进不同，空行并不是Python语法的一部分。书写时不插入空行，Python解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。</li><li>记住：空行也是程序代码的一部分。</li></ul><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><h4 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = b = c = <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>以上实例，创建一个整型对象，值为1，三个变量被分配到相同的内存空间上。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b, c = <span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;john&quot;</span></span><br></pre></td></tr></table></figure><ul><li>为多个对象指定多个变量</li></ul><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><ol><li><p>算术运算符</p><ul><li>a = 10，b = 21</li></ul><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">+</td><td align="left">加 - 两个对象相加</td><td align="left">a + b 输出结果 31</td></tr><tr><td align="left">-</td><td align="left">减 - 得到负数或是一个数减去另一个数</td><td align="left">a - b 输出结果 -11</td></tr><tr><td align="left">*</td><td align="left">乘 - 两个数相乘或是返回一个被重复若干次的字符串</td><td align="left">a * b 输出结果 210</td></tr><tr><td align="left">/</td><td align="left">除 - x 除以 y</td><td align="left">b / a 输出结果 2.1</td></tr><tr><td align="left">%</td><td align="left">取模 - 返回除法的余数</td><td align="left">b % a 输出结果 1</td></tr><tr><td align="left">**</td><td align="left">幂 - 返回x的y次幂</td><td align="left">a**b 为10的21次方</td></tr><tr><td align="left">//</td><td align="left">取整除 - 向下取接近商的整数</td><td align="left"><code>&gt;&gt;&gt; 9//2 4 &gt;&gt;&gt; -9//2 -5</code></td></tr></tbody></table></li><li><p>比较（关系）运算符</p><ul><li>a = 10，b = 20</li></ul><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">==</td><td align="left">等于 - 比较对象是否相等</td><td align="left">(a == b) 返回 False。</td></tr><tr><td align="left">!=</td><td align="left">不等于 - 比较两个对象是否不相等</td><td align="left">(a != b) 返回 True。</td></tr><tr><td align="left">&gt;</td><td align="left">大于 - 返回x是否大于y</td><td align="left">(a &gt; b) 返回 False。</td></tr><tr><td align="left">&lt;</td><td align="left">小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。注意，这些变量名的大写。</td><td align="left">(a &lt; b) 返回 True。</td></tr><tr><td align="left">&gt;=</td><td align="left">大于等于 - 返回x是否大于等于y。</td><td align="left">(a &gt;= b) 返回 False。</td></tr><tr><td align="left">&lt;=</td><td align="left">小于等于 - 返回x是否小于等于y。</td><td align="left">(a &lt;= b) 返回 True。</td></tr></tbody></table></li><li><p>赋值运算符</p><ul><li>a = 10，b = 20</li></ul><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">=</td><td align="left">简单的赋值运算符</td><td align="left">c = a + b 将 a + b 的运算结果赋值为 c</td></tr><tr><td align="left">+=</td><td align="left">加法赋值运算符</td><td align="left">c += a 等效于 c = c + a</td></tr><tr><td align="left">-=</td><td align="left">减法赋值运算符</td><td align="left">c -= a 等效于 c = c - a</td></tr><tr><td align="left">*=</td><td align="left">乘法赋值运算符</td><td align="left">c *= a 等效于 c = c * a</td></tr><tr><td align="left">/=</td><td align="left">除法赋值运算符</td><td align="left">c /= a 等效于 c = c / a</td></tr><tr><td align="left">%=</td><td align="left">取模赋值运算符</td><td align="left">c %= a 等效于 c = c % a</td></tr><tr><td align="left">**=</td><td align="left">幂赋值运算符</td><td align="left">c **= a 等效于 c = c ** a</td></tr><tr><td align="left">//=</td><td align="left">取整除赋值运算符</td><td align="left">c //= a 等效于 c = c // a</td></tr><tr><td align="left">:=</td><td align="left">海象运算符，可在表达式内部为变量赋值。<strong>Python3.8 版本新增运算符</strong>。</td><td align="left">在这个示例中，赋值表达式可以避免调用 len() 两次:<br><code>if (n := len(a)) &gt; 10:    print(f&quot;List is too long (&#123;n&#125; elements, expected &lt;= 10)&quot;)</code></td></tr></tbody></table></li><li><p>逻辑运算符</p><ul><li>a = 10，b = 20</li></ul><table><thead><tr><th align="left">运算符</th><th align="left">逻辑表达式</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">and</td><td align="left">x and y</td><td align="left">布尔”与” - 如果 x 为 False，x and y 返回 x 的值，否则返回 y 的计算值。</td><td align="left">(a and b) 返回 20。</td></tr><tr><td align="left">or</td><td align="left">x or y</td><td align="left">布尔”或” - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。</td><td align="left">(a or b) 返回 10。</td></tr><tr><td align="left">not</td><td align="left">not x</td><td align="left">布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。</td><td align="left">not(a and b) 返回 False</td></tr></tbody></table></li><li><p>位运算符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">60</span>     <span class="comment"># 0011 1100</span></span><br><span class="line">b = <span class="number">13</span>     <span class="comment"># 0000 1101</span></span><br><span class="line">-----------------</span><br><span class="line">a&amp;b = <span class="number">12</span>   <span class="comment"># 0000 1100   按位与</span></span><br><span class="line">a|b = <span class="number">61</span>   <span class="comment"># 0011 1101   按位或</span></span><br><span class="line">a^b = <span class="number">49</span>   <span class="comment"># 0011 0001   按位异或</span></span><br><span class="line">~a = -<span class="number">61</span>   <span class="comment"># 1100 0011   按位取反</span></span><br><span class="line">a&lt;&lt;<span class="number">2</span> = <span class="number">240</span> <span class="comment"># 1111 0000   左移</span></span><br><span class="line">a&gt;&gt;<span class="number">2</span> = <span class="number">15</span>  <span class="comment"># 0000 1111   右移</span></span><br></pre></td></tr></table></figure></li><li><p>成员运算符</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">in</td><td align="left">如果在指定的序列中找到值返回 True，否则返回 False。</td><td align="left">x 在 y 序列中 , 如果 x 在 y 序列中返回 True。</td></tr><tr><td align="left">not in</td><td align="left">如果在指定的序列中没有找到值返回 True，否则返回 False。</td><td align="left">x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。</td></tr></tbody></table></li><li><p>身份运算符</p><ul><li>比较两个对象的存储单元</li><li><code>id()</code>：获取对象内存地址。</li><li>is和==<ul><li>is 用于判断两个变量引用对象是否为同一个</li><li> == 用于判断引用变量的值是否相等。</li></ul></li></ul><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">is</td><td align="left">is 是判断两个标识符是不是引用自一个对象</td><td align="left"><strong>x is y</strong>, 类似 <strong>id(x) == id(y)</strong> , 如果引用的是同一个对象则返回 True，否则返回 False</td></tr><tr><td align="left">is  not</td><td align="left">is not 是判断两个标识符是不是引用自不同对象</td><td align="left"><strong>x is not y</strong> ， 类似 **id(a) != id(b)**。如果引用的不是同一个对象则返回结果 True，否则返回 False。</td></tr></tbody></table></li><li><p>运算符优先级</p></li></ol><h4 id="标准数据类型"><a href="#标准数据类型" class="headerlink" title="标准数据类型"></a>标准数据类型</h4><ul><li>不可变数据：Number（数字）、String（字符串）、Tuple（元组）；<ul><li>变量赋值 <strong>a=5</strong> 后再赋值 <strong>a=10</strong>，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变 a 的值，相当于新生成了 a。</li></ul></li><li>可变数据：List（列表）、Dictionary（字典）、Set（集合）。<ul><li>变量赋值 <strong>la=[1,2,3,4]</strong> 后再赋值 <strong>la[2]=5</strong> 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。</li></ul></li></ul><h5 id="Numbers（数字）"><a href="#Numbers（数字）" class="headerlink" title="Numbers（数字）"></a>Numbers（数字）</h5><ul><li><p>数字数据类型用于存储数值。</p></li><li><p>他们是<strong>不可改变</strong>的数据类型，这意味着改变数字数据类型会分配一个新的对象。</p></li><li><p>当你指定一个值时，Number 对象就会被创建：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var1 = <span class="number">1</span></span><br><span class="line">var2 = <span class="number">10</span></span><br></pre></td></tr></table></figure><p><strong>删除</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> var1[,var2,[var3[..., varN]]]</span><br><span class="line"><span class="keyword">del</span> var</span><br><span class="line"><span class="keyword">del</span> var_a, var_b</span><br></pre></td></tr></table></figure><p><strong>数字类型</strong>：</p><ul><li>查询变量所指的对象类型<ul><li>内置的<code>type（）</code>函数：不会认为子类是一种父类类型</li><li><code>isinstance（）</code>：会认为子类是一种父类类型</li></ul></li></ul><table><thead><tr><th align="left">int</th><th align="left">long</th><th align="left">float</th><th align="left">complex</th></tr></thead><tbody><tr><td align="left">10</td><td align="left">51924361L</td><td align="left">0.0</td><td align="left">3.14j</td></tr><tr><td align="left">100</td><td align="left">-0x19323L</td><td align="left">15.20</td><td align="left">45.j</td></tr><tr><td align="left">-786</td><td align="left">0122L</td><td align="left">-21.9</td><td align="left">9.322e-36j</td></tr><tr><td align="left">080</td><td align="left">0xDEFABCECBDAECBFBAEl</td><td align="left">32.3e+18</td><td align="left">.876j</td></tr><tr><td align="left">-0490</td><td align="left">535633629843L</td><td align="left">-90.</td><td align="left">-.6545+0J</td></tr><tr><td align="left">-0x260</td><td align="left">-052318172735L</td><td align="left">-32.54e100</td><td align="left">3e+26J</td></tr><tr><td align="left">0x69</td><td align="left">-4721885298529L</td><td align="left">70.2E-12</td><td align="left">4.53e-7j</td></tr></tbody></table><ul><li><p>int（有符号整型）：通常被称为是整型或整数，是正或负整数，不带小数点</p></li><li><p>long（长整数）</p><ul><li><p>长整型也可以使用小写 l，但是还是建议您使用大写 L，避免与数字 1 混淆。Python使用 L 来显示长整型。</p><blockquote><p>long 类型只存在于 Python2.X 版本中，在 2.2 以后的版本中，int 类型数据溢出后会自动转为long类型。在 Python3.X 版本中 long 类型被移除，使用 int 替代。</p></blockquote></li></ul></li><li><p>float（浮点数）： 浮点型由整数部分与小数部分组成，浮点型也可以使用科学计数法表示（2.5e2 = 2.5 x 102 = 250）</p></li><li><p>bool（布尔值）</p><ul><li><blockquote><p>python2中没有这个数据类型</p></blockquote></li></ul></li><li><p>complex（复数）</p><ul><li>复数由实数部分和虚数部分构成，可以用 a + bj,或者 complex(a,b) 表示</li><li>复数的实部 a 和虚部 b 都是浮点型。</li></ul></li></ul><p><strong>运算：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> / <span class="number">4</span>    <span class="comment"># 除法，得到一个浮点数</span></span><br><span class="line"><span class="number">2</span> // <span class="number">4</span>   <span class="comment"># 除法，得到一个整数，但不一定是int类型的整数，可能是 1.0</span></span><br><span class="line"><span class="number">17</span> % <span class="number">3</span>   <span class="comment"># 取余</span></span><br><span class="line"><span class="number">2</span> ** <span class="number">5</span>   <span class="comment"># 乘方，得到32</span></span><br></pre></td></tr></table></figure><h5 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;hello world&quot;</span></span><br><span class="line">s[<span class="number">0</span>] = <span class="string">&#x27;1&#x27;</span>   <span class="comment"># 会报错</span></span><br></pre></td></tr></table></figure><p><strong>下标索引</strong></p><img src="/2020/12/15/python/截屏2020-12-15 下午6.08.56.png" alt="截屏2020-12-15 下午6.08.56" style="zoom:33%;"><ul><li>左往右：0开始，右往左：-1开始</li></ul><blockquote><p>在Python2中，普通字符串是以8位ASCII码进行存储的，而Unicode字符串则存储为16位unicode字符串，这样能够表示更多的字符集。使用的语法是在字符串前面加上前缀 <strong>u</strong>。</p><p>在Python3中，所有的字符串都是Unicode字符串</p></blockquote><p><strong>字符串操作</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&#x27;abcdef&#x27;</span></span><br><span class="line"><span class="built_in">print</span> (s[<span class="number">1</span>:<span class="number">5</span>])    <span class="comment"># bcde</span></span><br><span class="line"><span class="built_in">print</span> (s[<span class="number">1</span>:<span class="number">5</span>:<span class="number">2</span>])  <span class="comment"># bd</span></span><br><span class="line"><span class="built_in">print</span> (s * <span class="number">2</span>)     <span class="comment"># abcdefabcdef</span></span><br><span class="line"><span class="built_in">print</span> (s[:<span class="number">2</span>] + <span class="string">&#x27;11&#x27;</span>)  <span class="comment"># ab11</span></span><br></pre></td></tr></table></figure><ul><li>使用<code>[头下标:尾下标:步长]</code>来截取字符串，在头下标-尾下标的范围内以步长来截取字符</li><li><strong>注意</strong>：所有的截取都取不到尾下标</li></ul><p><strong>原始字符串：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">r&#x27;\n&#x27;</span>)    <span class="comment"># \n，不会进行换行，而是直接输出</span></span><br></pre></td></tr></table></figure><ul><li>所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。</li><li> 原始字符串除在字符串的第一个引号前加上字母 <strong>r/R</strong>以外，与普通字符串有着几乎完全相同的语法。</li></ul><p><strong>字符串格式化：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> (<span class="string">&quot;我叫 %s 今年 %d 岁!&quot;</span> % (<span class="string">&#x27;小明&#x27;</span>, <span class="number">10</span>))</span><br><span class="line"><span class="comment"># 我叫 小明 今年 10 岁!</span></span><br></pre></td></tr></table></figure><ul><li><p>使用与 C 中 sprintf 函数一样的语法。</p><blockquote><p>Python2.6 开始，新增了一种格式化字符串的函数 str.format()，它增强了字符串格式化的功能。</p></blockquote></li></ul><p><strong>f-string：</strong></p><ul><li>之后版本添加的，称之为字面量格式化字符串，是新的格式化字符串的语法。</li><li>不用再去判断使用 %s，还是 %d。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#### 以前 ###</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">&#x27;world&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;Hello %s&#x27;</span> % name</span><br><span class="line"><span class="string">&#x27;Hello world&#x27;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">#### 现在 ###</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">&#x27;world&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f&#x27;Hello <span class="subst">&#123;name&#125;</span>&#x27;</span>  <span class="comment"># 替换变量</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f&#x27;<span class="subst">&#123;<span class="number">1</span>+<span class="number">2</span>&#125;</span>&#x27;</span>         <span class="comment"># 使用表达式</span></span><br><span class="line"><span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>w = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;url&#x27;</span>: <span class="string">&#x27;www.runoob.com&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f&#x27;<span class="subst">&#123;w[<span class="string">&quot;name&quot;</span>]&#125;</span>: <span class="subst">&#123;w[<span class="string">&quot;url&quot;</span>]&#125;</span>&#x27;</span></span><br><span class="line"><span class="string">&#x27;Runoob: www.runoob.com&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">f&#x27;<span class="subst">&#123;x+<span class="number">1</span>&#125;</span>&#x27;</span>)   <span class="comment"># Python 3.6</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">f&#x27;<span class="subst">&#123;x+<span class="number">1</span>=&#125;</span>&#x27;</span>)  <span class="comment"># Python 3.8</span></span><br><span class="line"><span class="string">&#x27;x+1=2&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>内建函数：</strong></p><ul><li><p>列表 = 字符串.split(“str”)</p></li><li><p>capitalize()</p><ul><li>将字符串的第一个字符转换为大写</li></ul></li><li><p>center(width, fillchar)</p><ul><li>返回一个指定的宽度 width 居中的字符串，fillchar 为填充的字符，默认为空格。</li></ul></li><li><p>count(str, beg= 0,end=len(string))</p><ul><li>返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数</li></ul></li><li><p>bytes.decode(encoding=”utf-8”, errors=”strict”)</p><blockquote><p>Python3 中没有 decode 方法，但我们可以使用 bytes 对象的 decode() 方法来解码给定的 bytes 对象，这个 bytes 对象可以由 str.encode() 来编码返回。</p></blockquote></li><li><p>encode(encoding=’UTF-8’,errors=’strict’)</p><ul><li>以 encoding 指定的编码格式编码字符串，如果出错默认报一个ValueError 的异常，除非 errors 指定的是’ignore’或者’replace’</li></ul></li><li><p>endswith(suffix, beg=0, end=len(string))</p><ul><li>检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False.</li></ul></li><li><p>expandtabs(tabsize=8)</p><ul><li>把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8 。<br>8    </li></ul></li><li><p>find(str, beg=0, end=len(string))</p><ul><li>检测 str 是否包含在字符串中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1</li></ul></li><li><p>index(str, beg=0, end=len(string))</p><ul><li>跟find()方法一样，只不过如果str不在字符串中会报一个异常。</li></ul></li><li><p>isalnum()</p><ul><li>如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 True，否则返回 False</li></ul></li><li><p>isalpha()</p><ul><li>如果字符串至少有一个字符并且所有字符都是字母或中文字则返回 True, 否则返回 False</li></ul></li><li><p>isdigit()</p><ul><li>如果字符串只包含数字则返回 True 否则返回 False..</li></ul></li><li><p>islower()</p><ul><li>如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False</li></ul></li><li><p>isnumeric()</p><ul><li>如果字符串中只包含数字字符，则返回 True，否则返回 False</li></ul></li><li><p>isspace()</p><ul><li>如果字符串中只包含空白，则返回 True，否则返回 False.</li></ul></li><li><p>istitle()</p><ul><li>如果字符串是标题化的(见 title())则返回 True，否则返回 False</li></ul></li><li><p>isupper()</p><ul><li>如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False</li></ul></li><li><p>‘char’.join(seq)</p><ul><li>以指定字符串作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串</li></ul></li><li><p>len(string)</p><ul><li>返回字符串长度</li></ul></li><li><p>ljust(width[, fillchar])</p><ul><li>返回一个原字符串左对齐,并使用 fillchar 填充至长度 width 的新字符串，fillchar 默认为空格。</li></ul></li><li><p>lower()</p><ul><li>转换字符串中所有大写字符为小写.</li></ul></li><li><p>lstrip()</p><ul><li>截掉字符串左边的空格或指定字符。</li></ul></li><li><p>maketrans()</p><ul><li>创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目</li></ul></li><li><p>max(str)</p><ul><li>返回字符串 str 中最大的字母。</li></ul></li><li><p>min(str)</p><ul><li>返回字符串 str 中最小的字母。</li></ul></li><li><p>replace(old, new [, max])</p><ul><li>把将字符串中的 old 替换成 new,如果 max 指定，则替换不超过 max 次。</li></ul><blockquote><p><strong>注意：</strong>replace函数将会返回一个新的字符串，原来的字符串不会改变</p><p>需要使用：<code>str = str.replace(old, new)</code></p></blockquote></li><li><p>rfind(str, beg=0,end=len(string))</p><ul><li>类似于 find()函数，不过是从右边开始查找.</li></ul></li><li><p>rindex( str, beg=0, end=len(string))</p><ul><li>类似于 index()，不过是从右边开始.</li></ul></li><li><p>rjust(width,[, fillchar])</p><ul><li>返回一个原字符串右对齐,并使用fillchar(默认空格）填充至长度 width 的新字符串</li></ul></li><li><p>rstrip()</p><ul><li>删除字符串字符串末尾的空格.</li></ul></li><li><p>split(str=””, num=string.count(str))</p><ul><li>以 str 为分隔符截取字符串，如果 num 有指定值，则仅截取 num+1 个子字符串</li></ul></li><li><p>splitlines([keepends])</p><ul><li>按照行(‘\r’, ‘\r\n’, \n’)分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。</li></ul></li><li><p>startswith(substr, beg=0,end=len(string))</p><ul><li>检查字符串是否是以指定子字符串 substr 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查。</li></ul></li><li><p>strip([chars])</p><ul><li>在字符串上执行 lstrip()和 rstrip()</li></ul></li><li><p>swapcase()</p><ul><li>将字符串中大写转换为小写，小写转换为大写</li></ul></li><li><p>title()</p><ul><li>返回”标题化”的字符串,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle())</li></ul></li><li><p>translate(table, deletechars=””)</p><ul><li>根据 str 给出的表(包含 256 个字符)转换 string 的字符, 要过滤掉的字符放到 deletechars 参数中</li></ul></li><li><p>upper()</p><ul><li>转换字符串中的小写字母为大写</li></ul></li><li><p>zfill (width)</p><ul><li>返回长度为 width 的字符串，原字符串右对齐，前面填充0</li></ul></li><li><p>isdecimal()</p><ul><li>检查字符串是否只包含十进制字符，如果是返回 true，否则返回 false。</li></ul></li></ul><table><thead><tr><th align="left">序号</th><th align="left">方法及描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-capitalize.html">capitalize()<i class="fas fa-external-link-alt"></i></a> <br>将字符串的第一个字符转换为大写</td></tr><tr><td align="left">2</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-center.html">center(width, fillchar)<i class="fas fa-external-link-alt"></i></a> <br>返回一个指定的宽度 width 居中的字符串，fillchar 为填充的字符，默认为空格。</td></tr><tr><td align="left">3</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-count.html">count(str, beg= 0,end=len(string))<i class="fas fa-external-link-alt"></i></a> <br>返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数</td></tr><tr><td align="left">4</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-decode.html">bytes.decode(encoding=”utf-8”, errors=”strict”)<i class="fas fa-external-link-alt"></i></a><br> Python3 中没有 decode 方法，但我们可以使用 bytes 对象的 decode() 方法来解码给定的 bytes 对象，这个 bytes 对象可以由 str.encode() 来编码返回。</td></tr><tr><td align="left">5</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-encode.html">encode(encoding=’UTF-8’,errors=’strict’)<i class="fas fa-external-link-alt"></i></a> <br>以 encoding 指定的编码格式编码字符串，如果出错默认报一个ValueError 的异常，除非 errors 指定的是’ignore’或者’replace’</td></tr><tr><td align="left">6</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-endswith.html">endswith(suffix, beg=0, end=len(string))<i class="fas fa-external-link-alt"></i></a> <br>检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False.</td></tr><tr><td align="left">7</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-expandtabs.html">expandtabs(tabsize=8)<i class="fas fa-external-link-alt"></i></a> <br>把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8 。</td></tr><tr><td align="left">8</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-find.html">find(str, beg=0, end=len(string))<i class="fas fa-external-link-alt"></i></a> <br>检测 str 是否包含在字符串中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1</td></tr><tr><td align="left">9</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-index.html">index(str, beg=0, end=len(string))<i class="fas fa-external-link-alt"></i></a> <br>跟find()方法一样，只不过如果str不在字符串中会报一个异常。</td></tr><tr><td align="left">10</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-isalnum.html">isalnum()<i class="fas fa-external-link-alt"></i></a> <br>如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 True，否则返回 False</td></tr><tr><td align="left">11</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-isalpha.html">isalpha()<i class="fas fa-external-link-alt"></i></a> <br>如果字符串至少有一个字符并且所有字符都是字母或中文字则返回 True, 否则返回 False</td></tr><tr><td align="left">12</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-isdigit.html">isdigit()<i class="fas fa-external-link-alt"></i></a> <br>如果字符串只包含数字则返回 True 否则返回 False..</td></tr><tr><td align="left">13</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-islower.html">islower()<i class="fas fa-external-link-alt"></i></a> <br>如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False</td></tr><tr><td align="left">14</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-isnumeric.html">isnumeric()<i class="fas fa-external-link-alt"></i></a> <br>如果字符串中只包含数字字符，则返回 True，否则返回 False</td></tr><tr><td align="left">15</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-isspace.html">isspace()<i class="fas fa-external-link-alt"></i></a> <br>如果字符串中只包含空白，则返回 True，否则返回 False.</td></tr><tr><td align="left">16</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-istitle.html">istitle()<i class="fas fa-external-link-alt"></i></a> <br>如果字符串是标题化的(见 title())则返回 True，否则返回 False</td></tr><tr><td align="left">17</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-isupper.html">isupper()<i class="fas fa-external-link-alt"></i></a><br>如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False</td></tr><tr><td align="left">18</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-join.html">join(seq)<i class="fas fa-external-link-alt"></i></a> <br>以指定字符串作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串</td></tr><tr><td align="left">19</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-len.html">len(string)<i class="fas fa-external-link-alt"></i></a> <br>返回字符串长度</td></tr><tr><td align="left">20</td><td align="left">ljust(width[, fillchar]) <br>返回一个原字符串左对齐,并使用 fillchar 填充至长度 width 的新字符串，fillchar 默认为空格。</td></tr><tr><td align="left">21</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-lower.html">lower()<i class="fas fa-external-link-alt"></i></a> <br>转换字符串中所有大写字符为小写.</td></tr><tr><td align="left">22</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-lstrip.html">lstrip()<i class="fas fa-external-link-alt"></i></a> <br>截掉字符串左边的空格或指定字符。</td></tr><tr><td align="left">23</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-maketrans.html">maketrans()<i class="fas fa-external-link-alt"></i></a><br> 创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。</td></tr><tr><td align="left">24</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-max.html">max(str)<i class="fas fa-external-link-alt"></i></a> <br>返回字符串 str 中最大的字母。</td></tr><tr><td align="left">25</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-min.html">min(str)<i class="fas fa-external-link-alt"></i></a> <br>返回字符串 str 中最小的字母。</td></tr><tr><td align="left">26</td><td align="left">[replace(old, new [, max])] <br>把 将字符串中的 old 替换成 new,如果 max 指定，则替换不超过 max 次。</td></tr><tr><td align="left">27</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-rfind.html">rfind(str, beg=0,end=len(string))<i class="fas fa-external-link-alt"></i></a> <br>类似于 find()函数，不过是从右边开始查找.</td></tr><tr><td align="left">28</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-rindex.html">rindex( str, beg=0, end=len(string))<i class="fas fa-external-link-alt"></i></a> <br>类似于 index()，不过是从右边开始.</td></tr><tr><td align="left">29</td><td align="left">rjust(width,[, fillchar])<br>返回一个原字符串右对齐,并使用fillchar(默认空格）填充至长度 width 的新字符串</td></tr><tr><td align="left">30</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-rstrip.html">rstrip()<i class="fas fa-external-link-alt"></i></a> <br>删除字符串字符串末尾的空格.</td></tr><tr><td align="left">31</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-split.html">split(str=””, num=string.count(str))<i class="fas fa-external-link-alt"></i></a> <br>以 str 为分隔符截取字符串，如果 num 有指定值，则仅截取 num+1 个子字符串</td></tr><tr><td align="left">32</td><td align="left">splitlines([keepends]) <br>按照行(‘\r’, ‘\r\n’, \n’)分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。</td></tr><tr><td align="left">33</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-startswith.html">startswith(substr, beg=0,end=len(string))<i class="fas fa-external-link-alt"></i></a> <br>检查字符串是否是以指定子字符串 substr 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查。</td></tr><tr><td align="left">34</td><td align="left">strip([chars])<br>在字符串上执行 lstrip()和 rstrip()</td></tr><tr><td align="left">35</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-swapcase.html">swapcase()<i class="fas fa-external-link-alt"></i></a> <br>将字符串中大写转换为小写，小写转换为大写</td></tr><tr><td align="left">36</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-title.html">title()<i class="fas fa-external-link-alt"></i></a> <br>返回”标题化”的字符串,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle())</td></tr><tr><td align="left">37</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-translate.html">translate(table, deletechars=””)<i class="fas fa-external-link-alt"></i></a> <br>根据 str 给出的表(包含 256 个字符)转换 string 的字符, 要过滤掉的字符放到 deletechars 参数中</td></tr><tr><td align="left">38</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-upper.html">upper()<i class="fas fa-external-link-alt"></i></a> <br>转换字符串中的小写字母为大写</td></tr><tr><td align="left">39</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-zfill.html">zfill (width)<i class="fas fa-external-link-alt"></i></a> <br>返回长度为 width 的字符串，原字符串右对齐，前面填充0</td></tr><tr><td align="left">40</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-isdecimal.html">isdecimal()<i class="fas fa-external-link-alt"></i></a> <br>检查字符串是否只包含十进制字符，如果是返回 true，否则返回 false。</td></tr></tbody></table><h5 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h5><ul><li>通用符合数据类型，用[标识]</li><li>有序集合</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">0</span>, <span class="number">1</span>, <span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;def&#x27;</span>, <span class="number">4</span> ]</span><br><span class="line">y = [<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> (x[<span class="number">2</span>:<span class="number">4</span>])   <span class="comment"># [&#x27;abc&#x27;, &#x27;def&#x27;]</span></span><br><span class="line"><span class="built_in">print</span> (x * <span class="number">2</span>)    <span class="comment"># [0, 1, &#x27;abc&#x27;, &#x27;def&#x27;, 4, 0, 1, &#x27;abc&#x27;, &#x27;def&#x27;, 4]</span></span><br><span class="line"><span class="built_in">print</span> (x + y)    <span class="comment"># [0, 1, &#x27;abc&#x27;, &#x27;def&#x27;, 4, &#x27;b&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> x[<span class="number">1</span>]         <span class="comment"># 使用del删除列表元素</span></span><br><span class="line"><span class="built_in">print</span> (x)        <span class="comment"># [0, &#x27;abc&#x27;, &#x27;def&#x27;, 4 ]</span></span><br></pre></td></tr></table></figure><p><strong>迭代</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> a: print(x, end=<span class="string">&quot;。&quot;</span>)</span><br><span class="line"><span class="comment"># 1。2。3。      迭代列表a，每个元素后面跟&quot;。&quot;</span></span><br></pre></td></tr></table></figure><p><strong>内置函数：</strong></p><ul><li><p>字符串 = ‘char’.join(列表)</p></li><li><p>len(list)</p><ul><li>列表元素个数</li></ul></li><li><p>max(list)</p><ul><li>返回列表元素最大值</li></ul></li><li><p>min(list)</p><ul><li>返回列表元素最小值</li></ul></li><li><p>list(seq\string\dict.items()…)</p><ul><li>将元组、字符串、字典元素等转换为列表</li></ul><blockquote><p><code>list(dictionary)</code>将会得到一个元素为元组的列表，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;disList = <span class="built_in">list</span>(dic)</span><br><span class="line">&gt;<span class="comment"># [(key0, value0), (key1, value1), (key2, value2), ...]</span></span><br><span class="line">&gt;disList[<span class="number">1</span>] <span class="comment"># (key1, value1)</span></span><br><span class="line">&gt;disList[<span class="number">1</span>][<span class="number">0</span>] <span class="comment"># key1</span></span><br><span class="line">&gt;disList[<span class="number">1</span>][<span class="number">1</span>] <span class="comment"># value1</span></span><br></pre></td></tr></table></figure></blockquote></li></ul><p><strong>方法</strong></p><ul><li>list.append(obj)<ul><li>在列表末尾添加新的对象</li></ul></li><li>list.count(obj)<ul><li>统计某个元素在列表中出现的次数</li></ul></li><li>list.extend(seq)<ul><li>在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</li></ul></li><li>list.index(obj)<ul><li>从列表中找出某个值第一个匹配项的索引位置</li></ul></li><li>list.insert(index, obj)<ul><li>将对象插入列表</li></ul></li><li>list.pop([index=-1])<ul><li>移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</li></ul></li><li>list.remove(obj)<ul><li>移除列表中某个值的第一个匹配项</li></ul></li><li>list.reverse()<ul><li>反向列表中元素</li></ul></li><li>list.sort( key=None, reverse=False)<ul><li>对原列表进行排序</li></ul></li><li>list.clear()<ul><li>清空列表</li></ul></li><li>list.copy()<ul><li>复制列表</li></ul></li></ul><p><strong>列表元素反转</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseWords</span>(<span class="params"><span class="built_in">input</span></span>):</span> </span><br><span class="line">      </span><br><span class="line">    <span class="comment"># 通过空格将字符串分隔符，把各个单词分隔为列表[&#x27;I&#x27;, &#x27;like&#x27;, &#x27;runoob&#x27;]</span></span><br><span class="line">    inputWords = <span class="built_in">input</span>.split(<span class="string">&quot; &quot;</span>) </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 翻转字符串</span></span><br><span class="line">    <span class="comment"># 假设列表 list = [1,2,3,4],  </span></span><br><span class="line">    <span class="comment"># list[0]=1, list[1]=2 ，而 -1 表示最后一个元素 list[-1]=4 ( 与 list[3]=4 一样) </span></span><br><span class="line">    <span class="comment"># inputWords[-1::-1] 有三个参数</span></span><br><span class="line">    <span class="comment"># 第一个参数 -1 表示最后一个元素</span></span><br><span class="line">    <span class="comment"># 第二个参数为空，表示移动到列表末尾</span></span><br><span class="line">    <span class="comment"># 第三个参数为步长，-1 表示逆向</span></span><br><span class="line">    inputWords=inputWords[-<span class="number">1</span>::-<span class="number">1</span>] </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 重新组合字符串，与split相反，将inputWords列表中的每个对象以空格合并</span></span><br><span class="line">    output = <span class="string">&#x27; &#x27;</span>.join(inputWords) </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> output </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>: </span><br><span class="line">    <span class="built_in">input</span> = <span class="string">&#x27;I like runoob&#x27;</span></span><br><span class="line">    rw = reverseWords(<span class="built_in">input</span>) </span><br><span class="line">    print(rw)</span><br></pre></td></tr></table></figure><h5 id="Tuple（元组）"><a href="#Tuple（元组）" class="headerlink" title="Tuple（元组）"></a>Tuple（元组）</h5><ul><li><p>元组是另一个数据类型，类似于 List（列表）。</p></li><li><p>元组用 <strong>()</strong> 标识。内部元素用逗号隔开。</p></li><li><p>与字符串一样，元组的元素不能修改，相当于只读列表。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">y = <span class="number">4</span></span><br><span class="line">z = (x, y)</span><br><span class="line">print(z)        <span class="comment"># ([1, 2], 4)</span></span><br><span class="line"></span><br><span class="line">x.append(<span class="number">3</span>)</span><br><span class="line">print(z)        <span class="comment"># ([1, 2, 3], 4)</span></span><br><span class="line"></span><br><span class="line">x[<span class="number">0</span>] = <span class="number">333</span></span><br><span class="line">print(z)        <span class="comment"># ([333, 2, 3], 4)</span></span><br><span class="line"></span><br><span class="line">x = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]   </span><br><span class="line">print(z)        <span class="comment"># ([1, 2, 3], 4)，相当于x换了个对象，所以不行</span></span><br><span class="line"></span><br><span class="line">z[<span class="number">0</span>] = <span class="string">&#x27;123&#x27;</span>    <span class="comment"># 会报错，元组是不可变的</span></span><br><span class="line"></span><br><span class="line">z = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)   <span class="comment"># 重新赋值的元组 z，绑定到新的对象了，不是修改了原来的对象。</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tup1 = ()      <span class="comment"># 创建空元组</span></span><br><span class="line">tup1 = (<span class="number">50</span>)    <span class="comment"># 整数50</span></span><br><span class="line">tup1 = (<span class="number">50</span>,)   <span class="comment"># 元组</span></span><br></pre></td></tr></table></figure><ul><li>元组中只包含一个元素时，需要在元素后面添加逗号，否则括号会被当作运算符使用</li></ul><p><strong>内置函数：</strong></p><ul><li><p>len(tuple)</p><ul><li>计算元组元素个数。    </li></ul></li><li><p>max(tuple)</p><ul><li>返回元组中元素最大值。    </li></ul></li><li><p>min(tuple)</p><ul><li>返回元组中元素最小值。    </li></ul></li><li><p>tuple(iterable)</p><ul><li><p>将可迭代系列转换为元组。</p></li><li><pre><code class="python">&gt;&gt;&gt; list1= [&#39;Google&#39;, &#39;Taobao&#39;, &#39;Runoob&#39;, &#39;Baidu&#39;]&gt;&gt;&gt; tuple1=tuple(list1)&gt;&gt;&gt; tuple1(&#39;Google&#39;, &#39;Taobao&#39;, &#39;Runoob&#39;, &#39;Baidu&#39;)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### Set（集合）</span><br><span class="line"></span><br><span class="line">* 集合（set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员。</span><br><span class="line">* 基本功能是进行成员关系测试和删除重复元素。</span><br><span class="line">* 可以使用大括号 **&#123; &#125;** 或者 **set()** 函数创建集合</span><br><span class="line">  * **注意**：创建一个空集合必须用 **set()** 而不是 **&#123; &#125;**，因为 **&#123; &#125;** 是用来创建一个空字典。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line">parame &#x3D; &#123;value01,value02,...&#125;</span><br><span class="line"># 或者</span><br><span class="line">parame &#x3D; set(value)</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><p><strong>集合运算</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">set</span>(<span class="string">&#x27;abracadabra&#x27;</span>)</span><br><span class="line">b = <span class="built_in">set</span>(<span class="string">&#x27;alacazam&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 成员测试</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">in</span> sites :</span><br><span class="line">    print(<span class="string">&#x27;a 在集合中&#x27;</span>)     <span class="comment"># true</span></span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">    print(<span class="string">&#x27;a 不在集合中&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结合运算</span></span><br><span class="line">print(a)      <span class="comment">#               &#123;&#x27;b&#x27;, &#x27;c&#x27;, &#x27;a&#x27;, &#x27;r&#x27;, &#x27;d&#x27;&#125;</span></span><br><span class="line">print(a - b)  <span class="comment"># a 和 b 的差集  &#123;&#x27;r&#x27;, &#x27;b&#x27;, &#x27;d&#x27;&#125;</span></span><br><span class="line">print(a | b)  <span class="comment"># a 和 b 的并集  &#123;&#x27;b&#x27;, &#x27;c&#x27;, &#x27;a&#x27;, &#x27;z&#x27;, &#x27;m&#x27;, &#x27;r&#x27;, &#x27;l&#x27;, &#x27;d&#x27;&#125;</span></span><br><span class="line">print(a &amp; b)  <span class="comment"># a 和 b 的交集  &#123;&#x27;c&#x27;, &#x27;a&#x27;&#125;</span></span><br><span class="line">print(a ^ b)  <span class="comment"># a 和 b 中不同时存在的元素 &#123;&#x27;z&#x27;, &#x27;b&#x27;, &#x27;m&#x27;, &#x27;r&#x27;, &#x27;l&#x27;, &#x27;d&#x27;&#125;</span></span><br></pre></td></tr></table></figure><p><strong>基本操作：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">set</span>(<span class="string">&#x27;abracadabra&#x27;</span>)</span><br><span class="line">a.add(<span class="string">&#x27;h&#x27;</span>)      <span class="comment"># &#123;&#x27;a&#x27;, &#x27;h&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;r&#x27;, &#x27;d&#x27;&#125;</span></span><br><span class="line">s.update(<span class="string">&#x27;h&#x27;</span>)   <span class="comment"># 效果相同</span></span><br><span class="line"></span><br><span class="line">s.remove(<span class="string">&#x27;h&#x27;</span>)   <span class="comment"># &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;r&#x27;, &#x27;d&#x27;&#125;</span></span><br><span class="line">s.discard(<span class="string">&#x27;h&#x27;</span>)  <span class="comment"># 效果相同</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机删除集合中的一个元素</span></span><br><span class="line">x = a.pop()     <span class="comment"># x为a中随机一个元素</span></span><br></pre></td></tr></table></figure><p><strong>内置函数：</strong></p><ul><li>len(set)<ul><li>输出集合的个数</li></ul></li></ul><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">add()</td><td align="left">为集合添加元素</td></tr><tr><td align="left">clear()</td><td align="left">移除集合中的所有元素</td></tr><tr><td align="left">copy()</td><td align="left">拷贝一个集合</td></tr><tr><td align="left">difference()</td><td align="left">返回多个集合的差集</td></tr><tr><td align="left">difference_update()</td><td align="left">移除集合中的元素，该元素在指定的集合也存在。</td></tr><tr><td align="left">discard()</td><td align="left">删除集合中指定的元素</td></tr><tr><td align="left">intersection()</td><td align="left">返回集合的交集</td></tr><tr><td align="left">intersection_update()</td><td align="left">返回集合的交集。</td></tr><tr><td align="left">isdisjoint()</td><td align="left">判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 False。</td></tr><tr><td align="left">issubset()</td><td align="left">判断指定集合是否为该方法参数集合的子集。</td></tr><tr><td align="left">issuperset()</td><td align="left">判断该方法的参数集合是否为指定集合的子集</td></tr><tr><td align="left">pop()</td><td align="left">随机移除元素</td></tr><tr><td align="left">remove()</td><td align="left">移除指定元素</td></tr><tr><td align="left">symmetric_difference()</td><td align="left">返回两个集合中不重复的元素集合。</td></tr><tr><td align="left">symmetric_difference_update()</td><td align="left">移除当前集合中在另外一个指定集合相同的元素，并将另外一个指定集合中不同的元素插入到当前集合中。</td></tr><tr><td align="left">union()</td><td align="left">返回两个集合的并集</td></tr><tr><td align="left">update()</td><td align="left">给集合添加元素</td></tr></tbody></table><h5 id="Dictionary（字典）"><a href="#Dictionary（字典）" class="headerlink" title="Dictionary（字典）"></a>Dictionary（字典）</h5><ul><li>列表是有序的对象集合，字典是无序的对象集合。<ul><li>即使排序了，放进字典也是无序的</li></ul></li><li>两者之间的区别在于：<ul><li>字典当中的元素是通过键来存取的，而不是通过偏移存取。</li></ul></li><li>字典是一种映射类型，字典用 <strong>{ }</strong> 标识，它是一个无序的 <strong>键(key) : 值(value)</strong> 的集合。<ul><li>键(key)必须使用<strong>不可变类型</strong>。（列表等不行）</li><li>在同一个字典中，键(key)必须是<strong>唯一</strong>的，重复时选择后一个</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dict</span> = &#123;&#125;     <span class="comment"># 创建空字典</span></span><br><span class="line"><span class="built_in">dict</span>[<span class="string">&#x27;one&#x27;</span>] = <span class="string">&quot;111&quot;</span></span><br><span class="line"><span class="built_in">dict</span>[<span class="number">2</span>]     = <span class="string">&quot;222&quot;</span></span><br><span class="line"></span><br><span class="line">tinydict = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;aaa&#x27;</span>,<span class="string">&#x27;b&#x27;</span>:<span class="number">1</span>, (c): <span class="string">&#x27;ccc&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">dict</span>[<span class="string">&#x27;one&#x27;</span>])       <span class="comment"># 输出键为 &#x27;one&#x27; 的值  &quot;111&quot;</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">dict</span>[<span class="number">2</span>])           <span class="comment"># 输出键为 2 的值      &quot;222&quot;</span></span><br><span class="line"><span class="built_in">print</span> (tinydict)          <span class="comment"># 输出完整的字典   &#123;&#x27;a&#x27;:&#x27;aaa&#x27;,&#x27;b&#x27;:1,(c):&#x27;ccc&#x27;&#125;</span></span><br><span class="line"><span class="built_in">print</span> (tinydict.keys())   <span class="comment"># 输出所有键   dict_keys([&#x27;a&#x27;, &#x27;b&#x27;, (c)])</span></span><br><span class="line"><span class="built_in">print</span> (tinydict.values()) <span class="comment"># 输出所有值   dict_values([&#x27;aaa&#x27;, 1, &#x27;ccc&#x27;])</span></span><br></pre></td></tr></table></figure><p><strong>内置函数</strong></p><ul><li><p>构造函数<code>dict（）</code>：</p><ul><li><pre><code class="python">&gt;&gt;&gt; dict([(&#39;aa&#39;, 1), (&#39;bb&#39;, 2), (&#39;cc&#39;, 3)])&#123;&#39;aa&#39;: 1, &#39;bb&#39;: 2, &#39;cc&#39;: 3&#125;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* len(dict)</span><br><span class="line">  </span><br><span class="line">  * 计算字典元素个数，即键的总数</span><br><span class="line">* str(dict)</span><br><span class="line">  </span><br><span class="line">  * 输出字典，以可打印的字符串表示。</span><br><span class="line">* type(variable)</span><br><span class="line">  </span><br><span class="line">  * 返回输入的变量类型，如果变量是字典就返回字典类型。</span><br><span class="line">* keys()</span><br><span class="line">* values()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">| 序号 | 函数及描述                                                   |</span><br><span class="line">| :--- | :----------------------------------------------------------- |</span><br><span class="line">| 1    | [radiansdict.clear()](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-dictionary-clear.html) &lt;br &#x2F;&gt;删除字典内所有元素 |</span><br><span class="line">| 2    | [radiansdict.copy()](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-dictionary-copy.html) &lt;br &#x2F;&gt;返回一个字典的浅复制 |</span><br><span class="line">| 3    | [radiansdict.fromkeys()](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-dictionary-fromkeys.html) &lt;br &#x2F;&gt;创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值 |</span><br><span class="line">| 4    | [radiansdict.get(key, default&#x3D;None)](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-dictionary-get.html) &lt;br &#x2F;&gt;返回指定键的值，如果键不在字典中返回 default 设置的默认值 |</span><br><span class="line">| 5    | [key in dict](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-dictionary-in.html) &lt;br &#x2F;&gt;如果键在字典dict里返回true，否则返回false |</span><br><span class="line">| 6    | [radiansdict.items()](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-dictionary-items.html) &lt;br &#x2F;&gt;以列表返回可遍历的(键, 值) 元组数组 |</span><br><span class="line">| 7    | [radiansdict.keys()](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-dictionary-keys.html) &lt;br &#x2F;&gt;返回一个迭代器，可以使用 list() 来转换为列表 |</span><br><span class="line">| 8    | [radiansdict.setdefault(key, default&#x3D;None)](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-dictionary-setdefault.html)&lt;br &#x2F;&gt; 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default |</span><br><span class="line">| 9    | [radiansdict.update(dict2)](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-dictionary-update.html) &lt;br &#x2F;&gt;把字典dict2的键&#x2F;值对更新到dict里 |</span><br><span class="line">| 10   | [radiansdict.values()](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-dictionary-values.html) &lt;br &#x2F;&gt;返回一个迭代器，可以使用 list() 来转换为列表 |</span><br><span class="line">| 11   | pop(key[,default\]) &lt;br &#x2F;&gt;删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。 |</span><br><span class="line">| 12   | [popitem()](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-dictionary-popitem.html) &lt;br &#x2F;&gt;随机返回并删除字典中的最后一对键和值。 |</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">#### 数据类型转换</span><br><span class="line"></span><br><span class="line">| 函数                    | 描述                                                |</span><br><span class="line">| :---------------------- | :-------------------------------------------------- |</span><br><span class="line">| int(x)                  | 将x转换为一个整数                                   |</span><br><span class="line">| float(x)                | 将x转换到一个浮点数                                 |</span><br><span class="line">| complex(real [,imag\])] | 创建一个复数，实部是real，虚部是imag                |</span><br><span class="line">| str(x)                  | 将对象 x 转换为字符串                               |</span><br><span class="line">| repr(x)                 | 将对象 x 转换为表达式字符串                         |</span><br><span class="line">| eval(str)               | 用来计算在字符串中的有效Python表达式,并返回一个对象 |</span><br><span class="line">| tuple(s)                | 将序列 s 转换为一个元组                             |</span><br><span class="line">| list(s)                 | 将序列 s 转换为一个列表                             |</span><br><span class="line">| set(s)                  | 转换为可变集合                                      |</span><br><span class="line">| dict(d)                 | 创建一个字典。d 必须是一个 (key, value)元组序列。   |</span><br><span class="line">| frozenset(s)            | 转换为不可变集合                                    |</span><br><span class="line">| chr(x)                  | 将一个整数转换为一个字符                            |</span><br><span class="line">| ord(x)                  | 将一个字符转换为它的整数值                          |</span><br><span class="line">| hex(x)                  | 将一个整数转换为一个十六进制字符串                  |</span><br><span class="line">| oct(x)                  | 将一个整数转换为一个八进制字符串                    |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### **进制转换：**</span><br><span class="line"></span><br><span class="line">**二进制表示**</span><br><span class="line"></span><br><span class="line">* 通过&#96;0b&#x2F;-0b&#96;开头的字符串来表示二进制</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line">print 0b101 # 输出5</span><br><span class="line">print 0b10  # 输出2</span><br><span class="line">print -0b101 # 输出-5</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p><code>bin()</code>函数将十进制转换成而二进制表示</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bin</span>(<span class="number">5</span>)  <span class="comment"># 输出0b101</span></span><br></pre></td></tr></table></figure><p><strong>二进制位操作：</strong></p><ul><li>关于bit有一个很有用的Packag叫做bitarray，其中bitarray对象可以帮助我们存储0，1值或者Boolean值，并像list一样进行操作。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bitarray <span class="keyword">import</span> bitarray</span><br><span class="line"></span><br><span class="line"><span class="comment">#初始化一个有10个bit位的数组，初始值为0</span></span><br><span class="line">a = bitarray(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#可以像操作list一样操作bitarray对象</span></span><br><span class="line">a[<span class="number">1</span>:<span class="number">8</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#bitarray还提供了一些特殊的方法，如：all()</span></span><br><span class="line"><span class="comment">#当bitarray中所有的元素都为1时，all()返回为True</span></span><br><span class="line"><span class="keyword">if</span> a.<span class="built_in">all</span>():</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;all bits are True.&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h3><h4 id="条件控制"><a href="#条件控制" class="headerlink" title="条件控制"></a>条件控制</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition_1:</span><br><span class="line">    statement_block_1</span><br><span class="line"><span class="keyword">elif</span> condition_2:</span><br><span class="line">    statement_block_2</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    statement_block_3</span><br></pre></td></tr></table></figure><ul><li>python中没有<code>switch-case</code></li></ul><h4 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h4><p><strong>while</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> 判断条件(condition)：</span><br><span class="line">    执行语句(statements)……</span><br></pre></td></tr></table></figure><p>​    </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> &lt;expr&gt;:</span><br><span class="line">    &lt;statement(s)&gt;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    &lt;additional_statement(s)&gt;</span><br></pre></td></tr></table></figure><ul><li>条件语句为 false 时执行 else 的语句块。</li></ul><p>​     </p><p><strong>for</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &lt;variable&gt; <span class="keyword">in</span> &lt;sequence&gt;:</span><br><span class="line">    &lt;statements&gt;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    &lt;statements&gt;</span><br></pre></td></tr></table></figure><ul><li>在没有循环数据时执行else的语句块</li></ul><p>​    </p><p><code>range()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">  print(i)   <span class="comment"># 0 1 2 3 4</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>, <span class="number">9</span>):</span><br><span class="line">  print(i)   <span class="comment"># 5 6 7 8</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>, <span class="number">3</span>):</span><br><span class="line">  print(i)   <span class="comment"># 0 3 6 9</span></span><br></pre></td></tr></table></figure><p><strong>continue break</strong></p><ul><li>同java，c++等的使用一样</li></ul><p>​    </p><p><strong>pass</strong></p><ul><li>pass是空语句，是为了保持程序结构的完整性。</li><li>pass 不做任何事情，一般用做占位语句</li></ul><p>​    </p><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><ul><li>在字典中遍历时，关键字和对应的值可以使用<code>items()</code> 方法同时解读出来：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>knights = &#123;<span class="string">&#x27;gallahad&#x27;</span>: <span class="string">&#x27;the pure&#x27;</span>, <span class="string">&#x27;robin&#x27;</span>: <span class="string">&#x27;the brave&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> k, v <span class="keyword">in</span> knights.items():</span><br><span class="line"><span class="meta">... </span>    print(k, v)</span><br><span class="line">...</span><br><span class="line">gallahad the pure</span><br><span class="line">robin the brave</span><br></pre></td></tr></table></figure><ul><li>在序列中遍历时，索引位置和对应值可以使用 <code>enumerate()</code> 函数同时得到：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>([<span class="string">&#x27;tic&#x27;</span>, <span class="string">&#x27;tac&#x27;</span>, <span class="string">&#x27;toe&#x27;</span>]):</span><br><span class="line"><span class="meta">... </span>    print(i, v)</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> tic</span><br><span class="line"><span class="number">1</span> tac</span><br><span class="line"><span class="number">2</span> toe</span><br></pre></td></tr></table></figure><ul><li>同时遍历两个或更多的序列，可以使用 <code>zip()</code> 组合：</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>questions = [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;quest&#x27;</span>, <span class="string">&#x27;favorite color&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>answers = [<span class="string">&#x27;lancelot&#x27;</span>, <span class="string">&#x27;the holy grail&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> q, a <span class="keyword">in</span> <span class="built_in">zip</span>(questions, answers):</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">&#x27;What is your &#123;0&#125;?  It is &#123;1&#125;.&#x27;</span>.<span class="built_in">format</span>(q, a))</span><br><span class="line">...</span><br><span class="line">What is your name?  It is lancelot.</span><br><span class="line">What is your quest?  It is the holy grail.</span><br><span class="line">What is your favorite color?  It is blue.</span><br></pre></td></tr></table></figure><ul><li>反向遍历一个序列，首先指定这个序列，然后调用 <code>reversed()</code> 函数：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>)):</span><br><span class="line"><span class="meta">... </span>    print(i)</span><br><span class="line">...</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>要按顺序遍历一个序列，使用 <code>sorted()</code>函数返回一个已排序的序列，并不修改原值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>basket = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> f <span class="keyword">in</span> <span class="built_in">sorted</span>(<span class="built_in">set</span>(basket)):</span><br><span class="line"><span class="meta">... </span>    print(f)</span><br><span class="line">...</span><br><span class="line">apple</span><br><span class="line">banana</span><br><span class="line">orange</span><br><span class="line">pear</span><br></pre></td></tr></table></figure><h3 id="迭代器与生成器"><a href="#迭代器与生成器" class="headerlink" title="迭代器与生成器"></a>迭代器与生成器</h3><ul><li>迭代是Python最强大的功能之一，是访问集合元素的一种方式。</li><li>迭代器是一个可以记住遍历的位置的对象。</li><li>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</li><li>迭代器有两个基本的方法：<strong>iter()</strong> 和 **next()**。</li><li>字符串，列表或元组对象都可用于创建迭代器：</li></ul><h4 id="iter"><a href="#iter" class="headerlink" title="iter()"></a>iter()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">it = <span class="built_in">iter</span>(<span class="built_in">list</span>)  <span class="comment"># 创建迭代器对象</span></span><br><span class="line">print(it)        <span class="comment"># &lt;list_iterator object at 0x7fe777a83d30&gt;</span></span><br><span class="line">print(<span class="built_in">next</span>(it))  <span class="comment"># 1 输出迭代器的下一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### for ###</span></span><br><span class="line"><span class="built_in">list</span>=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it = <span class="built_in">iter</span>(<span class="built_in">list</span>)  <span class="comment"># 创建迭代器对象</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> it:</span><br><span class="line">    <span class="built_in">print</span> (x, end=<span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="next"><a href="#next" class="headerlink" title="next()"></a>next()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys         <span class="comment"># 引入 sys 模块</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">list</span>=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it = <span class="built_in">iter</span>(<span class="built_in">list</span>)    <span class="comment"># 创建迭代器对象</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span> (<span class="built_in">next</span>(it))</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        sys.exit()</span><br></pre></td></tr></table></figure><p><strong>创建一个迭代器：</strong></p><ul><li><p>把一个类作为一个迭代器使用需要在类中实现两个方法 __iter__() 与__next__() 。</p></li><li><p>如果你已经了解的面向对象编程，就知道类都有一个构造函数，Python 的构造函数为 <strong>init</strong>(), 它会在对象初始化的时候执行。</p><ul><li>更多内容查阅：Python3 面向对象</li></ul></li><li><p> __iter__()：返回一个特殊的迭代器对象， 这个迭代器对象实现了 __next__() 方法并通过 StopIteration 异常标识迭代的完成。</p></li><li><p> __next__()：（Python 2 里是 next()）会返回下一个迭代器对象。</p></li></ul><p>创建一个返回数字的迭代器，初始值为 1，逐步递增 1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyNumbers</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> self</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span></span><br><span class="line">    x = self.a</span><br><span class="line">    self.a += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"> </span><br><span class="line">myclass = MyNumbers()</span><br><span class="line">myiter = <span class="built_in">iter</span>(myclass)</span><br><span class="line"> </span><br><span class="line">print(<span class="built_in">next</span>(myiter))   <span class="comment"># 1</span></span><br><span class="line">print(<span class="built_in">next</span>(myiter))   <span class="comment"># 2</span></span><br><span class="line">print(<span class="built_in">next</span>(myiter))   <span class="comment"># 3</span></span><br></pre></td></tr></table></figure><h4 id="StopIteration"><a href="#StopIteration" class="headerlink" title="StopIteration"></a>StopIteration</h4><ul><li>StopIteration 异常用于标识迭代的完成，防止出现无限循环的情况，在__next__() 方法中我们可以设置在完成指定循环次数后触发 StopIteration 异常来结束迭代。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyNumbers</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> self</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">if</span> self.a &lt;= <span class="number">20</span>:      <span class="comment"># 设置迭代20次后停止</span></span><br><span class="line">      x = self.a</span><br><span class="line">      self.a += <span class="number">1</span></span><br><span class="line">      <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">raise</span> StopIteration</span><br><span class="line"> </span><br><span class="line">myclass = MyNumbers()</span><br><span class="line">myiter = <span class="built_in">iter</span>(myclass)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> myiter:</span><br><span class="line">  print(x)</span><br></pre></td></tr></table></figure><h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><ul><li>在 Python 中，使用了 yield 的函数被称为生成器（generator）。</li><li>跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。 </li><li>在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。</li><li>调用一个生成器函数，返回的是一个迭代器对象。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 yield 实现斐波那契数列</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span>(<span class="params">n</span>):</span> <span class="comment"># 生成器函数 - 斐波那契</span></span><br><span class="line">    a, b, counter = <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> (counter &gt; n): </span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        counter += <span class="number">1</span></span><br><span class="line">f = fibonacci(<span class="number">10</span>) <span class="comment"># f 是一个迭代器，由生成器返回生成</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span> (<span class="built_in">next</span>(f), end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        sys.exit()</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> 函数名（参数列表）:</span></span><br><span class="line">    函数体</span><br></pre></td></tr></table></figure><img src="/2020/12/15/python/截屏2020-12-16 下午3.51.47.png" alt="截屏2020-12-16 下午3.51.47" style="zoom:50%;">    <h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><blockquote><p>python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。</p></blockquote><ul><li><strong>不可变类型：</strong>类似 C++ 的值传递，如 整数、字符串、元组。如 fun(a)，传递的只是 a 的值，没有影响 a 对象本身。如果在 fun(a)）内部修改 a 的值，则是新生成来一个 a。</li><li><strong>可变类型：</strong>类似 C++ 的引用传递，如 列表，字典。如 fun(la)，则是将 la 真正的传过去，修改后 fun 外部的 la 也会受影响</li></ul><p><strong>调用函数时可使用的正式参数类型：</strong></p><ul><li><p>必需参数</p><ul><li><p>必需参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#可写函数说明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printme</span>(<span class="params"> <span class="built_in">str</span> </span>):</span></span><br><span class="line">   <span class="string">&quot;打印任何传入的字符串&quot;</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="built_in">str</span>)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用 printme 函数，不加参数会报错</span></span><br><span class="line">printme()</span><br></pre></td></tr></table></figure></li></ul></li><li><p>关键字参数</p><ul><li><p>关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。</p></li><li><p>使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#可写函数说明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printinfo</span>(<span class="params"> name, age </span>):</span></span><br><span class="line">   <span class="string">&quot;打印任何传入的字符串&quot;</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;名字: &quot;</span>, name)</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;年龄: &quot;</span>, age)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#调用printinfo函数</span></span><br><span class="line">printinfo( age=<span class="number">50</span>, name=<span class="string">&quot;runoob&quot;</span> )</span><br></pre></td></tr></table></figure></li></ul></li><li><p>默认参数</p><ul><li><p>调用函数时，如果没有传递参数，则会使用默认参数。以下实例中如果没有传入 age 参数，则使用默认值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#可写函数说明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printinfo</span>(<span class="params"> name, age = <span class="number">35</span> </span>):</span></span><br><span class="line">   <span class="string">&quot;打印任何传入的字符串&quot;</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;名字: &quot;</span>, name)</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;年龄: &quot;</span>, age)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#调用printinfo函数</span></span><br><span class="line">printinfo( age=<span class="number">50</span>, name=<span class="string">&quot;runoob&quot;</span> )  <span class="comment"># 名字: runoob    年龄: 50</span></span><br><span class="line">printinfo( name=<span class="string">&quot;runoob&quot;</span> )          <span class="comment"># 名字: runoob    年龄: 35</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>不定长参数</p><ul><li><p>可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述 2 种参数不同，声明时不会命名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">functionname</span>(<span class="params">[formal_args,] *var_args_tuple </span>):</span></span><br><span class="line">   <span class="string">&quot;函数_文档字符串&quot;</span></span><br><span class="line">   function_suite</span><br><span class="line">   <span class="keyword">return</span> [expression]</span><br></pre></td></tr></table></figure></li><li><p>带<code>*</code>以元组形式传入</p><ul><li>如果单独出现星号<code>*</code>后的参数必须用关键字传入。</li><li><code>def f(a,b,*,c):</code>  调用：<code>f(1,2,c=3)</code></li></ul></li><li><p>带<code>**</code>以字典形式传入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printinfo</span>(<span class="params"> arg1, *vartuple </span>):</span></span><br><span class="line">   <span class="string">&quot;打印任何传入的参数&quot;</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;输出: &quot;</span>)</span><br><span class="line">   <span class="built_in">print</span> (arg1)</span><br><span class="line">   <span class="built_in">print</span> (vartuple)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用printinfo 函数</span></span><br><span class="line">printinfo( <span class="number">70</span>, <span class="number">60</span>, <span class="number">50</span> )</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="number">70</span></span><br><span class="line">(<span class="number">60</span>, <span class="number">50</span>)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><ul><li>python 使用<code>lambda</code>来创建匿名函数。</li><li>所谓匿名，意即不再使用 def 语句这样标准的形式定义一个函数。<ul><li>lambda 只是一个表达式，函数体比 def 简单很多。</li><li>lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。</li><li>lambda 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。</li><li>虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。</li></ul></li></ul><h4 id="函数库"><a href="#函数库" class="headerlink" title="函数库"></a>函数库</h4><h5 id="math"><a href="#math" class="headerlink" title="math"></a>math</h5><h6 id="数学常量"><a href="#数学常量" class="headerlink" title="数学常量"></a>数学常量</h6><ul><li><code>pi</code>：数学常量 pi（圆周率，一般以π来表示）</li><li><code>e</code>：数学常量 e，e即自然常数（自然常数）</li></ul><h6 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h6><ul><li><p>abs(x)    返回数字的绝对值，如abs(-10) 返回 10</p></li><li><p>ceil(x)    返回数字的上入整数，如math.ceil(4.1) 返回 5</p></li><li><p>cmp(x, y)</p><ul><li>如果 x &lt; y 返回 -1, 如果 x == y 返回 0, 如果 x &gt; y 返回 1。</li><li> Python 3 已废弃，使用 (x&gt;y)-(x&lt;y) 替换。</li></ul></li><li><p>exp(x)    返回e的x次幂(ex)，如math.exp(1) 返回2.718281828459045</p></li><li><p>fabs(x)    返回数字的绝对值的浮点类型，如math.fabs(-10) 返回10.0</p></li><li><p>floor(x)    返回数字的下舍整数，如math.floor(4.9)返回 4</p></li><li><p>log(x)    如math.log(math.e)返回1.0，math.log(100,10)返回2.0</p></li><li><p>log10(x)    返回以10为基数的x的对数，如math.log10(100)返回 2.0</p></li><li><p>max(x1, x2,…)    返回给定参数的最大值，参数可以为序列。</p></li><li><p>min(x1, x2,…)    返回给定参数的最小值，参数可以为序列。</p></li><li><p>modf(x)    返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。</p></li><li><p>pow(x, y)    x**y 运算后的值。</p></li><li><p>round(x [,n])    返回浮点数 x 的四舍五入值，如给出 n 值，则代表舍入到小数点后的位数。</p><ul><li>其实准确的说是保留值将保留到离上一位更近的一端。</li></ul></li><li><p>sqrt(x)    返回数字x的平方根。</p></li></ul><h6 id="随机数函数"><a href="#随机数函数" class="headerlink" title="随机数函数"></a>随机数函数</h6><ul><li>choice(seq)    从序列的元素中随机挑选一个元素<ul><li>比如：random.choice(range(10))，从0到9中随机挑选一个整数。</li></ul></li><li>randrange ([start,] stop [,step])    从指定范围内，按指定基数递增的集合中获取一个随机数，基数默认值为 1</li><li>random()    随机生成下一个实数，它在[0,1)范围内。</li><li>seed([x])    改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed。</li><li>shuffle(lst)    将序列的所有元素随机排序</li><li>uniform(x, y)    随机生成下一个实数，它在[x,y]范围内。</li></ul><h6 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h6><ul><li>acos(x)    返回x的反余弦弧度值。</li><li>asin(x)    返回x的反正弦弧度值。</li><li>atan(x)    返回x的反正切弧度值。</li><li>atan2(y, x)    返回给定的 X 及 Y 坐标值的反正切值。</li><li>cos(x)    返回x的弧度的余弦值。</li><li>hypot(x, y)    返回欧几里德范数 sqrt(x<em>x + y</em>y)。</li><li>sin(x)    返回的x弧度的正弦值。</li><li>tan(x)    返回x弧度的正切值。</li><li>degrees(x)    将弧度转换为角度,如degrees(math.pi/2) ， 返回90.0</li><li>radians(x)    将角度转换为弧度</li></ul><h5 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h5><p>很多Python函数用一个元组装起来的9组数字处理时间:</p><table><thead><tr><th>4位数年</th><th>2008</th><th></th></tr></thead><tbody><tr><td>1</td><td>月</td><td>1 到 12</td></tr><tr><td>2</td><td>日</td><td>1到31</td></tr><tr><td>3</td><td>小时</td><td>0到23</td></tr><tr><td>4</td><td>分钟</td><td>0到59</td></tr><tr><td>5</td><td>秒</td><td>0到61 (60或61 是闰秒)</td></tr><tr><td>6</td><td>一周的第几日</td><td>0到6 (0是周一)</td></tr><tr><td>7</td><td>一年的第几日</td><td>1到366 (儒略历)</td></tr><tr><td>8</td><td>夏令时</td><td>-1, 0, 1, -1是决定是否为夏令时的旗帜</td></tr></tbody></table><p>上述也就是struct_time元组。这种结构具有如下属性：</p><table><thead><tr><th align="left">序号</th><th align="left">属性</th><th align="left">值</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">tm_year</td><td align="left">2008</td></tr><tr><td align="left">1</td><td align="left">tm_mon</td><td align="left">1 到 12</td></tr><tr><td align="left">2</td><td align="left">tm_mday</td><td align="left">1 到 31</td></tr><tr><td align="left">3</td><td align="left">tm_hour</td><td align="left">0 到 23</td></tr><tr><td align="left">4</td><td align="left">tm_min</td><td align="left">0 到 59</td></tr><tr><td align="left">5</td><td align="left">tm_sec</td><td align="left">0 到 61 (60或61 是闰秒)</td></tr><tr><td align="left">6</td><td align="left">tm_wday</td><td align="left">0到6 (0是周一)</td></tr><tr><td align="left">7</td><td align="left">tm_yday</td><td align="left">一年中的第几天，1 到 366</td></tr><tr><td align="left">8</td><td align="left">tm_isdst</td><td align="left">是否为夏令时，值有：1(夏令时)、0(不是夏令时)、-1(未知)，默认 -1</td></tr></tbody></table><h6 id="time"><a href="#time" class="headerlink" title="time"></a>time</h6><ul><li><p>以下时间均为<code>2020-12-16 15:35:15 周三</code></p></li><li><p>time.time()</p><ul><li>获取当前时间戳<code>1608104115.4493172</code></li><li>时间戳单位最适于做日期运算。但是1970年之前的日期就无法以此表示了。太遥远的日期也不行，UNIX和Windows只支持到2038年。</li></ul></li><li><p>time.localtime(时间戳)</p><ul><li><p>获取当前时间</p></li><li><pre><code class="python">time.struct_time(tm_year=2020, tm_mon=12, tm_mday=16, tm_hour=15, tm_min=35, tm_sec=15, tm_wday=2, tm_yday=351, tm_isdst=0)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* time.asctime(time.localtime(时间戳))</span><br><span class="line"></span><br><span class="line">  * 获取格式化的时间</span><br><span class="line"></span><br><span class="line">  * &#96;&#96;&#96;python</span><br><span class="line">    Wed Dec 16 15:35:15 2020</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>time.strftime(format[, time])</p><ul><li><p>格式化日期</p></li><li><pre><code class="python"># 格式化成2020-12-16 15:35:15形式print (time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime()))# 格式化成Wed Dec 16 15:35:15 2020形式print (time.strftime(&quot;%a %b %d %H:%M:%S %Y&quot;, time.localtime()))# 将格式字符串转换为时间戳a = &quot;Wed Dec 16 15:35:15 2020&quot;print (time.mktime(time.strptime(a,&quot;%a %b %d %H:%M:%S %Y&quot;)))<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">​         </span><br><span class="line"></span><br><span class="line">**两个非常重要的属性：**</span><br><span class="line"></span><br><span class="line">1. time.timezone</span><br><span class="line">   * 属性time.timezone是当地时区（未启动夏令时）距离格林威治的偏移秒数（&gt;0，美洲;&lt;&#x3D;0大部分欧洲，亚洲，非洲）。</span><br><span class="line">2. time.tzname</span><br><span class="line">   * 属性time.tzname包含一对根据情况的不同而不同的字符串，分别是带夏令时的本地时区名称，和不带的。</span><br><span class="line"></span><br><span class="line">| 序号 | 函数及描述                                                   | 实例                                                         |</span><br><span class="line">| :--- | :----------------------------------------------------------- | :----------------------------------------------------------- |</span><br><span class="line">| 1    | time.altzone&lt;br &#x2F;&gt;返回格林威治西部的夏令时地区的偏移秒数。如果该地区在格林威治东部会返回负值（如西欧，包括英国）。对夏令时启用地区才能使用。 | 以下实例展示了 altzone()函数的使用方法：&lt;br &#x2F;&gt;&#96;&gt;&gt;&gt; import time &#96;&lt;br &#x2F;&gt;&#96;&gt;&gt;&gt; print (&quot;time.altzone %d &quot; % time.altzone) &#96;&lt;br &#x2F;&gt;&#96;time.altzone -28800 &#96; |</span><br><span class="line">| 2    | time.asctime([tupletime]) &lt;br &#x2F;&gt;接受时间元组并返回一个可读的形式为&quot;Tue Dec 11 18:07:14 2008&quot;（2008年12月11日 周二18时07分14秒）的24个字符的字符串。 | 以下实例展示了 asctime()函数的使用方法：&lt;br &#x2F;&gt;&#96;&gt;&gt;&gt; import time &gt;&gt;&gt; t &#x3D; time.localtime() &#96;&lt;br &#x2F;&gt;&#96;&gt;&gt;&gt; print (&quot;time.asctime(t): %s &quot; % time.asctime(t)) &#96;&lt;br &#x2F;&gt;&#96;time.asctime(t): Thu Apr  7 10:36:20 2016 &#96; |</span><br><span class="line">| 3    | [time.clock()](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-time-clock.html) &lt;br &#x2F;&gt;用以浮点数计算的秒数返回当前的CPU时间。用来衡量不同程序的耗时，比time.time()更有用。 | [实例](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-time-clock.html)由于该方法依赖操作系统，在 Python 3.3 以后不被推荐，而在 3.8 版本中被移除，需使用下列两个函数替代。&#96;time.perf_counter()  # 返回系统运行时间 time.process_time()  # 返回进程运行时间&#96; |</span><br><span class="line">| 4    | time.ctime([secs]) &lt;br &#x2F;&gt;作用相当于asctime(localtime(secs))，未给参数相当于asctime() | 以下实例展示了 ctime()函数的使用方法：&lt;br &#x2F;&gt;&#96;&gt;&gt;&gt; import time &#96;&lt;br &#x2F;&gt;&#96;&gt;&gt;&gt; print (&quot;time.ctime() : %s&quot; % time.ctime()) &#96;&lt;br &#x2F;&gt;&#96;time.ctime() : Thu Apr  7 10:51:58 2016&#96; |</span><br><span class="line">| 5    | time.gmtime([secs]) &lt;br &#x2F;&gt;接收时间戳（1970纪元后经过的浮点秒数）并返回格林威治天文时间下的时间元组t。注：t.tm_isdst始终为0 | 以下实例展示了 gmtime()函数的使用方法：&lt;br &#x2F;&gt;&#96;&gt;&gt;&gt; import time &#96;&lt;br &#x2F;&gt;&#96;&gt;&gt;&gt; print (&quot;gmtime :&quot;, time.gmtime(1455508609.34375)) &#96;&lt;br &#x2F;&gt;&#96;gmtime: time.struct_time(tm_year&#x3D;2016, tm_mon&#x3D;2, tm_mday&#x3D;15, tm_hour&#x3D;3, tm_min&#x3D;56, tm_sec&#x3D;49, tm_wday&#x3D;0, tm_yday&#x3D;46, tm_isdst&#x3D;0)&#96; |</span><br><span class="line">| 6    | time.localtime([secs] &lt;br &#x2F;&gt;接收时间戳（1970纪元后经过的浮点秒数）并返回当地时间下的时间元组t（t.tm_isdst可取0或1，取决于当地当时是不是夏令时）。 | 以下实例展示了 localtime()函数的使用方法：&lt;br &#x2F;&gt;&#96;&gt;&gt;&gt; import time &#96;&lt;br &#x2F;&gt;&#96;&gt;&gt;&gt; print (&quot;localtime(): &quot;, time.localtime(1455508609.34375)) &#96;&lt;br &#x2F;&gt;&#96;localtime():  time.struct_time(tm_year&#x3D;2016, tm_mon&#x3D;2, tm_mday&#x3D;15, tm_hour&#x3D;11, tm_min&#x3D;56, tm_sec&#x3D;49, tm_wday&#x3D;0, tm_yday&#x3D;46, tm_isdst&#x3D;0)&#96; |</span><br><span class="line">| 7    | [time.mktime(tupletime)](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-time-mktime.html)&lt;br &#x2F;&gt; 接受时间元组并返回时间戳（1970纪元后经过的浮点秒数）。 | [实例](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-time-mktime.html) |</span><br><span class="line">| 8    | time.sleep(secs) &lt;br &#x2F;&gt;推迟调用线程的运行，secs指秒数。      | 以下实例展示了 sleep()函数的使用方法：&#96;#!&#x2F;usr&#x2F;bin&#x2F;python3 import time print (&quot;Start : %s&quot; % time.ctime()) time.sleep( 5 ) print (&quot;End : %s&quot; % time.ctime())&#96; |</span><br><span class="line">| 9    | time.strftime(fmt[,tupletime]) &lt;br &#x2F;&gt;接收以时间元组，并返回以可读字符串表示的当地时间，格式由fmt决定。 | 以下实例展示了 strftime()函数的使用方法：&#96;&gt;&gt;&gt; import time &gt;&gt;&gt; print (time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime())) 2016-04-07 11:18:05&#96; |</span><br><span class="line">| 10   | time.strptime(str,fmt&#x3D;&#39;%a %b %d %H:%M:%S %Y&#39;) &lt;br &#x2F;&gt;根据fmt的格式把一个时间字符串解析为时间元组。 | 以下实例展示了 strptime()函数的使用方法：&#96;&gt;&gt;&gt; import time &gt;&gt;&gt; struct_time &#x3D; time.strptime(&quot;30 Nov 00&quot;, &quot;%d %b %y&quot;) &gt;&gt;&gt; print (&quot;返回元组: &quot;, struct_time) 返回元组:  time.struct_time(tm_year&#x3D;2000, tm_mon&#x3D;11, tm_mday&#x3D;30, tm_hour&#x3D;0, tm_min&#x3D;0, tm_sec&#x3D;0, tm_wday&#x3D;3, tm_yday&#x3D;335, tm_isdst&#x3D;-1)&#96; |</span><br><span class="line">| 11   | time.time( ) &lt;br &#x2F;&gt;返回当前时间的时间戳（1970纪元后经过的浮点秒数）。 | 以下实例展示了 time()函数的使用方法：&#96;&gt;&gt;&gt; import time &gt;&gt;&gt; print(time.time()) 1459999336.1963577&#96; |</span><br><span class="line">| 12   | [time.tzset()](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-time-tzset.html) &lt;br &#x2F;&gt;根据环境变量TZ重新初始化时间相关设置。 | [实例](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-time-tzset.html) |</span><br><span class="line">| 13   | **time.perf_counter()** &lt;br &#x2F;&gt;返回计时器的精准时间（系统的运行时间），包含整个系统的睡眠时间。由于返回值的基准点是未定义的，所以，只有连续调用的结果之间的差才是有效的。 | [实例](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-date-time.html#comment-35499) |</span><br><span class="line">| 14   | **time.process_time()**  &lt;br &#x2F;&gt;返回当前进程执行 CPU 的时间总和，不包含睡眠时间。由于返回值的基准点是未定义的，所以，只有连续调用的结果之间的差才是有效的。 |                                                              |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**日期格式化符号：**</span><br><span class="line"></span><br><span class="line">- %y 两位数的年份表示（00-99）</span><br><span class="line">- %Y 四位数的年份表示（000-9999）</span><br><span class="line">- %m 月份（01-12）</span><br><span class="line">- %d 月内中的一天（0-31）</span><br><span class="line">- %H 24小时制小时数（0-23）</span><br><span class="line">- %I 12小时制小时数（01-12）</span><br><span class="line">- %M 分钟数（00&#x3D;59）</span><br><span class="line">- %S 秒（00-59）</span><br><span class="line">- %a 本地简化星期名称</span><br><span class="line">- %A 本地完整星期名称</span><br><span class="line">- %b 本地简化的月份名称</span><br><span class="line">- %B 本地完整的月份名称</span><br><span class="line">- %c 本地相应的日期表示和时间表示</span><br><span class="line">- %j 年内的一天（001-366）</span><br><span class="line">- %p 本地A.M.或P.M.的等价符</span><br><span class="line">- %U 一年中的星期数（00-53）星期天为星期的开始</span><br><span class="line">- %w 星期（0-6），星期天为星期的开始</span><br><span class="line">- %W 一年中的星期数（00-53）星期一为星期的开始</span><br><span class="line">- %x 本地相应的日期表示</span><br><span class="line">- %X 本地相应的时间表示</span><br><span class="line">- %Z 当前时区的名称</span><br><span class="line">- %% %号本身</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###### calendar</span><br><span class="line"></span><br><span class="line">* 星期一是默认的每周第一天，星期天是默认的最后一天。更改设置需调用calendar.setfirstweekday()函数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">| 序号 | 函数及描述                                                   |</span><br><span class="line">| :--- | :----------------------------------------------------------- |</span><br><span class="line">| 1    | **calendar.calendar(year,w&#x3D;2,l&#x3D;1,c&#x3D;6)**&lt;br &#x2F;&gt; 返回一个多行字符串格式的year年年历，3个月一行，间隔距离为c。 每日宽度间隔为w字符。每行长度为21* W+18+2* C。l是每星期行数。 |</span><br><span class="line">| 2    | **calendar.firstweekday( )** &lt;br &#x2F;&gt;返回当前每周起始日期的设置。默认情况下，首次载入caendar模块时返回0，即星期一。 |</span><br><span class="line">| 3    | **calendar.isleap(year)** &lt;br &#x2F;&gt;是闰年返回 True，否则为 false。&lt;br &#x2F;&gt;&lt;img src&#x3D;&quot;python&#x2F;截屏2020-12-16 下午3.44.04.png&quot; alt&#x3D;&quot;截屏2020-12-16 下午3.44.04&quot; style&#x3D;&quot;zoom:40%;&quot; &#x2F;&gt; |</span><br><span class="line">| 4    | **calendar.leapdays(y1,y2)** &lt;br &#x2F;&gt;返回在Y1，Y2两年之间的闰年总数。 |</span><br><span class="line">| 5    | **calendar.month(year,month,w&#x3D;2,l&#x3D;1)**&lt;br &#x2F;&gt; 返回一个多行字符串格式的year年month月日历，两行标题，一周一行。每日宽度间隔为w字符。每行的长度为7* w+6。l是每星期的行数。 |</span><br><span class="line">| 6    | **calendar.monthcalendar(year,month)** &lt;br &#x2F;&gt;返回一个整数的单层嵌套列表。每个子列表装载代表一个星期的整数。Year年month月外的日期都设为0;范围内的日子都由该月第几日表示，从1开始。 |</span><br><span class="line">| 7    | **calendar.monthrange(year,month)** &lt;br &#x2F;&gt;返回两个整数。第一个是该月的星期几，第二个是该月有几天。星期几是从0（星期一）到 6（星期日）。&lt;br &#x2F;&gt;&lt;img src&#x3D;&quot;python&#x2F;截屏2020-12-16 下午3.44.50.png&quot; alt&#x3D;&quot;截屏2020-12-16 下午3.44.50&quot; style&#x3D;&quot;zoom:45%;&quot; &#x2F;&gt;&lt;br &#x2F;&gt;(5, 30)解释：5 表示 2014 年 11 月份的第一天是周六，30 表示 2014 年 11 月份总共有 30 天。 |</span><br><span class="line">| 8    | **calendar.prcal(year, w&#x3D;0, l&#x3D;0, c&#x3D;6, m&#x3D;3)** &lt;br &#x2F;&gt;相当于 print (calendar.calendar(year, w&#x3D;0, l&#x3D;0, c&#x3D;6, m&#x3D;3))。 |</span><br><span class="line">| 9    | **calendar.prmonth(theyear, themonth, w&#x3D;0, l&#x3D;0)** &lt;br &#x2F;&gt;相当于 **print(calendar.month(theyear, themonth, w&#x3D;0, l&#x3D;0))**。 |</span><br><span class="line">| 10   | **calendar.setfirstweekday(weekday)** &lt;br &#x2F;&gt;设置每周的起始日期码。0（星期一）到6（星期日）。 |</span><br><span class="line">| 11   | **calendar.timegm(tupletime)** &lt;br &#x2F;&gt;和time.gmtime相反：接受一个时间元组形式，返回该时刻的时间戳（1970纪元后经过的浮点秒数）。 |</span><br><span class="line">| 12   | **calendar.weekday(year,month,day)**&lt;br &#x2F;&gt; 返回给定日期的日期码。0（星期一）到6（星期日）。月份为 1（一月） 到 12（12月）。 |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###### datetime</span><br><span class="line"></span><br><span class="line">- [datetime模块](https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;datetime.html)</span><br><span class="line">- datetime模块为日期和时间处理同时提供了简单和复杂的方法。</span><br><span class="line">- 支持日期和时间算法的同时，实现的重点放在更有效的处理和格式化输出。</span><br><span class="line">- 该模块还支持时区处理</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line">now &#x3D; date.today()</span><br><span class="line">print(str(now))  # 2020-12-17</span><br><span class="line">print(now.strftime(&quot;%m-%d-%y. %d %b %Y is a %A on the %d day of %B.&quot;))</span><br><span class="line"># 212-17-20. 17 Dec 2020 is a Thursday on the 17 day of December.</span><br><span class="line">birthday &#x3D; date(1964, 7, 31)</span><br><span class="line">age &#x3D; now - birthday</span><br><span class="line">print(birthday)    # 1964-07-31</span><br><span class="line">print(age)         # 20593 days, 0:00:00</span><br><span class="line">print(age.days)    # 20593</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h4 id="内置函数-build-in"><a href="#内置函数-build-in" class="headerlink" title="内置函数(build.in)"></a>内置函数(build.in)</h4><h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">sorted</span>(<span class="built_in">dict</span>.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><ul><li>根据value(x[1])值来进行排序</li><li>dict是无序的，所以即使sorted了，得到的依然不是完全的排序号的</li></ul><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><ul><li><strong>类(Class):</strong> 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。</li><li><strong>方法：</strong>类中定义的函数。</li><li><strong>类变量：</strong>类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。</li><li><strong>数据成员：</strong>类变量或者实例变量用于处理类及其实例对象的相关的数据。</li><li><strong>方法重写：</strong>如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。</li><li><strong>局部变量：</strong>定义在方法中的变量，只作用于当前实例的类。</li><li><strong>实例变量：</strong>在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用 self 修饰的变量。</li><li><strong>继承：</strong>即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟”是一个（is-a）”关系（例图，Dog是一个Animal）。</li><li><strong>实例化：</strong>创建一个类的实例，类的具体对象。</li><li><strong>对象：</strong>通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。</li></ul><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span></span><br><span class="line">  data = <span class="number">12345</span>            <span class="comment"># 基本属性</span></span><br><span class="line">  __private = <span class="number">0</span>            <span class="comment"># 私有属性</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, a</span>):</span>  <span class="comment"># 类的构造方法</span></span><br><span class="line">    self.data = a</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">self, b</span>):</span>         <span class="comment"># 类方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello world&#x27;</span> + b</span><br><span class="line">  </span><br><span class="line">myclass = MyClass(a)      <span class="comment"># 实例化类</span></span><br><span class="line">myclass.f(b)</span><br></pre></td></tr></table></figure><ul><li>在类的内部，使用 <code>def</code> 关键字来定义一个<strong>方法</strong>，与一般函数定义不同，类方法必须包含参数 <code>self</code>，且为第一个参数<ul><li><code>self</code>代表的是类的实例，代表当前对象的地址，而<code>self.class</code>则指向类。</li><li><code>self</code>的名字并不是规定死的，也可以使用 <code>this</code>，但是最好还是按照约定是用 <code>self</code>。</li></ul></li><li><ul><li>类方法必须包含参数<code>self</code>, 且为第一个参数</li></ul></li><li><code>__private_attrs</code>：两个下划线开头，声明该<strong>属性为私有</strong>，不能在类的外部被使用或直接访问。在类内部的方法中使用时 <code>self.__private_attrs</code>。</li><li><code>__private_method</code>：两个下划线开头，声明该方法为<strong>私有方法</strong>，只能在类的内部调用 ，不能在类的外部调用。<code>self.__private_methods</code>。</li></ul><p><strong>类的专有方法：</strong></p><ul><li><strong>__init__</strong> : 构造函数，在生成对象时调用</li><li><strong>__del__ :</strong> 析构函数，释放对象时使用</li><li><strong>__repr__ :</strong> 打印，转换</li><li><strong>__setitem__ :</strong> 按照索引赋值</li><li><strong>__getitem__:</strong> 按照索引获取值</li><li><strong>__len__:</strong> 获得长度</li><li><strong>__cmp__:</strong> 比较运算</li><li><strong>__call__:</strong> 函数调用</li><li><strong>__add__:</strong> 加运算</li><li><strong>__sub__:</strong> 减运算</li><li><strong>__mul__:</strong> 乘运算</li><li><strong>__truediv__:</strong> 除运算</li><li><strong>__mod__:</strong> 求余运算</li><li><strong>__pow__:</strong> 乘方</li></ul><p><strong>运算符重载：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, a, b</span>):</span></span><br><span class="line">      self.a = a</span><br><span class="line">      self.b = b</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;Vector (%d, %d)&#x27;</span> % (self.a, self.b)</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__add__</span>(<span class="params">self,other</span>):</span></span><br><span class="line">      <span class="keyword">return</span> Vector(self.a + other.a, self.b + other.b)</span><br><span class="line"> </span><br><span class="line">v1 = Vector(<span class="number">2</span>,<span class="number">10</span>)</span><br><span class="line">v2 = Vector(<span class="number">5</span>,-<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span> (v1 + v2)</span><br></pre></td></tr></table></figure><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClassName</span>(<span class="params">BaseClassName1, BaseClassNameN</span>):</span></span><br><span class="line">    &lt;statement-<span class="number">1</span>&gt;</span><br><span class="line">    .</span><br><span class="line">    &lt;statement-N&gt;</span><br><span class="line"><span class="comment">### or ##</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClassName</span>(<span class="params">modname.BaseClassName</span>):</span></span><br></pre></td></tr></table></figure><p><strong>单继承</strong></p><ul><li>以下实例<code>student</code>继承<code>people</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>:</span></span><br><span class="line">    <span class="comment">#定义基本属性</span></span><br><span class="line">    name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    age = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义私有属性,私有属性在类外部无法直接进行访问</span></span><br><span class="line">    __weight = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#定义构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,n,a,w</span>):</span></span><br><span class="line">        self.name = n</span><br><span class="line">        self.age = a</span><br><span class="line">        self.__weight = w</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;%s 说: 我 %d 岁。&quot;</span> %(self.name,self.age))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#单继承示例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span>(<span class="params">people</span>):</span></span><br><span class="line">    grade = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,n,a,w,g</span>):</span></span><br><span class="line">        <span class="comment">#调用父类的构函</span></span><br><span class="line">        people.__init__(self,n,a,w)</span><br><span class="line">        self.grade = g</span><br><span class="line">       </span><br><span class="line">    <span class="comment">#覆写父类的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;</span>%(self.name, self.age, self.grade))</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">s = student(<span class="string">&#x27;ken&#x27;</span>,<span class="number">10</span>,<span class="number">60</span>,<span class="number">3</span>)</span><br><span class="line">s.speak()</span><br><span class="line"><span class="comment"># ken 说: 我 10 岁了，我在读 3 年级</span></span><br></pre></td></tr></table></figure><p><strong>多继承</strong></p><ul><li>需要注意圆括号中父类的顺序，若是父类中有相同的方法名，而在子类使用时未指定，python从左至右搜索，即方法在子类中未找到时，从左到右查找父类中是否包含方法。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>:</span></span><br><span class="line">    <span class="comment">#定义基本属性</span></span><br><span class="line">    name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    age = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义私有属性,私有属性在类外部无法直接进行访问</span></span><br><span class="line">    __weight = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,n,a,w</span>):</span></span><br><span class="line">        self.name = n</span><br><span class="line">        self.age = a</span><br><span class="line">        self.__weight = w</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;%s 说: 我 %d 岁。&quot;</span> %(self.name,self.age))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#单继承示例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span>(<span class="params">people</span>):</span></span><br><span class="line">    grade = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,n,a,w,g</span>):</span></span><br><span class="line">        <span class="comment">#调用父类的构函</span></span><br><span class="line">        people.__init__(self,n,a,w)</span><br><span class="line">        self.grade = g</span><br><span class="line">    <span class="comment">#覆写父类的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;</span>%(self.name, self.age, self.grade))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#另一个类，多重继承之前的准备</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">speaker</span>():</span></span><br><span class="line">    topic = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,n,t</span>):</span></span><br><span class="line">        self.name = n</span><br><span class="line">        self.topic = t</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;我叫 %s，我是一个演说家，我演讲的主题是 %s&quot;</span>%(self.name,self.topic))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#多重继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sample</span>(<span class="params">speaker,student</span>):</span></span><br><span class="line">    a =<span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,n,a,w,g,t</span>):</span></span><br><span class="line">        student.__init__(self,n,a,w,g)</span><br><span class="line">        speaker.__init__(self,n,t)</span><br><span class="line"> </span><br><span class="line">test = sample(<span class="string">&quot;Tim&quot;</span>,<span class="number">25</span>,<span class="number">80</span>,<span class="number">4</span>,<span class="string">&quot;Python&quot;</span>)</span><br><span class="line">test.speak()   <span class="comment">#方法名同，默认调用的是在括号中排前地父类的方法</span></span><br><span class="line"><span class="comment"># 我叫 Tim，我是一个演说家，我演讲的主题是 Python</span></span><br></pre></td></tr></table></figure><p><strong>方法重写</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>:</span>        <span class="comment"># 定义父类</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">myMethod</span>(<span class="params">self</span>):</span></span><br><span class="line">      <span class="built_in">print</span> (<span class="string">&#x27;调用父类方法&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>(<span class="params">Parent</span>):</span> <span class="comment"># 定义子类</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">myMethod</span>(<span class="params">self</span>):</span></span><br><span class="line">      <span class="built_in">print</span> (<span class="string">&#x27;调用子类方法&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">c = Child()          <span class="comment"># 子类实例</span></span><br><span class="line">c.myMethod()         <span class="comment"># &#x27;调用子类方法&#x27; 子类调用重写方法</span></span><br><span class="line"><span class="built_in">super</span>(Child,c).myMethod()  <span class="comment"># &#x27;调用父类方法&#x27; 用子类对象调用父类已被覆盖的方法</span></span><br></pre></td></tr></table></figure><ul><li>super() 函数：用于调用父类(超类)的一个方法。</li></ul><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;super method&#x27;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delegate</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.action()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inheritor</span>(<span class="params">Super</span>):</span> <span class="comment">#1 获得父类的一切内容</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Replacer</span>(<span class="params">Super</span>):</span> <span class="comment">#2 覆盖父类的method</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;replacer.method&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Extender</span>(<span class="params">Super</span>):</span> <span class="comment">#3  覆盖并回调method 定制父类的method方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;extender.method&#x27;</span>)</span><br><span class="line">        Super.method(self)</span><br><span class="line">        print(<span class="string">&#x27;ending extend.method&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Provider</span>(<span class="params">Super</span>):</span>  <span class="comment">#4</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">action</span>(<span class="params">self</span>):</span>  <span class="comment"># 实现super的delegate方法预期的action方法</span></span><br><span class="line">        print(<span class="string">&#x27;provider.action&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> (Inheritor,Replacer,Extender):</span><br><span class="line">        print(i.__name__)</span><br><span class="line">        i().method()</span><br><span class="line">        x = Provider()</span><br><span class="line">        x.delegate()</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Inheritor</span></span><br><span class="line"><span class="string">super method</span></span><br><span class="line"><span class="string">provider.action</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Replacer</span></span><br><span class="line"><span class="string">replacer.method</span></span><br><span class="line"><span class="string">provider.action</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Extender</span></span><br><span class="line"><span class="string">extender.method</span></span><br><span class="line"><span class="string">super method</span></span><br><span class="line"><span class="string">ending extend.method</span></span><br><span class="line"><span class="string">provider.action</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><p><strong>pyinstaller</strong></p><ul><li>打包py文件，将在当前目录生成一个<code>.spec</code>文件和<code>dist</code>目录，可执行文件在<code>dist</code>目录下</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pip install pyinstaller</span><br><span class="line"><span class="meta">#</span><span class="bash"> 到文件夹下</span></span><br><span class="line">pyinstaller -F file.py</span><br><span class="line"></span><br><span class="line"><span class="meta"> #</span><span class="bash"> -F 打包出来是一个可执行文件，不然的话是多个，没有把包封装进去，需要pythonu环境来运行</span></span><br></pre></td></tr></table></figure><p>=======</p><ul><li>终端切换</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chsh -s /bin/zsh</span><br><span class="line">chsh -s /bin/bash</span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换后重启完成</span></span><br></pre></td></tr></table></figure><h2 id="一些错误"><a href="#一些错误" class="headerlink" title="一些错误"></a>一些错误</h2><img src="/2020/12/15/python/截屏2020-12-25 下午10.44.40.png" alt="截屏2020-12-25 下午10.44.40" style="zoom: 67%;">    <ul><li>字典类型的键是不可变的，可以使用数字、字符串或元组充当，但是不能使用列表作为键值</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Anaconda&quot;&gt;&lt;a href=&quot;#Anaconda&quot; class=&quot;headerlink&quot; title=&quot;Anaconda&quot;&gt;&lt;/a&gt;Anaconda&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;link&quot; href=&quot;https://www.jiansh</summary>
      
    
    
    
    <category term="notebook" scheme="https://jieyang-wei.github.io/categories/notebook/"/>
    
    
    <category term="编程语言" scheme="https://jieyang-wei.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="python" scheme="https://jieyang-wei.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>gdb调试</title>
    <link href="https://jieyang-wei.github.io/2020/12/14/gdb%E8%B0%83%E8%AF%95/"/>
    <id>https://jieyang-wei.github.io/2020/12/14/gdb%E8%B0%83%E8%AF%95/</id>
    <published>2020-12-14T09:56:55.000Z</published>
    <updated>2021-03-10T04:30:15.500Z</updated>
    
    <content type="html"><![CDATA[<p>制作链接库的目的是希望别人使用我们已经实现的功能，但又不希望别人看到我们的源代码<br><code>Linux</code>下的静态链接库是以<code>.a</code>结尾的二进制文件，它作为程序的一个模块，在链接期间被组合到程序中。和静态链接库相对的是动态链接库（.so文件），它在程序运行阶段被加载进内存。</p><p>静态库生成步骤</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1 对所有源文件，只编译不链接</span></span><br><span class="line">gcc -c test.c</span><br><span class="line"><span class="comment">//2 利用ar命令，生成库文件</span></span><br><span class="line">ar rcs libtest.a test.o</span><br></pre></td></tr></table></figure><p><code>ar</code>是 Linux 的一个备份压缩命令，它可以将多个文件打包成一个备份文件（也叫归档文件），也可以从备份文件中提取成员文件，最常见的用法是将目标文件打包为静态链接库。</p><p>对参数的说明：</p><ul><li>r：用来替换库中已有的目标文件，或者加入新的目标文件。</li><li>c：表示创建一个库。不管库否存在，都将创建。</li><li>s：用来创建目标文件索引，这在创建较大的库时能提高速度。</li></ul><ul><li>-lm：表示连接系统的数学库libm.a<ul><li>需要放在库之后，不然找不到</li></ul></li></ul><p>Linux 下动态链接库（shared object file，共享对象文件）的文件后缀为.so，它是一种特殊的目标文件（object file），可以在程序运行时被加载（链接）进来。</p><p>使用动态链接库的优点是：程序的可执行文件更小，便于程序的模块化以及更新，同时，有效内存的使用效率更高</p><ol><li>如果想创建一个动态链接库，可以使用 GCC 的-shared选项。输入文件可以是源文件、汇编文件或者目标文件。</li><li>另外还得结合<code>-fPIC</code>选项。<code>-fPIC</code>选项作用于编译阶段，告诉编译器产生与位置无关代码（Position-Independent Code）；这样一来，产生的代码中就没有绝对地址了，全部使用相对地址，所以代码可以被加载器加载到内存的任意位置，都可以正确的执行。这正是共享库所要求的，共享库被加载时，在内存的位置不是固定的。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 从源文件生成动态链接库：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -fPIC -shared func.c -o libfunc.so</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从目标文件生成动态链接库：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -fPIC -c func.c -o func.o</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -shared func.o -o libfunc.so</span></span><br><span class="line"> * -fPIC 选项作用于编译阶段，在生成目标文件时就得使用该选项，以生成位置无关的代码。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;制作链接库的目的是希望别人使用我们已经实现的功能，但又不希望别人看到我们的源代码&lt;br&gt;&lt;code&gt;Linux&lt;/code&gt;下的静态链接库是以&lt;code&gt;.a&lt;/code&gt;结尾的二进制文件，它作为程序的一个模块，在链接期间被组合到程序中。和静态链接库相对的是动态链接库（.s</summary>
      
    
    
    
    <category term="course" scheme="https://jieyang-wei.github.io/categories/course/"/>
    
    
    <category term="C++" scheme="https://jieyang-wei.github.io/tags/C/"/>
    
    <category term="linux" scheme="https://jieyang-wei.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>版本管理</title>
    <link href="https://jieyang-wei.github.io/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"/>
    <id>https://jieyang-wei.github.io/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/</id>
    <published>2020-12-14T07:55:40.000Z</published>
    <updated>2021-03-18T06:43:43.934Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h2><ol><li><p><strong>本地版本控制系统</strong>（Version Control Systems，简称VCS）</p><ul><li><p>大多都是采用某种简单的数据库来记录文件的历次更新差异</p></li><li><p>最流行的：<code>RCS</code></p><ul><li>工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，可以重新计算出各个版本的文件内容。”</li></ul></li></ul></li><li><p><strong>集中化版本控制系统</strong>（Centralized Version Control Systems，简称 CVCS ）</p><ul><li>诸如CVS、Subversion以及perforce等</li><li>容易单点故障、丢失所有历史更新记录的风险</li></ul></li><li><p><strong>分布式版本控制系统</strong>（Distributed Version Control System，简称 DVCS）</p><ul><li>像Git、Mercurial、Bazaar以及Darcs</li><li>客户端并不只提取最新版本的文件快照， 而是把代码仓库完整地镜像下来，包括完整的历史记录</li></ul></li></ol><ul><li>大部分系统以文件变更列表的方式存储信息，这类系统（CVS、Subversion、Perforce、Bazaar等）将他们存储的信息看作是一组基本文件和每个文件随时间逐步累积的差异（**基于差异[delta-based]**的版本控制）</li><li>Git 更像是把数据看作是对<strong>小型文件系统</strong>的一系列快照。 在 Git 中，每当你提交更新或保存项目状态时，它基本上就会对当时的全部文件创建一个快照并保存这个快照的索引。 为了效率，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 <strong>快照流</strong></li></ul><p><strong>git</strong>：分布式版本控制系统，c语言开发</p><p><strong>免费集中式版本控制</strong>：CVS、SVN  —  速度慢，且需要联网</p><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p><a class="link" href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">廖雪峰<i class="fas fa-external-link-alt"></i></a></p><p>电子书：progit_v2.1.54</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>git校验和机制</strong>：<strong>SHA-1散列</strong>，这是一个由 40 个十六进制字符（0-9 和 a-f）组成的字符串，基于 Git 中文件的内容或目录结构计算出来</p><h4 id="三种状态"><a href="#三种状态" class="headerlink" title="三种状态"></a>三种状态</h4><ul><li><strong>已提交（committed）</strong>：表示数据已经安全地保存在本地数据库中</li><li><strong>已修改（modified）</strong>：表示修改了文件，但还没保存到数据库中</li><li><strong>已暂存（staged）</strong>：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中</li></ul><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/截屏2020-12-09 下午2.58.04.png" alt="截屏2020-12-07 下午3.29.20"><ul><li>工作区：对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改</li><li>暂存区：是一个文件，保存了下次将要提交的文件列表信息，一般在 Git 仓库目录中。 按照 Git 的术语叫做“索引”，不过一般说法还是叫“暂存区</li><li>git目录：Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，复制的就是这里的数据</li></ul><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><ol><li>在工作区中修改文件。</li><li>将你想要下次提交的更改选择性地暂存，这样只会将更改的部分添加到暂存区。</li><li>提交更新，找到暂存区的文件，将快照永久性存储到 Git 目录。</li></ol><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install git-all</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看版本</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git --version</span></span><br></pre></td></tr></table></figure><p>工具目录结构</p><ul><li>git自带一个<code>git config</code>的工具来帮助设置，这些变量存储在三个不同的位置</li></ul><ol><li>/etc/gitconfig 文件：包含系统上每一个用户及他们仓库的通用配置。 如果在执行 git config 时带上 –system 选项，那么它就会读写该文件中的配置变量。 （由于它是系统配置文件，因此你需要管理员或超级用户权限来修改它。）</li><li>~/.gitconfig 或 ~/.config/git/config 文件：只针对当前用户。 你可以传递 –global 选项让 Git 读写此文件，这会对你系统上所有的仓库生效</li><li>当前使用仓库的 Git 目录中的 config 文件（即 .git/config）：针对该仓库。 你可以传递 –local 选项让 Git 强制读写此文件，虽然默认情况下用的就是它。。 （当然，你需要进入某个 Git 仓库中才能让该选项生效。）<ul><li>每一个级别会覆盖上一级别的配置，所以 .git/config 的配置变量会覆盖 /etc/gitconfig 中的配置变量</li></ul></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --list --show-origin  <span class="comment"># 查看所有配置以及他们所在文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置用户信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.name <span class="string">&quot;Weijieyang&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.email <span class="string">&quot;name@mail.com&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> git config 选项列表</span></span><br><span class="line"> * --list 列出所有 Git 当时能找到的配置</span><br><span class="line"> * --global 配置所有的项目</span><br></pre></td></tr></table></figure><ul><li>git工作目录下每一个文件只有两种状态<ol><li><strong>已跟踪</strong>：指那些被纳入了版本控制的文件，在上一次快照中有它们的记录。即git已经知道的文件</li><li><strong>未跟踪</strong>：其他文件</li></ol></li></ul><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="版本库（Repository）"><a href="#版本库（Repository）" class="headerlink" title="版本库（Repository）"></a>版本库（Repository）</h3><p>工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。</p><p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</p><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/截屏2020-12-07 下午3.29.20.png" alt="截屏2020-12-07 下午3.29.20" style="zoom:50%;"><ol><li><strong>创建版本库</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br></pre></td></tr></table></figure><ul><li>到需要版本管理的目录下</li><li>初始化后会在目录下形成一个<code>.git</code>文件，此文件为隐藏文件，需要使用命令<code>ls -a</code>查看</li></ul><ol start="2"><li><strong>使用步骤</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add file</span> </span><br></pre></td></tr></table></figure><ul><li>添加本地修改后的文件到暂存区</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"> * -s/--short 更为紧凑的输出展示效果</span><br></pre></td></tr></table></figure><ul><li>时刻掌握仓库当前情况，查看未被提交的修改，包括工作区和暂存区</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&#x27;注释&#x27;</span></span></span><br></pre></td></tr></table></figure><ul><li>将暂存区的修改提交到版本库中</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&#x27;注释&#x27;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add filemore</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend</span></span><br></pre></td></tr></table></figure><ul><li>第一次提交后发现漏了几个文件，可以使用<code>--amend</code>添加，此次提交将会替代上一次的提交，上一次的提交将不会出现在版本历史中ß</li></ul><ol start="3"><li><strong>版本管理</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line"> * —-pretty=onelines pretty可以指定不同于默认格式的方式展示历史</span><br><span class="line"> * onelines 输出消息更简洁，最前面是每个版本的commit id（用SHA1计算）</span><br><span class="line"> * format:&quot;%h - %an, %ar : %s&quot; 定制记录的显示格式</span><br><span class="line"> * 还有short、full和fuller</span><br><span class="line"> </span><br><span class="line"> * -p/--patch 显示每次提交所引入的差异（按 补丁 的格式输出）</span><br><span class="line"> * --stat 每次提交的简略统计信息</span><br><span class="line"> * --shortstat 只显示 --stat 中最后的行数修改添加移除统计</span><br><span class="line"> * --name-only 仅在提交信息后显示已修改的文件清单</span><br><span class="line"> * --name-status 显示新增、修改、删除的文件清单</span><br><span class="line"> * --graph 查看分支合并图，在日志旁以 ASCII 图形显示分支与合并历</span><br><span class="line"> * --abbrev-commit 查看详细的合并信息，仅显示 SHA-1 校验和所有 40 个字符中的前几个字符</span><br><span class="line"> * --relative-data 使用较短的相对时间而不是完整格式显示日期（比如“2 weeks ago”）</span><br></pre></td></tr></table></figure><ul><li>显示从最近到最远的提交日志</li><li><strong>format</strong>格式设置：<ul><li><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/截屏2020-12-09 下午3.39.00.png" alt="截屏2020-12-09 下午3.39.00" style="zoom: 33%;"></li><li><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/截屏2020-12-09 下午3.39.17.png" alt="截屏2020-12-09 下午3.39.17" style="zoom: 33%;"></li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git last</span></span><br></pre></td></tr></table></figure><ul><li>查看最后一次提交</li></ul><p><strong>取消暂存 reset</strong>  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard HEAD^</span> </span><br></pre></td></tr></table></figure><ul><li>回退到前一个版本<ul><li><code>HEAD</code>：相当于一个指针，指向<code>master</code>，而<code>master</code>指向提交</li><li><code>^</code>：是上一个版本，<code>^^</code>：前两个的版本，<code>HEAD～100</code>：往上100个版本</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard commitId</span></span><br></pre></td></tr></table></figure><ul><li>回退到版本号为<code>commitId</code>的版本</li><li><strong>注意</strong>：<code>--hard</code> 是一个危险的选项</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rerset HEAD &lt;file&gt;</span></span><br></pre></td></tr></table></figure><ul><li>撤销暂存区(unstage)的修改回退到工作区</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reflog</span></span><br><span class="line">e475afc HEAD@&#123;1&#125;: reset: moving to HEAD^</span><br><span class="line">1094adb (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: append GPL</span><br><span class="line">e475afc HEAD@&#123;3&#125;: commit: add distributed</span><br><span class="line">eaadf4e HEAD@&#123;4&#125;: commit (initial): wrote a readme file</span><br></pre></td></tr></table></figure><ul><li>记录了你的每一次命令，可以用来找已经撤销掉的版本id</li></ul><ol start="4"><li><strong>其他操作</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff file</span></span><br></pre></td></tr></table></figure><ul><li>查看修改内容，<code>diff</code>均是未提交的内容</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff --staged</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看已暂存文件和最后一次提交的文件差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff --cached</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看已经暂存起来的变化（--staged和--cached是同义词）</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff HEAD -- file</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看工作区和版本库里面最新版本的区别</span></span><br></pre></td></tr></table></figure><p><strong>撤销操作 checkout</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -- &lt;file&gt;</span></span><br></pre></td></tr></table></figure><ul><li>撤销上一次修改，回到最近一次git commit或者git add状态，不管是在工作区还是在暂存区<ul><li>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</li><li>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</li><li>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考<a class="link" href="https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192">版本回退<i class="fas fa-external-link-alt"></i></a>一节，不过前提是没有推送到远程库。</li></ul></li></ul><p><strong>删除文件 rm</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rm file</span></span><br></pre></td></tr></table></figure><ul><li>通过rm删除了文件之后，status会告诉删除信息，因为删除也算是修改操作（deleted： file）</li><li>在本地目录中删除文件之后可以选择彻底删除或者使用git恢复<ol><li>彻底删除：<code>$ git rm file</code>— 在暂存区中删除，<code>$ git commit</code> — 确定要在版本库中删除<ul><li>(如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失<strong>最近一次提交后你修改的内容</strong>。)</li></ul></li><li>恢复：<code>$ git checkout --file</code><ul><li>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</li></ul></li></ol></li></ul><p><strong>改名操作 mv</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git mv old new</span></span><br><span class="line">---- 相当于 ----</span><br><span class="line"><span class="meta">$</span><span class="bash"> mv old new</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm old</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add new</span></span><br></pre></td></tr></table></figure><p><strong>忽略文件</strong></p><p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。在这种情况下，我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件的模式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat .gitignore</span></span><br><span class="line">*～      # 忽略所有名字以～结尾的文件（通常是副本文件）</span><br><span class="line">*.[oa]   # 忽略以.o .a 结尾的文件</span><br><span class="line">!lib.a.  # 忽略.a文件，但跟踪所有 lib.a 文件</span><br><span class="line">/TODO    # 只忽略当前目录下的 TODO 文件</span><br><span class="line">build/   # 忽略任何目录下名为 build 的文件夹</span><br><span class="line">doc/*.txt    #忽略doc下的txt，但不忽略doc/server/a.txt</span><br><span class="line">doc/**/*.pdf #忽略doc及其子目录下的所有pdf文件</span><br></pre></td></tr></table></figure><p>格式规范：</p><ul><li>所有空行或者以 # 开头的行都会被 Git 忽略。</li><li>可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。</li><li>匹配模式可以以（/）开头防止递归。</li><li>匹配模式可以以（/）结尾指定目录。</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上叹号（!）取反。</li></ul><h3 id="远程仓库（github）"><a href="#远程仓库（github）" class="headerlink" title="远程仓库（github）"></a>远程仓库（github）</h3><ol><li><strong>创建电脑用户自己的密钥</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen -t rsa -C <span class="string">&quot;youremail@example.com&quot;</span></span></span><br><span class="line"> * -t 指定密钥类型，默认是 rsa ，可以省略。</span><br><span class="line"> * -C 设置注释文字，比如邮箱。</span><br><span class="line"> * -f 指定密钥文件存储文件名.</span><br></pre></td></tr></table></figure><ul><li>在用户主目录<code>/home/username</code>下创建密钥</li><li>生成<code>id_rsa</code>和<code>id_rsa.pub</code></li></ul><ol start="2"><li><strong>绑定电脑用户和github用户</strong></li></ol><ul><li>将公钥<code>id_rsa.pub</code>加载到github网站上<code>Add SSH Key</code></li></ul><ol start="3"><li><strong>添加远程仓库</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote add origin git@github-link</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote -v</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote show &lt;remote&gt;    <span class="comment"># 查看摸一个远程仓库的更多信息</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote rename old new   <span class="comment"># 给远程仓库改名</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote remove name      <span class="comment"># 删除远程仓库，及所有跟踪分支和配置信息</span></span></span><br></pre></td></tr></table></figure><ul><li>链接本地仓库和github上创建的远程仓库</li><li><code>origin</code>为远程仓库的默认名字，可自行更改</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push -u origin mymaster:master</span></span><br></pre></td></tr></table></figure><ul><li>将本地仓库的内容推送到远程仓库上，实际上是把当前分支master推送到远程</li><li><code>-u</code>：如果当前分支与多个主机存在追踪关系，则可以使用 -u 参数指定一个默认主机，这样后面就可以不加任何参数使用<code>git push</code><ul><li>不指定<code>mymaster</code>：将会删除远程的<code>master</code>分支，这相当于是push了一个空分支到<code>master</code></li><li>不指定<code>:master</code>：默认推送到与<code>mymaster</code>有追踪关系的分支，一般为同名分支，没有的话会在远程建一个（<code>git remote show &lt;origin&gt;</code>查看各个分支的追踪关系）</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull origin master:mymaster</span></span><br></pre></td></tr></table></figure><ul><li>提交远程之前，最好先将远程仓库的文件拉取下来，再<code>push</code>，以免造成冲突</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git fetch &lt;remote&gt; &lt;remote branchname&gt;:&lt;your branchname&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 不指定远程分支将会默认为‘default’分支（一般为master）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 不给本地分支命名的话，会自动默认指针 FETCH_HEAD</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者使用远程分支名 origin/master 指定fetch的分支</span></span><br></pre></td></tr></table></figure><ul><li>他与pull一样，就拉取远程仓库中有但你没有的文件（不要拉取到当前所在分支）</li><li>不同的是，fetch并不会自动合并或修改你当前的工作，更安全。 当准备好时你必须手动将其合并入你的工作。</li><li><strong>pull = fetch + merge (FETCH_HEAD)</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git fetch origin</span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge origin/<span class="string">&#x27;default&#x27;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 拉取远程默认分支到本地当前分支上，再与远程的默认分支合并</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git fetch origin master:mymaster-tmp</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge mymaster-tmp</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 建议建一个专用存放fetch的分支tmp，拉去下来文件后，再与myaster来merge</span></span><br></pre></td></tr></table></figure><p><strong><code>FETCH_HEAD</code></strong></p><ul><li>某个branch在服务器上的最新状态.</li><li>每一个执行过fetch操作的项目都会存在一个FETCH_HEAD列表,这个列表保存在 <code>.git/FETCH_HEAD</code> 文件中, 其中每一行对应于远程服务器的一个分支.当前分支指向的FETCH_HEAD, 就是这个文件第一行对应的那个分支</li><li>一般来说, 存在两种情况:<ul><li>如果没有显式的指定<code>远程分支</code>, 则远程分支的<code>master</code>将作为默认的<code>FETCH_HEAD</code>.</li><li>如果指定了<code>远程分支</code>, 就将这个远程分支作为<code>FETCH_HEAD</code>.</li></ul></li></ul><p><strong><code>–rebase</code></strong></p><ul><li>作用是取消掉本地库中刚刚的commit，并把他们接到更新后的版本库之中。</li></ul><ol start="4"><li><strong>克隆远程仓库</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> git@github-link</span></span><br></pre></td></tr></table></figure><ul><li>如果远程仓库已有文件，可以将其克隆到本地的空仓库中</li></ul><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p><code>master</code>：主分支</p><p><code>HEAD</code>：指向当前分支，即指向<code>master</code></p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul><li><strong>新建<code>dev</code>分支</strong>：现在修改东西就是<code>dev</code>指针移动了，而<code>HEAD</code>指向当前的<code>dev</code>分支<ul><li>此时修改<code>dev</code>分支，<code>master</code>分支将不会改变</li></ul></li></ul><p><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/3DEC42CC-E46F-4939-ACAA-33BD4B3F88B2.png" alt="3DEC42CC-E46F-4939-ACAA-33BD4B3F88B2" style="zoom:67%;"><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/截屏2020-12-07 下午4.12.29.png" alt="截屏2020-12-07 下午4.12.29" style="zoom: 33%;"></p><ul><li><strong>合并分支</strong>：改改指针的问题                                          <ul><li>将<code>dev</code>分支合并到<code>master</code>上，右图为不使用<code>Fast-Forward</code>快进模式时（–no-ff）</li></ul></li></ul><p><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/69B01EAC-0670-4DED-85A9-A41465FCBF3C.png" alt="69B01EAC-0670-4DED-85A9-A41465FCBF3C" style="zoom: 67%;"><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/B0212A11-D318-457F-9943-E5FCD27820B4.png" alt="B0212A11-D318-457F-9943-E5FCD27820B4" style="zoom: 67%;"></p><ul><li><strong>删除分支</strong>：将dev指针给删掉就行了</li></ul><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/9CA8FECF-51AB-438D-86D7-59846BF675C9.png" alt="9CA8FECF-51AB-438D-86D7-59846BF675C9" style="zoom:80%;"><h4 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h4><ul><li>创建分支：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout (-b) dev</span></span><br><span class="line"> * -b 创建并切换分支</span><br><span class="line">-------------------------</span><br><span class="line"><span class="meta">$</span><span class="bash"> git switch (-c) dev</span></span><br><span class="line"> * -c 创建并切换分支</span><br></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch dev     //创建分支(会创建一个和当前分支有一样内容的分支)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout/switch dev   //切换分支</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br><span class="line">* dev</span><br><span class="line">  master</span><br></pre></td></tr></table></figure><ul><li>查看当前分支，当前分支上会加上<code>*</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -d dev</span></span><br></pre></td></tr></table></figure><ul><li>删除分支dev</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br><span class="line"> * -vv 将所有的本地分支列出来并且包含更多的信息</span><br><span class="line"> * -r 查看远程所有分支</span><br><span class="line"> * -a 查看本地和远程的所有分支</span><br><span class="line"> * &lt;branchname&gt; 新建分支</span><br><span class="line"> * -d -r &lt;branchname&gt; 删除远程分支，删除后还需要推送到服务器</span><br><span class="line"> * -m old new 重命名分支</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch --set-upstream-to origin/branchname</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch --set-upstream-to=origin/branchname  branchname</span></span><br></pre></td></tr></table></figure><ul><li>修改<code>pull</code>时的远程分支关联<ul><li>upstream：将当前分支推送到其上游分支（ tracking &gt;是不推荐的同义词对于上游）</li><li>current：将当前分支推送到同名分支</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git merge dev</span>   </span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge --no-ff -m <span class="string">&quot;merge with no-ff” dev</span></span> </span><br></pre></td></tr></table></figure><ul><li>合并分支到当前分支（如：将<code>dev</code>上的工作结果合并到<code>master</code>上）</li><li>注：两个分支分别都修改了文件的冲突情况下，需要进行手动更改冲突<ul><li>一般合并分支会在<code>Fast Forward</code>模式，但此模式下删除分支，会丢失掉分支信息；</li><li>如果要强制禁用<code>Fast Forward</code>模式，Git就会在<code>merge</code>时生成一个新的<code>commit</code>，这样，从分支历史上就可以看出分支信息。</li><li><code>--no-ff</code>方式的git merge：看的出原来发生过合并，而merge看不出</li></ul></li></ul><ul><li><strong>分支策略</strong>：<ul><li>master：最稳定的，用来发布版本；</li><li>dev：不稳定，所有人将自己的修改合并到这个分支上</li></ul></li></ul><p><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/FD4949A7-CB58-4BD1-B887-3A833E23A7DD.png" alt="FD4949A7-CB58-4BD1-B887-3A833E23A7DD"></p><p>修改bug：创建新的分支进行修改，修改后合并到dev上，但是因为commit是一次提交所有的暂存区，所以需要将现在在写的，不需要提交的先用stash指令存储起来</p><p>git stash：将当前工作现场存储起来，等以后恢复现场工作后继续使用，此时git status非常的干净</p><p>查看：git stash list</p><p>恢复：git stash apply  -  恢复后不删除stash中的内容，需要用 git stash drop 来删除</p><p>​      git stash pop  -  恢复的同时删除</p><p>​       git stash apply stash@{0}：恢复指令的stash</p><p>feature分支</p><p>每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分</p><p>强行删除未合并的分支：git branch -D <file></file></p><h3 id="标签设置"><a href="#标签设置" class="headerlink" title="标签设置"></a>标签设置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出标签</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag -l <span class="string">&quot;v1.8.5&quot;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -l/-list 指定需要某些标签，如上只输出 v1.8.5 系列的</span></span><br></pre></td></tr></table></figure><h4 id="标签类型"><a href="#标签类型" class="headerlink" title="标签类型"></a><strong>标签类型</strong></h4><ol><li><strong>轻量标签（lightweight）</strong>：像一个不会改变的分支，它只是某个提交的引用</li><li><strong>附注标签（annotated）</strong>：是存储在git数据库的一个完整对象，它可以被校验，其中包含打标签者的名字、电子邮件、地址、日期时间，此外还有一个标签信息，并且可以使用GNU Privacy Guard（GPG）签名并验证</li></ol><h4 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a><strong>创建标签</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag -a v1.4 -m <span class="string">&quot;指定一条标签信息&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 轻量只用指定标签名字</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag v1.4</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 给历史版本打标签</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag -a v1.4 commitId</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git show v1.4</span></span><br></pre></td></tr></table></figure><ul><li>查看标签信息和与之对应的提交信息，如果是轻量标签则只会有提交信息</li></ul><h4 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a><strong>删除标签</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag -d v1.4</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin :refs/tags/v1.4</span></span><br></pre></td></tr></table></figure><ul><li>本地删除标签后并不会在远程仓库移除，需要执行第二条指令</li><li>将冒号前面的空值推送到远程标签名，从而高效地删除它</li><li>或者使用下面的方式更直观的删除</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin --delete &lt;tagname&gt;</span></span><br></pre></td></tr></table></figure><h4 id="共享标签"><a href="#共享标签" class="headerlink" title="共享标签"></a><strong>共享标签</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin v1.4</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin --tags</span></span><br></pre></td></tr></table></figure><ul><li><p>在创建完标签后你必须显式地推送标签到共享服务器上</p></li><li><p>–tags：这将会把所有不在远程仓库服务器上的标签全部传送到那里</p></li></ul><h4 id="检出标签"><a href="#检出标签" class="headerlink" title="检出标签"></a><strong>检出标签</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout 2.0.0</span></span><br></pre></td></tr></table></figure><ul><li>查看某个标签所指向的文件版本，但这会是你的仓库处于“分离头指针（detached HEAD）”的状态<ul><li>此状态如果你做了某些更改然后提交它们，标签不会发生变化， 但你的新提交将不属于任何分支，并且将无法访问，除非通过确切的提交哈希才能访问。 因此，如果你需要进行更改，比如你要修复旧版本中的错误，那么通常需要创建一个新分支<code>$ git checkout -b version2 v2.0.0</code></li></ul></li></ul><h3 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h3><h1 id="SVM"><a href="#SVM" class="headerlink" title="SVM"></a>SVM</h1><p>阿斯顿</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;h2 id=&quot;发展历史&quot;&gt;&lt;a href=&quot;#发展历史&quot; class=&quot;headerlink&quot; title=&quot;发展历史&quot;&gt;&lt;/a&gt;发展历史&lt;/h</summary>
      
    
    
    
    <category term="notebook" scheme="https://jieyang-wei.github.io/categories/notebook/"/>
    
    <category term="tool" scheme="https://jieyang-wei.github.io/categories/notebook/tool/"/>
    
    
    <category term="linux" scheme="https://jieyang-wei.github.io/tags/linux/"/>
    
    <category term="git" scheme="https://jieyang-wei.github.io/tags/git/"/>
    
  </entry>
  
</feed>
