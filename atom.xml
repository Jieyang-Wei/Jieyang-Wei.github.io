<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WeiJY&#39;s blog</title>
  
  
  <link href="https://jieyang-wei.github.io/atom.xml" rel="self"/>
  
  <link href="https://jieyang-wei.github.io/"/>
  <updated>2020-12-24T04:03:17.578Z</updated>
  <id>https://jieyang-wei.github.io/</id>
  
  <author>
    <name>Wei Jieyang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机基础</title>
    <link href="https://jieyang-wei.github.io/2020/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    <id>https://jieyang-wei.github.io/2020/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/</id>
    <published>2020-12-23T01:18:40.000Z</published>
    <updated>2020-12-24T04:03:17.578Z</updated>
    
    <content type="html"><![CDATA[<p>专用计算机：凯撒密码徽章，算盘</p><p>1946：宾夕法尼亚研究的第一台电子计算机</p><p>求 pai</p><p>密码学：</p><p>二进制编辑器：file info</p><p>Bmp：位图文件，没有压缩的原始文件</p><ul><li>jpg：是压缩之后的</li><li>文件前缀是BM(424d)，可以用二进编辑器打开</li><li>格式：（找到文档规范就能找到）<ul><li>源信息：BM 文件大小 空字节 … 宽 高 … </li><li>数据信息</li></ul></li></ul><p>文件类型：</p><ul><li>私有文件，不能对外交换信息</li><li>通用数据格式文件<ul><li>找到数据规范，就可以解析这个文件</li><li>去掉文件头，别人就打不开了</li><li>bmp，jpg，mp3等</li></ul></li></ul><p>vim -b  filename</p><p>:!xxde</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;专用计算机：凯撒密码徽章，算盘&lt;/p&gt;
&lt;p&gt;1946：宾夕法尼亚研究的第一台电子计算机&lt;/p&gt;
&lt;p&gt;求 pai&lt;/p&gt;
&lt;p&gt;密码学：&lt;/p&gt;
&lt;p&gt;二进制编辑器：file info&lt;/p&gt;
&lt;p&gt;Bmp：位图文件，没有压缩的原始文件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;jpg：</summary>
      
    
    
    
    <category term="notebook" scheme="https://jieyang-wei.github.io/categories/notebook/"/>
    
    
    <category term="理论知识" scheme="https://jieyang-wei.github.io/tags/%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>nodejs</title>
    <link href="https://jieyang-wei.github.io/2020/12/18/nodejs/"/>
    <id>https://jieyang-wei.github.io/2020/12/18/nodejs/</id>
    <published>2020-12-18T09:56:37.000Z</published>
    <updated>2020-12-23T11:48:44.607Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h2><ul><li>nodejs的包管理工具</li></ul><p><strong><a class="link" href="https://www.cnblogs.com/datiangou/p/10172994.html">package.json<i class="fas fa-external-link-alt"></i></a></strong></p><ul><li><a class="link" href="https://docs.npmjs.com/cli/v6/configuring-npm/package-json">官方文档<i class="fas fa-external-link-alt"></i></a></li></ul><p><code>npm init</code></p><ul><li>可以初始化一个package.json文件。在初始化的过程中，会叫用户输入name, version等等信息，当然，你都可以忽略。一路点回车，就生成了下面这样一个初始化的package.json。</li></ul><p><code>package.json</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;test&quot;</span>, <span class="comment">// 假如项目叫做test</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;this is my test&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;index.js&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;amp;&amp;amp; exit 1&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;author&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;license&quot;</span>: <span class="string">&quot;ISC&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>name</strong>: 这个很好理解，就是package的名称。不过需要注意的是，name有长度限制(虽然一般都不会超)，而且name不能以 【点】 或者 【下划线】开头，name中不能有大写字母。这个是每一个package必须的。在业务代码中，通过<code>require($&#123;name&#125;)</code>就可以引入对应的程序包了。</li><li><strong>version</strong>: package的版本。对于业务项目来说，这个往往不太重要，但是如果你要发布自己的项目，这个就显得十分重要了。name和version共同决定了唯一一份代码。npm是用[<a class="link" href="https://docs.npmjs.com/misc/semver.html">npm-semver]<i class="fas fa-external-link-alt"></i></a>来解析版本号的。我们一般见到的都是<code>大版本.次要版本.小版本</code>这种版本号，比如<code>16.1.0</code>。版本号的规则、含义其实蛮多的，可以参考<a class="link" href="https://segmentfault.com/a/1190000011368506">这篇文章<i class="fas fa-external-link-alt"></i></a>。</li><li><strong>desription</strong>：包的描述。开发组件库时必需，简明的向库的使用者介绍这个库是干嘛的。对于公司的业务项目，这个配置项一般无所谓。</li><li><strong>keywords</strong>：关键词。一个字符串数组，对这个npm包的介绍。组件库必需，便于使用者在npm中搜索。对于公司业务项目，这个配置一般无所谓。</li><li>homepage： 项目主页。对于开发组件库来说挺有用的。</li><li>bugs：开发者的联系方式，代码库的issues地址等。如果代码使用者发现了bug，可以通过这个配置项找到提bug的地方。</li><li><strong>license</strong>：开源协议。对于开源组件库，这个十分重要。之前react还因为这事儿没少被社区嫌弃。开源协议略微复杂，用<a class="link" href="http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html">阮一峰<i class="fas fa-external-link-alt"></i></a>前辈的一张图来说明一下吧。注：图里少了ISC, ISC和BSD差不多</li></ul><img src="/2020/12/18/nodejs/截屏2020-12-22 下午7.11.30.png" alt="截屏2020-12-22 下午7.11.30" style="zoom: 33%;"><ul><li><p>author：项目的作者。可以为字符串，对象。</p></li><li><p>contributors：项目的贡献者。author的数组。</p></li><li><p><strong>main</strong>：代码入口。这个十分重要，特别是对于组件库。当你想在node_modules中修改你使用的某个组件库的代码时，首先在node_modules中找到这个组件库，第一眼就是要看这个main，找到组件库的入口文件。在这个入口文件中再去修改代码吧。</p></li><li><p><strong>scripts</strong>：指定了运行脚本命令的npm命令行缩写。十分重要。</p><ul><li>在命令行输入：<code>npm run dev</code> , 对应的命令就会被执行。这里有一个地方需要注意，当执行<code>npm run xxx </code>的时候，<code>node_modules/.bin/</code>目录会在运行时被加入系统的PATH变量。</li><li>上面的例子，当我们在命令行输入：<code>npm run build</code>时，其实真正执行的命令是<code>node_modules/.bin/webpack</code>而不是<code>webpack</code>。所以，当你的webpack并未全局安装时，直接在命令行输入：<code>webpack</code>是会报错的。因为你的webapck是安装在<code>node_modules/.bin/</code>下面的。</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;dev&quot;: &quot;NODE_ENV=dev webpack-dev-server --progress --hot --host 0.0.0.0 --port 8089&quot;,</span><br><span class="line">    &quot;test&quot;: &quot;NODE_ENV=test webpack --config webpack.test.config.js --progress&quot;,</span><br><span class="line">    &quot;online&quot;: &quot;NODE_ENV=production webpack --config webpack.online.config.js --progress&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;webpack&quot;,</span><br><span class="line">    &quot;node&quot;: &quot;node server.js&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>directories：对整个代码结构的描述。告诉代码包使用者可以在哪里找到对应的文件。</p></li><li><p>files：数组。表示代码包下载安装完成时包括的所有文件。</p></li><li><p><strong>repository</strong>：对于组件库很有用。让组件库使用者找到你的代码库地址。这个配置项会直接在组件库的npm首页生效。例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;repository&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;git&quot;,</span><br><span class="line">    &quot;url&quot;: &quot;git+https:&#x2F;&#x2F;github.com&#x2F;CoyPan&#x2F;react-scroll-to-show-cb.git&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><p>config：用于添加命令行的环境变量。具体用法见<a class="link" href="https://docs.npmjs.com/misc/config">这里<i class="fas fa-external-link-alt"></i></a>。</p></li><li><p><strong>dependencies</strong>：项目的依赖。通过<code>npm install --save</code>安装的包会出现在这里。</p><ul><li>注意，<strong>不要把测试工具、代码转换器或者打包工具</strong>等放在这里。当你在命令行里面使用<code>npm install react --save</code>时，react就会出现在dependencies。默认是安装最新的版本。如果想安装某个特定的版本，可以<code>npm install react@15.6.2</code>。</li></ul></li></ul><hr><p>以下的dependencies，格式都是合法的，</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&quot;dependencies&quot; : &#123; </span><br><span class="line">    &quot;foo&quot; : &quot;1.0.0 - 2.9999.9999&quot;,</span><br><span class="line">    &quot;bar&quot; : &quot;&amp;gt;=1.0.2 &amp;lt;2.1.2&quot;,</span><br><span class="line">    &quot;baz&quot; : &quot;&amp;gt;1.0.2 &amp;lt;=2.3.4&quot;,</span><br><span class="line">    &quot;boo&quot; : &quot;2.0.1&quot;,    // 指定了就是2.0.1版本</span><br><span class="line">    &quot;qux&quot; : &quot;&amp;lt;1.0.0 || &amp;gt;=2.3.1 &amp;lt;2.4.5 || &amp;gt;=2.5.2 &amp;lt;3.0.0&quot;,</span><br><span class="line">    &quot;asd&quot; : &quot;http://asdf.com/asdf.tar.gz&quot;,</span><br><span class="line">    &quot;til&quot; : &quot;~1.2.2&quot;,   // 安装版本号不低于1.2.2的1.2.x的最新版本</span><br><span class="line">  <span class="comment">// 例如:1.2.3， 1.2.4等等。1.2.1 ，1.3.x 等就不行了</span></span><br><span class="line">    &quot;elf&quot; : &quot;^1.2.3&quot;,   // 安装版本号不低于1.2.2的1.x.x的最新版本</span><br><span class="line">  <span class="comment">// 例如: 1.2.7，1.7.8等,1.2.1 ，2.0.0 等就不行了。</span></span><br><span class="line">    <span class="comment">// 注意，如果配置是^0.x.x，则和~0.x.x的效果一样。  </span></span><br><span class="line">    &quot;two&quot; : &quot;2.x&quot;,</span><br><span class="line">    &quot;thr&quot; : &quot;3.3.x&quot;,</span><br><span class="line">    &quot;lat&quot; : &quot;latest&quot;,   // 安装最新版本</span><br><span class="line">    &quot;dyl&quot; : &quot;file:../dyl&quot;,</span><br><span class="line">  <span class="comment">//&quot;foo&quot;: &quot;git+ssh://git@github.com:foo/foo.git#v1.0.1&quot;   // 还可以这样</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>foo组件的地址为<code>git+ssh://&#123;foo代码库的ssh地址&#125;#v&#123;foo的版本号&#125;</code><ul><li>好处：组内的许多项目都有同一个功能，把这个功能抽出来做成组件是很自然的想法。但是每个项目都有自己的代码库，公司也没有内部的npm库，组件应该放在哪里呢？可以专门为组件新建一个代码仓库，将组件放在这里开发、迭代。这样，各个项目都可以引用该组件：只需要在dependencies中将组件配置成上述的形式。至于组件的版本，可以通过<code>git tag</code>来控制。</li></ul></li><li>dependencies还有其他的配置方式，具体在<a class="link" href="https://docs.npmjs.com/files/package.json.html#dependencies">这里<i class="fas fa-external-link-alt"></i></a>查看。</li></ul><hr><ul><li><strong>devDependencies</strong>：项目的依赖。通过<code>npm run install --save-dev</code>安装的包会出现在这里。主要是在<strong>开发过程</strong>中依赖的一些工具。用法与dependencies相似。</li><li>bundledDependencies：数组，打包时的依赖。如果配置了bundledDependencies，在项目中执行 <code>npm pack</code>将项目打包时，最后生成的<code>.tgz</code>包中，会包含bundledDependencies中配置的依赖。bundledDependencies中的依赖必须在devDependencies或者dependencies中声明过。</li><li>peerDependencies: 指定当前组件的依赖以其版本。如果组件使用者在项目中安装了其他版本的同一依赖，会提示报错。</li><li>engines：指定项目所依赖的node环境、npm版本等。</li><li>private：如果设为true，无法通过<code>npm publish</code>发布代码。</li><li>bin：用来指定各个内部命令对应的可执行文件的路径。具体用法这里不多讲了。详情可以点击<a class="link" href="https://docs.npmjs.com/files/package.json.html#bin">这里<i class="fas fa-external-link-alt"></i></a>。</li></ul><p><code>npm install</code></p><ul><li>根据配置文件<code>package.json</code>来安装环境</li><li>会在当前路径下自动创建文件夹<code>node_modules</code>，里面放所有下载的依赖包</li></ul><p><code>npm install name --save</code></p><ul><li>下载包name，同时加载到配置文件<code>package.json</code>的依赖<code>&quot;dependencies&quot;</code>里面</li></ul><h1 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123</span>; <span class="comment">// 整数123</span></span><br><span class="line"><span class="number">0.456</span>; <span class="comment">// 浮点数0.456</span></span><br><span class="line"><span class="number">1.2345e3</span>; <span class="comment">// 科学计数法表示1.2345x1000，等同于1234.5</span></span><br><span class="line">-<span class="number">99</span>; <span class="comment">// 负数</span></span><br><span class="line"><span class="literal">NaN</span>; <span class="comment">// NaN表示Not a Number，当无法计算结果时用NaN表示</span></span><br><span class="line"><span class="literal">Infinity</span>; <span class="comment">// Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity</span></span><br></pre></td></tr></table></figure><ul><li>JavaScript不区分整数和浮点数，统一用Number表示，以上都是合法的Number类型</li><li>Number的四则运算同数学</li><li><strong>注意</strong>：<ul><li><code>NaN</code>这个特殊的Number与所有其他值都不相等，包括它自己：<ul><li>NaN === NaN        //false</li><li>isNaN(NaN);          //true</li></ul></li></ul></li></ul><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p><strong>比较运算符</strong></p><ul><li><code>==</code>：它会<strong>自动转换数据类型</strong>再比较，很多时候，会得到非常诡异的结果；</li><li><code>===</code>：它<strong>不会</strong>自动转换数据类型，如果数据类型不一致，返回<code>false</code>，如果一致，再比较。<ul><li>由于JavaScript这个设计缺陷，<em>不要</em>使用<code>==</code>比较，始终坚持使用<code>===</code>比较。</li></ul></li></ul><p><strong>null和undefined：</strong></p><ul><li><code>null</code>表示一个“空”的值，它和<code>0</code>以及空字符串<code>&#39;&#39;</code>不同，<code>0</code>是一个数值，<code>&#39;&#39;</code>表示长度为0的字符串，而<code>null</code>表示“空”。</li><li>在其他语言中，也有类似JavaScript的<code>null</code>的表示，例如Java也用<code>null</code>，Swift用<code>nil</code>，Python用<code>None</code>表示。但是，在JavaScript中，还有一个和<code>null</code>类似的<code>undefined</code>，它表示“未定义”。</li><li>JavaScript的设计者希望用<code>null</code>表示一个空的值，而<code>undefined</code>表示值未定义。事实证明，这并没有什么卵用，区分两者的意义不大。</li><li>大多数情况下，我们都应该用<code>null</code>。<code>undefined</code>仅仅在判断函数参数是否传递的情况下有用。</li></ul><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p><strong>strict模式</strong></p><ul><li>JavaScript在设计之初，为了方便初学者学习，并不强制要求用<code>var</code>申明变量。这个设计错误带来了严重的后果：如果一个变量没有通过<code>var</code>申明就被使用，那么该变量就自动被申明为全局变量</li><li>为了修补JavaScript这一严重设计缺陷，ECMA在后续规范中推出了<code>strict模式</code>，在<code>strict模式</code>下运行的JavaScript代码，强制通过<code>var</code>申明变量，未使用<code>var</code>申明变量就使用的，将导致运行错误。</li></ul><h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><h5 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h5><h5 id="Iterable"><a href="#Iterable" class="headerlink" title="Iterable"></a>Iterable</h5><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul><li>变量名是大小写英文、数字、<code>$</code>和<code>_</code>的组合，且不能用数字开头。</li><li>变量名也不能是JavaScript的关键字，如<code>if</code>、<code>while</code>等。</li><li>申明一个变量用<code>var</code>语句</li></ul><p><strong>变量输出</strong></p><ul><li>console.log(x)</li><li>alert(x) –html弹窗</li></ul><h2 id="标准对象"><a href="#标准对象" class="headerlink" title="标准对象"></a>标准对象</h2><ul><li>在JavaScript的世界里，一切都是对象。</li><li>但是某些对象还是和其他对象不太一样。为了区分对象的类型，我们用<code>typeof</code>操作符获取对象的类型，它总是返回一个字符串</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">123</span>; <span class="comment">// &#x27;number&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span>; <span class="comment">// &#x27;number&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;str&#x27;</span>; <span class="comment">// &#x27;string&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>; <span class="comment">// &#x27;boolean&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>; <span class="comment">// &#x27;undefined&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Math</span>.abs; <span class="comment">// &#x27;function&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>; <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> []; <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;; <span class="comment">// &#x27;object&#x27;</span></span><br></pre></td></tr></table></figure><ul><li><code>number</code>、<code>string</code>、<code>boolean</code>、<code>function</code>和<code>undefined</code>有别于其他类型。</li><li><strong>特别注意</strong>：<code>null</code>的类型是<code>object</code>，<code>Array</code>的类型也是<code>object</code>，如果我们用<code>typeof</code>将无法区分出<code>null</code>、<code>Array</code>和通常意义上的object——<code>&#123;&#125;</code>。</li></ul><p><strong>包装对象</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>); <span class="comment">// 123,生成了新的包装类型</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>); <span class="comment">// true,生成了新的包装类型</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;str&#x27;</span>); <span class="comment">// &#x27;str&#x27;,生成了新的包装类型</span></span><br></pre></td></tr></table></figure><ul><li>类型为<code>object</code></li></ul><p>总结一下，有这么几条规则需要遵守：</p><ul><li><p>不要使用<code>new Number()</code>、<code>new Boolean()</code>、<code>new String()</code>创建包装对象；</p><ul><li>如果没写<code>new</code>，<code>Number()</code>、<code>Boolean</code>和<code>String()</code>被当做普通函数，把任何类型的数据转换为<code>number</code>、<code>boolean</code>和<code>string</code>类型（注意不是其包装类型）</li></ul></li><li><p>用<code>parseInt()</code>或<code>parseFloat()</code>来转换任意类型到<code>number</code>；</p></li><li><p>用<code>String()</code>来转换任意类型到<code>string</code>，或者直接调用某个对象的<code>toString()</code>方法；</p><ul><li><p><code>null</code>和<code>undefined</code>就没有<code>toString()</code>方法；Object一些情况下也不能使用</p></li><li><p><code>number</code>对象调用<code>toString()</code>报<strong>SyntaxError：</strong></p></li><li><pre><code class="javascript">123.toString();    // SyntaxError123..toString();   // &#39;123&#39;, 注意是两个点！(123).toString();  // &#39;123&#39;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 通常不必把任意类型转换为&#96;boolean&#96;再判断，因为可以直接写&#96;if (myVar) &#123;...&#125;&#96;；</span><br><span class="line"></span><br><span class="line">- &#96;typeof&#96;操作符可以判断出&#96;number&#96;、&#96;boolean&#96;、&#96;string&#96;、&#96;function&#96;和&#96;undefined&#96;；</span><br><span class="line"></span><br><span class="line">- 判断&#96;Array&#96;要使用&#96;Array.isArray(arr)&#96;；</span><br><span class="line"></span><br><span class="line">- 判断&#96;null&#96;请使用&#96;myVar &#x3D;&#x3D;&#x3D; null&#96;；</span><br><span class="line"></span><br><span class="line">- 判断某个全局变量是否存在用&#96;typeof window.myVar &#x3D;&#x3D;&#x3D; &#39;undefined&#39;&#96;；</span><br><span class="line"></span><br><span class="line">- 函数内部判断某个变量是否存在用&#96;typeof myVar &#x3D;&#x3D;&#x3D; &#39;undefined&#39;&#96;。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### Date</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### RegExp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### JSON</span><br><span class="line"></span><br><span class="line">* JSON实际上是JavaScript的一个子集。</span><br><span class="line">* JSON字符集必须是UTF-8</span><br><span class="line">* 为了统一解析JSON的字符串规定必须用双引号&#96;&quot;&quot;&#96;，Object的键也必须用双引号&#96;&quot;&quot;&#96;。</span><br><span class="line">* 在JSON中，一共就这么几种数据类型：</span><br><span class="line">  1. **number**：和JavaScript的&#96;number&#96;完全一致；</span><br><span class="line">  2. **boolean**：就是JavaScript的&#96;true&#96;或&#96;false&#96;；</span><br><span class="line">  3. **string**：就是JavaScript的&#96;string&#96;；</span><br><span class="line">  4. **nul**l：就是JavaScript的&#96;null&#96;；</span><br><span class="line">  5. **array**：就是JavaScript的&#96;Array&#96;表示方式——&#96;[]&#96;；</span><br><span class="line">  6. **object**：就是JavaScript的&#96;&#123; ... &#125;&#96;表示方式。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**序列化:** 对象 -&gt; JSON</span><br><span class="line"></span><br><span class="line">* &#96;JSON.stringfy(var, null, &#39; &#39;)&#96;：将nodejs对象输出成标准JSON格式</span><br><span class="line"></span><br><span class="line">  * 第二个参数用于控制如何筛选对象的键值，如果我们只想输出指定的属性，可以传入&#96;Array&#96;</span><br><span class="line"></span><br><span class="line">    * &#96;JSON.stringify(xiaoming, [&#39;name&#39;, &#39;skills&#39;], &#39;&#39;);  &#96;</span><br><span class="line">    * 只输出对象 xiaoming 的 name 和 skills 属性</span><br><span class="line"></span><br><span class="line">  * 第二个参数还能是一个函数，这样对象的每个键值对都会被函数先处理，</span><br><span class="line"></span><br><span class="line">    * &#96;&#96;&#96;javascript</span><br><span class="line">      function convert(key, value) &#123;</span><br><span class="line">          if (typeof value &#x3D;&#x3D;&#x3D; &#39;string&#39;) &#123;</span><br><span class="line">              return value.toUpperCase();</span><br><span class="line">          &#125;</span><br><span class="line">          return value;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      JSON.stringfy(xiaoming, convert, &#39;  &#39;);</span><br></pre></td></tr></table></figure></code></pre></li></ul><ul><li>第三个参数控制按缩进输出</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    age: <span class="number">14</span>,</span><br><span class="line">    gender: <span class="literal">true</span>,</span><br><span class="line">    height: <span class="number">1.65</span>,</span><br><span class="line">    grade: <span class="literal">null</span>,</span><br><span class="line">    <span class="string">&#x27;middle-school&#x27;</span>: <span class="string">&#x27;\&quot;W3C\&quot; Middle School&#x27;</span>,</span><br><span class="line">    skills: [<span class="string">&#x27;JavaScript&#x27;</span>, <span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;Lisp&#x27;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="built_in">JSON</span>.stringify(xiaoming);</span><br><span class="line"><span class="built_in">console</span>.log(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;小明&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">14</span>,<span class="string">&quot;gender&quot;</span>:<span class="literal">true</span>,<span class="string">&quot;height&quot;</span>:<span class="number">1.65</span>,<span class="string">&quot;grade&quot;</span>:<span class="literal">null</span>,<span class="string">&quot;middle-school&quot;</span>:<span class="string">&quot;\&quot;W3C\&quot; Middle School&quot;</span>,<span class="string">&quot;skills&quot;</span>:[<span class="string">&quot;JavaScript&quot;</span>,<span class="string">&quot;Java&quot;</span>,<span class="string">&quot;Python&quot;</span>,<span class="string">&quot;Lisp&quot;</span>]&#125;</span><br></pre></td></tr></table></figure><ul><li>如果我们还想要精确控制如何序列化小明，可以给<code>xiaoming</code>定义一个<code>toJSON()</code>的方法，直接返回JSON应该序列化的数据：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    age: <span class="number">14</span>,</span><br><span class="line">    gender: <span class="literal">true</span>,</span><br><span class="line">    height: <span class="number">1.65</span>,</span><br><span class="line">    grade: <span class="literal">null</span>,</span><br><span class="line">    <span class="string">&#x27;middle-school&#x27;</span>: <span class="string">&#x27;\&quot;W3C\&quot; Middle School&#x27;</span>,</span><br><span class="line">    skills: [<span class="string">&#x27;JavaScript&#x27;</span>, <span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;Lisp&#x27;</span>],</span><br><span class="line">    toJSON: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="comment">// 只输出name和age，并且改变了key：</span></span><br><span class="line">            <span class="string">&#x27;Name&#x27;</span>: <span class="built_in">this</span>.name,</span><br><span class="line">            <span class="string">&#x27;Age&#x27;</span>: <span class="built_in">this</span>.age</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify(xiaoming); <span class="comment">// &#x27;&#123;&quot;Name&quot;:&quot;小明&quot;,&quot;Age&quot;:14&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>反序列化:</strong> JSON -&gt; 对象</p><ul><li><code>JSON.parse()</code>：把JSON变成一个JavaScript对象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;[1,2,3,true]&#x27;</span>); <span class="comment">// [1, 2, 3, true]</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;&#123;&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:14&#125;&#x27;</span>); <span class="comment">// Object &#123;name: &#x27;小明&#x27;, age: 14&#125;</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;true&#x27;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;123.45&#x27;</span>); <span class="comment">// 123.45</span></span><br></pre></td></tr></table></figure><ul><li><code>JSON.parse()</code>还可以接收一个函数，用来转换解析出的属性：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">JSON</span>.parse(<span class="string">&#x27;&#123;&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:14&#125;&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key === <span class="string">&#x27;name&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value + <span class="string">&#x27;同学&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj)); <span class="comment">// &#123;name: &#x27;小明同学&#x27;, age: 14&#125;</span></span><br></pre></td></tr></table></figure><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><h3 id="fs"><a href="#fs" class="headerlink" title="fs"></a>fs</h3><ul><li>文件系统模块，负责读写文件</li><li>和所有其它JavaScript模块不同的是，<code>fs</code>模块同时提供了异步和同步的方法。、</li></ul><p><strong>异步读文件</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">&#x27;sample.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>异步读取时，传入的回调函数接收两个参数，当正常读取时，<code>err</code>参数为<code>null</code>，<code>data</code>参数为读取到的String。当读取发生错误时，<code>err</code>参数代表一个错误对象，<code>data</code>为<code>undefined</code>。</li><li>这也是Node.js<strong>标准的</strong>回调函数：第一个参数代表错误信息，第二个参数代表结果。后面我们还会经常编写这种回调函数。</li></ul><p>读取图片</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">&#x27;sample.png&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">        <span class="built_in">console</span>.log(data.length + <span class="string">&#x27; bytes&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>当读取二进制文件时，不传入文件编码时，回调函数的<code>data</code>参数将返回一个<code>Buffer</code>对象。在Node.js中，<code>Buffer</code>对象就是一个包含零个或任意个字节的数组（注意和Array不同）。<ul><li><code>Buffer</code>对象可以和String作转换，例如，把一个<code>Buffer</code>对象转换成String：</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Buffer -&gt; String</span></span><br><span class="line"><span class="keyword">var</span> text = data.toString(<span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(text);</span><br></pre></td></tr></table></figure><ul><li>或者把一个String转换成<code>Buffer</code>：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String -&gt; Buffer</span></span><br><span class="line"><span class="keyword">var</span> buf = Buffer.from(text, <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(buf);</span><br></pre></td></tr></table></figure><p><strong>同步读文件</strong></p><ul><li>同步读取的函数和异步函数相比，多了一个<code>Sync</code>后缀，并且不接收回调函数，函数直接返回结果。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data = fs.readFileSync(<span class="string">&#x27;sample.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(data);</span><br></pre></td></tr></table></figure><ul><li>如果同步读取文件发生错误，则需要用<code>try...catch</code>捕获该错误：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data = fs.readFileSync(<span class="string">&#x27;sample.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="comment">// 出错了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h3><h3 id="http"><a href="#http" class="headerlink" title="http"></a>http</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入http模块:</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建http server，并传入回调函数:</span></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(req.method == <span class="string">&quot;GET&quot;</span>)&#123;</span><br><span class="line">        doGet(req, res)</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(req.method == <span class="string">&quot;POST&quot;</span>)&#123;</span><br><span class="line">        doPost(req, res)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        res.end();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 让服务器监听8080端口:</span></span><br><span class="line">server.listen(<span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doGet</span>(<span class="params">request, response</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 回调函数接收request和response对象,</span></span><br><span class="line">    <span class="comment">// 获得HTTP请求的method和url:</span></span><br><span class="line">    <span class="built_in">console</span>.log(request.method + <span class="string">&#x27;: &#x27;</span> + request.url);</span><br><span class="line">    <span class="comment">// 解析请求的Url，返回一个标准的对象</span></span><br><span class="line">    <span class="keyword">var</span> params = url.parse(request.url, <span class="literal">true</span>);   </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 向http请求返回一个表单</span></span><br><span class="line">    <span class="comment">// 协议头，将HTTP响应200写入response, 同时设置Content-Type: text/html:</span></span><br><span class="line">    response.writeHead(<span class="number">200</span>, &#123;<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/html&#x27;</span>&#125;);</span><br><span class="line">    response.write(<span class="string">&#x27;&lt;html&gt;&#x27;</span>);</span><br><span class="line">    response.write(<span class="string">&#x27;&lt;head&gt;&#x27;</span>);</span><br><span class="line">    response.write(<span class="string">&#x27;&lt;meta charset=&quot;utf-8&quot;&gt;&#x27;</span>);</span><br><span class="line">    response.write(<span class="string">&#x27;&lt;title&gt;&#x27;</span>);</span><br><span class="line">    response.write(<span class="string">&#x27;&lt;/title&gt;&#x27;</span>);</span><br><span class="line">    response.write(<span class="string">&#x27;&lt;/head&gt;&#x27;</span>);</span><br><span class="line">    response.write(<span class="string">&#x27;&lt;body&gt;&#x27;</span>);</span><br><span class="line">    response.write(<span class="string">&#x27;&lt;form method=&quot;post&quot;&gt;&#x27;</span>);  <span class="comment">//表单post输出传入下面的函数</span></span><br><span class="line">    response.write(<span class="string">&#x27;username:&lt;input name=&quot;username&quot;&gt;&#x27;</span>);</span><br><span class="line">    response.write(<span class="string">&#x27;password:&lt;input name=&quot;password&quot;&gt;&lt;input type=&quot;submit&quot;&gt;&#x27;</span>);</span><br><span class="line">    response.write(<span class="string">&#x27;&lt;/form&gt;&#x27;</span>);</span><br><span class="line">    response.write(<span class="string">&#x27;&lt;/body&gt;&#x27;</span>);</span><br><span class="line">    response.write(<span class="string">&#x27;&lt;/html&gt;&#x27;</span>);</span><br><span class="line">    <span class="comment">// 将HTTP响应的HTML内容写入response:</span></span><br><span class="line">    response.end()</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doPost</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> formDate = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 通过req的data事件监听函数，每当接受到请求体的数据，就累加到formDate变量中</span></span><br><span class="line">    req.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        formDate += data;</span><br><span class="line">        <span class="built_in">console</span>.log(data); </span><br><span class="line"><span class="comment">//&lt;Buffer 75 73 65 72 6e 61 6d 65 3d 25 45 39 25 41 44 25 38 46 25 45 36 25 42 34 25 38 31 25 45 36 25 39 44 25 41 38 26 70 61 73 73 77 6f 72 64 3d 34 35 36 37&gt;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 在end事件触发后，通过querystring.parse将formDate解析为真正的POST请求格式，然后向客户端返回。</span></span><br><span class="line">    req.on(<span class="string">&#x27;end&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> body = querystring.parse(formDate);</span><br><span class="line">    res.end(util.inspect(body));</span><br><span class="line">      <span class="comment">// [Object: null prototype] &#123; username: &#x27;wjy&#x27;, password: &#x27;456&#x27; &#125;</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Server is running at http://127.0.0.1:8080/&#x27;</span>);</span><br></pre></td></tr></table></figure><ul><li><code>request</code>：封装了HTTP请求，我们调用<code>request</code>对象的属性和方法就可以拿到所有HTTP请求的信息；<ul><li>{‘Content-Type’: ‘text/html’}：设置类型为html页面</li><li><strong>方法</strong><ul><li><code>req.on(&#39;data&#39;, function(data)&#123;&#125;)</code>：data为一个buffer数据，需要将所有数据包的字节都存储起来，再来分析</li><li><code>req.on(&#39;end&#39;, function(data)&#123;  res.end();  &#125;)</code>：在出发结束的函数后，再在他的function里面结束相应<code>res.end();</code></li></ul></li></ul></li><li><code>response</code>：封装了HTTP响应，我们操作<code>response</code>对象的方法，就可以把HTTP响应返回给浏览器。<ul><li><strong>方法</strong><ul><li><code>response.writeHead()</code>：设置http协议头，给浏览器看的</li><li><code>response.write()</code>：仅发送数据</li><li><code>response.end()</code>：发送并结束请求，必须有，可以发送空</li></ul></li></ul></li></ul><p><strong>编码模式</strong></p><ul><li>浏览器默认<code>urlencode</code>字符集编码，不支持中文<ul><li>接收浏览器的请求数据res，在nodejs中输出是中文适配的</li><li>但是如果直接将中文传到浏览器输出将会出现乱码，所以设置html页面属性meta为<code>utf-8</code></li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">res.write(<span class="string">&#x27;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;/&gt;&lt;/head&gt;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">------ urlcode 加解码 ------</span><br><span class="line"><span class="built_in">encodeURI</span>(<span class="string">&quot;魏洁杨&quot;</span>);    <span class="comment">// %E9%AD%8F%E6%B4%81%E6%9D%A8</span></span><br><span class="line"><span class="built_in">decodeURI</span>(<span class="string">&quot;%E9%AD%8F%E6%B4%81%E6%9D%A8&quot;</span>)   <span class="comment">//魏洁杨</span></span><br></pre></td></tr></table></figure><p><strong>请求内容</strong></p><ul><li>GET：<ul><li>由于GET请求直接被嵌入在路径中，URL是完整的请求路径，包括了?后面的部分，因此你可以手动解析后面的内容作为GET请求的参数。</li><li>下面 url 模块中的 <code>parse</code>函数提供了这个功能。</li></ul></li><li>POST：<ul><li>POST 请求的内容全部的都在请求体中，http.ServerRequest 并没有一个属性内容为请求体，原因是等待请求体传输可能是一件耗时的工作。</li><li>比如上传文件，而很多时候我们可能并不需要理会请求体的内容，恶意的POST请求会大大消耗服务器的资源，所以 node.js 默认是不会解析请求体的，当你需要的时候，需要手动来做。</li><li>下面的querystring和util模块提供了相应的处理</li></ul></li></ul><h4 id="url"><a href="#url" class="headerlink" title="url"></a>url</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(url.parse(<span class="string">&#x27;http://user:pass@host.com:8080/path/to/file?query=string#hash&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出 */</span></span><br><span class="line">Url &#123;</span><br><span class="line">  protocol: <span class="string">&#x27;http:&#x27;</span>,</span><br><span class="line">  slashes: <span class="literal">true</span>,</span><br><span class="line">  auth: <span class="string">&#x27;user:pass&#x27;</span>,</span><br><span class="line">  host: <span class="string">&#x27;host.com:8080&#x27;</span>,</span><br><span class="line">  port: <span class="string">&#x27;8080&#x27;</span>,</span><br><span class="line">  hostname: <span class="string">&#x27;host.com&#x27;</span>,</span><br><span class="line">  hash: <span class="string">&#x27;#hash&#x27;</span>,</span><br><span class="line">  search: <span class="string">&#x27;?query=string&#x27;</span>,</span><br><span class="line">  query: <span class="string">&#x27;query=string&#x27;</span>,</span><br><span class="line">  pathname: <span class="string">&#x27;/path/to/file&#x27;</span>,</span><br><span class="line">  path: <span class="string">&#x27;/path/to/file?query=string&#x27;</span>,</span><br><span class="line">  href: <span class="string">&#x27;http://user:pass@host.com:8080/path/to/file?query=string#hash&#x27;</span> &#125;</span><br></pre></td></tr></table></figure><h4 id="querystring"><a href="#querystring" class="headerlink" title="querystring"></a>querystring</h4><h4 id="util"><a href="#util" class="headerlink" title="util"></a>util</h4><h4 id="path"><a href="#path" class="headerlink" title="path"></a>path</h4><h3 id="module-exports"><a href="#module-exports" class="headerlink" title="module  exports"></a>module  exports</h3><p><strong>模块规范</strong></p><ul><li><code>CommonJS</code>模块规范和<code>ES6</code>模块规范完全是两种不同的概念。</li><li><a class="link" href="http://javascript.ruanyifeng.com/nodejs/module.html">CommonJS规范<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" href="http://es6.ruanyifeng.com/#docs/module">ES6 Module 的语法<i class="fas fa-external-link-alt"></i></a></li></ul><p><strong>CommonJS</strong></p><ul><li><strong>Node</strong>应用由模块组成，采用CommonJS模块规范。</li><li>根据这个规范，每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。</li><li>CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。</li></ul><ul><li>下面代码通过module.exports输出变量x和函数addX。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> addX = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value + x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports.x = x;</span><br><span class="line"><span class="built_in">module</span>.exports.addX = addX;</span><br></pre></td></tr></table></figure><ul><li>require方法用于加载模块。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> example = <span class="built_in">require</span>(<span class="string">&#x27;./example.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(example.x); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(example.addX(<span class="number">1</span>)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><ul><li><strong>exports 与 module.exports</strong><ul><li>为了方便，Node为每个模块提供一个exports变量，指向module.exports。这等同在每个模块头部，有一行这样的命令。</li><li><code>var exports = module.exports;</code></li><li>于是我们可以直接在 exports 对象上添加方法，表示对外输出的接口，如同在module.exports 上添加一样。注意，不能直接将exports变量指向一个值，因为这样等于切断了exports与module.exports的联系。</li></ul></li></ul><p><strong>ES6</strong></p><ul><li>不同于CommonJS，ES6使用 export 和 import 来导出、导入模块。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// profile.js</span></span><br><span class="line"><span class="keyword">var</span> firstName = <span class="string">&#x27;Michael&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> lastName = <span class="string">&#x27;Jackson&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> year = <span class="number">1958</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;firstName, lastName, year&#125;;</span><br></pre></td></tr></table></figure><ul><li>需要特别注意的是，export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;m&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法三</span></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;n <span class="keyword">as</span> m&#125;;</span><br></pre></td></tr></table></figure><p><strong>export default</strong></p><ul><li>使用export default命令，为模块指定默认输出。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// export-default.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="crypto"><a href="#crypto" class="headerlink" title="crypto"></a>crypto</h3><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><h3 id="express"><a href="#express" class="headerlink" title="express"></a>express</h3><h1 id="多人实时聊天服务器"><a href="#多人实时聊天服务器" class="headerlink" title="多人实时聊天服务器"></a>多人实时聊天服务器</h1><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p><code>npm install socket.io --save</code>    </p><ul><li><p>网络上的程序实现双向的数据链接，这个链接的一端成为socket。</p><p> 1.Socket是一个持久链接。</p><p> 2.Socket是双向通信的。</p></li></ul><p><strong>Socket VS ajax轮询</strong></p><ul><li>ajax轮询 ， 是利用客户端来发送请求，每隔几秒发送一个http请求，服务器压力大。</li><li>Socket不会，一旦链接不会断开，可以实现实时通信。 比如微信的朋友圈更新提示。即时聊天通讯。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;h2 id=&quot;NPM&quot;&gt;&lt;a href=&quot;#NPM&quot; class=&quot;headerlink&quot; title=&quot;NPM&quot;&gt;&lt;/a&gt;NPM&lt;/h2&gt;&lt;u</summary>
      
    
    
    
    <category term="notebook" scheme="https://jieyang-wei.github.io/categories/notebook/"/>
    
    
    <category term="编程语言" scheme="https://jieyang-wei.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="nodejs" scheme="https://jieyang-wei.github.io/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>ruby</title>
    <link href="https://jieyang-wei.github.io/2020/12/17/ruby/"/>
    <id>https://jieyang-wei.github.io/2020/12/17/ruby/</id>
    <published>2020-12-17T02:12:34.000Z</published>
    <updated>2020-12-18T07:59:53.447Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Ruby是一种纯粹的面向对象编程语言。它由日本的松本行弘（まつもとゆきひろ/Yukihiro Matsumoto）创建于1993年。</p><p>您可以在 <a class="link" href="http://www.ruby-lang.org/">www.ruby-lang.org<i class="fas fa-external-link-alt"></i></a> 的 Ruby 邮件列表上找到松本行弘（まつもとゆきひろ/Yukihiro Matsumoto）的名字。在 Ruby 社区，松本也被称为马茨（Matz）。</p><p><strong>Ruby 是”程序员的最佳朋友”。</strong></p><p>Ruby 的特性与 Smalltalk、Perl 和 Python 类似。Perl、Python 和 Smalltalk 是脚本语言。Smalltalk 是一个真正的面向对象语言。Ruby，与 Smalltalk 一样，是一个完美的面向对象语言。使用 Ruby 的语法比使用 Smalltalk 的语法要容易得多。</p><p><strong>Ruby历史</strong></p><p>Ruby明显比其他类似的编程语言（如Perl或Python）年轻，又因为Ruby是日本人发明的，所以早期的非日文资料和程序都比较贫乏，所以在网上仍然可以找到类似“Ruby的资料太少”之类的批评。约于2000年，Ruby开始进入美国，英文的资料开始发展。Ruby归根结底源于Perl和Python两类语言，与C，C++，C#，java是不同大类。</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>Ruby 是开源的，在 Web 上免费提供，但需要一个许可证。</li><li>Ruby 是一种通用的、解释的编程语言。</li><li>Ruby 是一种真正的面向对象编程语言。</li><li>Ruby 是一种类似于 Python 和 Perl 的服务器端脚本语言。</li><li>Ruby 可以用来编写通用网关接口（CGI）脚本。</li><li>Ruby 可以被嵌入到超文本标记语言（HTML）。</li><li>Ruby 语法简单，这使得新的开发人员能够快速轻松地学习 Ruby。</li><li>Ruby 与 C++ 和 Perl 等许多编程语言有着类似的语法。</li><li>Ruby 可扩展性强，用 Ruby 编写的大程序易于维护。</li><li>Ruby 可用于开发的 Internet 和 Intranet 应用程序。</li><li>Ruby 可以安装在 Windows 和 POSIX 环境中。</li><li>Ruby 支持许多 GUI 工具，比如 Tcl/Tk、GTK 和 OpenGL。</li><li>Ruby 可以很容易地连接到 DB2、MySQL、Oracle 和 Sybase。</li><li>Ruby 有丰富的内置函数，可以直接在 Ruby 脚本中使用。</li></ul><p><strong>语言特点</strong></p><ul><li>完全面向对象<ul><li>在Ruby语言中，任何东西都是对象，包括其他语言中的基本数据类型，比如整数</li></ul></li><li>变量没有类型</li><li>Ruby的变量可以保存任何类型的数据。</li><li>任何东西都有值</li><li>不管是数学或者逻辑表达式还是一个语句，都会有值。</li><li>ruby语言很优雅，可以做到不需要注释就可以读懂。</li></ul><p>Ruby是动态语言，你可以在程序中修改先前定义过的类。 也可以在某个类的实例中定义该实例特有的方法，这叫做单例方法。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">the_method</span></span></span><br><span class="line">        <span class="string">&quot;generalmethod&quot;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">mc=MyClass.new</span><br><span class="line">def mc.the_method</span><br><span class="line">    <span class="string">&quot;special for this instance.&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><strong>Homebrew:</strong></p><ul><li><a class="link" href="https://brew.sh/index_zh-cn">官网链接<i class="fas fa-external-link-alt"></i></a></li><li>Homebrew是一款Mac OS平台下的软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能。简单的一条指令，就可以实现包管理，而不用你关心各种依赖和文件路径的情况，十分方便快捷。</li><li>援引<a class="link" href="https://link.jianshu.com/?t=http://brew.sh/">官方<i class="fas fa-external-link-alt"></i></a>的一句话：又提示缺少套件啦？别担心，Homebrew 随时守候。Homebrew —— OS X 不可或缺的套件管理器。</li></ul><ul><li>安装路径：<code>/usr/local/Homebrew</code></li><li>大部分情况下，它把软件包安装到 <code>/usr/local/Cellar/程序名/版本号</code>目录 下，然后在 <code>/usr/local/bin</code> 下建立符号链接，没有其他的操作了。</li></ul><ul><li><strong>指令</strong><ul><li>brew –version：查看版本</li><li>brew –repo：查看路径</li></ul></li></ul><p><strong>Ruby:</strong></p><ul><li><a class="link" href="http://www.ruby-lang.org/zh_cn/">官网链接<i class="fas fa-external-link-alt"></i></a></li><li>Ruby，一种简单快捷的面向对象（面向对象程序设计）脚本语言</li><li>Mac OS X 或 Linux，别在 Windows 上面搞，那是在浪费时间，两个原因：<ol><li>Ruby 对 Unix 环境的需求非常高，这点 Mac OS X 和 Linux 系列的系统才能很好的满足；</li><li>Ruby 在 Windows 环境下面执行效率低。</li></ol></li><li>CocoaPods是用Ruby构建的，它可以使用macOS上的默认Ruby进行安装。您可以使用Ruby版本管理器(RVM)，但建议使用macOS上提供的标准Ruby。</li></ul><hr><p><strong>注意：</strong>Mac OS X 或 Linux，别在 Windows 上面搞，那是在浪费时间，两个原因</p><ol><li>Ruby 对 Unix 环境的需求非常高，这点 Mac OS X 和 Linux 系列的系统才能很好的满足；</li><li>Ruby 在 Windows 环境下面执行效率低。</li></ol><hr><p><strong>RubyGem:</strong></p><ul><li><a class="link" href="https://www.runoob.com/ruby/ruby-rubygems.html">菜鸟教程<i class="fas fa-external-link-alt"></i></a></li><li>RubyGems 是 Ruby 的一个包管理器，它提供一个分发 Ruby 程序和库的标准格式，还提供一个管理程序包安装的工具。</li><li>RubyGems 旨在方便地管理 gem 安装的工具，以及用于分发 gem 的服务器。这类似于 Ubuntu 下的apt-get, Centos 的 yum，Python 的 pip。</li><li>RubyGems大约创建于2003年11月，从Ruby 1.9版起成为Ruby标准库的一部分。</li><li>Gem 是 Ruby 模块 (叫做 Gems) 的包管理器。其包含包信息，以及用于安装的文件。</li><li>Gem通常是依照”.gemspec”文件构建的，包含了有关Gem信息的YAML文件。Ruby代码也可以直接建立Gem，这种情况下通常利用Rake来进行。</li><li>gem命令用于构建、上传、下载以及安装Gem包。</li></ul><ul><li><strong>指令</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ruby -v          <span class="comment"># 查看安装版本</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rvm -v</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gem sources -l   <span class="comment"># 查看默认镜像源</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> uby的默认源使用的是cocoapods.org，国内访问这个网址有时候会有问题，网上的一种解决方案是将远替换成淘宝的，替换方式如下</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gem <span class="built_in">source</span> -r https://rubygems.org/               <span class="comment"># 移除次镜像源</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gem <span class="built_in">source</span> -a/--add https://gems.ruby-china.org   <span class="comment"># 添加新的镜像源</span></span></span><br></pre></td></tr></table></figure><img src="/2020/12/17/ruby/截屏2020-12-18 上午9.17.40.png" alt="截屏2020-12-18 上午9.17.40" style="zoom:50%;"><p><strong>RVM:</strong></p><ul><li><a class="link" href="https://rvm.io/">官网链接<i class="fas fa-external-link-alt"></i></a></li><li>(Ruby Version Manager)Ruby的版本管理工具。</li><li>RVM 是一个命令行工具，可以让你简单的管理多种版本的Ruby，并在这些版本中切换。</li><li><a class="link" href="https://www.jianshu.com/p/c44ef74d99f9">简书教程<i class="fas fa-external-link-alt"></i></a></li></ul><ul><li><strong>指令</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rvm install 版本      <span class="comment"># 安装指定版本</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rvm install ruby --head  <span class="comment"># 安装最新版本</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> RVM其他常用命令</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rvm info                   <span class="comment"># rvm信息</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rvm list known             <span class="comment"># 列出已知的ruby版本</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rvm list                   <span class="comment"># 查询已经安装的 ruby</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rvm use [版本号] --default  <span class="comment"># 配置ruby使用版本</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rvm get head               <span class="comment"># 升级</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rvm remove 版本号           <span class="comment"># 移除ruby版本</span></span></span><br></pre></td></tr></table></figure><h2 id="Linux-Unix"><a href="#Linux-Unix" class="headerlink" title="Linux / Unix"></a>Linux / Unix</h2><p><strong>Mac</strong></p><ul><li>默认情况下，mac系统已经安装了Ruby, 安装在 <code>/System/Library/Frameworks/Ruby.framework/Versions/Current </code> 目录下。</li><li>但是，由于默认的 Ruby 安装在 <code>/System</code> 目录下，过深的、与 *nix 约定不同的目录结构对日常的开发、维护都带来许多不便。</li></ul><p><strong>Linux/Unix</strong></p><p><a class="link" href="https://www.runoob.com/ruby/ruby-installation-unix.html">Linux/Unix 上的 Ruby 安装<i class="fas fa-external-link-alt"></i></a></p><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p><a class="link" href="https://www.runoob.com/ruby/ruby-installation-windows.html">Windows 上的 Ruby 安装<i class="fas fa-external-link-alt"></i></a></p><p><a class="link" href="https://www.runoob.com/ruby/ruby-command-line-options.html">Ruby 命令行选项<i class="fas fa-external-link-alt"></i></a></p><p><a class="link" href="https://www.runoob.com/ruby/ruby-environment-variables.html">Ruby 环境变量<i class="fas fa-external-link-alt"></i></a></p><ul><li>Ruby 解释器使用下列环境变量来控制它的行为。</li><li>ENV 对象包含了所有当前设置的环境变量列表。</li></ul><table><thead><tr><th align="left">变量</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><strong>DLN_LIBRARY_PATH</strong></td><td align="left">动态加载模块搜索的路径。</td></tr><tr><td align="left"><strong>HOME</strong></td><td align="left">当没有参数传递给 Dir::chdir 时，要移动到的目录。也用于 File::expand_path 来扩展 “~”。</td></tr><tr><td align="left"><strong>LOGDIR</strong></td><td align="left">当没有参数传递给 Dir::chdir 且未设置环境变量 HOME 时，要移动到的目录。</td></tr><tr><td align="left"><strong>PATH</strong></td><td align="left">执行子进程的搜索路径，以及在指定 -S 选项后，Ruby 程序的搜索路径。每个路径用冒号分隔（在 DOS 和 Windows 中用分号分隔）。</td></tr><tr><td align="left"><strong>RUBYLIB</strong></td><td align="left">库的搜索路径。每个路径用冒号分隔（在 DOS 和 Windows 中用分号分隔）。</td></tr><tr><td align="left"><strong>RUBYLIB_PREFIX</strong></td><td align="left">用于修改 RUBYLIB 搜索路径，通过使用格式 path1;path2 或 path1path2，把库的前缀 path1 替换为 path2。</td></tr><tr><td align="left"><strong>RUBYOPT</strong></td><td align="left">传给 Ruby 解释器的命令行选项。在 taint 模式时被忽略（其中，$SAFE 大于 0）。</td></tr><tr><td align="left"><strong>RUBYPATH</strong></td><td align="left">指定 -S 选项后，Ruby 程序的搜索路径。优先级高于 PATH。在 taint 模式时被忽略（其中，$SAFE 大于 0）。</td></tr><tr><td align="left"><strong>RUBYSHELL</strong></td><td align="left">指定执行命令时所使用的 shell。如果未设置该环境变量，则使用 SHELL 或 COMSPEC。</td></tr></tbody></table><h2 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h2><p>Ruby 不需要 IDE，一个简单的文本编辑器就足够了，作为 Ruby 开发者，这个必须习惯。</p><ul><li><p>Mac 平台</p><ul><li><a class="link" href="https://github.com/textmate/textmate/releases">TextMate 2<i class="fas fa-external-link-alt"></i></a></li></ul></li><li><p>Linux / Mac / Windows</p><ul><li><p><a class="link" href="https://code.visualstudio.com/">Visual Studio Code<i class="fas fa-external-link-alt"></i></a></p></li><li><p><a class="link" href="https://atom.io/">Atom<i class="fas fa-external-link-alt"></i></a></p></li><li><p><a class="link" href="http://www.vim.org/">Vim<i class="fas fa-external-link-alt"></i></a> 或 <a class="link" href="http://emacs.org/">Emacs<i class="fas fa-external-link-alt"></i></a></p></li><li><p>如果用 Vim 的话也可以尝试用 <a class="link" href="https://github.com/carlhuda/janus">janus<i class="fas fa-external-link-alt"></i></a></p></li><li><p>Vim 的 Rails 插件 <a class="link" href="http://www.vim.org/scripts/script.php?script_id=1567">rails.vim<i class="fas fa-external-link-alt"></i></a></p></li><li><p><strong><a class="link" href="http://www.sublimetext.com/">Sublime Text<i class="fas fa-external-link-alt"></i></a></strong></p><ul><li>Sublime文件默认存储编码为UTF8，我们几乎不用修改这个选项。</li><li>在按快捷键<code>Control + B</code>执行代码的时候，所有输出都会被Python（Sublime是用Python开发的）接收，然后输出到控制台，输出的字符串编码必须是UTF8编码。</li></ul></li></ul></li></ul><hr><p><strong>设置编译环境</strong></p><p>Tool -&gt; Build System</p><p><strong>编译</strong></p><p>Tool -&gt; build</p><hr><h1 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><strong>空白</strong></p><p><strong>行尾</strong></p><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><h3 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h3><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="语言标准"><a href="#语言标准" class="headerlink" title="语言标准"></a>语言标准</h3><ul><li><p>$ 开头的一定是全局变量</p></li><li><p>@ 开头的都是实例变量</p></li><li><p>@@ 开头的是类变量</p></li><li><p>常数则以大写字母开头</p><ul><li>这种方法，对文本编辑器的命令补全很有帮助，如在vim下先键入$及开头字母，再敲击Ctrl+p，则可专门补全本文件以及关联文件中的全局变量，perl与php亦有此优点。</li></ul></li><li><p>已经定义的类可以在运行时修改</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;Ruby是一种纯粹的面向对象编程语言。它由日本的松本行弘（まつもとゆきひろ/Yukihiro Matsumoto）创建于1993年。&lt;/p&gt;</summary>
      
    
    
    
    <category term="notebook" scheme="https://jieyang-wei.github.io/categories/notebook/"/>
    
    
    <category term="rugy" scheme="https://jieyang-wei.github.io/tags/rugy/"/>
    
    <category term="编程语言" scheme="https://jieyang-wei.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>编程语言学习</title>
    <link href="https://jieyang-wei.github.io/2020/12/16/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    <id>https://jieyang-wei.github.io/2020/12/16/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-12-16T08:18:33.000Z</published>
    <updated>2020-12-18T09:32:10.938Z</updated>
    
    <content type="html"><![CDATA[<p>最快掌握编程语言</p><ul><li>coder：<ul><li>图灵完备：相互之间可以替代的，c的能做，java也能，bat不是</li><li>标记语言，不是编程语言，没有逻辑</li></ul></li></ul><ol><li><p>语言背景</p></li><li><p>程序逻辑</p><ul><li>编程语言环境<ul><li>强类型：<ul><li>定义a = “string”，就知道a是一个字符串类型</li><li>Java，python</li></ul></li><li>弱类型：<ul><li>需要定义 String a = “String”，才知道类型，像C需要程序猿去判定类型</li><li>C，PHP，js</li></ul></li></ul></li></ul></li><li><p>变量</p><ul><li>变量定义<ul><li>动态类型<ul><li>js</li></ul></li><li>静态类型<ul><li>java</li></ul></li></ul></li><li>变量类型<ul><li>值类型（基本类型）<ul><li>变量在栈里面声明，</li><li>C，C++，引用类型通过指针来实现</li></ul></li><li>引用类型（封装类型）<ul><li>变量是指针，指向了内存地址中变量的地址</li><li>python，js</li></ul></li><li>java - 即保留值类型，也保留引用类型</li><li>应用在比较变量中，引用类型需要重写equal方法，不然比较的是地址</li></ul></li></ul></li><li><p>容器对象</p><ul><li>简单操作</li><li>浅复制，深复制、序列化</li></ul></li><li><p>类接口、抽象类</p></li><li><p>函数</p></li><li><p>生态、依赖</p><ul><li>框架，包管理工具</li></ul></li><li><p>高级特性</p><ul><li>java - 并发、高性能处理</li><li>是否支持携程</li></ul></li></ol><p>训练任务：</p><ol><li>支持消息循环的交互程序，一个文字版RPG小游戏</li><li>比较机械的控制，比如二进制位控制，</li></ol><p>【python game】</p><p>fixupdate</p><p>显卡不给力：一帧一帧的出来</p><p>update</p><p>window.setAnimation</p><p>2D技术跟3D完全不一样</p><p>3D - 显卡实时渲染</p><p>nodejs</p><p>ECMAScript，ES标准：</p><ul><li>最早浏览器支持的是ES2的标准</li></ul><p>WebKit</p><p>alert():bomapi</p><p>nodejs、unity这种是js运行的环境</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最快掌握编程语言&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;coder：&lt;ul&gt;
&lt;li&gt;图灵完备：相互之间可以替代的，c的能做，java也能，bat不是&lt;/li&gt;
&lt;li&gt;标记语言，不是编程语言，没有逻辑&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;语言背景&lt;/</summary>
      
    
    
    
    <category term="notebook" scheme="https://jieyang-wei.github.io/categories/notebook/"/>
    
    
    <category term="编程语言" scheme="https://jieyang-wei.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>python</title>
    <link href="https://jieyang-wei.github.io/2020/12/15/python/"/>
    <id>https://jieyang-wei.github.io/2020/12/15/python/</id>
    <published>2020-12-15T06:32:10.000Z</published>
    <updated>2020-12-25T15:13:39.014Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a>Anaconda</h1><ul><li><a class="link" href="https://www.jianshu.com/p/62f155eb6ac5">Anaconda部分原博客<i class="fas fa-external-link-alt"></i></a></li><li>Anaconda（<a class="link" href="https://link.jianshu.com/?t=https://www.anaconda.com/download/%23macos">官方网站<i class="fas fa-external-link-alt"></i></a>）就是可以便捷获取包且对包能够进行管理，同时对环境可以统一管理的发行版本。</li><li>Anaconda包含了conda、Python在内的超过180个科学包及其依赖项。</li><li>其特点的实现是因为包含：<ul><li> conda包</li><li>环境管理器</li><li>1000+开源库</li></ul></li></ul><p>特点：</p><ul><li>开源</li><li>安装过程简单</li><li>高性能使用python和R语言</li><li>免费的社区支持</li></ul><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><h3 id="1-Anaconda"><a href="#1-Anaconda" class="headerlink" title="1. Anaconda"></a>1. Anaconda</h3><ul><li>Anaconda是一个包含180+的科学包及其依赖项的发行版本。</li><li>其包含的科学包包括：<ul><li>conda, numpy, scipy, ipython notebook等。</li></ul></li></ul><h3 id="2-conda"><a href="#2-conda" class="headerlink" title="2. conda"></a>2. conda</h3><ul><li><p>conda是包及其依赖项和环境的管理工具。</p></li><li><p>适用语言：</p><ul><li>Python, R, Ruby, Lua, Scala, Java, JavaScript, C/C++, FORTRAN。</li></ul></li><li><p>适用平台：</p><ul><li>Windows, macOS, Linux</li></ul></li></ul><p><strong>用途</strong>：</p><ol><li>快速安装、运行和升级包及其依赖项。</li><li>在计算机中便捷地创建、保存、加载和切换环境。</li></ol><blockquote><p>如果你需要的包要求不同版本的Python，你无需切换到不同的环境，因为conda同样是一个环境管理器。仅需要几条命令，你可以创建一个完全独立的环境来运行不同的Python版本，同时继续在你常规的环境中使用你常用的Python版本。——<a class="link" href="https://link.jianshu.com/?t=https://conda.io/docs/">conda官方网站<i class="fas fa-external-link-alt"></i></a></p></blockquote><ul><li>onda为Python项目而创造，但可适用于上述的多种语言。</li><li>conda包和环境管理器包含于Anaconda的所有版本当中。</li></ul><h3 id="3-pip"><a href="#3-pip" class="headerlink" title="3. pip"></a>3. pip</h3><ul><li><p>pip是用于安装和管理软件包的包管理器。</p></li><li><p>pip编写语言：Python。</p></li><li><p>Python中默认安装的版本：</p><ul><li>Python 2.7.9及后续版本：默认安装，命令为<code>pip</code></li><li>Python 3.4及后续版本：默认安装，命令为<code>pip3</code></li></ul></li><li><p>pip名称的由来：pip采用的是<strong>递归缩写</strong>进行命名的。其名字被普遍认为来源于2处：</p><ul><li>“Pip installs Packages”（“pip安装包”）</li><li>“Pip installs Python”（“pip安装Python”）</li></ul></li></ul><h3 id="4-virtualenv"><a href="#4-virtualenv" class="headerlink" title="4.virtualenv"></a>4.virtualenv</h3><ul><li><p>virtualenv：用于创建一个<strong>独立的</strong>Python环境的工具。</p></li><li><p>解决问题：</p><ol><li>当一个程序需要使用Python 2.7版本，而另一个程序需要使用Python 3.6版本，如何同时使用这两个程序？</li><li>如果将所有程序都安装在系统下的默认路径，如：<code>/usr/lib/python2.7/site-packages</code>，当不小心升级了本不该升级的程序时，将会对其他的程序造成影响。</li><li>如果想要安装程序并在程序运行时对其库或库的版本进行修改，都会导致程序的中断。</li><li>在共享主机时，无法在全局<code>site-packages</code>目录中安装包。</li></ol></li><li><p>virtualenv将会为它自己的安装目录创建一个环境，这并<strong>不与</strong>其他virtualenv环境共享库；同时也可以<strong>选择性</strong>地不连接已安装的全局库。</p></li></ul><hr><p><strong>pip与conda比较</strong>：</p><ol><li><p><strong>依赖项检查</strong></p><ul><li>pip：<ul><li><strong>不一定</strong>会展示所需其他依赖包。</li><li>安装包时<strong>或许</strong>会直接忽略依赖项而安装，仅在结果中提示错误。</li></ul></li><li>conda：<ul><li>列出所需其他依赖包。</li><li>安装包时自动安装其依赖项。</li><li>可以便捷地在包的不同版本中自由切换。</li></ul></li></ul></li><li><p><strong>环境管理</strong></p><ul><li>pip：维护多个环境难度较大。</li><li>conda：比较方便地在不同环境之间进行切换，环境管理较为简单。</li></ul></li><li><p><strong>对系统自带Python的影响</strong></p><ul><li>pip：在系统自带Python中包的**更新/回退版本/卸载将影响其他程序。</li><li>conda：不会影响系统自带Python。</li></ul></li><li><p><strong>适用语言</strong></p><ul><li>pip：仅适用于Python。</li><li>conda：适用于Python, R, Ruby, Lua, Scala, Java, JavaScript, C/C++, FORTRAN。</li></ul></li></ol><p> <strong>conda与pip、virtualenv的关系</strong></p><ul><li>conda<strong>结合</strong>了pip和virtualenv的功能。</li></ul><hr><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>查看是否安装了python和anaconda：</p><img src="/2020/12/15/python/DF8274195F82F3A1713FE9FAB66C46B5.png" alt="DF8274195F82F3A1713FE9FAB66C46B5" style="zoom: 50%;">    <ol><li><p><code>$ conda list</code>：如果Anaconda被成功安装，则会显示已经安装的包名和版本号。</p></li><li><p><code>$ python</code>：进入python终端的命令行</p><ul><li>如果同时安装了Anaconda，则会显示上图红色的部分</li><li>exit() / quit()：退出</li></ul></li><li><p>终端输入<code>$ anaconda-navigator</code>将会打开anaconda-navigator图形界面</p></li></ol><p><strong>安装教程</strong>：自行百度，或者<a class="link" href="https://www.jianshu.com/p/62f155eb6ac5">原博客<i class="fas fa-external-link-alt"></i></a>有</p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="管理conda和环境"><a href="#管理conda和环境" class="headerlink" title="管理conda和环境"></a>管理conda和环境</h3><ul><li>验证conda已被安装</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda list              <span class="comment"># 显示已经安装的包名和版本号</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> conda --version         <span class="comment"># 查看conda版本号码</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> conda update conda      <span class="comment"># 更新conda至最新版本</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> conda --<span class="built_in">help</span>            <span class="comment"># 查看帮助信息</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rm -rf anaconda安装路径   <span class="comment"># 删除只需要删除安装目录即可（mac os）</span></span> </span><br></pre></td></tr></table></figure><p><strong>创建新环境</strong> </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda create --name &lt;env_name&gt; &lt;package_names&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;env_name&gt;</code>：即创建的环境名。建议以英文命名，且不加空格，名称两边不加尖括号“&lt;&gt;”。</li><li><code>&lt;package_names&gt;</code>：即安装在环境中的包名。名称两边不加尖括号“&lt;&gt;”。<ol><li>如果要安装指定的版本号，则只需要在包名后面以<code>=</code>和版本号的形式执行。如：<code>conda create --name python2 python=2.7</code>，即创建一个名为“python2”的环境，环境中安装版本为2.7的python。</li><li>如果要在新创建的环境中创建多个包，则直接在<code>&lt;package_names&gt;</code>后以<strong>空格</strong>隔开，添加多个包名即可。如：<code>conda create -n python3 python=3.5 numpy pandas</code>，即创建一个名为“python3”的环境，环境中安装版本为3.5的python，同时也安装了numpy和pandas。</li></ol></li><li>默认情况下，新创建的环境将会被保存在<code>/Users/&lt;user_name&gt;/anaconda3/env</code>目录下，其中，<code>&lt;user_name&gt;</code>为当前用户的用户名。</li></ul><p><strong>切换环境</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Linux 或macOS</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> activate &lt;env_name&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Windows</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> activate &lt;env_name&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>如果创建环境后安装Python时没有指定Python的版本，那么将会安装与Anaconda版本相同的Python版本，即如果安装Anaconda第2版，则会自动安装Python 2.x；如果安装Anaconda第3版，则会自动安装Python 3.x。</p></li><li><p>当成功切换环境之后，在该行行首将以“(env_name)”或“[env_name]”开头。其中，“env_name”为切换到的环境名。如：在macOS系统中执行<code>source active python2</code>，即切换至名为“python2”的环境，则行首将会以(python2)开头。</p></li></ul><p><strong>退出环境至root</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Linux 或macOS</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> deactivate</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Windows</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> deactivate</span></span><br></pre></td></tr></table></figure><ul><li>当执行退出当前环境，回到root环境命令后，原本行首以 “(env_name)” 或 “[env_name]” 开头的字符将不再显示。</li></ul><p><strong>显示已创建的环境</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda info -envs</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> conda info -e</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> conda env list</span></span><br></pre></td></tr></table></figure><img src="/2020/12/15/python/6349AECA-85FB-4EBA-82CE-CCBE8F84A59B.png" alt="6349AECA-85FB-4EBA-82CE-CCBE8F84A59B" style="zoom:50%;">    <ul><li>结果中星号<code>*</code>所在行即为当前所在环境。macOS系统中默认创建的环境名为<code>base</code>。</li></ul><p><strong>复制环境</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda create --name &lt;new_env_name&gt; --<span class="built_in">clone</span> &lt;copied_env_name&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;copied_env_name&gt;</code>即为被复制/克隆环境名。环境名两边不加尖括号“&lt;&gt;”</li><li><code>&lt;new_env_name&gt;</code>即为复制之后新环境的名称。环境名两边不加尖括号“&lt;&gt;”。<ul><li>如：<code>$ conda create --name py2 --clone python2</code>，即为克隆名为“python2”的环境，克隆后的新环境名为“py2”。此时，环境中将同时存在“python2”和“py2”环境，且两个环境的配置相同。</li></ul></li></ul><p><strong>删除环境</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda remove --name &lt;env_name&gt; --all</span></span><br></pre></td></tr></table></figure><p><strong>复制环境</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda create --name &lt;new_env_name&gt; --<span class="built_in">clone</span> &lt;copied_env_name&gt;</span></span><br></pre></td></tr></table></figure><h3 id="管理包"><a href="#管理包" class="headerlink" title="管理包"></a>管理包</h3><h4 id="1-查找可供安装的包版本"><a href="#1-查找可供安装的包版本" class="headerlink" title="1. 查找可供安装的包版本"></a>1. 查找可供安装的包版本</h4><ol><li>精确查找</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ conda search --full-name &lt;package_full_name&gt;</span><br></pre></td></tr></table></figure><ul><li><code>--full-name</code>：精确查找的参数。</li><li><code>&lt;package_full_name&gt;</code>：是被查找包的<strong>全名</strong>。包名两边不加尖括号“&lt;&gt;”。<ul><li>例如：<code>conda search --full-name python</code>即查找全名为“python”的包有哪些版本可供安装。</li></ul></li></ul><ol start="2"><li>模糊查找</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda search &lt;text&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;text&gt;</code>：查找含有<strong>此字段</strong>的包名。此字段两边不加尖括号“&lt;&gt;”。<ul><li>例如：<code>conda search py</code>即查找含有“py”字段的包，有哪些版本可供安装。</li></ul></li></ul><h4 id="2-获取当前环境中已安装的包信息"><a href="#2-获取当前环境中已安装的包信息" class="headerlink" title="2. 获取当前环境中已安装的包信息"></a>2. 获取当前环境中已安装的包信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda list</span></span><br></pre></td></tr></table></figure><ul><li>执行上述命令后将在终端显示当前环境已安装包的包名及其版本号。</li></ul><h4 id="3-安装包"><a href="#3-安装包" class="headerlink" title="3. 安装包"></a>3. 安装包</h4><ol><li><strong>在指定环境中安装包</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda install --name &lt;env_name&gt; &lt;package_name&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;env_name&gt;</code>：将包安装的指定环境名。环境名两边不加尖括号“&lt;&gt;”。</li><li><code>&lt;package_name&gt;</code>：要安装的包名。包名两边不加尖括号“&lt;&gt;”。<ul><li>例如：<code>conda install --name python2 pandas</code>即在名为“python2”的环境中安装pandas包。</li></ul></li></ul><ol start="2"><li><strong>在当前环境中安装包</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda install &lt;package_name&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;package_name&gt;</code>：要安装的包名。包名两边不加尖括号“&lt;&gt;”。</li><li>执行命令后在当前环境中安装包。<ul><li>例如：<code>conda install pandas</code>即在当前环境中安装pandas包。</li></ul></li></ul><ol start="3"><li><strong>使用pip安装包</strong></li></ol><p><strong>使用场景</strong>：</p><ul><li>当使用<code>conda install</code>无法进行安装时，可以使用pip进行安装。例如：see包。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> pip install &lt;package_name&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;pacage_name&gt;</code>：指定安装包的名称。包名两边不加尖括号“&lt;&gt;”。<ul><li>如：<code>pip install see</code>即安装see包。</li></ul></li></ul><p><strong>注意：</strong></p><ul><li>pip只是包管理器，无法对环境进行管理。因此如果想在指定环境中使用pip进行安装包，则需要先切换到指定环境中，再使用pip命令安装包。</li><li>pip无法更新python，因为pip并不将python视为包。</li><li>pip可以安装一些conda无法安装的包；conda也可以安装一些pip无法安装的包。因此当使用一种命令无法安装包时，可以尝试用另一种命令。</li></ul><ol start="4"><li><strong>从Anaconda.org安装包</strong></li></ol><p><strong>使用场景</strong></p><ul><li>当使用<code>conda install</code>无法进行安装时，可以考虑从Anaconda.org中获取安装包的命令，并进行安装。</li></ul><p><strong>注意</strong></p><ol><li>从Anaconda.org安装包时，无需注册。</li><li>在<strong>当前环境</strong>中安装来自于Anaconda.org的包时，需要通过输入要安装的包在Anaconda.org中的路径作为获取途径（channel）</li></ol><h4 id="4-卸载包"><a href="#4-卸载包" class="headerlink" title="4. 卸载包"></a>4. 卸载包</h4><ol><li>卸载指定环境中的包</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda remove --name &lt;env_name&gt; &lt;package_name&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;env_name&gt;</code>：卸载包所在指定环境的名称。环境名两边不加尖括号“&lt;&gt;”</li><li><code>&lt;package_name&gt;</code>：要卸载包的名称。包名两边不加尖括号“&lt;&gt;”。<ul><li>例如：<code>conda remove --name python2 pandas</code>即卸载名为“python2”中的pandas包。</li></ul></li></ul><ol start="2"><li>卸载当前环境中的包</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda remove &lt;package_name&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;package_name&gt;</code>：要卸载包的名称。包名两边不加尖括号“&lt;&gt;”。</li><li>执行命令后即在当前环境中卸载指定包。<ul><li>例如：<code>conda remove pandas</code>即在当前环境中卸载pandas包。</li></ul></li></ul><h4 id="5-更新包"><a href="#5-更新包" class="headerlink" title="5. 更新包"></a>5. 更新包</h4><ol><li>更新所有包</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda update --all</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> conda upgrade --all</span></span><br></pre></td></tr></table></figure><ul><li>建议：在安装Anaconda之后执行上述命令更新Anaconda中的所有包至最新版本，便于使用。</li></ul><ol start="2"><li>更新指定包</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda update &lt;package_name&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> conda upgrade &lt;package_name&gt;</span></span><br></pre></td></tr></table></figure><ul><li>注意：<ol><li><code>&lt;package_name&gt;</code>为指定更新的包名。包名两边不加尖括号“&lt;&gt;”。</li><li>更新多个指定包，则包名以<strong>空格</strong>隔开，向后排列。如：<code>conda update pandas numpy matplotlib</code>即更新pandas、numpy、matplotlib包。</li></ol></li></ul><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><p><a class="link" href="https://www.runoob.com/python/python-tutorial.html">菜鸟教程<i class="fas fa-external-link-alt"></i></a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>Python 是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言</li><li>Python 的设计具有很强的可读性，相比其他语言经常使用英文关键字，其他语言的一些标点符号，它具有比其他语言更有特色语法结构。<ul><li><strong>Python 是一种解释型语言：</strong>这意味着开发过程中没有了编译这个环节。类似于PHP和Perl语言。</li><li><strong>Python 是交互式语言：</strong>这意味着，您可以在一个 Python 提示符 <strong>&gt;&gt;&gt;</strong> 后直接执行代码。</li><li><strong>Python 是面向对象语言：</strong> 这意味着Python支持面向对象的风格或代码封装在对象的编程技术。</li><li><strong>Python 是初学者的语言：</strong>Python 对初级程序员而言，是一种伟大的语言，它支持广泛的应用程序开发，从简单的文字处理到 WWW 浏览器再到游戏。</li></ul></li></ul><p>特点：</p><ol><li><strong>易于学习：</strong>Python有相对较少的关键字，结构简单，和一个明确定义的语法，学习起来更加简单。</li><li><strong>易于阅读：</strong>Python代码定义的更清晰。</li><li><strong>易于维护：</strong>Python的成功在于它的源代码是相当容易维护的。</li><li><strong>一个广泛的标准库：</strong>Python的最大的优势之一是丰富的库，跨平台的，在UNIX，Windows和Macintosh兼容很好。</li><li><strong>互动模式：</strong>互动模式的支持，您可以从终端输入执行代码并获得结果的语言，互动的测试和调试代码片断。</li><li><strong>可移植：</strong>基于其开放源代码的特性，Python已经被移植（也就是使其工作）到许多平台。</li><li><strong>可扩展：</strong>如果你需要一段运行很快的关键代码，或者是想要编写一些不愿开放的算法，你可以使用C或C++完成那部分程序，然后从你的Python程序中调用。</li><li><strong>数据库：</strong>Python提供所有主要的商业数据库的接口。</li><li><strong>GUI编程：</strong>Python支持GUI可以创建和移植到许多系统调用。</li><li><strong>可嵌入：</strong>你可以将Python嵌入到C/C++程序，让你的程序的用户获得”脚本化”的能力。</li></ol><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><p>安装过程：自行百度云</p><p><strong>环境变量</strong></p><table><thead><tr><th>PYTHONPATH</th><th>PYTHONPATH是Python搜索路径，默认我们import的模块都会从PYTHONPATH里面寻找。</th></tr></thead><tbody><tr><td>PYTHONSTARTUP</td><td>Python启动后，先寻找PYTHONSTARTUP环境变量，然后执行此变量指定的文件中的代码。</td></tr><tr><td>PYTHONCASEOK</td><td>加入PYTHONCASEOK的环境变量, 就会使python导入模块的时候不区分大小写.</td></tr><tr><td>PYTHONHOME</td><td>另一种模块搜索路径。它通常内嵌于的PYTHONSTARTUP或PYTHONPATH目录中，使得两个模块库更容易切换。</td></tr></tbody></table><p><strong>集成开发环境（IDE, Integrated Development Environment）</strong>：PyCharm</p><ul><li>PyCharm 是由 JetBrains 打造的一款 Python IDE，支持 macOS、 Windows、 Linux 系统。</li><li>功能 : <ul><li>调试、语法高亮、Project管理、代码跳转、智能提示、自动完成、单元测试、版本控制……</li></ul></li><li><a class="link" href="https://www.jetbrains.com/pycharm/download/">下载地址<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" href="http://www.runoob.com/w3cnote/pycharm-windows-install.html](https://www.runoob.com/w3cnote/pycharm-windows-install.html)">安装地址<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="基础教程"><a href="#基础教程" class="headerlink" title="基础教程"></a>基础教程</h2><p><strong>中文编码</strong></p><img src="/2020/12/15/python/截屏2020-12-15 下午4.13.19.png" alt="截屏2020-12-15 下午4.13.19" style="zoom:60%;"><ul><li>python3.x源文件默认支持中文编码，无需制定</li><li>如果你使用编辑器，同时需要设置 py 文件存储的格式为 UTF-8，否则会出现错误信息<ul><li>进入 <strong>file &gt; Settings</strong>，在输入框搜索 <strong>encoding</strong>。</li><li>找到 <strong>Editor &gt; File encodings</strong>，将 <strong>IDE Encoding</strong> 和 <strong>Project Encoding</strong> 设置为utf-8。</li></ul></li></ul><h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> num     <span class="comment"># python2.x</span></span><br><span class="line"><span class="built_in">print</span> (num)   <span class="comment"># python3.x</span></span><br></pre></td></tr></table></figure><ul><li>默认换行输出，如果不需要换行，在末尾加入逗号<code>print x,</code>这样的话只会空格</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]: <span class="built_in">print</span> (x, end=<span class="string">&quot;。&quot;</span>)   <span class="comment"># 1。2。3。</span></span><br></pre></td></tr></table></figure><ul><li>指定以”。”为末尾输出，默认是”\n”换行</li></ul><p><strong>等待用户输入：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">str</span> = <span class="built_in">input</span>(<span class="string">&quot;\n\n按下 enter 键后退出。&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>两种输出值的方式：</strong></p><ol><li>表达式</li><li>print()</li><li>文件使用文件对象write()方法，标准输出文件可以用 sys.stdout 引用。</li></ol><ul><li>如果你希望输出的形式更加多样，可以使用 str.format() 函数来格式化输出值。</li><li>如果你希望将输出的值转成字符串，可以使用 repr() 或 str() 函数来实现。<ul><li><strong>str()：</strong> 函数返回一个用户易读的表达形式。 </li><li><strong>repr()：</strong> 产生一个解释器易读的表达形式。</li></ul></li></ul><p><strong>python2.x中使用python2.x的print函数</strong>：</p><ul><li><code>from __future__ import print_function</code></li><li>可以导入 <code>__future__</code>包，该包禁用 Python2.x 的 print 语句，采用 Python3.x 的 print 函数</li><li>Python3.x 与 Python2.x 的许多兼容性设计的功能可以通过  <code>__future__</code>这个包来导入</li></ul><p><strong>输出格式</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&quot;&#123;0:&lt;10&#125;&#123;1:&lt;10&#125;&#123;2:&gt;5&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&#x27;word&#x27;</span>, <span class="string">&#x27;len&#x27;</span>, <span class="string">&#x27;num&#x27;</span>))</span><br><span class="line"><span class="comment"># word      len         num</span></span><br></pre></td></tr></table></figure><ul><li>以标准格式输出</li></ul><h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h4><ul><li><p>标识符由字母、数字、下划线组成。</p></li><li><p>所有标识符可以包括英文、数字以及下划线(_)，但不能以数字开头。</p></li><li><p>Python 中的标识符是区分大小写的。</p></li><li><p>以<strong>下划线开头</strong>的标识符是有特殊意义的。</p><ul><li>以单下划线开头<code> _foo</code>的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用<code>from xxx import *</code>而导入。</li><li>以双下划线开头的<code>__foo</code>代表类的私有成员，以双下划线开头和结尾的 <code>__foo__</code>代表 Python 里特殊方法专用的标识<ul><li>如<code>__init__()</code>代表类的构造函数。</li></ul></li></ul></li><li><p>Python 可以同一行显示多条语句，方法是用分号 <strong>;</strong> 分开</p><ul><li><code>print (&#39;hello&#39;); print (&#39;world&#39;)</code></li></ul></li></ul><h4 id="保留字符"><a href="#保留字符" class="headerlink" title="保留字符"></a>保留字符</h4><ul><li>不能用作常数或变数，或任何其他标识符名称</li><li>所有 Python 的关键字只包含小写字母</li></ul><table><thead><tr><th>and</th><th>exec</th><th>not</th></tr></thead><tbody><tr><td>assert</td><td>finally</td><td>or</td></tr><tr><td>break</td><td>for</td><td>pass</td></tr><tr><td>class</td><td>from</td><td>print</td></tr><tr><td>continue</td><td>global</td><td>raise</td></tr><tr><td>def</td><td>if</td><td>return</td></tr><tr><td>del</td><td>import</td><td>try</td></tr><tr><td>elif</td><td>in</td><td>while</td></tr><tr><td>else</td><td>is</td><td>with</td></tr><tr><td>except</td><td>lambda</td><td>yield</td></tr></tbody></table><h4 id="行和缩进"><a href="#行和缩进" class="headerlink" title="行和缩进"></a>行和缩进</h4><ul><li>学习 Python 与其他语言最大的区别就是，Python 的代码块不使用大括号 <strong>{}</strong> 来控制类，函数以及其他逻辑判断。python 最具特色的就是用缩进来写模块。</li><li>缩进的空白数量是可变的，但是所有代码块语句必须包含相同的缩进空白数量，这个必须严格执行。<ul><li><img src="/2020/12/15/python/截屏2020-12-15 下午4.27.30.png" alt="截屏2020-12-15 下午4.27.30" style="zoom:50%;">    </li></ul></li></ul><p><strong>多行语句：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">total = item_one + \</span><br><span class="line">        item_two + \</span><br><span class="line">        item_three</span><br><span class="line"><span class="comment"># 和</span></span><br><span class="line">days = [<span class="string">&#x27;Monday&#x27;</span>, <span class="string">&#x27;Tuesday&#x27;</span>, <span class="string">&#x27;Wednesday&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Thursday&#x27;</span>, <span class="string">&#x27;Friday&#x27;</span>]</span><br></pre></td></tr></table></figure><p><strong>引号：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">word = <span class="string">&#x27;word&#x27;</span></span><br><span class="line">sentence = <span class="string">&quot;这是一个句子。&quot;</span></span><br><span class="line">paragraph = <span class="string">&quot;&quot;&quot;这是一个段落</span></span><br><span class="line"><span class="string">包含了多个语句&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">多行注释1</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">多行注释2</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><ul><li>三引号可以由多行组成，编写多行文本的快捷语法，常用于文档字符串，在文件的特定地点，被当做注释。</li></ul><p><strong>空行：</strong></p><ul><li>函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。</li><li>空行与代码缩进不同，空行并不是Python语法的一部分。书写时不插入空行，Python解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。</li><li>记住：空行也是程序代码的一部分。</li></ul><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><h4 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = b = c = <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>以上实例，创建一个整型对象，值为1，三个变量被分配到相同的内存空间上。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b, c = <span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;john&quot;</span></span><br></pre></td></tr></table></figure><ul><li>为多个对象指定多个变量</li></ul><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><ol><li><p>算术运算符</p><ul><li>a = 10，b = 21</li></ul><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">+</td><td align="left">加 - 两个对象相加</td><td align="left">a + b 输出结果 31</td></tr><tr><td align="left">-</td><td align="left">减 - 得到负数或是一个数减去另一个数</td><td align="left">a - b 输出结果 -11</td></tr><tr><td align="left">*</td><td align="left">乘 - 两个数相乘或是返回一个被重复若干次的字符串</td><td align="left">a * b 输出结果 210</td></tr><tr><td align="left">/</td><td align="left">除 - x 除以 y</td><td align="left">b / a 输出结果 2.1</td></tr><tr><td align="left">%</td><td align="left">取模 - 返回除法的余数</td><td align="left">b % a 输出结果 1</td></tr><tr><td align="left">**</td><td align="left">幂 - 返回x的y次幂</td><td align="left">a**b 为10的21次方</td></tr><tr><td align="left">//</td><td align="left">取整除 - 向下取接近商的整数</td><td align="left"><code>&gt;&gt;&gt; 9//2 4 &gt;&gt;&gt; -9//2 -5</code></td></tr></tbody></table></li><li><p>比较（关系）运算符</p><ul><li>a = 10，b = 20</li></ul><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">==</td><td align="left">等于 - 比较对象是否相等</td><td align="left">(a == b) 返回 False。</td></tr><tr><td align="left">!=</td><td align="left">不等于 - 比较两个对象是否不相等</td><td align="left">(a != b) 返回 True。</td></tr><tr><td align="left">&gt;</td><td align="left">大于 - 返回x是否大于y</td><td align="left">(a &gt; b) 返回 False。</td></tr><tr><td align="left">&lt;</td><td align="left">小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。注意，这些变量名的大写。</td><td align="left">(a &lt; b) 返回 True。</td></tr><tr><td align="left">&gt;=</td><td align="left">大于等于 - 返回x是否大于等于y。</td><td align="left">(a &gt;= b) 返回 False。</td></tr><tr><td align="left">&lt;=</td><td align="left">小于等于 - 返回x是否小于等于y。</td><td align="left">(a &lt;= b) 返回 True。</td></tr></tbody></table></li><li><p>赋值运算符</p><ul><li>a = 10，b = 20</li></ul><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">=</td><td align="left">简单的赋值运算符</td><td align="left">c = a + b 将 a + b 的运算结果赋值为 c</td></tr><tr><td align="left">+=</td><td align="left">加法赋值运算符</td><td align="left">c += a 等效于 c = c + a</td></tr><tr><td align="left">-=</td><td align="left">减法赋值运算符</td><td align="left">c -= a 等效于 c = c - a</td></tr><tr><td align="left">*=</td><td align="left">乘法赋值运算符</td><td align="left">c *= a 等效于 c = c * a</td></tr><tr><td align="left">/=</td><td align="left">除法赋值运算符</td><td align="left">c /= a 等效于 c = c / a</td></tr><tr><td align="left">%=</td><td align="left">取模赋值运算符</td><td align="left">c %= a 等效于 c = c % a</td></tr><tr><td align="left">**=</td><td align="left">幂赋值运算符</td><td align="left">c **= a 等效于 c = c ** a</td></tr><tr><td align="left">//=</td><td align="left">取整除赋值运算符</td><td align="left">c //= a 等效于 c = c // a</td></tr><tr><td align="left">:=</td><td align="left">海象运算符，可在表达式内部为变量赋值。<strong>Python3.8 版本新增运算符</strong>。</td><td align="left">在这个示例中，赋值表达式可以避免调用 len() 两次:<br><code>if (n := len(a)) &gt; 10:    print(f&quot;List is too long (&#123;n&#125; elements, expected &lt;= 10)&quot;)</code></td></tr></tbody></table></li><li><p>逻辑运算符</p><ul><li>a = 10，b = 20</li></ul><table><thead><tr><th align="left">运算符</th><th align="left">逻辑表达式</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">and</td><td align="left">x and y</td><td align="left">布尔”与” - 如果 x 为 False，x and y 返回 x 的值，否则返回 y 的计算值。</td><td align="left">(a and b) 返回 20。</td></tr><tr><td align="left">or</td><td align="left">x or y</td><td align="left">布尔”或” - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。</td><td align="left">(a or b) 返回 10。</td></tr><tr><td align="left">not</td><td align="left">not x</td><td align="left">布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。</td><td align="left">not(a and b) 返回 False</td></tr></tbody></table></li><li><p>位运算符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">60</span>     <span class="comment"># 0011 1100</span></span><br><span class="line">b = <span class="number">13</span>     <span class="comment"># 0000 1101</span></span><br><span class="line">-----------------</span><br><span class="line">a&amp;b = <span class="number">12</span>   <span class="comment"># 0000 1100   按位与</span></span><br><span class="line">a|b = <span class="number">61</span>   <span class="comment"># 0011 1101   按位或</span></span><br><span class="line">a^b = <span class="number">49</span>   <span class="comment"># 0011 0001   按位异或</span></span><br><span class="line">~a = -<span class="number">61</span>   <span class="comment"># 1100 0011   按位取反</span></span><br><span class="line">a&lt;&lt;<span class="number">2</span> = <span class="number">240</span> <span class="comment"># 1111 0000   左移</span></span><br><span class="line">a&gt;&gt;<span class="number">2</span> = <span class="number">15</span>  <span class="comment"># 0000 1111   右移</span></span><br></pre></td></tr></table></figure></li><li><p>成员运算符</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">in</td><td align="left">如果在指定的序列中找到值返回 True，否则返回 False。</td><td align="left">x 在 y 序列中 , 如果 x 在 y 序列中返回 True。</td></tr><tr><td align="left">not in</td><td align="left">如果在指定的序列中没有找到值返回 True，否则返回 False。</td><td align="left">x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。</td></tr></tbody></table></li><li><p>身份运算符</p><ul><li>比较两个对象的存储单元</li><li><code>id()</code>：获取对象内存地址。</li><li>is和==<ul><li>is 用于判断两个变量引用对象是否为同一个</li><li> == 用于判断引用变量的值是否相等。</li></ul></li></ul><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">is</td><td align="left">is 是判断两个标识符是不是引用自一个对象</td><td align="left"><strong>x is y</strong>, 类似 <strong>id(x) == id(y)</strong> , 如果引用的是同一个对象则返回 True，否则返回 False</td></tr><tr><td align="left">is  not</td><td align="left">is not 是判断两个标识符是不是引用自不同对象</td><td align="left"><strong>x is not y</strong> ， 类似 **id(a) != id(b)**。如果引用的不是同一个对象则返回结果 True，否则返回 False。</td></tr></tbody></table></li><li><p>运算符优先级</p></li></ol><h4 id="标准数据类型"><a href="#标准数据类型" class="headerlink" title="标准数据类型"></a>标准数据类型</h4><ul><li>不可变数据：Number（数字）、String（字符串）、Tuple（元组）；<ul><li>变量赋值 <strong>a=5</strong> 后再赋值 <strong>a=10</strong>，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变 a 的值，相当于新生成了 a。</li></ul></li><li>可变数据：List（列表）、Dictionary（字典）、Set（集合）。<ul><li>变量赋值 <strong>la=[1,2,3,4]</strong> 后再赋值 <strong>la[2]=5</strong> 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。</li></ul></li></ul><h5 id="Numbers（数字）"><a href="#Numbers（数字）" class="headerlink" title="Numbers（数字）"></a>Numbers（数字）</h5><ul><li><p>数字数据类型用于存储数值。</p></li><li><p>他们是<strong>不可改变</strong>的数据类型，这意味着改变数字数据类型会分配一个新的对象。</p></li><li><p>当你指定一个值时，Number 对象就会被创建：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var1 = <span class="number">1</span></span><br><span class="line">var2 = <span class="number">10</span></span><br></pre></td></tr></table></figure><p><strong>删除</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> var1[,var2,[var3[..., varN]]]</span><br><span class="line"><span class="keyword">del</span> var</span><br><span class="line"><span class="keyword">del</span> var_a, var_b</span><br></pre></td></tr></table></figure><p><strong>数字类型</strong>：</p><ul><li>查询变量所指的对象类型<ul><li>内置的<code>type（）</code>函数：不会认为子类是一种父类类型</li><li><code>isinstance（）</code>：会认为子类是一种父类类型</li></ul></li></ul><table><thead><tr><th align="left">int</th><th align="left">long</th><th align="left">float</th><th align="left">complex</th></tr></thead><tbody><tr><td align="left">10</td><td align="left">51924361L</td><td align="left">0.0</td><td align="left">3.14j</td></tr><tr><td align="left">100</td><td align="left">-0x19323L</td><td align="left">15.20</td><td align="left">45.j</td></tr><tr><td align="left">-786</td><td align="left">0122L</td><td align="left">-21.9</td><td align="left">9.322e-36j</td></tr><tr><td align="left">080</td><td align="left">0xDEFABCECBDAECBFBAEl</td><td align="left">32.3e+18</td><td align="left">.876j</td></tr><tr><td align="left">-0490</td><td align="left">535633629843L</td><td align="left">-90.</td><td align="left">-.6545+0J</td></tr><tr><td align="left">-0x260</td><td align="left">-052318172735L</td><td align="left">-32.54e100</td><td align="left">3e+26J</td></tr><tr><td align="left">0x69</td><td align="left">-4721885298529L</td><td align="left">70.2E-12</td><td align="left">4.53e-7j</td></tr></tbody></table><ul><li><p>int（有符号整型）：通常被称为是整型或整数，是正或负整数，不带小数点</p></li><li><p>long（长整数）</p><ul><li><p>长整型也可以使用小写 l，但是还是建议您使用大写 L，避免与数字 1 混淆。Python使用 L 来显示长整型。</p><blockquote><p>long 类型只存在于 Python2.X 版本中，在 2.2 以后的版本中，int 类型数据溢出后会自动转为long类型。在 Python3.X 版本中 long 类型被移除，使用 int 替代。</p></blockquote></li></ul></li><li><p>float（浮点数）： 浮点型由整数部分与小数部分组成，浮点型也可以使用科学计数法表示（2.5e2 = 2.5 x 102 = 250）</p></li><li><p>bool（布尔值）</p><ul><li><blockquote><p>python2中没有这个数据类型</p></blockquote></li></ul></li><li><p>complex（复数）</p><ul><li>复数由实数部分和虚数部分构成，可以用 a + bj,或者 complex(a,b) 表示</li><li>复数的实部 a 和虚部 b 都是浮点型。</li></ul></li></ul><p><strong>运算：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> / <span class="number">4</span>    <span class="comment"># 除法，得到一个浮点数</span></span><br><span class="line"><span class="number">2</span> // <span class="number">4</span>   <span class="comment"># 除法，得到一个整数，但不一定是int类型的整数，可能是 1.0</span></span><br><span class="line"><span class="number">17</span> % <span class="number">3</span>   <span class="comment"># 取余</span></span><br><span class="line"><span class="number">2</span> ** <span class="number">5</span>   <span class="comment"># 乘方，得到32</span></span><br></pre></td></tr></table></figure><h5 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;hello world&quot;</span></span><br><span class="line">s[<span class="number">0</span>] = <span class="string">&#x27;1&#x27;</span>   <span class="comment"># 会报错</span></span><br></pre></td></tr></table></figure><p><strong>下标索引</strong></p><img src="/2020/12/15/python/截屏2020-12-15 下午6.08.56.png" alt="截屏2020-12-15 下午6.08.56" style="zoom:33%;"><ul><li>左往右：0开始，右往左：-1开始</li></ul><blockquote><p>在Python2中，普通字符串是以8位ASCII码进行存储的，而Unicode字符串则存储为16位unicode字符串，这样能够表示更多的字符集。使用的语法是在字符串前面加上前缀 <strong>u</strong>。</p><p>在Python3中，所有的字符串都是Unicode字符串</p></blockquote><p><strong>字符串操作</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&#x27;abcdef&#x27;</span></span><br><span class="line"><span class="built_in">print</span> (s[<span class="number">1</span>:<span class="number">5</span>])    <span class="comment"># bcde</span></span><br><span class="line"><span class="built_in">print</span> (s[<span class="number">1</span>:<span class="number">5</span>:<span class="number">2</span>])  <span class="comment"># bd</span></span><br><span class="line"><span class="built_in">print</span> (s * <span class="number">2</span>)     <span class="comment"># abcdefabcdef</span></span><br><span class="line"><span class="built_in">print</span> (s[:<span class="number">2</span>] + <span class="string">&#x27;11&#x27;</span>)  <span class="comment"># ab11</span></span><br></pre></td></tr></table></figure><ul><li>使用<code>[头下标:尾下标:步长]</code>来截取字符串，在头下标-尾下标的范围内以步长来截取字符</li><li><strong>注意</strong>：所有的截取都取不到尾下标</li></ul><p><strong>原始字符串：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">r&#x27;\n&#x27;</span>)    <span class="comment"># \n，不会进行换行，而是直接输出</span></span><br></pre></td></tr></table></figure><ul><li>所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。</li><li> 原始字符串除在字符串的第一个引号前加上字母 <strong>r/R</strong>以外，与普通字符串有着几乎完全相同的语法。</li></ul><p><strong>字符串格式化：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> (<span class="string">&quot;我叫 %s 今年 %d 岁!&quot;</span> % (<span class="string">&#x27;小明&#x27;</span>, <span class="number">10</span>))</span><br><span class="line"><span class="comment"># 我叫 小明 今年 10 岁!</span></span><br></pre></td></tr></table></figure><ul><li><p>使用与 C 中 sprintf 函数一样的语法。</p><blockquote><p>Python2.6 开始，新增了一种格式化字符串的函数 str.format()，它增强了字符串格式化的功能。</p></blockquote></li></ul><p><strong>f-string：</strong></p><ul><li>之后版本添加的，称之为字面量格式化字符串，是新的格式化字符串的语法。</li><li>不用再去判断使用 %s，还是 %d。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#### 以前 ###</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">&#x27;world&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;Hello %s&#x27;</span> % name</span><br><span class="line"><span class="string">&#x27;Hello world&#x27;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">#### 现在 ###</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">&#x27;world&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f&#x27;Hello <span class="subst">&#123;name&#125;</span>&#x27;</span>  <span class="comment"># 替换变量</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f&#x27;<span class="subst">&#123;<span class="number">1</span>+<span class="number">2</span>&#125;</span>&#x27;</span>         <span class="comment"># 使用表达式</span></span><br><span class="line"><span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>w = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;url&#x27;</span>: <span class="string">&#x27;www.runoob.com&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f&#x27;<span class="subst">&#123;w[<span class="string">&quot;name&quot;</span>]&#125;</span>: <span class="subst">&#123;w[<span class="string">&quot;url&quot;</span>]&#125;</span>&#x27;</span></span><br><span class="line"><span class="string">&#x27;Runoob: www.runoob.com&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">f&#x27;<span class="subst">&#123;x+<span class="number">1</span>&#125;</span>&#x27;</span>)   <span class="comment"># Python 3.6</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">f&#x27;<span class="subst">&#123;x+<span class="number">1</span>=&#125;</span>&#x27;</span>)  <span class="comment"># Python 3.8</span></span><br><span class="line"><span class="string">&#x27;x+1=2&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>内建函数：</strong></p><ul><li><p>列表 = 字符串.split(“str”)</p></li><li><p>capitalize()</p><ul><li>将字符串的第一个字符转换为大写</li></ul></li><li><p>center(width, fillchar)</p><ul><li>返回一个指定的宽度 width 居中的字符串，fillchar 为填充的字符，默认为空格。</li></ul></li><li><p>count(str, beg= 0,end=len(string))</p><ul><li>返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数</li></ul></li><li><p>bytes.decode(encoding=”utf-8”, errors=”strict”)</p><blockquote><p>Python3 中没有 decode 方法，但我们可以使用 bytes 对象的 decode() 方法来解码给定的 bytes 对象，这个 bytes 对象可以由 str.encode() 来编码返回。</p></blockquote></li><li><p>encode(encoding=’UTF-8’,errors=’strict’)</p><ul><li>以 encoding 指定的编码格式编码字符串，如果出错默认报一个ValueError 的异常，除非 errors 指定的是’ignore’或者’replace’</li></ul></li><li><p>endswith(suffix, beg=0, end=len(string))</p><ul><li>检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False.</li></ul></li><li><p>expandtabs(tabsize=8)</p><ul><li>把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8 。<br>8    </li></ul></li><li><p>find(str, beg=0, end=len(string))</p><ul><li>检测 str 是否包含在字符串中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1</li></ul></li><li><p>index(str, beg=0, end=len(string))</p><ul><li>跟find()方法一样，只不过如果str不在字符串中会报一个异常。</li></ul></li><li><p>isalnum()</p><ul><li>如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 True，否则返回 False</li></ul></li><li><p>isalpha()</p><ul><li>如果字符串至少有一个字符并且所有字符都是字母或中文字则返回 True, 否则返回 False</li></ul></li><li><p>isdigit()</p><ul><li>如果字符串只包含数字则返回 True 否则返回 False..</li></ul></li><li><p>islower()</p><ul><li>如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False</li></ul></li><li><p>isnumeric()</p><ul><li>如果字符串中只包含数字字符，则返回 True，否则返回 False</li></ul></li><li><p>isspace()</p><ul><li>如果字符串中只包含空白，则返回 True，否则返回 False.</li></ul></li><li><p>istitle()</p><ul><li>如果字符串是标题化的(见 title())则返回 True，否则返回 False</li></ul></li><li><p>isupper()</p><ul><li>如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False</li></ul></li><li><p>‘char’.join(seq)</p><ul><li>以指定字符串作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串</li></ul></li><li><p>len(string)</p><ul><li>返回字符串长度</li></ul></li><li><p>ljust(width[, fillchar])</p><ul><li>返回一个原字符串左对齐,并使用 fillchar 填充至长度 width 的新字符串，fillchar 默认为空格。</li></ul></li><li><p>lower()</p><ul><li>转换字符串中所有大写字符为小写.</li></ul></li><li><p>lstrip()</p><ul><li>截掉字符串左边的空格或指定字符。</li></ul></li><li><p>maketrans()</p><ul><li>创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目</li></ul></li><li><p>max(str)</p><ul><li>返回字符串 str 中最大的字母。</li></ul></li><li><p>min(str)</p><ul><li>返回字符串 str 中最小的字母。</li></ul></li><li><p>replace(old, new [, max])</p><ul><li>把将字符串中的 old 替换成 new,如果 max 指定，则替换不超过 max 次。</li></ul><blockquote><p><strong>注意：</strong>replace函数将会返回一个新的字符串，原来的字符串不会改变</p><p>需要使用：<code>str = str.replace(old, new)</code></p></blockquote></li><li><p>rfind(str, beg=0,end=len(string))</p><ul><li>类似于 find()函数，不过是从右边开始查找.</li></ul></li><li><p>rindex( str, beg=0, end=len(string))</p><ul><li>类似于 index()，不过是从右边开始.</li></ul></li><li><p>rjust(width,[, fillchar])</p><ul><li>返回一个原字符串右对齐,并使用fillchar(默认空格）填充至长度 width 的新字符串</li></ul></li><li><p>rstrip()</p><ul><li>删除字符串字符串末尾的空格.</li></ul></li><li><p>split(str=””, num=string.count(str))</p><ul><li>以 str 为分隔符截取字符串，如果 num 有指定值，则仅截取 num+1 个子字符串</li></ul></li><li><p>splitlines([keepends])</p><ul><li>按照行(‘\r’, ‘\r\n’, \n’)分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。</li></ul></li><li><p>startswith(substr, beg=0,end=len(string))</p><ul><li>检查字符串是否是以指定子字符串 substr 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查。</li></ul></li><li><p>strip([chars])</p><ul><li>在字符串上执行 lstrip()和 rstrip()</li></ul></li><li><p>swapcase()</p><ul><li>将字符串中大写转换为小写，小写转换为大写</li></ul></li><li><p>title()</p><ul><li>返回”标题化”的字符串,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle())</li></ul></li><li><p>translate(table, deletechars=””)</p><ul><li>根据 str 给出的表(包含 256 个字符)转换 string 的字符, 要过滤掉的字符放到 deletechars 参数中</li></ul></li><li><p>upper()</p><ul><li>转换字符串中的小写字母为大写</li></ul></li><li><p>zfill (width)</p><ul><li>返回长度为 width 的字符串，原字符串右对齐，前面填充0</li></ul></li><li><p>isdecimal()</p><ul><li>检查字符串是否只包含十进制字符，如果是返回 true，否则返回 false。</li></ul></li></ul><table><thead><tr><th align="left">序号</th><th align="left">方法及描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-capitalize.html">capitalize()<i class="fas fa-external-link-alt"></i></a> <br>将字符串的第一个字符转换为大写</td></tr><tr><td align="left">2</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-center.html">center(width, fillchar)<i class="fas fa-external-link-alt"></i></a> <br>返回一个指定的宽度 width 居中的字符串，fillchar 为填充的字符，默认为空格。</td></tr><tr><td align="left">3</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-count.html">count(str, beg= 0,end=len(string))<i class="fas fa-external-link-alt"></i></a> <br>返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数</td></tr><tr><td align="left">4</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-decode.html">bytes.decode(encoding=”utf-8”, errors=”strict”)<i class="fas fa-external-link-alt"></i></a><br> Python3 中没有 decode 方法，但我们可以使用 bytes 对象的 decode() 方法来解码给定的 bytes 对象，这个 bytes 对象可以由 str.encode() 来编码返回。</td></tr><tr><td align="left">5</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-encode.html">encode(encoding=’UTF-8’,errors=’strict’)<i class="fas fa-external-link-alt"></i></a> <br>以 encoding 指定的编码格式编码字符串，如果出错默认报一个ValueError 的异常，除非 errors 指定的是’ignore’或者’replace’</td></tr><tr><td align="left">6</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-endswith.html">endswith(suffix, beg=0, end=len(string))<i class="fas fa-external-link-alt"></i></a> <br>检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False.</td></tr><tr><td align="left">7</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-expandtabs.html">expandtabs(tabsize=8)<i class="fas fa-external-link-alt"></i></a> <br>把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8 。</td></tr><tr><td align="left">8</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-find.html">find(str, beg=0, end=len(string))<i class="fas fa-external-link-alt"></i></a> <br>检测 str 是否包含在字符串中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1</td></tr><tr><td align="left">9</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-index.html">index(str, beg=0, end=len(string))<i class="fas fa-external-link-alt"></i></a> <br>跟find()方法一样，只不过如果str不在字符串中会报一个异常。</td></tr><tr><td align="left">10</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-isalnum.html">isalnum()<i class="fas fa-external-link-alt"></i></a> <br>如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 True，否则返回 False</td></tr><tr><td align="left">11</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-isalpha.html">isalpha()<i class="fas fa-external-link-alt"></i></a> <br>如果字符串至少有一个字符并且所有字符都是字母或中文字则返回 True, 否则返回 False</td></tr><tr><td align="left">12</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-isdigit.html">isdigit()<i class="fas fa-external-link-alt"></i></a> <br>如果字符串只包含数字则返回 True 否则返回 False..</td></tr><tr><td align="left">13</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-islower.html">islower()<i class="fas fa-external-link-alt"></i></a> <br>如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False</td></tr><tr><td align="left">14</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-isnumeric.html">isnumeric()<i class="fas fa-external-link-alt"></i></a> <br>如果字符串中只包含数字字符，则返回 True，否则返回 False</td></tr><tr><td align="left">15</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-isspace.html">isspace()<i class="fas fa-external-link-alt"></i></a> <br>如果字符串中只包含空白，则返回 True，否则返回 False.</td></tr><tr><td align="left">16</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-istitle.html">istitle()<i class="fas fa-external-link-alt"></i></a> <br>如果字符串是标题化的(见 title())则返回 True，否则返回 False</td></tr><tr><td align="left">17</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-isupper.html">isupper()<i class="fas fa-external-link-alt"></i></a><br>如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False</td></tr><tr><td align="left">18</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-join.html">join(seq)<i class="fas fa-external-link-alt"></i></a> <br>以指定字符串作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串</td></tr><tr><td align="left">19</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-len.html">len(string)<i class="fas fa-external-link-alt"></i></a> <br>返回字符串长度</td></tr><tr><td align="left">20</td><td align="left">ljust(width[, fillchar]) <br>返回一个原字符串左对齐,并使用 fillchar 填充至长度 width 的新字符串，fillchar 默认为空格。</td></tr><tr><td align="left">21</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-lower.html">lower()<i class="fas fa-external-link-alt"></i></a> <br>转换字符串中所有大写字符为小写.</td></tr><tr><td align="left">22</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-lstrip.html">lstrip()<i class="fas fa-external-link-alt"></i></a> <br>截掉字符串左边的空格或指定字符。</td></tr><tr><td align="left">23</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-maketrans.html">maketrans()<i class="fas fa-external-link-alt"></i></a><br> 创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。</td></tr><tr><td align="left">24</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-max.html">max(str)<i class="fas fa-external-link-alt"></i></a> <br>返回字符串 str 中最大的字母。</td></tr><tr><td align="left">25</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-min.html">min(str)<i class="fas fa-external-link-alt"></i></a> <br>返回字符串 str 中最小的字母。</td></tr><tr><td align="left">26</td><td align="left">[replace(old, new [, max])] <br>把 将字符串中的 old 替换成 new,如果 max 指定，则替换不超过 max 次。</td></tr><tr><td align="left">27</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-rfind.html">rfind(str, beg=0,end=len(string))<i class="fas fa-external-link-alt"></i></a> <br>类似于 find()函数，不过是从右边开始查找.</td></tr><tr><td align="left">28</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-rindex.html">rindex( str, beg=0, end=len(string))<i class="fas fa-external-link-alt"></i></a> <br>类似于 index()，不过是从右边开始.</td></tr><tr><td align="left">29</td><td align="left">rjust(width,[, fillchar])<br>返回一个原字符串右对齐,并使用fillchar(默认空格）填充至长度 width 的新字符串</td></tr><tr><td align="left">30</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-rstrip.html">rstrip()<i class="fas fa-external-link-alt"></i></a> <br>删除字符串字符串末尾的空格.</td></tr><tr><td align="left">31</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-split.html">split(str=””, num=string.count(str))<i class="fas fa-external-link-alt"></i></a> <br>以 str 为分隔符截取字符串，如果 num 有指定值，则仅截取 num+1 个子字符串</td></tr><tr><td align="left">32</td><td align="left">splitlines([keepends]) <br>按照行(‘\r’, ‘\r\n’, \n’)分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。</td></tr><tr><td align="left">33</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-startswith.html">startswith(substr, beg=0,end=len(string))<i class="fas fa-external-link-alt"></i></a> <br>检查字符串是否是以指定子字符串 substr 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查。</td></tr><tr><td align="left">34</td><td align="left">strip([chars])<br>在字符串上执行 lstrip()和 rstrip()</td></tr><tr><td align="left">35</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-swapcase.html">swapcase()<i class="fas fa-external-link-alt"></i></a> <br>将字符串中大写转换为小写，小写转换为大写</td></tr><tr><td align="left">36</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-title.html">title()<i class="fas fa-external-link-alt"></i></a> <br>返回”标题化”的字符串,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle())</td></tr><tr><td align="left">37</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-translate.html">translate(table, deletechars=””)<i class="fas fa-external-link-alt"></i></a> <br>根据 str 给出的表(包含 256 个字符)转换 string 的字符, 要过滤掉的字符放到 deletechars 参数中</td></tr><tr><td align="left">38</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-upper.html">upper()<i class="fas fa-external-link-alt"></i></a> <br>转换字符串中的小写字母为大写</td></tr><tr><td align="left">39</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-zfill.html">zfill (width)<i class="fas fa-external-link-alt"></i></a> <br>返回长度为 width 的字符串，原字符串右对齐，前面填充0</td></tr><tr><td align="left">40</td><td align="left"><a class="link" href="https://www.runoob.com/python3/python3-string-isdecimal.html">isdecimal()<i class="fas fa-external-link-alt"></i></a> <br>检查字符串是否只包含十进制字符，如果是返回 true，否则返回 false。</td></tr></tbody></table><h5 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h5><ul><li>通用符合数据类型，用[标识]</li><li>有序集合</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">0</span>, <span class="number">1</span>, <span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;def&#x27;</span>, <span class="number">4</span> ]</span><br><span class="line">y = [<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> (x[<span class="number">2</span>:<span class="number">4</span>])   <span class="comment"># [&#x27;abc&#x27;, &#x27;def&#x27;]</span></span><br><span class="line"><span class="built_in">print</span> (x * <span class="number">2</span>)    <span class="comment"># [0, 1, &#x27;abc&#x27;, &#x27;def&#x27;, 4, 0, 1, &#x27;abc&#x27;, &#x27;def&#x27;, 4]</span></span><br><span class="line"><span class="built_in">print</span> (x + y)    <span class="comment"># [0, 1, &#x27;abc&#x27;, &#x27;def&#x27;, 4, &#x27;b&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> x[<span class="number">1</span>]         <span class="comment"># 使用del删除列表元素</span></span><br><span class="line"><span class="built_in">print</span> (x)        <span class="comment"># [0, &#x27;abc&#x27;, &#x27;def&#x27;, 4 ]</span></span><br></pre></td></tr></table></figure><p><strong>迭代</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> a: print(x, end=<span class="string">&quot;。&quot;</span>)</span><br><span class="line"><span class="comment"># 1。2。3。      迭代列表a，每个元素后面跟&quot;。&quot;</span></span><br></pre></td></tr></table></figure><p><strong>内置函数：</strong></p><ul><li><p>字符串 = ‘char’.join(列表)</p></li><li><p>len(list)</p><ul><li>列表元素个数</li></ul></li><li><p>max(list)</p><ul><li>返回列表元素最大值</li></ul></li><li><p>min(list)</p><ul><li>返回列表元素最小值</li></ul></li><li><p>list(seq\string\dict.items()…)</p><ul><li>将元组、字符串、字典元素等转换为列表</li></ul><blockquote><p><code>list(dictionary)</code>将会得到一个元素为元组的列表，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;disList = <span class="built_in">list</span>(dic)</span><br><span class="line">&gt;<span class="comment"># [(key0, value0), (key1, value1), (key2, value2), ...]</span></span><br><span class="line">&gt;disList[<span class="number">1</span>] <span class="comment"># (key1, value1)</span></span><br><span class="line">&gt;disList[<span class="number">1</span>][<span class="number">0</span>] <span class="comment"># key1</span></span><br><span class="line">&gt;disList[<span class="number">1</span>][<span class="number">1</span>] <span class="comment"># value1</span></span><br></pre></td></tr></table></figure></blockquote></li></ul><p><strong>方法</strong></p><ul><li>list.append(obj)<ul><li>在列表末尾添加新的对象</li></ul></li><li>list.count(obj)<ul><li>统计某个元素在列表中出现的次数</li></ul></li><li>list.extend(seq)<ul><li>在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</li></ul></li><li>list.index(obj)<ul><li>从列表中找出某个值第一个匹配项的索引位置</li></ul></li><li>list.insert(index, obj)<ul><li>将对象插入列表</li></ul></li><li>list.pop([index=-1])<ul><li>移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</li></ul></li><li>list.remove(obj)<ul><li>移除列表中某个值的第一个匹配项</li></ul></li><li>list.reverse()<ul><li>反向列表中元素</li></ul></li><li>list.sort( key=None, reverse=False)<ul><li>对原列表进行排序</li></ul></li><li>list.clear()<ul><li>清空列表</li></ul></li><li>list.copy()<ul><li>复制列表</li></ul></li></ul><p><strong>列表元素反转</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseWords</span>(<span class="params"><span class="built_in">input</span></span>):</span> </span><br><span class="line">      </span><br><span class="line">    <span class="comment"># 通过空格将字符串分隔符，把各个单词分隔为列表[&#x27;I&#x27;, &#x27;like&#x27;, &#x27;runoob&#x27;]</span></span><br><span class="line">    inputWords = <span class="built_in">input</span>.split(<span class="string">&quot; &quot;</span>) </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 翻转字符串</span></span><br><span class="line">    <span class="comment"># 假设列表 list = [1,2,3,4],  </span></span><br><span class="line">    <span class="comment"># list[0]=1, list[1]=2 ，而 -1 表示最后一个元素 list[-1]=4 ( 与 list[3]=4 一样) </span></span><br><span class="line">    <span class="comment"># inputWords[-1::-1] 有三个参数</span></span><br><span class="line">    <span class="comment"># 第一个参数 -1 表示最后一个元素</span></span><br><span class="line">    <span class="comment"># 第二个参数为空，表示移动到列表末尾</span></span><br><span class="line">    <span class="comment"># 第三个参数为步长，-1 表示逆向</span></span><br><span class="line">    inputWords=inputWords[-<span class="number">1</span>::-<span class="number">1</span>] </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 重新组合字符串，与split相反，将inputWords列表中的每个对象以空格合并</span></span><br><span class="line">    output = <span class="string">&#x27; &#x27;</span>.join(inputWords) </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> output </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>: </span><br><span class="line">    <span class="built_in">input</span> = <span class="string">&#x27;I like runoob&#x27;</span></span><br><span class="line">    rw = reverseWords(<span class="built_in">input</span>) </span><br><span class="line">    print(rw)</span><br></pre></td></tr></table></figure><h5 id="Tuple（元组）"><a href="#Tuple（元组）" class="headerlink" title="Tuple（元组）"></a>Tuple（元组）</h5><ul><li><p>元组是另一个数据类型，类似于 List（列表）。</p></li><li><p>元组用 <strong>()</strong> 标识。内部元素用逗号隔开。</p></li><li><p>与字符串一样，元组的元素不能修改，相当于只读列表。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">y = <span class="number">4</span></span><br><span class="line">z = (x, y)</span><br><span class="line">print(z)        <span class="comment"># ([1, 2], 4)</span></span><br><span class="line"></span><br><span class="line">x.append(<span class="number">3</span>)</span><br><span class="line">print(z)        <span class="comment"># ([1, 2, 3], 4)</span></span><br><span class="line"></span><br><span class="line">x[<span class="number">0</span>] = <span class="number">333</span></span><br><span class="line">print(z)        <span class="comment"># ([333, 2, 3], 4)</span></span><br><span class="line"></span><br><span class="line">x = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]   </span><br><span class="line">print(z)        <span class="comment"># ([1, 2, 3], 4)，相当于x换了个对象，所以不行</span></span><br><span class="line"></span><br><span class="line">z[<span class="number">0</span>] = <span class="string">&#x27;123&#x27;</span>    <span class="comment"># 会报错，元组是不可变的</span></span><br><span class="line"></span><br><span class="line">z = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)   <span class="comment"># 重新赋值的元组 z，绑定到新的对象了，不是修改了原来的对象。</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tup1 = ()      <span class="comment"># 创建空元组</span></span><br><span class="line">tup1 = (<span class="number">50</span>)    <span class="comment"># 整数50</span></span><br><span class="line">tup1 = (<span class="number">50</span>,)   <span class="comment"># 元组</span></span><br></pre></td></tr></table></figure><ul><li>元组中只包含一个元素时，需要在元素后面添加逗号，否则括号会被当作运算符使用</li></ul><p><strong>内置函数：</strong></p><ul><li><p>len(tuple)</p><ul><li>计算元组元素个数。    </li></ul></li><li><p>max(tuple)</p><ul><li>返回元组中元素最大值。    </li></ul></li><li><p>min(tuple)</p><ul><li>返回元组中元素最小值。    </li></ul></li><li><p>tuple(iterable)</p><ul><li><p>将可迭代系列转换为元组。</p></li><li><pre><code class="python">&gt;&gt;&gt; list1= [&#39;Google&#39;, &#39;Taobao&#39;, &#39;Runoob&#39;, &#39;Baidu&#39;]&gt;&gt;&gt; tuple1=tuple(list1)&gt;&gt;&gt; tuple1(&#39;Google&#39;, &#39;Taobao&#39;, &#39;Runoob&#39;, &#39;Baidu&#39;)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### Set（集合）</span><br><span class="line"></span><br><span class="line">* 集合（set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员。</span><br><span class="line">* 基本功能是进行成员关系测试和删除重复元素。</span><br><span class="line">* 可以使用大括号 **&#123; &#125;** 或者 **set()** 函数创建集合</span><br><span class="line">  * **注意**：创建一个空集合必须用 **set()** 而不是 **&#123; &#125;**，因为 **&#123; &#125;** 是用来创建一个空字典。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line">parame &#x3D; &#123;value01,value02,...&#125;</span><br><span class="line"># 或者</span><br><span class="line">parame &#x3D; set(value)</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><p><strong>集合运算</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">set</span>(<span class="string">&#x27;abracadabra&#x27;</span>)</span><br><span class="line">b = <span class="built_in">set</span>(<span class="string">&#x27;alacazam&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 成员测试</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">in</span> sites :</span><br><span class="line">    print(<span class="string">&#x27;a 在集合中&#x27;</span>)     <span class="comment"># true</span></span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">    print(<span class="string">&#x27;a 不在集合中&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结合运算</span></span><br><span class="line">print(a)      <span class="comment">#               &#123;&#x27;b&#x27;, &#x27;c&#x27;, &#x27;a&#x27;, &#x27;r&#x27;, &#x27;d&#x27;&#125;</span></span><br><span class="line">print(a - b)  <span class="comment"># a 和 b 的差集  &#123;&#x27;r&#x27;, &#x27;b&#x27;, &#x27;d&#x27;&#125;</span></span><br><span class="line">print(a | b)  <span class="comment"># a 和 b 的并集  &#123;&#x27;b&#x27;, &#x27;c&#x27;, &#x27;a&#x27;, &#x27;z&#x27;, &#x27;m&#x27;, &#x27;r&#x27;, &#x27;l&#x27;, &#x27;d&#x27;&#125;</span></span><br><span class="line">print(a &amp; b)  <span class="comment"># a 和 b 的交集  &#123;&#x27;c&#x27;, &#x27;a&#x27;&#125;</span></span><br><span class="line">print(a ^ b)  <span class="comment"># a 和 b 中不同时存在的元素 &#123;&#x27;z&#x27;, &#x27;b&#x27;, &#x27;m&#x27;, &#x27;r&#x27;, &#x27;l&#x27;, &#x27;d&#x27;&#125;</span></span><br></pre></td></tr></table></figure><p><strong>基本操作：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">set</span>(<span class="string">&#x27;abracadabra&#x27;</span>)</span><br><span class="line">a.add(<span class="string">&#x27;h&#x27;</span>)      <span class="comment"># &#123;&#x27;a&#x27;, &#x27;h&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;r&#x27;, &#x27;d&#x27;&#125;</span></span><br><span class="line">s.update(<span class="string">&#x27;h&#x27;</span>)   <span class="comment"># 效果相同</span></span><br><span class="line"></span><br><span class="line">s.remove(<span class="string">&#x27;h&#x27;</span>)   <span class="comment"># &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;r&#x27;, &#x27;d&#x27;&#125;</span></span><br><span class="line">s.discard(<span class="string">&#x27;h&#x27;</span>)  <span class="comment"># 效果相同</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机删除集合中的一个元素</span></span><br><span class="line">x = a.pop()     <span class="comment"># x为a中随机一个元素</span></span><br></pre></td></tr></table></figure><p><strong>内置函数：</strong></p><ul><li>len(set)<ul><li>输出集合的个数</li></ul></li></ul><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">add()</td><td align="left">为集合添加元素</td></tr><tr><td align="left">clear()</td><td align="left">移除集合中的所有元素</td></tr><tr><td align="left">copy()</td><td align="left">拷贝一个集合</td></tr><tr><td align="left">difference()</td><td align="left">返回多个集合的差集</td></tr><tr><td align="left">difference_update()</td><td align="left">移除集合中的元素，该元素在指定的集合也存在。</td></tr><tr><td align="left">discard()</td><td align="left">删除集合中指定的元素</td></tr><tr><td align="left">intersection()</td><td align="left">返回集合的交集</td></tr><tr><td align="left">intersection_update()</td><td align="left">返回集合的交集。</td></tr><tr><td align="left">isdisjoint()</td><td align="left">判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 False。</td></tr><tr><td align="left">issubset()</td><td align="left">判断指定集合是否为该方法参数集合的子集。</td></tr><tr><td align="left">issuperset()</td><td align="left">判断该方法的参数集合是否为指定集合的子集</td></tr><tr><td align="left">pop()</td><td align="left">随机移除元素</td></tr><tr><td align="left">remove()</td><td align="left">移除指定元素</td></tr><tr><td align="left">symmetric_difference()</td><td align="left">返回两个集合中不重复的元素集合。</td></tr><tr><td align="left">symmetric_difference_update()</td><td align="left">移除当前集合中在另外一个指定集合相同的元素，并将另外一个指定集合中不同的元素插入到当前集合中。</td></tr><tr><td align="left">union()</td><td align="left">返回两个集合的并集</td></tr><tr><td align="left">update()</td><td align="left">给集合添加元素</td></tr></tbody></table><h5 id="Dictionary（字典）"><a href="#Dictionary（字典）" class="headerlink" title="Dictionary（字典）"></a>Dictionary（字典）</h5><ul><li>列表是有序的对象集合，字典是无序的对象集合。<ul><li>即使排序了，放进字典也是无序的</li></ul></li><li>两者之间的区别在于：<ul><li>字典当中的元素是通过键来存取的，而不是通过偏移存取。</li></ul></li><li>字典是一种映射类型，字典用 <strong>{ }</strong> 标识，它是一个无序的 <strong>键(key) : 值(value)</strong> 的集合。<ul><li>键(key)必须使用<strong>不可变类型</strong>。（列表等不行）</li><li>在同一个字典中，键(key)必须是<strong>唯一</strong>的，重复时选择后一个</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dict</span> = &#123;&#125;     <span class="comment"># 创建空字典</span></span><br><span class="line"><span class="built_in">dict</span>[<span class="string">&#x27;one&#x27;</span>] = <span class="string">&quot;111&quot;</span></span><br><span class="line"><span class="built_in">dict</span>[<span class="number">2</span>]     = <span class="string">&quot;222&quot;</span></span><br><span class="line"></span><br><span class="line">tinydict = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;aaa&#x27;</span>,<span class="string">&#x27;b&#x27;</span>:<span class="number">1</span>, (c): <span class="string">&#x27;ccc&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">dict</span>[<span class="string">&#x27;one&#x27;</span>])       <span class="comment"># 输出键为 &#x27;one&#x27; 的值  &quot;111&quot;</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">dict</span>[<span class="number">2</span>])           <span class="comment"># 输出键为 2 的值      &quot;222&quot;</span></span><br><span class="line"><span class="built_in">print</span> (tinydict)          <span class="comment"># 输出完整的字典   &#123;&#x27;a&#x27;:&#x27;aaa&#x27;,&#x27;b&#x27;:1,(c):&#x27;ccc&#x27;&#125;</span></span><br><span class="line"><span class="built_in">print</span> (tinydict.keys())   <span class="comment"># 输出所有键   dict_keys([&#x27;a&#x27;, &#x27;b&#x27;, (c)])</span></span><br><span class="line"><span class="built_in">print</span> (tinydict.values()) <span class="comment"># 输出所有值   dict_values([&#x27;aaa&#x27;, 1, &#x27;ccc&#x27;])</span></span><br></pre></td></tr></table></figure><p><strong>内置函数</strong></p><ul><li><p>构造函数<code>dict（）</code>：</p><ul><li><pre><code class="python">&gt;&gt;&gt; dict([(&#39;aa&#39;, 1), (&#39;bb&#39;, 2), (&#39;cc&#39;, 3)])&#123;&#39;aa&#39;: 1, &#39;bb&#39;: 2, &#39;cc&#39;: 3&#125;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* len(dict)</span><br><span class="line">  </span><br><span class="line">  * 计算字典元素个数，即键的总数</span><br><span class="line">* str(dict)</span><br><span class="line">  </span><br><span class="line">  * 输出字典，以可打印的字符串表示。</span><br><span class="line">* type(variable)</span><br><span class="line">  </span><br><span class="line">  * 返回输入的变量类型，如果变量是字典就返回字典类型。</span><br><span class="line">* keys()</span><br><span class="line">* values()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">| 序号 | 函数及描述                                                   |</span><br><span class="line">| :--- | :----------------------------------------------------------- |</span><br><span class="line">| 1    | [radiansdict.clear()](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-dictionary-clear.html) &lt;br &#x2F;&gt;删除字典内所有元素 |</span><br><span class="line">| 2    | [radiansdict.copy()](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-dictionary-copy.html) &lt;br &#x2F;&gt;返回一个字典的浅复制 |</span><br><span class="line">| 3    | [radiansdict.fromkeys()](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-dictionary-fromkeys.html) &lt;br &#x2F;&gt;创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值 |</span><br><span class="line">| 4    | [radiansdict.get(key, default&#x3D;None)](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-dictionary-get.html) &lt;br &#x2F;&gt;返回指定键的值，如果键不在字典中返回 default 设置的默认值 |</span><br><span class="line">| 5    | [key in dict](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-dictionary-in.html) &lt;br &#x2F;&gt;如果键在字典dict里返回true，否则返回false |</span><br><span class="line">| 6    | [radiansdict.items()](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-dictionary-items.html) &lt;br &#x2F;&gt;以列表返回可遍历的(键, 值) 元组数组 |</span><br><span class="line">| 7    | [radiansdict.keys()](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-dictionary-keys.html) &lt;br &#x2F;&gt;返回一个迭代器，可以使用 list() 来转换为列表 |</span><br><span class="line">| 8    | [radiansdict.setdefault(key, default&#x3D;None)](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-dictionary-setdefault.html)&lt;br &#x2F;&gt; 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default |</span><br><span class="line">| 9    | [radiansdict.update(dict2)](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-dictionary-update.html) &lt;br &#x2F;&gt;把字典dict2的键&#x2F;值对更新到dict里 |</span><br><span class="line">| 10   | [radiansdict.values()](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-dictionary-values.html) &lt;br &#x2F;&gt;返回一个迭代器，可以使用 list() 来转换为列表 |</span><br><span class="line">| 11   | pop(key[,default\]) &lt;br &#x2F;&gt;删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。 |</span><br><span class="line">| 12   | [popitem()](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-dictionary-popitem.html) &lt;br &#x2F;&gt;随机返回并删除字典中的最后一对键和值。 |</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">#### 数据类型转换</span><br><span class="line"></span><br><span class="line">| 函数                    | 描述                                                |</span><br><span class="line">| :---------------------- | :-------------------------------------------------- |</span><br><span class="line">| int(x)                  | 将x转换为一个整数                                   |</span><br><span class="line">| float(x)                | 将x转换到一个浮点数                                 |</span><br><span class="line">| complex(real [,imag\])] | 创建一个复数，实部是real，虚部是imag                |</span><br><span class="line">| str(x)                  | 将对象 x 转换为字符串                               |</span><br><span class="line">| repr(x)                 | 将对象 x 转换为表达式字符串                         |</span><br><span class="line">| eval(str)               | 用来计算在字符串中的有效Python表达式,并返回一个对象 |</span><br><span class="line">| tuple(s)                | 将序列 s 转换为一个元组                             |</span><br><span class="line">| list(s)                 | 将序列 s 转换为一个列表                             |</span><br><span class="line">| set(s)                  | 转换为可变集合                                      |</span><br><span class="line">| dict(d)                 | 创建一个字典。d 必须是一个 (key, value)元组序列。   |</span><br><span class="line">| frozenset(s)            | 转换为不可变集合                                    |</span><br><span class="line">| chr(x)                  | 将一个整数转换为一个字符                            |</span><br><span class="line">| ord(x)                  | 将一个字符转换为它的整数值                          |</span><br><span class="line">| hex(x)                  | 将一个整数转换为一个十六进制字符串                  |</span><br><span class="line">| oct(x)                  | 将一个整数转换为一个八进制字符串                    |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### **进制转换：**</span><br><span class="line"></span><br><span class="line">**二进制表示**</span><br><span class="line"></span><br><span class="line">* 通过&#96;0b&#x2F;-0b&#96;开头的字符串来表示二进制</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line">print 0b101 # 输出5</span><br><span class="line">print 0b10  # 输出2</span><br><span class="line">print -0b101 # 输出-5</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p><code>bin()</code>函数将十进制转换成而二进制表示</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bin</span>(<span class="number">5</span>)  <span class="comment"># 输出0b101</span></span><br></pre></td></tr></table></figure><p><strong>二进制位操作：</strong></p><ul><li>关于bit有一个很有用的Packag叫做bitarray，其中bitarray对象可以帮助我们存储0，1值或者Boolean值，并像list一样进行操作。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bitarray <span class="keyword">import</span> bitarray</span><br><span class="line"></span><br><span class="line"><span class="comment">#初始化一个有10个bit位的数组，初始值为0</span></span><br><span class="line">a = bitarray(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#可以像操作list一样操作bitarray对象</span></span><br><span class="line">a[<span class="number">1</span>:<span class="number">8</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#bitarray还提供了一些特殊的方法，如：all()</span></span><br><span class="line"><span class="comment">#当bitarray中所有的元素都为1时，all()返回为True</span></span><br><span class="line"><span class="keyword">if</span> a.<span class="built_in">all</span>():</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;all bits are True.&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h3><h4 id="条件控制"><a href="#条件控制" class="headerlink" title="条件控制"></a>条件控制</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition_1:</span><br><span class="line">    statement_block_1</span><br><span class="line"><span class="keyword">elif</span> condition_2:</span><br><span class="line">    statement_block_2</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    statement_block_3</span><br></pre></td></tr></table></figure><ul><li>python中没有<code>switch-case</code></li></ul><h4 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h4><p><strong>while</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> 判断条件(condition)：</span><br><span class="line">    执行语句(statements)……</span><br></pre></td></tr></table></figure><p>​    </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> &lt;expr&gt;:</span><br><span class="line">    &lt;statement(s)&gt;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    &lt;additional_statement(s)&gt;</span><br></pre></td></tr></table></figure><ul><li>条件语句为 false 时执行 else 的语句块。</li></ul><p>​     </p><p><strong>for</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &lt;variable&gt; <span class="keyword">in</span> &lt;sequence&gt;:</span><br><span class="line">    &lt;statements&gt;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    &lt;statements&gt;</span><br></pre></td></tr></table></figure><ul><li>在没有循环数据时执行else的语句块</li></ul><p>​    </p><p><code>range()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">  print(i)   <span class="comment"># 0 1 2 3 4</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>, <span class="number">9</span>):</span><br><span class="line">  print(i)   <span class="comment"># 5 6 7 8</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>, <span class="number">3</span>):</span><br><span class="line">  print(i)   <span class="comment"># 0 3 6 9</span></span><br></pre></td></tr></table></figure><p><strong>continue break</strong></p><ul><li>同java，c++等的使用一样</li></ul><p>​    </p><p><strong>pass</strong></p><ul><li>pass是空语句，是为了保持程序结构的完整性。</li><li>pass 不做任何事情，一般用做占位语句</li></ul><p>​    </p><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><ul><li>在字典中遍历时，关键字和对应的值可以使用<code>items()</code> 方法同时解读出来：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>knights = &#123;<span class="string">&#x27;gallahad&#x27;</span>: <span class="string">&#x27;the pure&#x27;</span>, <span class="string">&#x27;robin&#x27;</span>: <span class="string">&#x27;the brave&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> k, v <span class="keyword">in</span> knights.items():</span><br><span class="line"><span class="meta">... </span>    print(k, v)</span><br><span class="line">...</span><br><span class="line">gallahad the pure</span><br><span class="line">robin the brave</span><br></pre></td></tr></table></figure><ul><li>在序列中遍历时，索引位置和对应值可以使用 <code>enumerate()</code> 函数同时得到：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>([<span class="string">&#x27;tic&#x27;</span>, <span class="string">&#x27;tac&#x27;</span>, <span class="string">&#x27;toe&#x27;</span>]):</span><br><span class="line"><span class="meta">... </span>    print(i, v)</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> tic</span><br><span class="line"><span class="number">1</span> tac</span><br><span class="line"><span class="number">2</span> toe</span><br></pre></td></tr></table></figure><ul><li>同时遍历两个或更多的序列，可以使用 <code>zip()</code> 组合：</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>questions = [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;quest&#x27;</span>, <span class="string">&#x27;favorite color&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>answers = [<span class="string">&#x27;lancelot&#x27;</span>, <span class="string">&#x27;the holy grail&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> q, a <span class="keyword">in</span> <span class="built_in">zip</span>(questions, answers):</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">&#x27;What is your &#123;0&#125;?  It is &#123;1&#125;.&#x27;</span>.<span class="built_in">format</span>(q, a))</span><br><span class="line">...</span><br><span class="line">What is your name?  It is lancelot.</span><br><span class="line">What is your quest?  It is the holy grail.</span><br><span class="line">What is your favorite color?  It is blue.</span><br></pre></td></tr></table></figure><ul><li>反向遍历一个序列，首先指定这个序列，然后调用 <code>reversed()</code> 函数：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>)):</span><br><span class="line"><span class="meta">... </span>    print(i)</span><br><span class="line">...</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>要按顺序遍历一个序列，使用 <code>sorted()</code>函数返回一个已排序的序列，并不修改原值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>basket = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> f <span class="keyword">in</span> <span class="built_in">sorted</span>(<span class="built_in">set</span>(basket)):</span><br><span class="line"><span class="meta">... </span>    print(f)</span><br><span class="line">...</span><br><span class="line">apple</span><br><span class="line">banana</span><br><span class="line">orange</span><br><span class="line">pear</span><br></pre></td></tr></table></figure><h3 id="迭代器与生成器"><a href="#迭代器与生成器" class="headerlink" title="迭代器与生成器"></a>迭代器与生成器</h3><ul><li>迭代是Python最强大的功能之一，是访问集合元素的一种方式。</li><li>迭代器是一个可以记住遍历的位置的对象。</li><li>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</li><li>迭代器有两个基本的方法：<strong>iter()</strong> 和 **next()**。</li><li>字符串，列表或元组对象都可用于创建迭代器：</li></ul><h4 id="iter"><a href="#iter" class="headerlink" title="iter()"></a>iter()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">it = <span class="built_in">iter</span>(<span class="built_in">list</span>)  <span class="comment"># 创建迭代器对象</span></span><br><span class="line">print(it)        <span class="comment"># &lt;list_iterator object at 0x7fe777a83d30&gt;</span></span><br><span class="line">print(<span class="built_in">next</span>(it))  <span class="comment"># 1 输出迭代器的下一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### for ###</span></span><br><span class="line"><span class="built_in">list</span>=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it = <span class="built_in">iter</span>(<span class="built_in">list</span>)  <span class="comment"># 创建迭代器对象</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> it:</span><br><span class="line">    <span class="built_in">print</span> (x, end=<span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="next"><a href="#next" class="headerlink" title="next()"></a>next()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys         <span class="comment"># 引入 sys 模块</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">list</span>=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it = <span class="built_in">iter</span>(<span class="built_in">list</span>)    <span class="comment"># 创建迭代器对象</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span> (<span class="built_in">next</span>(it))</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        sys.exit()</span><br></pre></td></tr></table></figure><p><strong>创建一个迭代器：</strong></p><ul><li><p>把一个类作为一个迭代器使用需要在类中实现两个方法 __iter__() 与__next__() 。</p></li><li><p>如果你已经了解的面向对象编程，就知道类都有一个构造函数，Python 的构造函数为 <strong>init</strong>(), 它会在对象初始化的时候执行。</p><ul><li>更多内容查阅：Python3 面向对象</li></ul></li><li><p> __iter__()：返回一个特殊的迭代器对象， 这个迭代器对象实现了 __next__() 方法并通过 StopIteration 异常标识迭代的完成。</p></li><li><p> __next__()：（Python 2 里是 next()）会返回下一个迭代器对象。</p></li></ul><p>创建一个返回数字的迭代器，初始值为 1，逐步递增 1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyNumbers</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> self</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span></span><br><span class="line">    x = self.a</span><br><span class="line">    self.a += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"> </span><br><span class="line">myclass = MyNumbers()</span><br><span class="line">myiter = <span class="built_in">iter</span>(myclass)</span><br><span class="line"> </span><br><span class="line">print(<span class="built_in">next</span>(myiter))   <span class="comment"># 1</span></span><br><span class="line">print(<span class="built_in">next</span>(myiter))   <span class="comment"># 2</span></span><br><span class="line">print(<span class="built_in">next</span>(myiter))   <span class="comment"># 3</span></span><br></pre></td></tr></table></figure><h4 id="StopIteration"><a href="#StopIteration" class="headerlink" title="StopIteration"></a>StopIteration</h4><ul><li>StopIteration 异常用于标识迭代的完成，防止出现无限循环的情况，在__next__() 方法中我们可以设置在完成指定循环次数后触发 StopIteration 异常来结束迭代。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyNumbers</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> self</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">if</span> self.a &lt;= <span class="number">20</span>:      <span class="comment"># 设置迭代20次后停止</span></span><br><span class="line">      x = self.a</span><br><span class="line">      self.a += <span class="number">1</span></span><br><span class="line">      <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">raise</span> StopIteration</span><br><span class="line"> </span><br><span class="line">myclass = MyNumbers()</span><br><span class="line">myiter = <span class="built_in">iter</span>(myclass)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> myiter:</span><br><span class="line">  print(x)</span><br></pre></td></tr></table></figure><h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><ul><li>在 Python 中，使用了 yield 的函数被称为生成器（generator）。</li><li>跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。 </li><li>在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。</li><li>调用一个生成器函数，返回的是一个迭代器对象。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 yield 实现斐波那契数列</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span>(<span class="params">n</span>):</span> <span class="comment"># 生成器函数 - 斐波那契</span></span><br><span class="line">    a, b, counter = <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> (counter &gt; n): </span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        counter += <span class="number">1</span></span><br><span class="line">f = fibonacci(<span class="number">10</span>) <span class="comment"># f 是一个迭代器，由生成器返回生成</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span> (<span class="built_in">next</span>(f), end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        sys.exit()</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> 函数名（参数列表）:</span></span><br><span class="line">    函数体</span><br></pre></td></tr></table></figure><img src="/2020/12/15/python/截屏2020-12-16 下午3.51.47.png" alt="截屏2020-12-16 下午3.51.47" style="zoom:50%;">    <h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><blockquote><p>python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。</p></blockquote><ul><li><strong>不可变类型：</strong>类似 C++ 的值传递，如 整数、字符串、元组。如 fun(a)，传递的只是 a 的值，没有影响 a 对象本身。如果在 fun(a)）内部修改 a 的值，则是新生成来一个 a。</li><li><strong>可变类型：</strong>类似 C++ 的引用传递，如 列表，字典。如 fun(la)，则是将 la 真正的传过去，修改后 fun 外部的 la 也会受影响</li></ul><p><strong>调用函数时可使用的正式参数类型：</strong></p><ul><li><p>必需参数</p><ul><li><p>必需参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#可写函数说明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printme</span>(<span class="params"> <span class="built_in">str</span> </span>):</span></span><br><span class="line">   <span class="string">&quot;打印任何传入的字符串&quot;</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="built_in">str</span>)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用 printme 函数，不加参数会报错</span></span><br><span class="line">printme()</span><br></pre></td></tr></table></figure></li></ul></li><li><p>关键字参数</p><ul><li><p>关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。</p></li><li><p>使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#可写函数说明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printinfo</span>(<span class="params"> name, age </span>):</span></span><br><span class="line">   <span class="string">&quot;打印任何传入的字符串&quot;</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;名字: &quot;</span>, name)</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;年龄: &quot;</span>, age)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#调用printinfo函数</span></span><br><span class="line">printinfo( age=<span class="number">50</span>, name=<span class="string">&quot;runoob&quot;</span> )</span><br></pre></td></tr></table></figure></li></ul></li><li><p>默认参数</p><ul><li><p>调用函数时，如果没有传递参数，则会使用默认参数。以下实例中如果没有传入 age 参数，则使用默认值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#可写函数说明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printinfo</span>(<span class="params"> name, age = <span class="number">35</span> </span>):</span></span><br><span class="line">   <span class="string">&quot;打印任何传入的字符串&quot;</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;名字: &quot;</span>, name)</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;年龄: &quot;</span>, age)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#调用printinfo函数</span></span><br><span class="line">printinfo( age=<span class="number">50</span>, name=<span class="string">&quot;runoob&quot;</span> )  <span class="comment"># 名字: runoob    年龄: 50</span></span><br><span class="line">printinfo( name=<span class="string">&quot;runoob&quot;</span> )          <span class="comment"># 名字: runoob    年龄: 35</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>不定长参数</p><ul><li><p>可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述 2 种参数不同，声明时不会命名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">functionname</span>(<span class="params">[formal_args,] *var_args_tuple </span>):</span></span><br><span class="line">   <span class="string">&quot;函数_文档字符串&quot;</span></span><br><span class="line">   function_suite</span><br><span class="line">   <span class="keyword">return</span> [expression]</span><br></pre></td></tr></table></figure></li><li><p>带<code>*</code>以元组形式传入</p><ul><li>如果单独出现星号<code>*</code>后的参数必须用关键字传入。</li><li><code>def f(a,b,*,c):</code>  调用：<code>f(1,2,c=3)</code></li></ul></li><li><p>带<code>**</code>以字典形式传入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printinfo</span>(<span class="params"> arg1, *vartuple </span>):</span></span><br><span class="line">   <span class="string">&quot;打印任何传入的参数&quot;</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;输出: &quot;</span>)</span><br><span class="line">   <span class="built_in">print</span> (arg1)</span><br><span class="line">   <span class="built_in">print</span> (vartuple)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用printinfo 函数</span></span><br><span class="line">printinfo( <span class="number">70</span>, <span class="number">60</span>, <span class="number">50</span> )</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="number">70</span></span><br><span class="line">(<span class="number">60</span>, <span class="number">50</span>)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><ul><li>python 使用<code>lambda</code>来创建匿名函数。</li><li>所谓匿名，意即不再使用 def 语句这样标准的形式定义一个函数。<ul><li>lambda 只是一个表达式，函数体比 def 简单很多。</li><li>lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。</li><li>lambda 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。</li><li>虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。</li></ul></li></ul><h4 id="函数库"><a href="#函数库" class="headerlink" title="函数库"></a>函数库</h4><h5 id="math"><a href="#math" class="headerlink" title="math"></a>math</h5><h6 id="数学常量"><a href="#数学常量" class="headerlink" title="数学常量"></a>数学常量</h6><ul><li><code>pi</code>：数学常量 pi（圆周率，一般以π来表示）</li><li><code>e</code>：数学常量 e，e即自然常数（自然常数）</li></ul><h6 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h6><ul><li><p>abs(x)    返回数字的绝对值，如abs(-10) 返回 10</p></li><li><p>ceil(x)    返回数字的上入整数，如math.ceil(4.1) 返回 5</p></li><li><p>cmp(x, y)</p><ul><li>如果 x &lt; y 返回 -1, 如果 x == y 返回 0, 如果 x &gt; y 返回 1。</li><li> Python 3 已废弃，使用 (x&gt;y)-(x&lt;y) 替换。</li></ul></li><li><p>exp(x)    返回e的x次幂(ex)，如math.exp(1) 返回2.718281828459045</p></li><li><p>fabs(x)    返回数字的绝对值的浮点类型，如math.fabs(-10) 返回10.0</p></li><li><p>floor(x)    返回数字的下舍整数，如math.floor(4.9)返回 4</p></li><li><p>log(x)    如math.log(math.e)返回1.0，math.log(100,10)返回2.0</p></li><li><p>log10(x)    返回以10为基数的x的对数，如math.log10(100)返回 2.0</p></li><li><p>max(x1, x2,…)    返回给定参数的最大值，参数可以为序列。</p></li><li><p>min(x1, x2,…)    返回给定参数的最小值，参数可以为序列。</p></li><li><p>modf(x)    返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。</p></li><li><p>pow(x, y)    x**y 运算后的值。</p></li><li><p>round(x [,n])    返回浮点数 x 的四舍五入值，如给出 n 值，则代表舍入到小数点后的位数。</p><ul><li>其实准确的说是保留值将保留到离上一位更近的一端。</li></ul></li><li><p>sqrt(x)    返回数字x的平方根。</p></li></ul><h6 id="随机数函数"><a href="#随机数函数" class="headerlink" title="随机数函数"></a>随机数函数</h6><ul><li>choice(seq)    从序列的元素中随机挑选一个元素<ul><li>比如：random.choice(range(10))，从0到9中随机挑选一个整数。</li></ul></li><li>randrange ([start,] stop [,step])    从指定范围内，按指定基数递增的集合中获取一个随机数，基数默认值为 1</li><li>random()    随机生成下一个实数，它在[0,1)范围内。</li><li>seed([x])    改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed。</li><li>shuffle(lst)    将序列的所有元素随机排序</li><li>uniform(x, y)    随机生成下一个实数，它在[x,y]范围内。</li></ul><h6 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h6><ul><li>acos(x)    返回x的反余弦弧度值。</li><li>asin(x)    返回x的反正弦弧度值。</li><li>atan(x)    返回x的反正切弧度值。</li><li>atan2(y, x)    返回给定的 X 及 Y 坐标值的反正切值。</li><li>cos(x)    返回x的弧度的余弦值。</li><li>hypot(x, y)    返回欧几里德范数 sqrt(x<em>x + y</em>y)。</li><li>sin(x)    返回的x弧度的正弦值。</li><li>tan(x)    返回x弧度的正切值。</li><li>degrees(x)    将弧度转换为角度,如degrees(math.pi/2) ， 返回90.0</li><li>radians(x)    将角度转换为弧度</li></ul><h5 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h5><p>很多Python函数用一个元组装起来的9组数字处理时间:</p><table><thead><tr><th>4位数年</th><th>2008</th><th></th></tr></thead><tbody><tr><td>1</td><td>月</td><td>1 到 12</td></tr><tr><td>2</td><td>日</td><td>1到31</td></tr><tr><td>3</td><td>小时</td><td>0到23</td></tr><tr><td>4</td><td>分钟</td><td>0到59</td></tr><tr><td>5</td><td>秒</td><td>0到61 (60或61 是闰秒)</td></tr><tr><td>6</td><td>一周的第几日</td><td>0到6 (0是周一)</td></tr><tr><td>7</td><td>一年的第几日</td><td>1到366 (儒略历)</td></tr><tr><td>8</td><td>夏令时</td><td>-1, 0, 1, -1是决定是否为夏令时的旗帜</td></tr></tbody></table><p>上述也就是struct_time元组。这种结构具有如下属性：</p><table><thead><tr><th align="left">序号</th><th align="left">属性</th><th align="left">值</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">tm_year</td><td align="left">2008</td></tr><tr><td align="left">1</td><td align="left">tm_mon</td><td align="left">1 到 12</td></tr><tr><td align="left">2</td><td align="left">tm_mday</td><td align="left">1 到 31</td></tr><tr><td align="left">3</td><td align="left">tm_hour</td><td align="left">0 到 23</td></tr><tr><td align="left">4</td><td align="left">tm_min</td><td align="left">0 到 59</td></tr><tr><td align="left">5</td><td align="left">tm_sec</td><td align="left">0 到 61 (60或61 是闰秒)</td></tr><tr><td align="left">6</td><td align="left">tm_wday</td><td align="left">0到6 (0是周一)</td></tr><tr><td align="left">7</td><td align="left">tm_yday</td><td align="left">一年中的第几天，1 到 366</td></tr><tr><td align="left">8</td><td align="left">tm_isdst</td><td align="left">是否为夏令时，值有：1(夏令时)、0(不是夏令时)、-1(未知)，默认 -1</td></tr></tbody></table><h6 id="time"><a href="#time" class="headerlink" title="time"></a>time</h6><ul><li><p>以下时间均为<code>2020-12-16 15:35:15 周三</code></p></li><li><p>time.time()</p><ul><li>获取当前时间戳<code>1608104115.4493172</code></li><li>时间戳单位最适于做日期运算。但是1970年之前的日期就无法以此表示了。太遥远的日期也不行，UNIX和Windows只支持到2038年。</li></ul></li><li><p>time.localtime(时间戳)</p><ul><li><p>获取当前时间</p></li><li><pre><code class="python">time.struct_time(tm_year=2020, tm_mon=12, tm_mday=16, tm_hour=15, tm_min=35, tm_sec=15, tm_wday=2, tm_yday=351, tm_isdst=0)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* time.asctime(time.localtime(时间戳))</span><br><span class="line"></span><br><span class="line">  * 获取格式化的时间</span><br><span class="line"></span><br><span class="line">  * &#96;&#96;&#96;python</span><br><span class="line">    Wed Dec 16 15:35:15 2020</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>time.strftime(format[, time])</p><ul><li><p>格式化日期</p></li><li><pre><code class="python"># 格式化成2020-12-16 15:35:15形式print (time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime()))# 格式化成Wed Dec 16 15:35:15 2020形式print (time.strftime(&quot;%a %b %d %H:%M:%S %Y&quot;, time.localtime()))# 将格式字符串转换为时间戳a = &quot;Wed Dec 16 15:35:15 2020&quot;print (time.mktime(time.strptime(a,&quot;%a %b %d %H:%M:%S %Y&quot;)))<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">​         </span><br><span class="line"></span><br><span class="line">**两个非常重要的属性：**</span><br><span class="line"></span><br><span class="line">1. time.timezone</span><br><span class="line">   * 属性time.timezone是当地时区（未启动夏令时）距离格林威治的偏移秒数（&gt;0，美洲;&lt;&#x3D;0大部分欧洲，亚洲，非洲）。</span><br><span class="line">2. time.tzname</span><br><span class="line">   * 属性time.tzname包含一对根据情况的不同而不同的字符串，分别是带夏令时的本地时区名称，和不带的。</span><br><span class="line"></span><br><span class="line">| 序号 | 函数及描述                                                   | 实例                                                         |</span><br><span class="line">| :--- | :----------------------------------------------------------- | :----------------------------------------------------------- |</span><br><span class="line">| 1    | time.altzone&lt;br &#x2F;&gt;返回格林威治西部的夏令时地区的偏移秒数。如果该地区在格林威治东部会返回负值（如西欧，包括英国）。对夏令时启用地区才能使用。 | 以下实例展示了 altzone()函数的使用方法：&lt;br &#x2F;&gt;&#96;&gt;&gt;&gt; import time &#96;&lt;br &#x2F;&gt;&#96;&gt;&gt;&gt; print (&quot;time.altzone %d &quot; % time.altzone) &#96;&lt;br &#x2F;&gt;&#96;time.altzone -28800 &#96; |</span><br><span class="line">| 2    | time.asctime([tupletime]) &lt;br &#x2F;&gt;接受时间元组并返回一个可读的形式为&quot;Tue Dec 11 18:07:14 2008&quot;（2008年12月11日 周二18时07分14秒）的24个字符的字符串。 | 以下实例展示了 asctime()函数的使用方法：&lt;br &#x2F;&gt;&#96;&gt;&gt;&gt; import time &gt;&gt;&gt; t &#x3D; time.localtime() &#96;&lt;br &#x2F;&gt;&#96;&gt;&gt;&gt; print (&quot;time.asctime(t): %s &quot; % time.asctime(t)) &#96;&lt;br &#x2F;&gt;&#96;time.asctime(t): Thu Apr  7 10:36:20 2016 &#96; |</span><br><span class="line">| 3    | [time.clock()](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-time-clock.html) &lt;br &#x2F;&gt;用以浮点数计算的秒数返回当前的CPU时间。用来衡量不同程序的耗时，比time.time()更有用。 | [实例](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-time-clock.html)由于该方法依赖操作系统，在 Python 3.3 以后不被推荐，而在 3.8 版本中被移除，需使用下列两个函数替代。&#96;time.perf_counter()  # 返回系统运行时间 time.process_time()  # 返回进程运行时间&#96; |</span><br><span class="line">| 4    | time.ctime([secs]) &lt;br &#x2F;&gt;作用相当于asctime(localtime(secs))，未给参数相当于asctime() | 以下实例展示了 ctime()函数的使用方法：&lt;br &#x2F;&gt;&#96;&gt;&gt;&gt; import time &#96;&lt;br &#x2F;&gt;&#96;&gt;&gt;&gt; print (&quot;time.ctime() : %s&quot; % time.ctime()) &#96;&lt;br &#x2F;&gt;&#96;time.ctime() : Thu Apr  7 10:51:58 2016&#96; |</span><br><span class="line">| 5    | time.gmtime([secs]) &lt;br &#x2F;&gt;接收时间戳（1970纪元后经过的浮点秒数）并返回格林威治天文时间下的时间元组t。注：t.tm_isdst始终为0 | 以下实例展示了 gmtime()函数的使用方法：&lt;br &#x2F;&gt;&#96;&gt;&gt;&gt; import time &#96;&lt;br &#x2F;&gt;&#96;&gt;&gt;&gt; print (&quot;gmtime :&quot;, time.gmtime(1455508609.34375)) &#96;&lt;br &#x2F;&gt;&#96;gmtime: time.struct_time(tm_year&#x3D;2016, tm_mon&#x3D;2, tm_mday&#x3D;15, tm_hour&#x3D;3, tm_min&#x3D;56, tm_sec&#x3D;49, tm_wday&#x3D;0, tm_yday&#x3D;46, tm_isdst&#x3D;0)&#96; |</span><br><span class="line">| 6    | time.localtime([secs] &lt;br &#x2F;&gt;接收时间戳（1970纪元后经过的浮点秒数）并返回当地时间下的时间元组t（t.tm_isdst可取0或1，取决于当地当时是不是夏令时）。 | 以下实例展示了 localtime()函数的使用方法：&lt;br &#x2F;&gt;&#96;&gt;&gt;&gt; import time &#96;&lt;br &#x2F;&gt;&#96;&gt;&gt;&gt; print (&quot;localtime(): &quot;, time.localtime(1455508609.34375)) &#96;&lt;br &#x2F;&gt;&#96;localtime():  time.struct_time(tm_year&#x3D;2016, tm_mon&#x3D;2, tm_mday&#x3D;15, tm_hour&#x3D;11, tm_min&#x3D;56, tm_sec&#x3D;49, tm_wday&#x3D;0, tm_yday&#x3D;46, tm_isdst&#x3D;0)&#96; |</span><br><span class="line">| 7    | [time.mktime(tupletime)](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-time-mktime.html)&lt;br &#x2F;&gt; 接受时间元组并返回时间戳（1970纪元后经过的浮点秒数）。 | [实例](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-time-mktime.html) |</span><br><span class="line">| 8    | time.sleep(secs) &lt;br &#x2F;&gt;推迟调用线程的运行，secs指秒数。      | 以下实例展示了 sleep()函数的使用方法：&#96;#!&#x2F;usr&#x2F;bin&#x2F;python3 import time print (&quot;Start : %s&quot; % time.ctime()) time.sleep( 5 ) print (&quot;End : %s&quot; % time.ctime())&#96; |</span><br><span class="line">| 9    | time.strftime(fmt[,tupletime]) &lt;br &#x2F;&gt;接收以时间元组，并返回以可读字符串表示的当地时间，格式由fmt决定。 | 以下实例展示了 strftime()函数的使用方法：&#96;&gt;&gt;&gt; import time &gt;&gt;&gt; print (time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime())) 2016-04-07 11:18:05&#96; |</span><br><span class="line">| 10   | time.strptime(str,fmt&#x3D;&#39;%a %b %d %H:%M:%S %Y&#39;) &lt;br &#x2F;&gt;根据fmt的格式把一个时间字符串解析为时间元组。 | 以下实例展示了 strptime()函数的使用方法：&#96;&gt;&gt;&gt; import time &gt;&gt;&gt; struct_time &#x3D; time.strptime(&quot;30 Nov 00&quot;, &quot;%d %b %y&quot;) &gt;&gt;&gt; print (&quot;返回元组: &quot;, struct_time) 返回元组:  time.struct_time(tm_year&#x3D;2000, tm_mon&#x3D;11, tm_mday&#x3D;30, tm_hour&#x3D;0, tm_min&#x3D;0, tm_sec&#x3D;0, tm_wday&#x3D;3, tm_yday&#x3D;335, tm_isdst&#x3D;-1)&#96; |</span><br><span class="line">| 11   | time.time( ) &lt;br &#x2F;&gt;返回当前时间的时间戳（1970纪元后经过的浮点秒数）。 | 以下实例展示了 time()函数的使用方法：&#96;&gt;&gt;&gt; import time &gt;&gt;&gt; print(time.time()) 1459999336.1963577&#96; |</span><br><span class="line">| 12   | [time.tzset()](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-time-tzset.html) &lt;br &#x2F;&gt;根据环境变量TZ重新初始化时间相关设置。 | [实例](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-att-time-tzset.html) |</span><br><span class="line">| 13   | **time.perf_counter()** &lt;br &#x2F;&gt;返回计时器的精准时间（系统的运行时间），包含整个系统的睡眠时间。由于返回值的基准点是未定义的，所以，只有连续调用的结果之间的差才是有效的。 | [实例](https:&#x2F;&#x2F;www.runoob.com&#x2F;python3&#x2F;python3-date-time.html#comment-35499) |</span><br><span class="line">| 14   | **time.process_time()**  &lt;br &#x2F;&gt;返回当前进程执行 CPU 的时间总和，不包含睡眠时间。由于返回值的基准点是未定义的，所以，只有连续调用的结果之间的差才是有效的。 |                                                              |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**日期格式化符号：**</span><br><span class="line"></span><br><span class="line">- %y 两位数的年份表示（00-99）</span><br><span class="line">- %Y 四位数的年份表示（000-9999）</span><br><span class="line">- %m 月份（01-12）</span><br><span class="line">- %d 月内中的一天（0-31）</span><br><span class="line">- %H 24小时制小时数（0-23）</span><br><span class="line">- %I 12小时制小时数（01-12）</span><br><span class="line">- %M 分钟数（00&#x3D;59）</span><br><span class="line">- %S 秒（00-59）</span><br><span class="line">- %a 本地简化星期名称</span><br><span class="line">- %A 本地完整星期名称</span><br><span class="line">- %b 本地简化的月份名称</span><br><span class="line">- %B 本地完整的月份名称</span><br><span class="line">- %c 本地相应的日期表示和时间表示</span><br><span class="line">- %j 年内的一天（001-366）</span><br><span class="line">- %p 本地A.M.或P.M.的等价符</span><br><span class="line">- %U 一年中的星期数（00-53）星期天为星期的开始</span><br><span class="line">- %w 星期（0-6），星期天为星期的开始</span><br><span class="line">- %W 一年中的星期数（00-53）星期一为星期的开始</span><br><span class="line">- %x 本地相应的日期表示</span><br><span class="line">- %X 本地相应的时间表示</span><br><span class="line">- %Z 当前时区的名称</span><br><span class="line">- %% %号本身</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###### calendar</span><br><span class="line"></span><br><span class="line">* 星期一是默认的每周第一天，星期天是默认的最后一天。更改设置需调用calendar.setfirstweekday()函数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">| 序号 | 函数及描述                                                   |</span><br><span class="line">| :--- | :----------------------------------------------------------- |</span><br><span class="line">| 1    | **calendar.calendar(year,w&#x3D;2,l&#x3D;1,c&#x3D;6)**&lt;br &#x2F;&gt; 返回一个多行字符串格式的year年年历，3个月一行，间隔距离为c。 每日宽度间隔为w字符。每行长度为21* W+18+2* C。l是每星期行数。 |</span><br><span class="line">| 2    | **calendar.firstweekday( )** &lt;br &#x2F;&gt;返回当前每周起始日期的设置。默认情况下，首次载入caendar模块时返回0，即星期一。 |</span><br><span class="line">| 3    | **calendar.isleap(year)** &lt;br &#x2F;&gt;是闰年返回 True，否则为 false。&lt;br &#x2F;&gt;&lt;img src&#x3D;&quot;python&#x2F;截屏2020-12-16 下午3.44.04.png&quot; alt&#x3D;&quot;截屏2020-12-16 下午3.44.04&quot; style&#x3D;&quot;zoom:40%;&quot; &#x2F;&gt; |</span><br><span class="line">| 4    | **calendar.leapdays(y1,y2)** &lt;br &#x2F;&gt;返回在Y1，Y2两年之间的闰年总数。 |</span><br><span class="line">| 5    | **calendar.month(year,month,w&#x3D;2,l&#x3D;1)**&lt;br &#x2F;&gt; 返回一个多行字符串格式的year年month月日历，两行标题，一周一行。每日宽度间隔为w字符。每行的长度为7* w+6。l是每星期的行数。 |</span><br><span class="line">| 6    | **calendar.monthcalendar(year,month)** &lt;br &#x2F;&gt;返回一个整数的单层嵌套列表。每个子列表装载代表一个星期的整数。Year年month月外的日期都设为0;范围内的日子都由该月第几日表示，从1开始。 |</span><br><span class="line">| 7    | **calendar.monthrange(year,month)** &lt;br &#x2F;&gt;返回两个整数。第一个是该月的星期几，第二个是该月有几天。星期几是从0（星期一）到 6（星期日）。&lt;br &#x2F;&gt;&lt;img src&#x3D;&quot;python&#x2F;截屏2020-12-16 下午3.44.50.png&quot; alt&#x3D;&quot;截屏2020-12-16 下午3.44.50&quot; style&#x3D;&quot;zoom:45%;&quot; &#x2F;&gt;&lt;br &#x2F;&gt;(5, 30)解释：5 表示 2014 年 11 月份的第一天是周六，30 表示 2014 年 11 月份总共有 30 天。 |</span><br><span class="line">| 8    | **calendar.prcal(year, w&#x3D;0, l&#x3D;0, c&#x3D;6, m&#x3D;3)** &lt;br &#x2F;&gt;相当于 print (calendar.calendar(year, w&#x3D;0, l&#x3D;0, c&#x3D;6, m&#x3D;3))。 |</span><br><span class="line">| 9    | **calendar.prmonth(theyear, themonth, w&#x3D;0, l&#x3D;0)** &lt;br &#x2F;&gt;相当于 **print(calendar.month(theyear, themonth, w&#x3D;0, l&#x3D;0))**。 |</span><br><span class="line">| 10   | **calendar.setfirstweekday(weekday)** &lt;br &#x2F;&gt;设置每周的起始日期码。0（星期一）到6（星期日）。 |</span><br><span class="line">| 11   | **calendar.timegm(tupletime)** &lt;br &#x2F;&gt;和time.gmtime相反：接受一个时间元组形式，返回该时刻的时间戳（1970纪元后经过的浮点秒数）。 |</span><br><span class="line">| 12   | **calendar.weekday(year,month,day)**&lt;br &#x2F;&gt; 返回给定日期的日期码。0（星期一）到6（星期日）。月份为 1（一月） 到 12（12月）。 |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###### datetime</span><br><span class="line"></span><br><span class="line">- [datetime模块](https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;datetime.html)</span><br><span class="line">- datetime模块为日期和时间处理同时提供了简单和复杂的方法。</span><br><span class="line">- 支持日期和时间算法的同时，实现的重点放在更有效的处理和格式化输出。</span><br><span class="line">- 该模块还支持时区处理</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line">now &#x3D; date.today()</span><br><span class="line">print(str(now))  # 2020-12-17</span><br><span class="line">print(now.strftime(&quot;%m-%d-%y. %d %b %Y is a %A on the %d day of %B.&quot;))</span><br><span class="line"># 212-17-20. 17 Dec 2020 is a Thursday on the 17 day of December.</span><br><span class="line">birthday &#x3D; date(1964, 7, 31)</span><br><span class="line">age &#x3D; now - birthday</span><br><span class="line">print(birthday)    # 1964-07-31</span><br><span class="line">print(age)         # 20593 days, 0:00:00</span><br><span class="line">print(age.days)    # 20593</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h4 id="内置函数-build-in"><a href="#内置函数-build-in" class="headerlink" title="内置函数(build.in)"></a>内置函数(build.in)</h4><h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">sorted</span>(<span class="built_in">dict</span>.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><ul><li>根据value(x[1])值来进行排序</li><li>dict是无序的，所以即使sorted了，得到的依然不是完全的排序号的</li></ul><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><ul><li><strong>类(Class):</strong> 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。</li><li><strong>方法：</strong>类中定义的函数。</li><li><strong>类变量：</strong>类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。</li><li><strong>数据成员：</strong>类变量或者实例变量用于处理类及其实例对象的相关的数据。</li><li><strong>方法重写：</strong>如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。</li><li><strong>局部变量：</strong>定义在方法中的变量，只作用于当前实例的类。</li><li><strong>实例变量：</strong>在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用 self 修饰的变量。</li><li><strong>继承：</strong>即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟”是一个（is-a）”关系（例图，Dog是一个Animal）。</li><li><strong>实例化：</strong>创建一个类的实例，类的具体对象。</li><li><strong>对象：</strong>通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。</li></ul><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span></span><br><span class="line">  data = <span class="number">12345</span>            <span class="comment"># 基本属性</span></span><br><span class="line">  __private = <span class="number">0</span>            <span class="comment"># 私有属性</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, a</span>):</span>  <span class="comment"># 类的构造方法</span></span><br><span class="line">    self.data = a</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">self, b</span>):</span>         <span class="comment"># 类方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello world&#x27;</span> + b</span><br><span class="line">  </span><br><span class="line">myclass = MyClass(a)      <span class="comment"># 实例化类</span></span><br><span class="line">myclass.f(b)</span><br></pre></td></tr></table></figure><ul><li>在类的内部，使用 <code>def</code> 关键字来定义一个<strong>方法</strong>，与一般函数定义不同，类方法必须包含参数 <code>self</code>，且为第一个参数<ul><li><code>self</code>代表的是类的实例，代表当前对象的地址，而<code>self.class</code>则指向类。</li><li><code>self</code>的名字并不是规定死的，也可以使用 <code>this</code>，但是最好还是按照约定是用 <code>self</code>。</li></ul></li><li><ul><li>类方法必须包含参数<code>self</code>, 且为第一个参数</li></ul></li><li><code>__private_attrs</code>：两个下划线开头，声明该<strong>属性为私有</strong>，不能在类的外部被使用或直接访问。在类内部的方法中使用时 <code>self.__private_attrs</code>。</li><li><code>__private_method</code>：两个下划线开头，声明该方法为<strong>私有方法</strong>，只能在类的内部调用 ，不能在类的外部调用。<code>self.__private_methods</code>。</li></ul><p><strong>类的专有方法：</strong></p><ul><li><strong>__init__</strong> : 构造函数，在生成对象时调用</li><li><strong>__del__ :</strong> 析构函数，释放对象时使用</li><li><strong>__repr__ :</strong> 打印，转换</li><li><strong>__setitem__ :</strong> 按照索引赋值</li><li><strong>__getitem__:</strong> 按照索引获取值</li><li><strong>__len__:</strong> 获得长度</li><li><strong>__cmp__:</strong> 比较运算</li><li><strong>__call__:</strong> 函数调用</li><li><strong>__add__:</strong> 加运算</li><li><strong>__sub__:</strong> 减运算</li><li><strong>__mul__:</strong> 乘运算</li><li><strong>__truediv__:</strong> 除运算</li><li><strong>__mod__:</strong> 求余运算</li><li><strong>__pow__:</strong> 乘方</li></ul><p><strong>运算符重载：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, a, b</span>):</span></span><br><span class="line">      self.a = a</span><br><span class="line">      self.b = b</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;Vector (%d, %d)&#x27;</span> % (self.a, self.b)</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__add__</span>(<span class="params">self,other</span>):</span></span><br><span class="line">      <span class="keyword">return</span> Vector(self.a + other.a, self.b + other.b)</span><br><span class="line"> </span><br><span class="line">v1 = Vector(<span class="number">2</span>,<span class="number">10</span>)</span><br><span class="line">v2 = Vector(<span class="number">5</span>,-<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span> (v1 + v2)</span><br></pre></td></tr></table></figure><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClassName</span>(<span class="params">BaseClassName1, BaseClassNameN</span>):</span></span><br><span class="line">    &lt;statement-<span class="number">1</span>&gt;</span><br><span class="line">    .</span><br><span class="line">    &lt;statement-N&gt;</span><br><span class="line"><span class="comment">### or ##</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClassName</span>(<span class="params">modname.BaseClassName</span>):</span></span><br></pre></td></tr></table></figure><p><strong>单继承</strong></p><ul><li>以下实例<code>student</code>继承<code>people</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>:</span></span><br><span class="line">    <span class="comment">#定义基本属性</span></span><br><span class="line">    name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    age = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义私有属性,私有属性在类外部无法直接进行访问</span></span><br><span class="line">    __weight = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#定义构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,n,a,w</span>):</span></span><br><span class="line">        self.name = n</span><br><span class="line">        self.age = a</span><br><span class="line">        self.__weight = w</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;%s 说: 我 %d 岁。&quot;</span> %(self.name,self.age))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#单继承示例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span>(<span class="params">people</span>):</span></span><br><span class="line">    grade = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,n,a,w,g</span>):</span></span><br><span class="line">        <span class="comment">#调用父类的构函</span></span><br><span class="line">        people.__init__(self,n,a,w)</span><br><span class="line">        self.grade = g</span><br><span class="line">       </span><br><span class="line">    <span class="comment">#覆写父类的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;</span>%(self.name, self.age, self.grade))</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">s = student(<span class="string">&#x27;ken&#x27;</span>,<span class="number">10</span>,<span class="number">60</span>,<span class="number">3</span>)</span><br><span class="line">s.speak()</span><br><span class="line"><span class="comment"># ken 说: 我 10 岁了，我在读 3 年级</span></span><br></pre></td></tr></table></figure><p><strong>多继承</strong></p><ul><li>需要注意圆括号中父类的顺序，若是父类中有相同的方法名，而在子类使用时未指定，python从左至右搜索，即方法在子类中未找到时，从左到右查找父类中是否包含方法。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>:</span></span><br><span class="line">    <span class="comment">#定义基本属性</span></span><br><span class="line">    name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    age = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义私有属性,私有属性在类外部无法直接进行访问</span></span><br><span class="line">    __weight = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,n,a,w</span>):</span></span><br><span class="line">        self.name = n</span><br><span class="line">        self.age = a</span><br><span class="line">        self.__weight = w</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;%s 说: 我 %d 岁。&quot;</span> %(self.name,self.age))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#单继承示例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span>(<span class="params">people</span>):</span></span><br><span class="line">    grade = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,n,a,w,g</span>):</span></span><br><span class="line">        <span class="comment">#调用父类的构函</span></span><br><span class="line">        people.__init__(self,n,a,w)</span><br><span class="line">        self.grade = g</span><br><span class="line">    <span class="comment">#覆写父类的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;</span>%(self.name, self.age, self.grade))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#另一个类，多重继承之前的准备</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">speaker</span>():</span></span><br><span class="line">    topic = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,n,t</span>):</span></span><br><span class="line">        self.name = n</span><br><span class="line">        self.topic = t</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;我叫 %s，我是一个演说家，我演讲的主题是 %s&quot;</span>%(self.name,self.topic))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#多重继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sample</span>(<span class="params">speaker,student</span>):</span></span><br><span class="line">    a =<span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,n,a,w,g,t</span>):</span></span><br><span class="line">        student.__init__(self,n,a,w,g)</span><br><span class="line">        speaker.__init__(self,n,t)</span><br><span class="line"> </span><br><span class="line">test = sample(<span class="string">&quot;Tim&quot;</span>,<span class="number">25</span>,<span class="number">80</span>,<span class="number">4</span>,<span class="string">&quot;Python&quot;</span>)</span><br><span class="line">test.speak()   <span class="comment">#方法名同，默认调用的是在括号中排前地父类的方法</span></span><br><span class="line"><span class="comment"># 我叫 Tim，我是一个演说家，我演讲的主题是 Python</span></span><br></pre></td></tr></table></figure><p><strong>方法重写</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>:</span>        <span class="comment"># 定义父类</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">myMethod</span>(<span class="params">self</span>):</span></span><br><span class="line">      <span class="built_in">print</span> (<span class="string">&#x27;调用父类方法&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>(<span class="params">Parent</span>):</span> <span class="comment"># 定义子类</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">myMethod</span>(<span class="params">self</span>):</span></span><br><span class="line">      <span class="built_in">print</span> (<span class="string">&#x27;调用子类方法&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">c = Child()          <span class="comment"># 子类实例</span></span><br><span class="line">c.myMethod()         <span class="comment"># &#x27;调用子类方法&#x27; 子类调用重写方法</span></span><br><span class="line"><span class="built_in">super</span>(Child,c).myMethod()  <span class="comment"># &#x27;调用父类方法&#x27; 用子类对象调用父类已被覆盖的方法</span></span><br></pre></td></tr></table></figure><ul><li>super() 函数：用于调用父类(超类)的一个方法。</li></ul><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;super method&#x27;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delegate</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.action()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inheritor</span>(<span class="params">Super</span>):</span> <span class="comment">#1 获得父类的一切内容</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Replacer</span>(<span class="params">Super</span>):</span> <span class="comment">#2 覆盖父类的method</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;replacer.method&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Extender</span>(<span class="params">Super</span>):</span> <span class="comment">#3  覆盖并回调method 定制父类的method方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;extender.method&#x27;</span>)</span><br><span class="line">        Super.method(self)</span><br><span class="line">        print(<span class="string">&#x27;ending extend.method&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Provider</span>(<span class="params">Super</span>):</span>  <span class="comment">#4</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">action</span>(<span class="params">self</span>):</span>  <span class="comment"># 实现super的delegate方法预期的action方法</span></span><br><span class="line">        print(<span class="string">&#x27;provider.action&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> (Inheritor,Replacer,Extender):</span><br><span class="line">        print(i.__name__)</span><br><span class="line">        i().method()</span><br><span class="line">        x = Provider()</span><br><span class="line">        x.delegate()</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Inheritor</span></span><br><span class="line"><span class="string">super method</span></span><br><span class="line"><span class="string">provider.action</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Replacer</span></span><br><span class="line"><span class="string">replacer.method</span></span><br><span class="line"><span class="string">provider.action</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Extender</span></span><br><span class="line"><span class="string">extender.method</span></span><br><span class="line"><span class="string">super method</span></span><br><span class="line"><span class="string">ending extend.method</span></span><br><span class="line"><span class="string">provider.action</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><p><strong>pyinstaller</strong></p><ul><li>打包py文件，将在当前目录生成一个<code>.spec</code>文件和<code>dist</code>目录，可执行文件在<code>dist</code>目录下</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pip install pyinstaller</span><br><span class="line"><span class="meta">#</span><span class="bash"> 到文件夹下</span></span><br><span class="line">pyinstaller -F file.py</span><br><span class="line"></span><br><span class="line"><span class="meta"> #</span><span class="bash"> -F 打包出来是一个可执行文件，不然的话是多个，没有把包封装进去，需要pythonu环境来运行</span></span><br></pre></td></tr></table></figure><p>=======</p><ul><li>终端切换</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chsh -s /bin/zsh</span><br><span class="line">chsh -s /bin/bash</span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换后重启完成</span></span><br></pre></td></tr></table></figure><h2 id="一些错误"><a href="#一些错误" class="headerlink" title="一些错误"></a>一些错误</h2><img src="/2020/12/15/python/截屏2020-12-25 下午10.44.40.png" alt="截屏2020-12-25 下午10.44.40" style="zoom: 67%;">    <ul><li>字典类型的键是不可变的，可以使用数字、字符串或元组充当，但是不能使用列表作为键值</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Anaconda&quot;&gt;&lt;a href=&quot;#Anaconda&quot; class=&quot;headerlink&quot; title=&quot;Anaconda&quot;&gt;&lt;/a&gt;Anaconda&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;link&quot; href=&quot;https://www.jiansh</summary>
      
    
    
    
    <category term="notebook" scheme="https://jieyang-wei.github.io/categories/notebook/"/>
    
    
    <category term="编程语言" scheme="https://jieyang-wei.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="python" scheme="https://jieyang-wei.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>gdb调试</title>
    <link href="https://jieyang-wei.github.io/2020/12/14/gdb%E8%B0%83%E8%AF%95/"/>
    <id>https://jieyang-wei.github.io/2020/12/14/gdb%E8%B0%83%E8%AF%95/</id>
    <published>2020-12-14T09:56:55.000Z</published>
    <updated>2020-12-30T11:28:27.571Z</updated>
    
    <content type="html"><![CDATA[<p>制作链接库的目的是希望别人使用我们已经实现的功能，但又不希望别人看到我们的源代码<br><code>Linux</code>下的静态链接库是以<code>.a</code>结尾的二进制文件，它作为程序的一个模块，在链接期间被组合到程序中。和静态链接库相对的是动态链接库（.so文件），它在程序运行阶段被加载进内存。</p><p>静态库生成步骤</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1 对所有源文件，只编译不链接</span></span><br><span class="line">gcc -c test.c</span><br><span class="line"><span class="comment">//2 利用ar命令，生成库文件</span></span><br><span class="line">ar rcs libtest.a test.o</span><br></pre></td></tr></table></figure><p><code>ar</code>是 Linux 的一个备份压缩命令，它可以将多个文件打包成一个备份文件（也叫归档文件），也可以从备份文件中提取成员文件，最常见的用法是将目标文件打包为静态链接库。</p><p>对参数的说明：</p><ul><li>r：用来替换库中已有的目标文件，或者加入新的目标文件。</li><li>c：表示创建一个库。不管库否存在，都将创建。</li><li>s：用来创建目标文件索引，这在创建较大的库时能提高速度。</li></ul><ul><li>-lm：表示连接系统的数学库libm.a<ul><li>需要放在库之后，不然找不到</li></ul></li></ul><p>Linux 下动态链接库（shared object file，共享对象文件）的文件后缀为.so，它是一种特殊的目标文件（object file），可以在程序运行时被加载（链接）进来。</p><p>使用动态链接库的优点是：程序的可执行文件更小，便于程序的模块化以及更新，同时，有效内存的使用效率更高</p><ol><li>如果想创建一个动态链接库，可以使用 GCC 的-shared选项。输入文件可以是源文件、汇编文件或者目标文件。</li><li>另外还得结合<code>-fPIC</code>选项。<code>-fPIC</code>选项作用于编译阶段，告诉编译器产生与位置无关代码（Position-Independent Code）；这样一来，产生的代码中就没有绝对地址了，全部使用相对地址，所以代码可以被加载器加载到内存的任意位置，都可以正确的执行。这正是共享库所要求的，共享库被加载时，在内存的位置不是固定的。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 从源文件生成动态链接库：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -fPIC -shared func.c -o libfunc.so</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从目标文件生成动态链接库：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -fPIC -c func.c -o func.o</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -shared func.o -o libfunc.so</span></span><br><span class="line"> * -fPIC 选项作用于编译阶段，在生成目标文件时就得使用该选项，以生成位置无关的代码。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;制作链接库的目的是希望别人使用我们已经实现的功能，但又不希望别人看到我们的源代码&lt;br&gt;&lt;code&gt;Linux&lt;/code&gt;下的静态链接库是以&lt;code&gt;.a&lt;/code&gt;结尾的二进制文件，它作为程序的一个模块，在链接期间被组合到程序中。和静态链接库相对的是动态链接库（.s</summary>
      
    
    
    
    <category term="course" scheme="https://jieyang-wei.github.io/categories/course/"/>
    
    
    <category term="linux" scheme="https://jieyang-wei.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>区块链</title>
    <link href="https://jieyang-wei.github.io/2020/12/14/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    <id>https://jieyang-wei.github.io/2020/12/14/%E5%8C%BA%E5%9D%97%E9%93%BE/</id>
    <published>2020-12-14T09:47:42.000Z</published>
    <updated>2021-01-04T08:14:19.630Z</updated>
    
    <content type="html"><![CDATA[<h1 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h1><ul><li>一个特殊的历史不可更改的链表<strong>数据结构</strong></li><li>一个电子记账本，以比特币和其他密码加密货币进行的交易公开地、按照日期顺序记录其中</li></ul><blockquote><p>总的来说，它是一个公开的数据库，新的数据存储在一个称为区块的容器中，并且附加到一个“不可变”的链条（即区块链）上，链条上还有以前附加的数据。</p><blockquote><p>这里的“不可变”指的是以前的数据一旦附加到链条上，后面是不可更改的。</p></blockquote></blockquote><p>结构：</p><img src="/2020/12/14/%E5%8C%BA%E5%9D%97%E9%93%BE/IMG_DD562F6FCFED-1.jpeg" alt="IMG_DD562F6FCFED-1" style="zoom: 50%;"><ul><li>genesis block：创世区块</li><li><strong>header</strong><ul><li>256bit：一串随机数nonce，需要使得整个区块信息取hash后值小于target（即前面有多少个0）</li><li>SHA256-1：前一个区块的hash值，创世区块没有前一个区块，所以该值为全0</li><li>SHA256-2：body数据的hash值</li></ul></li><li><strong>body</strong>：存储数据</li></ul><h1 id="crypto-currency（加密货币）"><a href="#crypto-currency（加密货币）" class="headerlink" title="crypto-currency（加密货币）"></a>crypto-currency（加密货币）</h1><ul><li><p>区块链是一种数据结构，而下面所讲的比特币和以太坊都是使用区块链这种数据结构实现的应用</p></li><li><p><a class="link" href="https://bitcoin.org/bitcoin.pdf">比特币白皮书<i class="fas fa-external-link-alt"></i></a></p></li><li><p><a class="link" href="https://www.cnblogs.com/coderzjz/p/13788649.html">别人好的笔记<i class="fas fa-external-link-alt"></i></a></p></li></ul><h1 id="比特币-BTC"><a href="#比特币-BTC" class="headerlink" title="比特币 BTC"></a>比特币 BTC</h1><p><strong>前提：</strong>大部分算力掌握在诚实的矿工手里</p><h2 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h2><h3 id="1-crypto-graphic-hash-function"><a href="#1-crypto-graphic-hash-function" class="headerlink" title="1. crypto graphic hash function"></a>1. crypto graphic hash function</h3><p>特性：</p><ol><li><p>collision resistance：抗碰撞性</p></li><li><p>hiding：x可以算出H(x)，但H(x)不能反推出x，即这个hash函数不会泄露x</p><ul><li><p>需要满足，不然可以通过蛮力求解</p><ol><li><p>输入空间大</p></li><li><p>均匀分布</p></li></ol></li><li><p>digital commitment / digital equivalent of a sealed envelope：密封预测结果</p></li></ul></li><li><p>puzzle friendly：H(x)是事先不可预测的</p></li></ol><p>H(block header) &lt;= target 目标域值（nBits：目标域值编码）</p><p>proof of work POW，工作证明</p><p>difficult to solve, but easy to verify</p><h3 id="2-签名"><a href="#2-签名" class="headerlink" title="2. 签名"></a><strong>2. 签名</strong></h3><p>账户 - public key, private key</p><ul><li>来源于非对称加密：asymmetric encryption algorithm</li><li>最早期是对称加密，symmetric encryption algorithm，但这样密钥分发是一个问题，所以有了公私钥</li></ul><p>a good source of randomness：使得生成的公钥相同的几率微乎其微</p><p><strong>SHA-256</strong>（Secure Hash Algorithm）</p><ul><li><a class="link" href="https://blog.csdn.net/u011583927/article/details/80905740">原理简介<i class="fas fa-external-link-alt"></i></a></li><li>和md5加密的效果一样，但是SHA-256更加的安全</li><li>都只能算是签名，加密算法是既能加密也能解密的算法，而签名就仅仅是起到校验和的作用</li></ul><hr><p>Mac, Linux hash命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> md5 file.txt    <span class="comment"># md5校验和</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> shasum -a 1 /tmp/hello.txt      <span class="comment"># SHA-1校验和</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> shasum -a 256 /tmp/hello.txt    <span class="comment"># SHA-256校验和</span></span></span><br><span class="line"><span class="meta"> #</span><span class="bash"> -a --algorithm</span></span><br></pre></td></tr></table></figure><img src="/2020/12/14/%E5%8C%BA%E5%9D%97%E9%93%BE/截屏2020-12-27 上午10.44.14.png" alt="截屏2020-12-27 上午10.44.14" style="zoom:60%;"> <hr><h2 id="BTC-数据结构"><a href="#BTC-数据结构" class="headerlink" title="BTC 数据结构"></a>BTC 数据结构</h2><blockquote><p>区块链仅仅是一个<strong>数据结构</strong>，BTC是使用区块链这种数据结构实现的应用</p></blockquote><h3 id="hash-point"><a href="#hash-point" class="headerlink" title="hash point"></a>hash point</h3><ul><li>无环链表都可以用 hash point 代替普通的point</li></ul><ol><li>区块链</li></ol><p><img src="/2020/12/14/%E5%8C%BA%E5%9D%97%E9%93%BE/IMG_0230-7744726.jpg" alt="IMG_0230"></p><ul><li><p>block chain is a linked list using hash pointers：用hash point 代替普通的指针</p><ul><li><p>genesis block：创世区块            most recent blcok：最近产生的区块      </p><p>H( )：hash point</p></li><li><p>tamper-evident log：最后一个hash值就能检查整个链表是否被修改过</p></li></ul></li></ul><blockquote><p>Merkle tree 不是区块链的信息存储结构，而是BTC使用过程中用到的数据结构，在节点验证交易正确性时，使用到的一个结构而已</p></blockquote><ol start="2"><li>Merkle tree<ul><li>与binary tree的区别<ol><li>用hash point代替普通的指针</li><li>只要记录<code>root hash</code>，就能检测对整棵树的修改</li></ol></li><li>block header：只保存<code>root hash</code>，</li><li>block body：保存所有的交易信息<code>tx</code>等</li><li>作用：<ul><li>提供<code>merkle proof</code></li></ul></li></ul></li></ol><blockquote><p><img src="/2020/12/14/%E5%8C%BA%E5%9D%97%E9%93%BE/IMG_231E499E57D8-1.jpeg" alt="IMG_231E499E57D8-1"></p><ul><li><strong>proof of membership</strong>：轻节点想知道黄色交易是否在<code>merkle tree</code>上，只有一个<code>root hash</code>(在<code>block header</code>里面)</li></ul><ol><li>轻节点向某个全节点发出证明请求，请求一个能证明黄色交易包括在<code>merkle tree</code>里面的一个<code>merkle proof</code></li><li>全节点收到请求，会将图中红色的三个<code>hash值</code>发送给这个轻节点</li><li><strong>从下往上</strong>：轻节点会算出黄色交易的hash值绿1，绿1和红1一起算出hash值绿2，绿2和红2算出绿3，绿3和红3一起算出<code>root hash</code></li><li>轻节点比较这个算出来的<code>root hash</code>和<code>block header</code>的hash值</li></ol><blockquote><p><strong>注意</strong>：我们只能验证绿色的部分，不能验证红色部分的hash值</p></blockquote><blockquote><ul><li>如果考虑通过调整红色的部分，使得被篡改后的绿色的部分算出来hash不变，是不实际的</li><li>因为<code>Collision resistance</code>性质，这样的操作相当于人为的制造hash碰撞</li></ul></blockquote><ul><li><strong>proof of non-memership</strong>：轻节点想证明某个交易不存在</li></ul><ol><li></li></ol></blockquote><h2 id="数字货币"><a href="#数字货币" class="headerlink" title="数字货币"></a>数字货币</h2><ul><li>使用公私钥，非对成加密算法<ol><li>Double spending attack，双花攻击 - 花两次攻击：数字货币本质上是一个文件，带签名的数字货币可以复制</li></ol></li><li>每个数字货币上带编号（防范DSA，但是是中心化的）<ul><li>bank维护一个数据库，每个编号的数字货币在谁手里</li><li>每次验证数字货币的签名和编号，这个货币有没有发过，被谁花过</li></ul></li></ul><p><strong>BTC安全性</strong></p><ol><li><strong>密码学</strong>：别人没有私钥，不能伪造签名<ul><li>前提：系统中拥有大多数算力的矿工是好的，是遵守协议的，不会接受没有合法签名的交易</li></ul></li><li><strong>共识机制</strong>：</li></ol><h3 id="BTC解决去中心化的数字货币发行问题"><a href="#BTC解决去中心化的数字货币发行问题" class="headerlink" title="BTC解决去中心化的数字货币发行问题"></a>BTC解决去中心化的数字货币发行问题</h3><ul><li><img src="/2020/12/14/%E5%8C%BA%E5%9D%97%E9%93%BE/IMG_9CCCEC7F3445-1.jpeg" alt="IMG_9CCCEC7F3445-1"><ul><li>交易中A的公钥表明是钱是哪儿来的，但是要将A和他的公钥联系在一起，不然E可以用自己的公钥冒充A的，再用自己的私钥签名<ul><li><strong>coinbase tx</strong>：需要验证A-&gt;B的钱的前一个交易（金币来源）中A的公钥，即金币来源的输出脚本，和交易中提供的A的公钥，即交易的输入脚本拼在一起合成一个程序，看能不能顺利执行</li></ul></li></ul></li></ul><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><h5 id="区块结构"><a href="#区块结构" class="headerlink" title="区块结构"></a>区块结构</h5><img src="/2020/12/14/%E5%8C%BA%E5%9D%97%E9%93%BE/IMG_9EF94BC347FE-1.jpeg" alt="IMG_9EF94BC347FE-1" style="zoom:70%;"> <ul><li><strong>Block Header</strong><ul><li>区块信息：<ul><li>version：比特币版本</li><li>时间戳等</li></ul></li><li>hash of previous block header：指向前一个区块的指针（只算header的hash）<ul><li>创世区块的<code>previous hash</code>为0</li></ul></li><li>merkle root hash：整棵merkle tree的根hash值<ul><li>保证了<code>transaction list</code>是无法被篡改的</li></ul></li><li>nonce：随机数，256bits<ul><li>target：挖矿难度目标域值</li></ul></li></ul></li><li><strong>Block Body</strong><ul><li>transaction list</li><li>只存交易信息</li></ul></li></ul><h5 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h5><ul><li>full node（fully validating node，全节点）：</li><li>light node（light weight node，轻节点）：<ul><li>一般无法验证交易的合法性，只是利用区块链的信息做一个查询</li></ul></li></ul><h4 id="Consensus-in-BitCoin，比特币共识"><a href="#Consensus-in-BitCoin，比特币共识" class="headerlink" title="Consensus in BitCoin，比特币共识"></a>Consensus in BitCoin，比特币共识</h4><p>distributed consensus，分布式共识</p><ul><li>impossibility result：<ul><li>FLP：在一个异步的系统里（asynchronous），网络时延没有上线，哪怕系统中只要有一个用户是faulty的，都没有办法达成共识</li><li>CAP Theorem：以下三个性质中，最多满足两种<ul><li>一致性Consistency、可用性Availability、分区容错性Partition tolerance</li></ul></li></ul></li></ul><p>membership</p><p>hyperledger</p><p>联盟链 - fabric</p><p>sybil attacl，女巫攻击：找一个超级计算机，不停的产生用户节点，当总数超过一半时，就得到了这个链的控制权</p><ul><li>coinbase transaction：<ul><li>通过算例投票 puzzle friendly</li><li>hash rate</li><li>nonce</li></ul></li></ul><p>mining - 挖矿：比特币争夺记账权</p><ul><li>digital gold</li><li>miner</li></ul><h4 id="BTC系统实现"><a href="#BTC系统实现" class="headerlink" title="BTC系统实现"></a>BTC系统实现</h4><h5 id="transaction-based-ledger，基于交易的账本模式"><a href="#transaction-based-ledger，基于交易的账本模式" class="headerlink" title="transaction-based ledger，基于交易的账本模式"></a>transaction-based ledger，基于交易的账本模式</h5><ul><li>每个交易需要说清楚，币是从哪儿来的，它没有账户的概念</li></ul><p>全节点维护一个数据结构：</p><ul><li><p>UTXO，unspent Transaction Output：还没有被花掉的交易的输出集合</p><img src="/2020/12/14/%E5%8C%BA%E5%9D%97%E9%93%BE/IMG_1019233284AC-1.jpeg" alt="IMG_1019233284AC-1" style="zoom:50%;"><ul><li><strong>包括</strong> 2个数据就能定位UTXO的输出：<ol><li>产生这个输出的交易的hash 值</li><li>这个输出是交易中的第几个输出</li></ol></li><li><strong>作用</strong>：检测Double Spending<ul><li>total inputs = total outputs：i可以略大于o，中间的<code>transaction fee</code>可能给了拥有记账权的区块</li><li>transaction fee：大约只有零点零几个币</li></ul></li></ul></li></ul><p>account-based ledger，基于账户的模式</p><ul><li>系统需要显示的记录每个账户有多少个币，如以太坊ß</li></ul><h5 id="Bernoulli-trial"><a href="#Bernoulli-trial" class="headerlink" title="Bernoulli trial"></a>Bernoulli trial</h5><ul><li><p>a random experiment with binary outcome</p></li><li><p>每次求解nonce可以看作是Bernoulli trial</p></li></ul><p><strong>Bernoulli process</strong>：a sequence of independent Bernoulli</p><ul><li>大量实践的Bernoulli trial就组成了</li><li>性质：<ul><li>memoryless，无记忆的：实验结果和之前的实验结果是没有关系的</li></ul></li></ul><p>Poisson process：</p><p>exponential distribution，出块时间：服从指数分布</p><img src="/2020/12/14/%E5%8C%BA%E5%9D%97%E9%93%BE/IMG_9A528FE35443-1.jpeg" alt="IMG_9A528FE35443-1" style="zoom:40%;"><ul><li>无记忆性：<ul><li>memory less：将来挖多少时间与之前已经挖了多少时间没有关系，即使等了10mins，下一挖到矿的时间仍然指数分布，平均是10mins</li><li>process free：过去的process是没用的，对挖矿公平性的保证</li></ul></li></ul><p>出块奖励</p><p>geometric series 几何级数</p><ul><li>BTC总数：21万 * 50 + 21万 * 25 + 21万 * 12.5 + ····<ul><li>= 21万 * 50 *（1 + 1/2 + 1/4 + ····）[等比求和，逐年减半]</li><li>= 2100万 [过去到未来的BTC总数]</li></ul></li></ul><p>Bitcoin is secured by mining</p><p>分岔攻击</p><p>回滚交易 - Double Spending Attack</p><ul><li>多等几个区块/确认 confirmation</li></ul><p>irrevocable ledger，不可篡改的账本</p><ul><li>不可篡改是该旅行的保证</li></ul><p>zero confirmation</p><ul><li>交易刚发出去，没有写进区块</li></ul><p>selfish mining</p><ul><li>我先不发布，等到挖到足够多的区块了，再一起发布，盖过其他的 - 分岔攻击</li><li>自己挖到两个的时候，不发布，等别人挖到一个，再一起发布，别人的那个就白发了</li><li>风险：<ul><li>不一定抢的赢别人</li></ul></li></ul><h4 id="BTC网络"><a href="#BTC网络" class="headerlink" title="BTC网络"></a>BTC网络</h4><p>BTC所有节点平等，没有super/master node</p><p>协议：</p><ul><li>application layer：BitCoin Block chain</li><li>network layer：P2P Overlay Network</li></ul><p>设计原则：simple简单，robot鲁棒，but not efficient不是高效</p><ul><li><p>消息节点：flooding方式</p></li><li><p>邻居节点：选取是随机的，不考虑底层的拓扑结构</p><ul><li>增强了鲁棒性，但是牺牲了效率</li></ul></li><li><p>每个节点维护一个等待上链的消息集合</p><ul><li>冲突交易</li></ul></li></ul><p>best effort，</p><blockquote><p>区块链是一种数据结构，而节点是在基于网络应用时，每一个连入区块的设备，比如手机就是轻节点，而矿池(后面有讲)就是一个全节点，保存所有的信息 - 现在BTC大约有100多G</p></blockquote><p><strong>全节点</strong>：保存所有的信息</p><ul><li>一直在线</li><li>在本地硬盘上维护完整的区块链信息</li><li>在内存里维护UTXO集合，以便快速检验交易的正确性</li><li>监听比特币网络上的交易信息，验证每个交易的合法性</li><li>决定哪些交易会被打包到区块里</li><li>监听别的矿工挖出来的区块，验证其合法性</li><li>挖矿：<ul><li>决定沿着那条链挖下去<ul><li>缺省情况下选择最长的链</li></ul></li><li>当出现等长的分岔的时候，选择哪一个分岔<ul><li>缺省情况下选择第一个发现的</li></ul></li></ul></li></ul><p><strong>轻节点</strong>：只保存block header（如手机上）</p><ul><li>不是一直在线</li><li>不用保存整个区块链，只要保存每个区块的块头</li><li>不用保存全部交易，只保存与自己相关的交易</li><li>无法检测大多数交易的合法性，只能检验与自己相关的那些交易的合法性</li><li>无法检测网上发布的区块的正确性<ul><li>因为无法知道区块里的交易是不是合法的</li></ul></li><li>可以验证挖矿的难度<ul><li>挖矿时计算hash值只需要用到块头的信息</li></ul></li><li>只能检测那个是最长的链，不知道哪个是最长的合法链<ul><li>只能知道这个链上的区块挖矿难度时符合要求的，但是无法验证每个区块里交易的合法性</li></ul></li></ul><h2 id="挖矿"><a href="#挖矿" class="headerlink" title="挖矿"></a>挖矿</h2><p>H(block header) &lt;= target</p><ul><li>target越小，难度越大</li><li>需要调整target值，使得出块时间保持稳定（BTC大约为10mins）</li></ul><p>hash算法：SHA-256</p><ul><li>取值空间：2^256</li><li>block header里面存nBits，只有4字节<ul><li>target有256位，32字节</li></ul></li></ul><h3 id="挖矿难度"><a href="#挖矿难度" class="headerlink" title="挖矿难度"></a>挖矿难度</h3><img src="/2020/12/14/%E5%8C%BA%E5%9D%97%E9%93%BE/IMG_3A7CCA25FE75-1.jpeg" alt="IMG_3A7CCA25FE75-1" style="zoom:50%;"><ul><li>difficulty_1_target：挖矿难度等于1时的目标域值</li><li>1是最低难度</li><li>不调整target的话，出块时间会越来越短<ul><li>分岔，几个用户同时出块</li><li>系统不容易统一</li><li>51% attack：将大部分算力用来放在攻击的回滚区块的链上</li></ul></li></ul><p>orphan block</p><p>uncle reward</p><h3 id="难度调整"><a href="#难度调整" class="headerlink" title="难度调整"></a>难度调整</h3><p>每2016个区块调整目标域值，大约为2周（2016 * 10 / 60 * 24 = 14）</p><ul><li>调整公式：<img src="/2020/12/14/%E5%8C%BA%E5%9D%97%E9%93%BE/IMG_E4D6502FBD91-1.jpeg" alt="IMG_E4D6502FBD91-1" style="zoom:40%;"><ul><li>如果实际时间超过了2周，那么平均出块时间超过了10mins，这个时候出块难度需要调整的低一点（右边分式大于1，target变大）</li></ul></li><li><img src="/2020/12/14/%E5%8C%BA%E5%9D%97%E9%93%BE/IMG_D3AE8A16D3B4-1.jpeg" alt="IMG_D3AE8A16D3B4-1" style="zoom:80%;"></li></ul><h3 id="设备"><a href="#设备" class="headerlink" title="设备"></a>设备</h3><p><strong>早期1代 - CPU</strong>：</p><ul><li>随着挖矿难度增加，性价比极低</li><li>计算机中大部分内存都是闲置的，挖矿只用到了其中很少一部分内存</li><li>大部分不见也是闲置的，挖矿中hash值的计算只用到了通用计算机cpu中很少一部分指令</li><li>硬盘和其他资源也是闲置的</li></ul><blockquote><p> GPU主要用于大规模的并行计算，如深度学习</p></blockquote><p><strong>2代 - GPU</strong>：</p><ul><li>效率得到了很大的提高</li><li>但gpu主要是为了并行计算设计的，其中仍然有很多部件是闲置的，所以也不划算<ul><li>如用于浮点数运算的部件</li></ul></li><li>对于现在的挖矿的难度，GPU的算力已经不够了</li></ul><blockquote><p>ASIC：Application Specific Integrated  Circuit</p></blockquote><p><strong>现在 - ASIC芯片</strong></p><ul><li>专门为了BTC挖矿<strong>计算hash值</strong>所设计的，生产周期长（不能做全节点其他工作）</li><li>为某种加密货币设计的芯片，只能挖着一种货币（除非两种货币用同一个mining puzzle）<ul><li>merge mining：一个新的货币发行时，为了解决冷启动问题，吸引更多的用户，故意用一个已有的mining puzzle</li></ul></li><li><strong>Alternative mining puzzle</strong><ul><li>有的货币会设计这种puzzle，达到下面的效果</li><li>ASIC resistance：抗ASIC芯片化，为了让通用CPU也能参与挖矿</li></ul></li></ul><h3 id="矿池"><a href="#矿池" class="headerlink" title="矿池"></a>矿池</h3><ul><li>一个全节点去驱动很多的矿机（一个矿工负责全部的工作比较累）</li></ul><img src="/2020/12/14/%E5%8C%BA%E5%9D%97%E9%93%BE/IMG_FFBC17D6F168-1.jpeg" alt="IMG_FFBC17D6F168-1" style="zoom:60%;"><ul><li><p>矿主：其他全节点的指责</p><ul><li>监听网上的交易，将这些交易组织打包成候选区块</li><li>同时关注是否有其他节点抢先发布了区块，如果有就需要作出调整等</li></ul></li><li><p>矿工：只负责计算hash值</p></li><li><p><strong>好处</strong>：</p><ul><li><p>减轻了矿工的工作量</p></li><li><p>解决单个矿工收入不稳定问题，以下两种方式</p><ol><li>像大型数据中心一样，矿池下有成千上万的矿机，属于一个机构，好分配</li><li>分布式，矿机来自不用的厂商，需要通过通讯协议与矿主联系，之后一起分红</li></ol><blockquote><p>如何解决矿工分红问题 - 工作量证明：</p><ul><li>降低挖矿难度，矿工提交 - share，almost valid block - 只能用来证明做了多少工作</li></ul></blockquote></li></ul></li><li><p>大型矿池的<strong>弊病</strong>：使得51%的攻击更加容易了</p><ul><li><strong>分叉攻击</strong>：对已经经过6次确认的交易分叉，利用51%算力将交易记录回滚。<ul><li>矿工只能计算哈希值，并不知道区块包含哪些交易，区块链状况是什么。所以，这些“群众”是无知的，容易被利用（《乌合之众》当中提出的观点，大多数人真的就能掌握真理吗？）。</li><li>此外，51%攻击只是一个概率问题，并非达到51%算力就能发动攻击，不能达到就无法发动攻击。此外，矿池本身算力也是在不断变化的。</li></ul></li><li><strong>封锁交易（Boycott）</strong>：<ul><li>假如攻击者不喜欢某个账户A，不想让A的交易上区块链，在监听到有其他人将A的交易发布到区块链上时，立刻发动分叉攻击，使A所在链无法成为”最长合法链“。这样，便实现了对A账户的封锁。</li><li>像不像即当裁判又当运动员？”堂下何人状告本官“？</li></ul></li><li><strong>盗币</strong>（将他人账户BTC转走）<ul><li>这个是<strong>不可能</strong>的，因为其并没有他人账户私钥。如果依仗算力强，强行将没有签名的转账发布到区块链，正常节点不会认为其合法，这样，即使这条链再长，其他人也不会认为其是最长合法链。</li></ul></li><li>on demand computing  -&gt;  on demand mining（潜在危害）</li></ul></li></ul><h2 id="BTC-使用的脚本语言"><a href="#BTC-使用的脚本语言" class="headerlink" title="BTC 使用的脚本语言"></a>BTC 使用的脚本语言</h2><ul><li>基于栈的编程语言：很简单，只有一个堆栈</li></ul><h3 id="交易结构"><a href="#交易结构" class="headerlink" title="交易结构"></a>交易结构</h3><h3 id="交易的输入"><a href="#交易的输入" class="headerlink" title="交易的输入"></a>交易的输入</h3><h3 id="交易的输出"><a href="#交易的输出" class="headerlink" title="交易的输出"></a>交易的输出</h3><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><blockquote><p>早期是将输入输出脚本拼接到一起执行</p><p>后面处于安全考虑，输入输出两者分别执行，都为非0(True)则成功</p></blockquote><p><strong>脚本形式</strong></p><ol><li><p>P2PK ，Pay to Public Key</p><ul><li>input script<ol><li><strong>PUSHDATA(SIG)**：将输入里提供的</strong>签名**压入栈</li></ol></li><li>output script<ol start="2"><li><strong>PUSHDATA(PubKey)**：将输出里提供的</strong>公钥**压入栈</li><li><strong>CHECKSIG</strong>：将栈顶的两个元素弹出来，用公钥检查签名是否正确<ul><li>正确则返回True，验证通过，否则执行出错，交易是非法的</li></ul></li></ol></li></ul></li><li><p>P2PKH，Pay to Public Key Hash</p><ul><li>input script<ol><li><strong>PUSHDATA(SIG)**：将输入里提供的</strong>签名**压入栈</li><li><strong>PUSHDATA(PubKey)**：将</strong>公钥**压入栈</li></ol></li><li>output script<ol start="3"><li><strong>DUP</strong>：将栈顶的元素复制一遍<ul><li>栈顶多了一个<strong>公钥</strong></li></ul></li><li><strong>HASH160</strong>：将栈顶元素弹出，取hash，再将此hash值压入栈<ul><li>此时栈顶是<strong>公钥的hash</strong></li></ul></li><li><strong>PUSHDATA(PubKeyHash)**：将输出中提供的</strong>公钥的hash**值压入栈<ul><li>此时栈顶有两个公钥的hash</li></ul></li><li><strong>EQUALVERIFY</strong>：弹出栈顶的两个元素，比较是否相等<ul><li>防止有人冒名顶替，用自己的公钥冒充收款人的公钥</li><li>相等的话栈顶的两个<strong>PubKeyHash</strong>就消失了</li></ul></li><li><strong>CHECKSIG</strong>：将栈顶的两个元素弹出来，用公钥检查签名是否正确<ul><li>正确则返回True，验证通过，否则执行出错，交易是非法的</li></ul></li></ol></li></ul><blockquote><p>区别：第二种没有在输出中直接给出收款人的公钥，而是给出公钥的hash。公钥则是在输入脚本中给出的，其他的操作都是为了验证正确性。</p><p>第二种更常用</p></blockquote></li><li><p>P2SH，Pay to Script Hash</p><blockquote><p>采用BIP16的方案</p><p>输出脚本不提供收款人公钥的hash，而是收款人提供的脚本的hash</p><ul><li>redeemScript：赎回脚本</li></ul></blockquote><ul><li>input script要给出一些签名（数目不定）及一段序列化的redeemScript<ol><li>验证序列化的<strong>redeemScript</strong>是否与<strong>output script</strong>中的hash值匹配</li><li>反序列化并执行<strong>redeemScript</strong>，验证<strong>input script</strong>中给出的签名是否正确</li></ol></li><li>output script</li></ul></li></ol><ul><li>第一阶段：</li></ul><ul><li>第二阶段：</li></ul><h1 id="以太坊-ETC"><a href="#以太坊-ETC" class="headerlink" title="以太坊 ETC"></a>以太坊 ETC</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;区块链&quot;&gt;&lt;a href=&quot;#区块链&quot; class=&quot;headerlink&quot; title=&quot;区块链&quot;&gt;&lt;/a&gt;区块链&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;一个特殊的历史不可更改的链表&lt;strong&gt;数据结构&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;一个电子记账本，以比特币和其他</summary>
      
    
    
    
    <category term="notebook" scheme="https://jieyang-wei.github.io/categories/notebook/"/>
    
    
    <category term="BTC" scheme="https://jieyang-wei.github.io/tags/BTC/"/>
    
  </entry>
  
  <entry>
    <title>版本管理</title>
    <link href="https://jieyang-wei.github.io/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"/>
    <id>https://jieyang-wei.github.io/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/</id>
    <published>2020-12-14T07:55:40.000Z</published>
    <updated>2020-12-15T05:40:02.286Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h3 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h3><ol><li><p><strong>本地版本控制系统</strong>（Version Control Systems，简称VCS）</p><ul><li><p>大多都是采用某种简单的数据库来记录文件的历次更新差异</p></li><li><p>最流行的：<code>RCS</code></p><ul><li>工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，可以重新计算出各个版本的文件内容。”</li></ul></li></ul></li><li><p><strong>集中化版本控制系统</strong>（Centralized Version Control Systems，简称 CVCS ）</p><ul><li>诸如CVS、Subversion以及perforce等</li><li>容易单点故障、丢失所有历史更新记录的风险</li></ul></li><li><p><strong>分布式版本控制系统</strong>（Distributed Version Control System，简称 DVCS）</p><ul><li>像Git、Mercurial、Bazaar以及Darcs</li><li>客户端并不只提取最新版本的文件快照， 而是把代码仓库完整地镜像下来，包括完整的历史记录</li></ul></li></ol><ul><li>大部分系统以文件变更列表的方式存储信息，这类系统（CVS、Subversion、Perforce、Bazaar等）将他们存储的信息看作是一组基本文件和每个文件随时间逐步累积的差异（**基于差异[delta-based]**的版本控制）</li><li>Git 更像是把数据看作是对<strong>小型文件系统</strong>的一系列快照。 在 Git 中，每当你提交更新或保存项目状态时，它基本上就会对当时的全部文件创建一个快照并保存这个快照的索引。 为了效率，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 <strong>快照流</strong></li></ul><p><strong>git</strong>：分布式版本控制系统，c语言开发</p><p><strong>免费集中式版本控制</strong>：CVS、SVN  —  速度慢，且需要联网</p><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p><a class="link" href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">廖雪峰<i class="fas fa-external-link-alt"></i></a></p><p>电子书：progit_v2.1.54</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>git校验和机制</strong>：<strong>SHA-1散列</strong>，这是一个由 40 个十六进制字符（0-9 和 a-f）组成的字符串，基于 Git 中文件的内容或目录结构计算出来</p><h4 id="三种状态"><a href="#三种状态" class="headerlink" title="三种状态"></a>三种状态</h4><ul><li><strong>已提交（committed）</strong>：表示数据已经安全地保存在本地数据库中</li><li><strong>已修改（modified）</strong>：表示修改了文件，但还没保存到数据库中</li><li><strong>已暂存（staged）</strong>：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中</li></ul><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/截屏2020-12-09 下午2.58.04.png" alt="截屏2020-12-07 下午3.29.20"><ul><li>工作区：对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改</li><li>暂存区：是一个文件，保存了下次将要提交的文件列表信息，一般在 Git 仓库目录中。 按照 Git 的术语叫做“索引”，不过一般说法还是叫“暂存区</li><li>git目录：Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，复制的就是这里的数据</li></ul><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><ol><li>在工作区中修改文件。</li><li>将你想要下次提交的更改选择性地暂存，这样只会将更改的部分添加到暂存区。</li><li>提交更新，找到暂存区的文件，将快照永久性存储到 Git 目录。</li></ol><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install git-all</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看版本</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git --version</span></span><br></pre></td></tr></table></figure><p>工具目录结构</p><ul><li>git自带一个<code>git config</code>的工具来帮助设置，这些变量存储在三个不同的位置</li></ul><ol><li>/etc/gitconfig 文件：包含系统上每一个用户及他们仓库的通用配置。 如果在执行 git config 时带上 –system 选项，那么它就会读写该文件中的配置变量。 （由于它是系统配置文件，因此你需要管理员或超级用户权限来修改它。）</li><li>~/.gitconfig 或 ~/.config/git/config 文件：只针对当前用户。 你可以传递 –global 选项让 Git 读写此文件，这会对你系统上所有的仓库生效</li><li>当前使用仓库的 Git 目录中的 config 文件（即 .git/config）：针对该仓库。 你可以传递 –local 选项让 Git 强制读写此文件，虽然默认情况下用的就是它。。 （当然，你需要进入某个 Git 仓库中才能让该选项生效。）<ul><li>每一个级别会覆盖上一级别的配置，所以 .git/config 的配置变量会覆盖 /etc/gitconfig 中的配置变量</li></ul></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --list --show-origin  <span class="comment"># 查看所有配置以及他们所在文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置用户信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.name <span class="string">&quot;Weijieyang&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.email <span class="string">&quot;name@mail.com&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> git config 选项列表</span></span><br><span class="line"> * --list 列出所有 Git 当时能找到的配置</span><br><span class="line"> * --global 配置所有的项目</span><br></pre></td></tr></table></figure><ul><li>git工作目录下每一个文件只有两种状态<ol><li><strong>已跟踪</strong>：指那些被纳入了版本控制的文件，在上一次快照中有它们的记录。即git已经知道的文件</li><li><strong>未跟踪</strong>：其他文件</li></ol></li></ul><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="版本库（Repository）"><a href="#版本库（Repository）" class="headerlink" title="版本库（Repository）"></a>版本库（Repository）</h3><p>工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。</p><p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</p><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/截屏2020-12-07 下午3.29.20.png" alt="截屏2020-12-07 下午3.29.20" style="zoom:50%;"><ol><li><strong>创建版本库</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br></pre></td></tr></table></figure><ul><li>到需要版本管理的目录下</li><li>初始化后会在目录下形成一个<code>.git</code>文件，此文件为隐藏文件，需要使用命令<code>ls -a</code>查看</li></ul><ol start="2"><li><strong>使用步骤</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add file</span> </span><br></pre></td></tr></table></figure><ul><li>添加本地修改后的文件到暂存区</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"> * -s/--short 更为紧凑的输出展示效果</span><br></pre></td></tr></table></figure><ul><li>时刻掌握仓库当前情况，查看未被提交的修改，包括工作区和暂存区</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&#x27;注释&#x27;</span></span></span><br></pre></td></tr></table></figure><ul><li>将暂存区的修改提交到版本库中</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&#x27;注释&#x27;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add filemore</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend</span></span><br></pre></td></tr></table></figure><ul><li>第一次提交后发现漏了几个文件，可以使用<code>--amend</code>添加，此次提交将会替代上一次的提交，上一次的提交将不会出现在版本历史中ß</li></ul><ol start="3"><li><strong>版本管理</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line"> * —-pretty=onelines pretty可以指定不同于默认格式的方式展示历史</span><br><span class="line"> * onelines 输出消息更简洁，最前面是每个版本的commit id（用SHA1计算）</span><br><span class="line"> * format:&quot;%h - %an, %ar : %s&quot; 定制记录的显示格式</span><br><span class="line"> * 还有short、full和fuller</span><br><span class="line"> </span><br><span class="line"> * -p/--patch 显示每次提交所引入的差异（按 补丁 的格式输出）</span><br><span class="line"> * --stat 每次提交的简略统计信息</span><br><span class="line"> * --shortstat 只显示 --stat 中最后的行数修改添加移除统计</span><br><span class="line"> * --name-only 仅在提交信息后显示已修改的文件清单</span><br><span class="line"> * --name-status 显示新增、修改、删除的文件清单</span><br><span class="line"> * --graph 查看分支合并图，在日志旁以 ASCII 图形显示分支与合并历</span><br><span class="line"> * --abbrev-commit 查看详细的合并信息，仅显示 SHA-1 校验和所有 40 个字符中的前几个字符</span><br><span class="line"> * --relative-data 使用较短的相对时间而不是完整格式显示日期（比如“2 weeks ago”）</span><br></pre></td></tr></table></figure><ul><li>显示从最近到最远的提交日志</li><li><strong>format</strong>格式设置：<ul><li><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/截屏2020-12-09 下午3.39.00.png" alt="截屏2020-12-09 下午3.39.00" style="zoom: 33%;"></li><li><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/截屏2020-12-09 下午3.39.17.png" alt="截屏2020-12-09 下午3.39.17" style="zoom: 33%;"></li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git last</span></span><br></pre></td></tr></table></figure><ul><li>查看最后一次提交</li></ul><p><strong>取消暂存 reset</strong>  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard HEAD^</span> </span><br></pre></td></tr></table></figure><ul><li>回退到前一个版本<ul><li><code>HEAD</code>：相当于一个指针，指向<code>master</code>，而<code>master</code>指向提交</li><li><code>^</code>：是上一个版本，<code>^^</code>：前两个的版本，<code>HEAD～100</code>：往上100个版本</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard commitId</span></span><br></pre></td></tr></table></figure><ul><li>回退到版本号为<code>commitId</code>的版本</li><li><strong>注意</strong>：<code>--hard</code> 是一个危险的选项</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rerset HEAD &lt;file&gt;</span></span><br></pre></td></tr></table></figure><ul><li>撤销暂存区(unstage)的修改回退到工作区</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reflog</span></span><br><span class="line">e475afc HEAD@&#123;1&#125;: reset: moving to HEAD^</span><br><span class="line">1094adb (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: append GPL</span><br><span class="line">e475afc HEAD@&#123;3&#125;: commit: add distributed</span><br><span class="line">eaadf4e HEAD@&#123;4&#125;: commit (initial): wrote a readme file</span><br></pre></td></tr></table></figure><ul><li>记录了你的每一次命令，可以用来找已经撤销掉的版本id</li></ul><ol start="4"><li><strong>其他操作</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff file</span></span><br></pre></td></tr></table></figure><ul><li>查看修改内容，<code>diff</code>均是未提交的内容</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff --staged</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看已暂存文件和最后一次提交的文件差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff --cached</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看已经暂存起来的变化（--staged和--cached是同义词）</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff HEAD -- file</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看工作区和版本库里面最新版本的区别</span></span><br></pre></td></tr></table></figure><p><strong>撤销操作 checkout</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -- &lt;file&gt;</span></span><br></pre></td></tr></table></figure><ul><li>撤销上一次修改，回到最近一次git commit或者git add状态，不管是在工作区还是在暂存区<ul><li>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</li><li>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</li><li>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考<a class="link" href="https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192">版本回退<i class="fas fa-external-link-alt"></i></a>一节，不过前提是没有推送到远程库。</li></ul></li></ul><p><strong>删除文件 rm</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rm file</span></span><br></pre></td></tr></table></figure><ul><li>通过rm删除了文件之后，status会告诉删除信息，因为删除也算是修改操作（deleted： file）</li><li>在本地目录中删除文件之后可以选择彻底删除或者使用git恢复<ol><li>彻底删除：<code>$ git rm file</code>— 在暂存区中删除，<code>$ git commit</code> — 确定要在版本库中删除<ul><li>(如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失<strong>最近一次提交后你修改的内容</strong>。)</li></ul></li><li>恢复：<code>$ git checkout --file</code><ul><li>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</li></ul></li></ol></li></ul><p><strong>改名操作 mv</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git mv old new</span></span><br><span class="line">---- 相当于 ----</span><br><span class="line"><span class="meta">$</span><span class="bash"> mv old new</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm old</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add new</span></span><br></pre></td></tr></table></figure><p><strong>忽略文件</strong></p><p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。在这种情况下，我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件的模式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat .gitignore</span></span><br><span class="line">*～      # 忽略所有名字以～结尾的文件（通常是副本文件）</span><br><span class="line">*.[oa]   # 忽略以.o .a 结尾的文件</span><br><span class="line">!lib.a.  # 忽略.a文件，但跟踪所有 lib.a 文件</span><br><span class="line">/TODO    # 只忽略当前目录下的 TODO 文件</span><br><span class="line">build/   # 忽略任何目录下名为 build 的文件夹</span><br><span class="line">doc/*.txt    #忽略doc下的txt，但不忽略doc/server/a.txt</span><br><span class="line">doc/**/*.pdf #忽略doc及其子目录下的所有pdf文件</span><br></pre></td></tr></table></figure><p>格式规范：</p><ul><li>所有空行或者以 # 开头的行都会被 Git 忽略。</li><li>可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。</li><li>匹配模式可以以（/）开头防止递归。</li><li>匹配模式可以以（/）结尾指定目录。</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上叹号（!）取反。</li></ul><h3 id="远程仓库（github）"><a href="#远程仓库（github）" class="headerlink" title="远程仓库（github）"></a>远程仓库（github）</h3><ol><li><strong>创建电脑用户自己的密钥</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen -t rsa -C <span class="string">&quot;youremail@example.com&quot;</span></span></span><br><span class="line"> * -t 指定密钥类型，默认是 rsa ，可以省略。</span><br><span class="line"> * -C 设置注释文字，比如邮箱。</span><br><span class="line"> * -f 指定密钥文件存储文件名.</span><br></pre></td></tr></table></figure><ul><li>在用户主目录<code>/home/username</code>下创建密钥</li><li>生成<code>id_rsa</code>和<code>id_rsa.pub</code></li></ul><ol start="2"><li><strong>绑定电脑用户和github用户</strong></li></ol><ul><li>将公钥<code>id_rsa.pub</code>加载到github网站上<code>Add SSH Key</code></li></ul><ol start="3"><li><strong>添加远程仓库</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote add origin git@github-link</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote -v</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote show &lt;remote&gt;    <span class="comment"># 查看摸一个远程仓库的更多信息</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote rename old new   <span class="comment"># 给远程仓库改名</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote remove name      <span class="comment"># 删除远程仓库，及所有跟踪分支和配置信息</span></span></span><br></pre></td></tr></table></figure><ul><li>链接本地仓库和github上创建的远程仓库</li><li><code>origin</code>为远程仓库的默认名字，可自行更改</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push -u origin mymaster:master</span></span><br></pre></td></tr></table></figure><ul><li>将本地仓库的内容推送到远程仓库上，实际上是把当前分支master推送到远程</li><li><code>-u</code>：如果当前分支与多个主机存在追踪关系，则可以使用 -u 参数指定一个默认主机，这样后面就可以不加任何参数使用<code>git push</code><ul><li>不指定<code>mymaster</code>：将会删除远程的<code>master</code>分支，这相当于是push了一个空分支到<code>master</code></li><li>不指定<code>:master</code>：默认推送到与<code>mymaster</code>有追踪关系的分支，一般为同名分支，没有的话会在远程建一个（<code>git remote show &lt;origin&gt;</code>查看各个分支的追踪关系）</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull origin master:mymaster</span></span><br></pre></td></tr></table></figure><ul><li>提交远程之前，最好先将远程仓库的文件拉取下来，再<code>push</code>，以免造成冲突</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git fetch &lt;remote&gt; &lt;remote branchname&gt;:&lt;your branchname&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 不指定远程分支将会默认为‘default’分支（一般为master）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 不给本地分支命名的话，会自动默认指针 FETCH_HEAD</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者使用远程分支名 origin/master 指定fetch的分支</span></span><br></pre></td></tr></table></figure><ul><li>他与pull一样，就拉取远程仓库中有但你没有的文件（不要拉取到当前所在分支）</li><li>不同的是，fetch并不会自动合并或修改你当前的工作，更安全。 当准备好时你必须手动将其合并入你的工作。</li><li><strong>pull = fetch + merge (FETCH_HEAD)</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git fetch origin</span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge origin/<span class="string">&#x27;default&#x27;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 拉取远程默认分支到本地当前分支上，再与远程的默认分支合并</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git fetch origin master:mymaster-tmp</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge mymaster-tmp</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 建议建一个专用存放fetch的分支tmp，拉去下来文件后，再与myaster来merge</span></span><br></pre></td></tr></table></figure><p><strong><code>FETCH_HEAD</code></strong></p><ul><li>某个branch在服务器上的最新状态.</li><li>每一个执行过fetch操作的项目都会存在一个FETCH_HEAD列表,这个列表保存在 <code>.git/FETCH_HEAD</code> 文件中, 其中每一行对应于远程服务器的一个分支.当前分支指向的FETCH_HEAD, 就是这个文件第一行对应的那个分支</li><li>一般来说, 存在两种情况:<ul><li>如果没有显式的指定<code>远程分支</code>, 则远程分支的<code>master</code>将作为默认的<code>FETCH_HEAD</code>.</li><li>如果指定了<code>远程分支</code>, 就将这个远程分支作为<code>FETCH_HEAD</code>.</li></ul></li></ul><p><strong><code>–rebase</code></strong></p><ul><li>作用是取消掉本地库中刚刚的commit，并把他们接到更新后的版本库之中。</li></ul><ol start="4"><li><strong>克隆远程仓库</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> git@github-link</span></span><br></pre></td></tr></table></figure><ul><li>如果远程仓库已有文件，可以将其克隆到本地的空仓库中</li></ul><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p><code>master</code>：主分支</p><p><code>HEAD</code>：指向当前分支，即指向<code>master</code></p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul><li><strong>新建<code>dev</code>分支</strong>：现在修改东西就是<code>dev</code>指针移动了，而<code>HEAD</code>指向当前的<code>dev</code>分支<ul><li>此时修改<code>dev</code>分支，<code>master</code>分支将不会改变</li></ul></li></ul><p><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/3DEC42CC-E46F-4939-ACAA-33BD4B3F88B2.png" alt="3DEC42CC-E46F-4939-ACAA-33BD4B3F88B2" style="zoom:67%;"><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/截屏2020-12-07 下午4.12.29.png" alt="截屏2020-12-07 下午4.12.29" style="zoom: 33%;"></p><ul><li><strong>合并分支</strong>：改改指针的问题                                          <ul><li>将<code>dev</code>分支合并到<code>master</code>上，右图为不使用<code>Fast-Forward</code>快进模式时（–no-ff）</li></ul></li></ul><p><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/69B01EAC-0670-4DED-85A9-A41465FCBF3C.png" alt="69B01EAC-0670-4DED-85A9-A41465FCBF3C" style="zoom: 67%;"><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/B0212A11-D318-457F-9943-E5FCD27820B4.png" alt="B0212A11-D318-457F-9943-E5FCD27820B4" style="zoom: 67%;"></p><ul><li><strong>删除分支</strong>：将dev指针给删掉就行了</li></ul><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/9CA8FECF-51AB-438D-86D7-59846BF675C9.png" alt="9CA8FECF-51AB-438D-86D7-59846BF675C9" style="zoom:80%;"><h4 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h4><ul><li>创建分支：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout (-b) dev</span></span><br><span class="line"> * -b 创建并切换分支</span><br><span class="line">-------------------------</span><br><span class="line"><span class="meta">$</span><span class="bash"> git switch (-c) dev</span></span><br><span class="line"> * -c 创建并切换分支</span><br></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch dev     //创建分支(会创建一个和当前分支有一样内容的分支)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout/switch dev   //切换分支</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br><span class="line">* dev</span><br><span class="line">  master</span><br></pre></td></tr></table></figure><ul><li>查看当前分支，当前分支上会加上<code>*</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -d dev</span></span><br></pre></td></tr></table></figure><ul><li>删除分支dev</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br><span class="line"> * -vv 将所有的本地分支列出来并且包含更多的信息</span><br><span class="line"> * -r 查看远程所有分支</span><br><span class="line"> * -a 查看本地和远程的所有分支</span><br><span class="line"> * &lt;branchname&gt; 新建分支</span><br><span class="line"> * -d -r &lt;branchname&gt; 删除远程分支，删除后还需要推送到服务器</span><br><span class="line"> * -m old new 重命名分支</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch --set-upstream-to origin/branchname</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch --set-upstream-to=origin/branchname  branchname</span></span><br></pre></td></tr></table></figure><ul><li>修改<code>pull</code>时的远程分支关联<ul><li>upstream：将当前分支推送到其上游分支（ tracking &gt;是不推荐的同义词对于上游）</li><li>current：将当前分支推送到同名分支</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git merge dev</span>   </span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge --no-ff -m <span class="string">&quot;merge with no-ff” dev</span></span> </span><br></pre></td></tr></table></figure><ul><li>合并分支到当前分支（如：将<code>dev</code>上的工作结果合并到<code>master</code>上）</li><li>注：两个分支分别都修改了文件的冲突情况下，需要进行手动更改冲突<ul><li>一般合并分支会在<code>Fast Forward</code>模式，但此模式下删除分支，会丢失掉分支信息；</li><li>如果要强制禁用<code>Fast Forward</code>模式，Git就会在<code>merge</code>时生成一个新的<code>commit</code>，这样，从分支历史上就可以看出分支信息。</li><li><code>--no-ff</code>方式的git merge：看的出原来发生过合并，而merge看不出</li></ul></li></ul><ul><li><strong>分支策略</strong>：<ul><li>master：最稳定的，用来发布版本；</li><li>dev：不稳定，所有人将自己的修改合并到这个分支上</li></ul></li></ul><p><img src="/2020/12/14/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/FD4949A7-CB58-4BD1-B887-3A833E23A7DD.png" alt="FD4949A7-CB58-4BD1-B887-3A833E23A7DD"></p><p>修改bug：创建新的分支进行修改，修改后合并到dev上，但是因为commit是一次提交所有的暂存区，所以需要将现在在写的，不需要提交的先用stash指令存储起来</p><p>git stash：将当前工作现场存储起来，等以后恢复现场工作后继续使用，此时git status非常的干净</p><p>查看：git stash list</p><p>恢复：git stash apply  -  恢复后不删除stash中的内容，需要用 git stash drop 来删除</p><p>​      git stash pop  -  恢复的同时删除</p><p>​       git stash apply stash@{0}：恢复指令的stash</p><p>feature分支</p><p>每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分</p><p>强行删除未合并的分支：git branch -D <file></file></p><h3 id="标签设置"><a href="#标签设置" class="headerlink" title="标签设置"></a>标签设置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出标签</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag -l <span class="string">&quot;v1.8.5&quot;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -l/-list 指定需要某些标签，如上只输出 v1.8.5 系列的</span></span><br></pre></td></tr></table></figure><h4 id="标签类型"><a href="#标签类型" class="headerlink" title="标签类型"></a><strong>标签类型</strong></h4><ol><li><strong>轻量标签（lightweight）</strong>：像一个不会改变的分支，它只是某个提交的引用</li><li><strong>附注标签（annotated）</strong>：是存储在git数据库的一个完整对象，它可以被校验，其中包含打标签者的名字、电子邮件、地址、日期时间，此外还有一个标签信息，并且可以使用GNU Privacy Guard（GPG）签名并验证</li></ol><h4 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a><strong>创建标签</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag -a v1.4 -m <span class="string">&quot;指定一条标签信息&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 轻量只用指定标签名字</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag v1.4</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 给历史版本打标签</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag -a v1.4 commitId</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git show v1.4</span></span><br></pre></td></tr></table></figure><ul><li>查看标签信息和与之对应的提交信息，如果是轻量标签则只会有提交信息</li></ul><h4 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a><strong>删除标签</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag -d v1.4</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin :refs/tags/v1.4</span></span><br></pre></td></tr></table></figure><ul><li>本地删除标签后并不会在远程仓库移除，需要执行第二条指令</li><li>将冒号前面的空值推送到远程标签名，从而高效地删除它</li><li>或者使用下面的方式更直观的删除</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin --delete &lt;tagname&gt;</span></span><br></pre></td></tr></table></figure><h4 id="共享标签"><a href="#共享标签" class="headerlink" title="共享标签"></a><strong>共享标签</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin v1.4</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin --tags</span></span><br></pre></td></tr></table></figure><ul><li><p>在创建完标签后你必须显式地推送标签到共享服务器上</p></li><li><p>–tags：这将会把所有不在远程仓库服务器上的标签全部传送到那里</p></li></ul><h4 id="检出标签"><a href="#检出标签" class="headerlink" title="检出标签"></a><strong>检出标签</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout 2.0.0</span></span><br></pre></td></tr></table></figure><ul><li>查看某个标签所指向的文件版本，但这会是你的仓库处于“分离头指针（detached HEAD）”的状态<ul><li>此状态如果你做了某些更改然后提交它们，标签不会发生变化， 但你的新提交将不属于任何分支，并且将无法访问，除非通过确切的提交哈希才能访问。 因此，如果你需要进行更改，比如你要修复旧版本中的错误，那么通常需要创建一个新分支<code>$ git checkout -b version2 v2.0.0</code></li></ul></li></ul><h3 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h3><h1 id="SVM"><a href="#SVM" class="headerlink" title="SVM"></a>SVM</h1><p>阿斯顿</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;h3 id=&quot;发展历史&quot;&gt;&lt;a href=&quot;#发展历史&quot; class=&quot;headerlink&quot; title=&quot;发展历史&quot;&gt;&lt;/a&gt;发展历史&lt;/h</summary>
      
    
    
    
    <category term="notebook" scheme="https://jieyang-wei.github.io/categories/notebook/"/>
    
    
    <category term="linux" scheme="https://jieyang-wei.github.io/tags/linux/"/>
    
    <category term="git" scheme="https://jieyang-wei.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://jieyang-wei.github.io/2020/12/12/hello-world/"/>
    <id>https://jieyang-wei.github.io/2020/12/12/hello-world/</id>
    <published>2020-12-12T08:51:34.056Z</published>
    <updated>2020-12-14T10:13:12.832Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a class="link" href="https://hexo.io/">Hexo<i class="fas fa-external-link-alt"></i></a>! This is your very first post. Check <a class="link" href="https://hexo.io/docs/">documentation<i class="fas fa-external-link-alt"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link" href="https://hexo.io/docs/troubleshooting.html">troubleshooting<i class="fas fa-external-link-alt"></i></a> or you can ask me on <a class="link" href="https://github.com/hexojs/hexo/issues">GitHub<i class="fas fa-external-link-alt"></i></a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a class="link" href="https://hexo.io/docs/writing.html">Writing<i class="fas fa-external-link-alt"></i></a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a class="link" href="https://hexo.io/docs/server.html">Server<i class="fas fa-external-link-alt"></i></a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a class="link" href="https://hexo.io/docs/generating.html">Generating<i class="fas fa-external-link-alt"></i></a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a class="link" href="https://hexo.io/docs/one-command-deployment.html">Deployment<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a class=&quot;link&quot; href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;i class=&quot;fas fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/a&gt;! This is your very first post. Check </summary>
      
    
    
    
    <category term="course" scheme="https://jieyang-wei.github.io/categories/course/"/>
    
    
    <category term="hello-world" scheme="https://jieyang-wei.github.io/tags/hello-world/"/>
    
  </entry>
  
</feed>
