<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WeiJY&#39;s blog</title>
  
  
  <link href="https://jieyang-wei.github.io/atom.xml" rel="self"/>
  
  <link href="https://jieyang-wei.github.io/"/>
  <updated>2021-04-19T06:44:21.429Z</updated>
  <id>https://jieyang-wei.github.io/</id>
  
  <author>
    <name>Wei Jieyang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>shell</title>
    <link href="https://jieyang-wei.github.io/2021/03/31/shell/"/>
    <id>https://jieyang-wei.github.io/2021/03/31/shell/</id>
    <published>2021-03-31T08:57:07.000Z</published>
    <updated>2021-04-19T06:44:21.429Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>后缀：<code>name.sh</code> 文件，可以使用 <code>./</code> 来运行</p><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置变量默认值的两种方式，如果不输入参数，则默认为</span></span><br><span class="line">VAR=$&#123;1:-&quot;2&quot;&#125;</span><br><span class="line"></span><br><span class="line">VAR=&quot;$1&quot;</span><br><span class="line">: $&#123;VAR:=&quot;1&quot;&#125;</span><br></pre></td></tr></table></figure><ul><li>$n：表示输入的第n个参数，<code>$0</code> 是特殊的，表示程序本身</li><li>变量赋值 <code>=</code> 周围不得有空格</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export VAR=&quot;var data&quot;</span><br></pre></td></tr></table></figure><ul><li>使用范围为 <code>./file.sh</code> 对应的那一次命令</li><li>如果需要范围扩展到整个命令窗口，需要使用 <code>source ./file.sh</code></li></ul><h3 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h3><table><thead><tr><th>变量</th><th>含义</th></tr></thead><tbody><tr><td>$0</td><td>当前脚本的文件名</td></tr><tr><td>$n</td><td>传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。</td></tr><tr><td>$#</td><td>传递给脚本或函数的参数个数。</td></tr><tr><td>$*</td><td>传递给脚本或函数的所有参数。</td></tr><tr><td>$@</td><td>传递给脚本或函数的所有参数。被双引号(“ “)包含时，与 $* 稍有不同，下面将会讲到。</td></tr><tr><td>$?</td><td>上个命令的退出状态，或函数的返回值。</td></tr><tr><td>$$</td><td>当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。</td></tr></tbody></table><h2 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h2><ul><li><p><strong>逻辑非</strong>：<code>!</code></p><ul><li><code>if [!表达式 ]</code></li></ul></li><li><p><strong>逻辑与</strong>：<code>–a</code></p><ul><li><code>if [ 表达式1 –a 表达式2 ]</code></li></ul></li><li><p><strong>逻辑或</strong>：<code>-o</code></p><ul><li><code>if [ 表达式1 –o 表达式2 ]</code></li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if []; then</span><br><span class="line">elif []; then</span><br><span class="line">else</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><h3 id="文件表达式"><a href="#文件表达式" class="headerlink" title="文件表达式"></a>文件表达式</h3><ul><li><strong>-e filename</strong>：如果 filename存在，则为真</li><li><strong>-d filename</strong>：如果 filename为目录，则为真 </li><li><strong>-f filename</strong>：如果 filename为常规文件，则为真</li><li><strong>-L filename</strong>：如果 filename为符号链接，则为真</li><li><strong>-r filename</strong>：如果 filename可读，则为真 </li><li><strong>-w filename</strong>：如果 filename可写，则为真 </li><li><strong>-x filename</strong>：如果 filename可执行，则为真</li><li><strong>-s filename</strong>：如果文件长度不为0，则为真</li><li><strong>-h filename</strong>：如果文件是软链接，则为真</li><li><strong>filename1 -nt filename2</strong>：如果 filename1比 filename2新，则为真。</li><li><strong>filename1 -ot filename2</strong>：如果 filename1比 filename2旧，则为真。</li></ul><h3 id="整数表达式"><a href="#整数表达式" class="headerlink" title="整数表达式"></a>整数表达式</h3><ul><li><strong>-eq</strong>：等于，equal</li><li><strong>-ne</strong>：不等于，not equal</li><li><strong>-gt</strong>：大于，greater than</li><li><strong>-ge</strong>：大于等于，greater equal</li><li><strong>-lt</strong>：小于，less than</li><li><strong>-le</strong>：小于等于，less equal</li></ul><h3 id="字符串表达式"><a href="#字符串表达式" class="headerlink" title="字符串表达式"></a>字符串表达式</h3><ul><li><code>if [ $string1 = $string2 ]</code>：如果string1等于string2，则为真<ul><li>字符串允许使用赋值号做等号</li></ul></li><li><code>if [ $string1 !=  $string2 ]</code>：如果string1不等于string2，则为真    </li><li><code>if [ -n $string  ]</code>：如果string 非空(非0），返回0(true)  </li><li><code>if [ -z $string  ]</code>：如果string 为空，则为真</li><li><code>if [ $sting ]</code>：如果string 非空，返回0 (和-n类似) </li></ul><h1 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h1><h2 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h2><p>向标准输出输出后面跟着的部分，直到第一个换行符出停止</p><p><strong>注意</strong>：</p><ul><li>直接跟输出的内容，如果有换行时，将会在第一个换行处停止，无法执行后面的部分</li><li>‘ ‘，引号中间的所有符号都将被字符串化，因此不可以使用 <code>$&#123;NAME&#125;</code> 来读取参数内容，但是加引号不会在换行符处停止，而是在引号结尾停止</li><li>``，将会执行此符号中间的部分</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 即需要换行，也有参数时：</span></span><br><span class="line">echo &#x27;adc</span><br><span class="line">def &#x27;$&#123;1&#125;&#x27; ghi</span><br><span class="line">jk&#x27; &gt; try.txt</span><br></pre></td></tr></table></figure><h1 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h1><p>就像我们平时写的程序一样，一段程序会处理外部的输入，然后将运算结果输出到指定的位置。在交互式的程序中，输入来自用户的键盘和鼠标，结果输出到用户的屏幕，甚至播放设备中。而对于某些后台运行的程序，输入可能来自于外部的一些文件，运算的结果通常又写到其他的文件中。而且程序在运行的过程中，会有一些关键性的信息，比如异常堆栈，外部接口调用情况等，这些都会统统写到日志文件里。</p><p>shell脚本也一样，但是我们一般在使用shell命令的时候，更多地还是通过键盘输入，然后在屏幕上查看命令的执行结果。如果某些情况下，我们需要将shell命令的执行结果存储到文件中，那么我们就需要使用输入输出的重定向功能。</p><h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><p>当执行shell命令时，会默认打开3个文件，每个文件有对应的文件描述符来方便我们使用：</p><table><thead><tr><th>类型</th><th>文件描述符</th><th>默认情况</th><th>对应文件句柄位置</th></tr></thead><tbody><tr><td>标准输入（standard input）</td><td>0</td><td>从键盘获得输入</td><td>/proc/self/fd/0</td></tr><tr><td>标准输出（standard output）</td><td>1</td><td>输出到屏幕（即控制台）</td><td>/proc/self/fd/1</td></tr><tr><td>错误输出（error output）</td><td>2</td><td>输出到屏幕（即控制台）</td><td>/proc/self/fd/2</td></tr></tbody></table><h2 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h2><table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>command &gt;filename</td><td>把标准输出重定向到新文件中</td></tr><tr><td>command 1&gt;filename</td><td>同上</td></tr><tr><td>command &gt;&gt;filename</td><td>把标准输出追加到文件中</td></tr><tr><td>command 1&gt;&gt;filename</td><td>同上</td></tr><tr><td>command 2&gt;filename</td><td>把标准错误重定向到新文件中</td></tr><tr><td>command 2&gt;&gt;filename</td><td>把标准错误追加到新文件中</td></tr></tbody></table><h2 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h2><table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>command &lt;filename</td><td>以filename文件作为标准输入</td></tr><tr><td>command 0&lt;filename</td><td>同上</td></tr><tr><td>command &lt;&lt;delimiter</td><td>从标准输入中读入，直到遇到delimiter分隔符</td></tr></tbody></table><h2 id="重定向绑定"><a href="#重定向绑定" class="headerlink" title="重定向绑定"></a>重定向绑定</h2><h3 id="command-gt-dev-null-2-gt-amp-1"><a href="#command-gt-dev-null-2-gt-amp-1" class="headerlink" title="command &gt; /dev/null 2&gt;&amp;1"></a>command &gt; /dev/null 2&gt;&amp;1</h3><p>这条命令分为两命令，一个是 <code>&gt;/dev/null</code>，另一个是 <code>2&gt;&amp;1</code>。</p><p><strong>1、<code> &gt; /dev/null</code></strong></p><ul><li><p>这条命令的作用是将标准输出1重定向到<code>/dev/null</code>中。</p></li><li><p><code>/dev/null</code>代表linux的空设备文件，所有往这个文件里面写入的内容都会丢失，俗称“黑洞”。那么执行了<code>&gt;/dev/null</code>之后，标准输出就会不再存在，没有任何地方能够找到输出的内容。</p></li></ul><p><strong>2、<code>2&gt;&amp;1</code></strong></p><ul><li>这条命令用到了重定向绑定，采用 <code>&amp;</code> 可以将两个输出绑定在一起。</li><li>这条命令的作用是错误输出将和标准输出同用一个文件描述符，说人话就是错误输出将会和标准输出输出到同一个地方。</li></ul><p>linux在执行shell命令之前，就会确定好所有的输入输出位置，并且从左到右依次执行重定向的命令，所以 <code>&gt; /dev/null 2&gt;&amp;1</code> 的作用就是让标准输出重定向到 <code>/dev/null</code> 中（丢弃标准输出），然后错误输出由于重用了标准输出的描述符，所以错误输出也被定向到了 <code>/dev/null</code> 中，错误输出同样也被丢弃了。执行了这条命令之后，该条shell命令将不会输出任何信息到控制台，也不会有任何信息输出到文件中。</p><p><strong><code>&gt; /dev/null 2&gt;&amp;1</code>  VS  <code>2&gt;&amp;1 &gt; /dev/null</code></strong></p><p>linux在执行shell命令之前，就会确定好所有的输入输出位置，并且从左到右依次执行重定向的命令。那么我们同样从左到右地来分析<code>2&gt;&amp;1 &gt;/dev/null</code>：</p><ul><li><code>2&gt;&amp;1</code>，将错误输出绑定到标准输出上。由于此时的标准输出是默认值，也就是输出到屏幕，所以错误输出会输出到屏幕。</li><li><code>&gt;/dev/null</code>，将标准输出1重定向到<code>/dev/null</code>中。</li></ul><p>用一个表格来更好地说明这两条命令的区别：</p><table><thead><tr><th>命令</th><th>标准输出</th><th>错误输出</th></tr></thead><tbody><tr><td>&gt;/dev/null 2&gt;&amp;1</td><td>丢弃</td><td>丢弃</td></tr><tr><td>2&gt;&amp;1 &gt;/dev/null</td><td>丢弃</td><td>屏幕</td></tr></tbody></table><h1 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h1><h2 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h2><p><code>nohup command &gt;/dev/null 2&gt;&amp;1 &amp;</code></p><ul><li>启动一些进程在后台挂起并且无任何输出到控制台</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;后缀：&lt;code&gt;name.sh&lt;/code&gt; 文件，可以使用 &lt;code&gt;./&lt;/code&gt; 来运行&lt;/p&gt;
&lt;h1 id=&quot;语法&quot;&gt;&lt;a</summary>
      
    
    
    
    <category term="Notebook" scheme="https://jieyang-wei.github.io/categories/Notebook/"/>
    
    <category term="Shell" scheme="https://jieyang-wei.github.io/categories/Notebook/Shell/"/>
    
    
    <category term="编程语言" scheme="https://jieyang-wei.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="rugy" scheme="https://jieyang-wei.github.io/tags/rugy/"/>
    
  </entry>
  
  <entry>
    <title>fabric-Contract-Nodejs</title>
    <link href="https://jieyang-wei.github.io/2021/03/31/fabric-Contract-Nodejs/"/>
    <id>https://jieyang-wei.github.io/2021/03/31/fabric-Contract-Nodejs/</id>
    <published>2021-03-31T05:28:34.000Z</published>
    <updated>2021-04-19T06:42:41.358Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本部分主要讲解使用nodejs开发fabric链码的过程</p><p>fabric链码开发需要注意的<a class="link" href="https://baijiahao.baidu.com/s?id=1658934901351367917&wfr=spider&for=pc">8个事项<i class="fas fa-external-link-alt"></i></a></p><ol><li>启用peer节点的开发模式</li><li>使用Fabric链码的日志<ul><li>Golang：shim ChaincodeLogger</li><li>NodeJS：shim newLogger</li><li>Java：可以使用任何标准的日志框架，例如log4j</li></ul></li><li>避免在Fabric链码中使用全局键</li><li>聪明地使用CouchDB查询（Mongo查询）</li><li>编写确定性的Fabric链码</li><li>调用其他通道的Fabric链码时要小心<ul><li>目前，跨通道的链码调用不会修改数据，因此， 一个交易一次只能写入一个通道。</li></ul></li><li>记得设置Fabric链码的执行超时时间</li><li>避免从Fabric链码中访问外部资源</li></ol><h1 id="fabric-shim"><a href="#fabric-shim" class="headerlink" title="fabric-shim"></a>fabric-shim</h1><p><code>fabric-contract-api</code>提供了一个高度封装的开发接口，使用该API可以在高层级 编写智能合约的业务逻辑。而<code>fabric-shim</code>则提供了底层的链码开发接口。</p><ul><li><code>fabric-shim</code> 要求开发者实现ChaincodeInterface接口，即实现Invoke和Init方法：</li></ul><p><strong>下载</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install fabric-shim</span></span><br></pre></td></tr></table></figure><p><strong>demo.js</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Chaincode = <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">Init</span>(<span class="params">stub</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// use the instantiate input arguments to decide initial chaincode state values</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// save the initial states</span></span><br><span class="line">        <span class="keyword">await</span> stub.putState(key, Buffer.from(aStringValue));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> shim.success(Buffer.from(<span class="string">&#x27;Initialized Successfully!&#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">Invoke</span>(<span class="params">stub</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// use the invoke input arguments to decide intended changes</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// retrieve existing chaincode states</span></span><br><span class="line">        <span class="keyword">let</span> oldValue = <span class="keyword">await</span> stub.getState(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// calculate new state values and saves them</span></span><br><span class="line">        <span class="keyword">let</span> newValue = oldValue + delta;</span><br><span class="line">        <span class="keyword">await</span> stub.putState(key, Buffer.from(newValue));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> shim.success(Buffer.from(newValue.toString()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">shim.start(<span class="keyword">new</span> Chaincode());</span><br></pre></td></tr></table></figure><p><strong>运行链码</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> node demo.js</span></span><br></pre></td></tr></table></figure><p><strong>源码分析</strong></p><h2 id="ChaincodeInterface"><a href="#ChaincodeInterface" class="headerlink" title="ChaincodeInterface"></a>ChaincodeInterface</h2><p>链码必须实现ChaincodeInterface接口中定义的方法。</p><p><code>Init()</code>方法在链码初始化或升级时被调用，以便进行必要的应用状态的初始化。</p><p><code>Invoke()</code>方法当处理交易或查询请求时被调用。两个方法被调用时都会传入一个存根对象（stub），链码可以利用该对象来获取请求的相关信息，例如调用 者身份、目标通道、参数等等，同时也需要利用存根对象与peer节点通信，以便 获取或更新应用状态。</p><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><h3 id="invoke"><a href="#invoke" class="headerlink" title="invoke"></a>invoke</h3><h2 id="ChaincodeStub"><a href="#ChaincodeStub" class="headerlink" title="ChaincodeStub"></a>ChaincodeStub</h2><p>ChaincodeStub封装了链码实现和Fabric的peer节点之间的API。</p><p><a class="link" href="http://cw.hubwiz.com/card/c/fabric-chaincode-node/1/2/22/">API文档<i class="fas fa-external-link-alt"></i></a></p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ChaincodeStub(client, channel_id, txId, chaincodeInput, signedProposal)</span><br></pre></td></tr></table></figure><ul><li>client：Handler实例</li><li>channel_id：通道id，string</li><li>txId：交易id，string</li><li>chaincodeInput：来自peer节点旳解码消息</li><li>signedProposal：签名提议</li></ul><h3 id="putState"><a href="#putState" class="headerlink" title="putState()"></a>putState()</h3><p>更新状态库中指定的状态变量键。如果变量已经存在，那么覆盖已有的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">putState</span>(<span class="params">key, value</span>)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">this</span>.handler.handlePutState(collection, key, value, <span class="built_in">this</span>.channel_id, <span class="built_in">this</span>.txId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>key：要更新的状态键，字符串</li><li>value：状态变量的新值，字节数组或字符串</li><li>返回：一个Promise对象</li></ul><h3 id="createCompositeKey"><a href="#createCompositeKey" class="headerlink" title="createCompositeKey()"></a>createCompositeKey()</h3><p>通过组合对象类别和给定的属性创建一个组合键。对象类别及属性都必须是<strong>有效的utf8字符串</strong>，并且不能包含U+0000 (空字节) 和 U+10FFFF (最大未分配代码点)。 </p><ul><li>组合键可以用作 <code>putState()</code> 调用中的参数键 <code>key</code>。</li></ul><p>Hyperledger Fabric使用一个简单的key/value模型来保存链码状态。在有些场景下， 可能需要跟踪多个属性，也可能需要使多种属性可搜索。组合键可用来满足这些需求。</p><p>类似于关系数据库中的组合键，你可以认为这里的可搜索属性就是组合键的组成列， 属性的值称为键的一部分，因此可以使用像 <code>getStateByRange()</code> 和 <code>getStateByPartialCompositeKey()</code> 这样的方法进行搜索。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCompositeKey</span>(<span class="params">objectType, attributes</span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>objectType：组合键的前缀（一般使用name）</li><li>attributes：拼接到组合键的各属性值，string数组</li><li>返回：string类型的组合键</li></ul><h3 id="getStateByRange"><a href="#getStateByRange" class="headerlink" title="getStateByRange()"></a>getStateByRange()</h3><p>该方法返回一个账本状态键的迭代器，可用来遍历在起始键和结束键之间的所有状态键，返回结果按<strong>词典顺序</strong>排列。</p><ul><li>如果起始键和结束键之间的数量大于节点配置文件 <code>core.yaml</code> 中定义的 <code>totalQueryLimit</code>， 那么返回结果数量将受限于 <code>totalQueryLimit</code> 的约定。</li><li>调用返回的 <code>StateQueryIterator</code> 迭代器对象的<code>close()</code>方法关闭迭代器。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">async</span>&gt; <span class="function"><span class="title">getStateByRange</span>(<span class="params">startKey, endKey</span>)</span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> convertToAsyncIterator(promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>startKey：起始键，字符串</li><li>endKey：结束键，字符串</li><li>返回：一个Promise对象，其解析值为StateQueryIterator迭代器。</li></ul><h3 id="getStateByPartialCompositeKey"><a href="#getStateByPartialCompositeKey" class="headerlink" title="getStateByPartialCompositeKey()"></a>getStateByPartialCompositeKey()</h3><p>基于给定的部分复合键查询账本状态。</p><ul><li><p>该方法返回的迭代器可用于遍历查询结果集。</p></li><li><p>当使用完毕后，调用返回的 <code>StateQueryIterator</code> 迭代器的<code>close()</code>方法关闭迭代器。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">async</span>&gt; <span class="function"><span class="title">getStateByPartialCompositeKey</span>(<span class="params">objectType, attributes</span>)</span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> convertToAsyncIterator(promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>objectType：结果键前缀，字符串</li><li>attributes：用于拼接复合键值的属性值列表，字符串数组</li><li>返回：一个Promise对象，其解析值为 <code>StateQueryIterator</code> 迭代器对象。</li></ul><h3 id="getHistoryForKey"><a href="#getHistoryForKey" class="headerlink" title="getHistoryForKey()"></a>getHistoryForKey()</h3><p>查看指定状态键的值历史记录。</p><ul><li>每次历史更新，都记录有当时的值和关联的交易id、时间戳。</li><li>时间戳取自交易提议头。</li></ul><p>该方法需要通过peer节点配置中的如下选项开启：</p><ul><li><pre><code class="yaml">core.ledger.history.enableHistoryDatabase = true<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;javascript</span><br><span class="line">&lt;async&gt; getHistoryForKey(key)&#123;&#125;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>key：状态键</p></li><li><p>返回一个Promise对象，其解析值为HistoryQueryIterator对象。</p></li></ul><h1 id="fabric-contract-api"><a href="#fabric-contract-api" class="headerlink" title="fabric-contract-api"></a>fabric-contract-api</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Contract, Context &#125; = <span class="built_in">require</span>(<span class="string">&#x27;fabric-contract-api&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="context"><a href="#context" class="headerlink" title="context"></a>context</h2><p><strong>源码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="title">setChaincodeStub</span>(<span class="params">stub</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stub = stub;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">setClientIdentity</span>(<span class="params">clientIdentity</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.clientIdentity = clientIdentity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="contract"><a href="#contract" class="headerlink" title="contract"></a>contract</h2><p><strong>源码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Contract</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.__isContract = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> name === <span class="string">&#x27;undefined&#x27;</span> || name === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = <span class="built_in">this</span>.constructor.name;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name.trim();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&#x27;Creating new Contract&#x27;</span>, name);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">_isContract</span>(<span class="params">obj</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> obj <span class="keyword">instanceof</span> Contract || <span class="built_in">Boolean</span>(obj.__isContract);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">beforeTransaction</span>(<span class="params">ctx</span>)</span> &#123;</span><br><span class="line">      <span class="comment">// default implementation is do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">afterTransaction</span>(<span class="params">ctx, result</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// default implementation is do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">unknownTransaction</span>(<span class="params">ctx</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;fcn, params&#125; = ctx.stub.getFunctionAndParameters();</span><br><span class="line"></span><br><span class="line">        logger.error(<span class="string">`[<span class="subst">$&#123;ctx.stub.getTxID()&#125;</span>] <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> contract-api.Contract unknown transaction`</span>, fcn, params);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`You&#x27;ve asked to invoke a function that does not exist: <span class="subst">$&#123;fcn&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">createContext</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Context();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本部分主要讲解使用nodejs开发fabric链码的过程&lt;/p&gt;
&lt;p&gt;fabric链码开发需要注意的&lt;a class=&quot;link&quot; hre</summary>
      
    
    
    
    <category term="Notebook" scheme="https://jieyang-wei.github.io/categories/Notebook/"/>
    
    <category term="Blockchain" scheme="https://jieyang-wei.github.io/categories/Notebook/Blockchain/"/>
    
    <category term="Fabric" scheme="https://jieyang-wei.github.io/categories/Notebook/Blockchain/Fabric/"/>
    
    
    <category term="fabric" scheme="https://jieyang-wei.github.io/tags/fabric/"/>
    
    <category term="blockchain" scheme="https://jieyang-wei.github.io/tags/blockchain/"/>
    
  </entry>
  
  <entry>
    <title>rust</title>
    <link href="https://jieyang-wei.github.io/2021/03/28/rust/"/>
    <id>https://jieyang-wei.github.io/2021/03/28/rust/</id>
    <published>2021-03-28T07:15:01.000Z</published>
    <updated>2021-04-19T06:44:03.968Z</updated>
    
    
    
    
    <category term="Notebook" scheme="https://jieyang-wei.github.io/categories/Notebook/"/>
    
    <category term="Programming language" scheme="https://jieyang-wei.github.io/categories/Notebook/Programming-language/"/>
    
    
    <category term="编程语言" scheme="https://jieyang-wei.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="rugy" scheme="https://jieyang-wei.github.io/tags/rugy/"/>
    
  </entry>
  
  <entry>
    <title>fabric2</title>
    <link href="https://jieyang-wei.github.io/2021/03/25/fabric-SDK/"/>
    <id>https://jieyang-wei.github.io/2021/03/25/fabric-SDK/</id>
    <published>2021-03-25T06:29:16.000Z</published>
    <updated>2021-04-19T06:43:10.514Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 Hyperledger Fabric 的SDK中， 提供的API的作用主要有：</p><ul><li>创建通道 （create channel）</li><li>请求节点加入通道 (join channel)</li><li>在节点中安装链码 （install chaincode）</li><li>通过调用链码来调用事物 （invoke chaincode）</li><li>查询事物或者区块的账本 (query chaincode)</li></ul><p>官方支持的版本：</p><ul><li><a class="link" href="https://link.zhihu.com/?target=https://github.com/hyperledger/fabric-sdk-node">Hyperledger Fabric Node SDK<i class="fas fa-external-link-alt"></i></a> （最详细）</li><li><a class="link" href="https://link.zhihu.com/?target=https://github.com/hyperledger/fabric-sdk-java">Hyperledger Fabric Java SDK<i class="fas fa-external-link-alt"></i></a></li></ul><p>非官方的版本：</p><ul><li><a class="link" href="https://link.zhihu.com/?target=https://github.com/hyperledger/fabric-sdk-py">Hyperledger Fabric Python SDK<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" href="https://link.zhihu.com/?target=https://github.com/hyperledger/fabric-sdk-go">Hyperledger Fabric GO SDK<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" href="https://link.zhihu.com/?target=https://github.com/hyperledger/fabric-sdk-rest">Hyperledger Fabric REST SDK<i class="fas fa-external-link-alt"></i></a></li></ul><h1 id="Go-SDK"><a href="#Go-SDK" class="headerlink" title="Go SDK"></a>Go SDK</h1><p><a class="link" href="https://blog.csdn.net/weixin_34067049/article/details/91901508">node sdk具体查看<i class="fas fa-external-link-alt"></i></a></p><h1 id="Node-SDK"><a href="#Node-SDK" class="headerlink" title="Node SDK"></a>Node SDK</h1><ul><li><strong>api</strong> ： 可插拔式的API， 可自由定制， SDK提供默认实现</li><li><strong>fabric-client</strong>：提供API用来同Hyperledger Fabirc的区块链网络进行交互， 具体就是同peer, orderer 和事件流交互。</li></ul><ul><li><a href="https://hyperledger.github.io/fabric-sdk-node/master/module-fabric-network.html"><strong>fabric-network</strong></a>：为客户端应用程序提供高级API以与智能合约（链码）进行交互，并且是构建客户端应用程序的推荐API。</li><li><strong>fabric-ca-client</strong>：提供API以与可选的证书颁发机构组件fabric-ca进行交互，该组件包含用于成员资格管理的服务。</li><li><strong>fabric-common</strong>：用于实现<strong>结构网络</strong>功能的低级API，它提供API与Hyperledger Fabric网络的核心组件（对等体，订购者和事件流）进行交互。</li></ul><h2 id="fabric-network"><a href="#fabric-network" class="headerlink" title="fabric-network"></a>fabric-network</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Wallets, Gateway &#125; = <span class="built_in">require</span>(<span class="string">&#x27;fabric-network&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="Wallets"><a href="#Wallets" class="headerlink" title="Wallets"></a>Wallets</h3><h3 id="Gateway"><a href="#Gateway" class="headerlink" title="Gateway"></a>Gateway</h3><h2 id="fabric-client"><a href="#fabric-client" class="headerlink" title="fabric-client"></a>fabric-client</h2><h2 id="fabric-ca-client"><a href="#fabric-ca-client" class="headerlink" title="fabric-ca-client"></a>fabric-ca-client</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> FabricCaServices = <span class="built_in">require</span>(<span class="string">&#x27;fabric-ca-client&#x27;</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在 Hyperledger Fabric 的SDK中， 提供的API的作用主要有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建通道 （create ch</summary>
      
    
    
    
    <category term="Notebook" scheme="https://jieyang-wei.github.io/categories/Notebook/"/>
    
    <category term="Blockchain" scheme="https://jieyang-wei.github.io/categories/Notebook/Blockchain/"/>
    
    <category term="Fabric" scheme="https://jieyang-wei.github.io/categories/Notebook/Blockchain/Fabric/"/>
    
    
    <category term="fabric" scheme="https://jieyang-wei.github.io/tags/fabric/"/>
    
    <category term="blockchain" scheme="https://jieyang-wei.github.io/tags/blockchain/"/>
    
  </entry>
  
  <entry>
    <title>Network</title>
    <link href="https://jieyang-wei.github.io/2021/03/22/fabric-Deploying%20Network/"/>
    <id>https://jieyang-wei.github.io/2021/03/22/fabric-Deploying%20Network/</id>
    <published>2021-03-22T10:15:31.000Z</published>
    <updated>2021-04-19T06:42:47.524Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本部分主要讲解生产网络的部署</p><p>因为所有的节点等都是在docker容器中跑的，所以</p><h1 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h1><h2 id="相关部分"><a href="#相关部分" class="headerlink" title="相关部分"></a>相关部分</h2><h3 id="证书颁发机构"><a href="#证书颁发机构" class="headerlink" title="证书颁发机构"></a>证书颁发机构</h3><p>作为整体决策的一部分</p><ul><li>必须决定<strong>peer</strong>（总共多少，每个通道上有多少）以及<strong>ordering service</strong>（有多少个节点，谁将拥有这些节点）</li><li>必须决定组织的CA将如何被部署。</li></ul><p>生产网络应使用传输层安全性（TLS），这将需要设置TLS CA并使用它来生成TLS证书。</p><ul><li>在enrollment CA之前，需要先部署TLS CA。</li><li>详细在“设置CA”部分</li></ul><h3 id="Organization"><a href="#Organization" class="headerlink" title="Organization"></a>Organization</h3><p>一些组织可能发现有必要建立组织单位，以在某些身份和单个CA创建的MSP之间建立隔离（例如，制造商可能希望其一个组织单位用于其运输部门，而另一个组织单位用于其质量控制部门）。请注意，这与“节点OU”的概念是分开的，在“节点OU”中，身份可以具有编码到其中的角色（例如，“ admin”或“ peer”）。</p><h3 id="Database"><a href="#Database" class="headerlink" title="Database"></a>Database</h3><p>网络中的某些通道可能要求以<a class="link" href="https://hyperledger-fabric.readthedocs.io/en/latest/couchdb_as_state_database.html">状态数据库<i class="fas fa-external-link-alt"></i></a>可以理解的方式对所有数据进行建模，而其他网络可能会优先考虑速度，从而决定所有对等方都将使用LevelDB。请注意，通道上不应有同时使用CouchDB和LevelDB的对等体，因为CouchDB对键和值施加了一些数据限制。在LevelDB中有效的键和值在CouchDB中可能无效。</p><h3 id="System-Channel"><a href="#System-Channel" class="headerlink" title="System Channel"></a>System Channel</h3><p>订购节点可以使用称为“系统通道”（可从中创建应用程序通道）的管理通道的配置块来加载，也可以简单地根据需要启动并加入到应用程序通道中。推荐的方法是在没有配置块的情况下进行引导，这是本部署指南假定采用的方法。有关创建系统通道创始块并使用它引导引导节点的更多信息，请参见Fabric v2.2文档中的“<a class="link" href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/deployment_guide_overview.html#creating-an-ordering-node">部署生产网络<i class="fas fa-external-link-alt"></i></a>”。</p><h3 id="Channel-and-Private-Data"><a href="#Channel-and-Private-Data" class="headerlink" title="Channel and Private Data"></a>Channel and Private Data</h3><p>某些网络可能会认为，<a class="link" href="https://hyperledger-fabric.readthedocs.io/en/latest/channels.html">通道<i class="fas fa-external-link-alt"></i></a>是确保某些交易的私密性和隔离性的最佳方法。其他人可能会决定，更少的通道（必要时补充<a class="link" href="https://hyperledger-fabric.readthedocs.io/en/latest/private-data/private-data.html">私人数据集<i class="fas fa-external-link-alt"></i></a>）可以更好地满足他们的隐私需求。</p><h3 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h3><p>不同的用户还可能对他们的容器编排做出不同的决定，为他们的对等进程，日志记录，CouchDB，gRPC通信和链代码创建单独的容器，而其他用户可能决定合并其中的一些过程。</p><h3 id="Chaincode"><a href="#Chaincode" class="headerlink" title="Chaincode"></a>Chaincode</h3><p>用户可以选择使用build-in build和run support，使用<a class="link" href="https://hyperledger-fabric.readthedocs.io/en/latest/cc_launcher.html">外部构建器和启动器<i class="fas fa-external-link-alt"></i></a>进行自定义的构建和运行，或者使用<a class="link" href="https://hyperledger-fabric.readthedocs.io/en/latest/cc_service.html">Chaincode作为外部服务<i class="fas fa-external-link-alt"></i></a>来部署其链代码。</p><h3 id="firewall"><a href="#firewall" class="headerlink" title="firewall"></a>firewall</h3><p>在生产部署中，属于一个组织的组件可能需要访问其他组织的组件，因此必须使用防火墙和高级网络配置。例如，使用Fabric SDK的应用程序需要访问所有组织的所有endorsing peer以及所有通道上的ordering service。同样，对等方需要从他们接收新块的通道上访问ordering service。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="设置资源集群"><a href="#设置资源集群" class="headerlink" title="设置资源集群"></a>设置资源集群</h3><p>推荐：Kubernetes</p><p>无论您选择在何处部署组件，都需要确保有足够的资源来使组件有效运行。您需要的大小将在很大程度上取决于您的用例。如果您打算将单个对等方加入到多个大容量通道，则比仅计划加入一个通道时，它需要更多的CPU和内存。粗略估计，在计划分配给单个订购节点时，计划将大约三倍的资源专用于对等方（如下所示，建议在订购服务中至少部署三个，最好部署五个节点） 。同样，与对等端一样，CA大约需要十分之一的资源。您还需要将存储添加到您的群集中（某些云提供商可能会提供存储），因为如果没有先与您的云提供商一起设置存储，就无法配置持久卷和持久卷声明。持久性存储的使用可确保MSP，分类帐和已安装链码之类的数据不存储在容器文件系统中，从而防止在销毁容器时将其销毁。</p><h3 id="管理基础架构"><a href="#管理基础架构" class="headerlink" title="管理基础架构"></a>管理基础架构</h3><p>用来管理后端的确切方法和工具将取决于所选择的后端。但请注意：</p><ul><li>使用机密对象将重要的配置文件安全地存储在群集中。有关Kubernetes机密的信息，请查看<a class="link" href="https://kubernetes.io/docs/concepts/configuration/secret/">Kubernetes机密<i class="fas fa-external-link-alt"></i></a>。您还可以选择使用硬件安全模块（HSM）或加密的永久卷（PV）。同样，在部署Fabric组件之后，您可能希望在自己的后端连接到容器，例如在Docker Hub之类的服务中使用私有仓库。在这种情况下，您将需要以Kubernetes机密的形式对登录信息进行编码，并在部署组件时将其包含在YAML文件中。</li><li>群集注意事项和节点大小。在上面的步骤中，我们讨论了有关如何考虑节点大小的总体概述。您的用例以及稳健的开发周期是您真正了解对等方，订购节点和CA的大小的唯一方法。</li><li>您如何选择挂载卷。最佳做法是将与您的节点相关的卷挂载到部署节点的外部。这将使您以后可以引用这些卷（例如，重新启动已崩溃的节点或容器），而不必重新部署或重新生成加密材料。</li><li>您将如何监视资源。建立用于监视各个节点使用的资源以及通常部署到群集的资源的策略和方法至关重要。当您将同伴加入更多渠道时，可能需要增加其CPU和内存分配。同样，您将需要确保有足够的存储空间用于状态数据库和区块链。</li></ul><h3 id="设置CA"><a href="#设置CA" class="headerlink" title="设置CA"></a>设置CA</h3><h3 id="CA和MSP"><a href="#CA和MSP" class="headerlink" title="CA和MSP"></a>CA和MSP</h3><p>创建CA后，可以使用它们为与组织（由MSP表示）相关的标识和组件创建证书。对于每个组织，至少需要：</p><ol><li><strong>register and enroll an admin identity and create an MSP</strong><ul><li>创建与组织相关联的CA，rigister a user and then enroll an identity （生成用于网络所有实体的证书对）<ol><li>由CA管理员分配用于标识身份的用户名和密码。属性和从属关系也可以被提供给身份（例如，一个<code>role</code>的<code>admin</code>，这是必要的组织管理员）</li><li>enroll identity之后可以用用户名和密码来register</li></ol></li><li>CA将为此身份生成两个证书，用于对身份采取的操作进行签名<ul><li>网络其他成员已知的<strong>公共证书</strong>（也称为“ signcert”或“公共证书”）</li><li><strong>私钥</strong>（存储在<code>keystore</code>文件夹）。</li></ul></li><li>CA还将生成一组文件夹，称为“ MSP”，其中包含颁发证书的CA的公共证书以及该CA的信任根（可能是相同的CA，也可能不是同一CA）。<ul><li>该MSP可以认为是定义与管理员身份相关联的组织。</li><li>如果组织的管理员也将是节点的管理员（这是典型的），则<strong>必须在创建节点的本地MSP之前创建组织的管理员身份，因为在之后情况下必须使用节点管理员的证书创建本地MSP</strong>。</li></ul></li></ul></li></ol><ol start="2"><li><strong>Register and enroll node identities</strong><ul><li>必须同时使用 enrollment CA和TLS CA（后者生成用于保护通信的证书）register和enroll 节点的身份。而不是给节点一个<code>admin</code>或者<code>user</code>的角色</li><li>在向 enrollmentCA注册该节点时，给它一个<code>peer</code>或<code>orderer</code>的角色。与管理员一样，也可以分配此身份的属性和从属关系。</li><li>节点的MSP结构称为“本地MSP”，因为分配给身份的权限仅在本地（节点）级别相关。此MSP是在创建节点标识时创建的，并在引导节点时使用。</li></ul></li></ol><h3 id="部署peer和orderer"><a href="#部署peer和orderer" class="headerlink" title="部署peer和orderer"></a>部署peer和orderer</h3><p>部署节点前先定义其配置文件</p><ul><li>peer：<code>config/core.yaml</code></li><li>ordering node：<code>config/orderer.yaml</code></li></ul><p>三个主要选项可用于调整配置。</p><ol><li>编辑与二进制文件捆绑在一起的YAML文件。<ul><li>优点：每当关闭并重新启动节点时，都将保留更改</li><li>缺点：在升级到新的二进制版本时，必须将自定义的选项移植到新的YAML（升级到新版本时，应使用最新的YAML）。</li></ul></li><li>部署时使用环境变量替代。</li><li>在CLI命令上指定标志。</li></ol><blockquote><p>可以使用所有大写字母，相关短语之间的下划线和前缀，从相关YAML文件中的参数推断环境变量。例如：</p><ul><li>peer配置变量称为<code>peer.localMSPid</code>（它是<code>localMSPid</code>内侧可变<code>peer</code>结构部分）在<code>core.yaml</code>将被呈现为所谓的环境变量<code>CORE_PEER_LOCALMSPID</code></li><li>而订购服务环境变量<code>General.LocalMSPID</code>在<code>orderer.yaml</code>配置文件的<code>General</code>所述的部分将被呈现为所谓的环境变量<code>ORDERER_GENERAL_LOCALMSPID</code>。</li></ul></blockquote><h4 id="peer"><a href="#peer" class="headerlink" title="peer"></a>peer</h4><h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><p>peer由属于渠道成员的组织所有（因此，有时将这些组织称为“对等组织”）。它们连接到订购服务和其他对等方，安装了智能合约，并且是分类帐的存储地。</p><p>在创建对等节点之前，必须了解这些角色，因为它们会影响您的自定义和部署决策。要查看您将需要做出的各种决策，请查看<a class="link" href="https://hyperledger-fabric.readthedocs.io/en/latest/deploypeer/peerplan.html">规划生产对等体<i class="fas fa-external-link-alt"></i></a>。</p><p>对等方在<code>config/core.yaml</code>文件中的配置值必须自定义或使用环境变量覆盖。此配置文件与对等映像捆绑在一起，并且也包含在可下载的二进制文件中。有关如何下载产品的<code>core.yaml</code>和对等映像的信息，请查看<a class="link" href="https://hyperledger-fabric.readthedocs.io/en/latest/deploypeer/peerdeploy.html">Deploy the peer<i class="fas fa-external-link-alt"></i></a>。</p><p>尽管默认的<code>core.yaml</code>中有许多参数，我们只需要自定义其中的一小部分即可。通常，如果不需要更改调整值，请保留默认值。</p><ul><li><strong>Identifiers</strong>：这些<strong>标识符</strong>不仅包括指向相关本地MSP和传输层安全性（TLS）证书的路径，而且还包括对等方的名称（称为“peer ID”）和拥有对等方的组织的MSP ID。</li><li><strong>Addresses and paths</strong>：因为对等点本身并不是实体，而是与其他对等点和组件交互，所以必须在配置中指定一系列地址。这些地址包其他组件可以用来找到对等点本身的地址，以及可以找到链码的地址（例如，如果您使用外部链码）。同样，您将需要指定分类帐的位置（以及状态数据库类型）和外部构建器的路径（同样，如果您打算使用外部链码）。其中包括“<strong>operations”和“metrics”</strong>，它们可以设置用于通过配置端点来监视对等方的运行状况和性能的方法。</li><li><strong>Gossip</strong>：Fabric网络中的组件使用“Gossip”协议相互通信。通过此协议，发现服务可以发现它们，并将区块和私有数据相互传播。请注意，Gossip通信使用TLS进行保护。</li></ul><blockquote><p>有关<code>core.yaml</code>其特定参数的更多信息，请查看<a class="link" href="https://hyperledger-fabric.readthedocs.io/en/latest/deploypeer/peerchecklist.html">production peer的清单<i class="fas fa-external-link-alt"></i></a>。</p><p>当对对等方的配置方式，卷的安装方式以及后端配置感到满意时，可以运行命令来启动对等方（此命令将取决于您的后端配置）。</p></blockquote><h5 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h5><ul><li><a class="link" href="https://hyperledger-fabric.readthedocs.io/en/latest/deploypeer/peerplan.html">规划production peer<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" href="https://hyperledger-fabric.readthedocs.io/en/latest/deploypeer/peerchecklist.html">production peer的清单<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" href="https://hyperledger-fabric.readthedocs.io/en/latest/deploypeer/peerdeploy.html">部署peer<i class="fas fa-external-link-alt"></i></a></li></ul><h4 id="order"><a href="#order" class="headerlink" title="order"></a>order</h4><h5 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h5><p>注意：虽然可以在订购服务中添加其他节点，但是这些教程仅介绍创建订购服务的过程。</p><p><strong>ordering service</strong>负责将已认可的交易按字面意义“订购”到块中，然后对等方验证并提交到其分类帐。</p><p>对等方和订购服务之间的<strong>主要区别</strong>在于</p><ul><li>在生产网络中，多个订购节点共同协作以形成通道的“订购服务”（这些节点也称为“消费者集”）。这将创建一系列需要在节点级别和集群级别上做出的重要决策。</li><li>其中一些群集决策不是在单个排序节点配置文件<code>orderer.yaml</code>中做出的，而是在<code>configtx.yaml</code>用于生成应用程序通道的创世纪块的文件中做出的。</li><li>要查看需要做出的各种决定，请查看<a class="link" href="https://hyperledger-fabric.readthedocs.io/en/latest/deployorderer/ordererplan.html">规划订购服务<i class="fas fa-external-link-alt"></i></a>。</li></ul><p><code>config/orderer.yaml</code>配置文件必须对定制节点文件中的配置值进行自定义或使用环境变量覆盖它们。</p><p>此配置文件与订购者映像捆绑在一起，并且还包含在可下载的二进制文件中。有关如何下载产品<code>orderer.yaml</code>和<a class="link" href="https://hyperledger-fabric.readthedocs.io/en/latest/deployorderer/ordererdeploy.html">订购<i class="fas fa-external-link-alt"></i></a>者映像的信息，请查看“<a class="link" href="https://hyperledger-fabric.readthedocs.io/en/latest/deployorderer/ordererdeploy.html">部署订购服务”<i class="fas fa-external-link-alt"></i></a>。</p><p>尽管默认的<code>orderer.yaml</code>中有许多参数，我们只需要自定义其中的一小部分即可。通常，如果不需要更改调整值，请保留默认值：</p><ul><li><strong>Identifiers</strong>：这些<strong>标识符</strong>不仅包括指向相关本地MSP和传输层安全性（TLS）证书的路径，还包括拥有订购节点的组织的MSP ID。</li><li><strong>Addresses and paths</strong>：由于订购节点与其他组件交互，因此必须在配置中指定一系列地址。这些地址包其他组件以及<strong>operations和Metrics</strong>可以在其中找到订购节点本身的地址，这些地址让我们可以设置方法来通过配置端点来监视订购节点的运行状况和性能。</li></ul><p>有关<code>orderer.yaml</code>其特定参数的更多信息，请查看<a class="link" href="https://hyperledger-fabric.readthedocs.io/en/latest/deployorderer/ordererchecklist.html">生产订购节点的清单<i class="fas fa-external-link-alt"></i></a>。</p><blockquote><p>注意：本教程假定引导orderer时将不使用系统通道生成块。取而代之的是，这些节点（或其中的一个子集）将使用<a class="link" href="https://hyperledger-fabric.readthedocs.io/en/latest/create_channel/create_channel_participation.html">创建通道<i class="fas fa-external-link-alt"></i></a>的过程加入到<a class="link" href="https://hyperledger-fabric.readthedocs.io/en/latest/create_channel/create_channel_participation.html">通道<i class="fas fa-external-link-alt"></i></a>中。有关如何创建将通过系统通道创始块自举<a class="link" href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/deployment_guide_overview.html">的订购程序的信息<i class="fas fa-external-link-alt"></i></a>，请<a class="link" href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/deployment_guide_overview.html">参阅<i class="fas fa-external-link-alt"></i></a>Fabric v2.2文档中的“<a class="link" href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/deployment_guide_overview.html">部署订购服务<i class="fas fa-external-link-alt"></i></a>”。</p></blockquote><h5 id="部署-1"><a href="#部署-1" class="headerlink" title="部署"></a>部署</h5><ul><li><a class="link" href="https://hyperledger-fabric.readthedocs.io/en/latest/deployorderer/ordererplan.html">规划订购服务<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" href="https://hyperledger-fabric.readthedocs.io/en/latest/deployorderer/ordererchecklist.html">生产订购节点的清单<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" href="https://hyperledger-fabric.readthedocs.io/en/latest/deployorderer/ordererdeploy.html">部署订购服务<i class="fas fa-external-link-alt"></i></a></li></ul><h1 id="test-network"><a href="#test-network" class="headerlink" title="test-network"></a>test-network</h1><h2 id="network-up"><a href="#network-up" class="headerlink" title="network up"></a>network up</h2><ul><li>checkPreps</li><li>CreateOrgs<ul><li>organizations/cryptogen<ul><li><code>cryptogen generate --config=./organizations/cryptogen/crypto-config.yaml --output=&quot;organizations&quot;</code></li><li><code>./organizations/ccp-generate.sh</code></li></ul></li><li>organizations/fabric-ca<ul><li><code>docker-compose -f docker/docker-compose-ca.yaml_CA up -d 2&gt;&amp;1</code></li><li><code>. organizations/fabric-ca/registerEnroll.sh</code> –&gt; <code>createOrg</code><ul><li>enroll ca admin：<code>fabric-ca-client enroll</code></li><li>Registering peer0：<code>fabric-ca-client register</code></li><li>Registering user：<code>fabric-ca-client register</code></li><li>Registering the org admin：<code>fabric-ca-client register</code></li><li>Generating the peer0 msp：<code>fabric-ca-client enroll</code></li><li>Generating the peer0-tls certificates：<code>fabric-ca-client enroll</code></li><li>Generating the user msp：<code>fabric-ca-client enroll</code></li><li>Generating the org admin msp：<code>fabric-ca-client enroll</code></li></ul></li><li><code>./organizations/ccp-generate.sh</code></li></ul></li></ul></li><li><code>docker-compose $&#123;COMPOSE_FILES&#125; up -d 2&gt;&amp;1</code><ul><li>COMPOSE_FILES：docker目录下，<ul><li><code>docker-compose-ca</code>：上面的ca模式使用，开启ca的docker</li><li><code>docker-compose-couch</code>：-s couchdb 模式下使用，开启couchdb的docker</li><li><code>docker-compose-ca</code>：除了couchdb，其他模式均使用</li></ul></li></ul></li></ul><h2 id="network-createChannel"><a href="#network-createChannel" class="headerlink" title="network createChannel"></a>network createChannel</h2><p>scripts/createChannel.sh</p><h1 id="代码工具"><a href="#代码工具" class="headerlink" title="代码工具"></a>代码工具</h1><p>下面两个二进制执行文件是使用fabric源码生成的</p><ul><li><a class="link" href="https://github.com/hyperledger/fabric.git">github<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" href="https://codechina.csdn.net/mirrors/hyperledger/fabric">code china<i class="fas fa-external-link-alt"></i></a> 国内镜像加速</li></ul><p>下载fabric源码之后，进入根目录，编译生成下面的二进制文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> fabric</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make cryptogen</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make configtxgen</span></span><br></pre></td></tr></table></figure><ul><li>make生成的可执行文件均在目录 <code>fabric/build/bin</code> 下</li></ul><h2 id="cryptogen"><a href="#cryptogen" class="headerlink" title="cryptogen"></a>cryptogen</h2><p>用于生成区块链网络中相应用户的相关证书文件，即组织结构身份文件</p><ul><li>编写配置文件 <code>crypto-config.yaml</code>，根据其生成相关的证书等，放在目录 <code>crypto-config</code> 下面</li></ul><p>从crypto-config.yaml配置文件中生成用户相应的秘钥和证书文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cryptogen generate --config=./crypto-config.yaml --output=<span class="string">&quot;organizations&quot;</span></span></span><br></pre></td></tr></table></figure><ul><li>文件将会生成在 <code>crypto-config.yaml</code> 文件所在路径的文件夹 <code>organizations </code>下<ul><li>一般会创建两种文件<code>peerOrganizations</code> 和 <code>ordererOrganizations</code></li></ul></li><li>不指定 <code>--output</code> 属性会默认在当前文件夹下建立一个 <code>crypto-config</code>文件夹，并将相关的证书放在该文件夹下</li></ul><h2 id="configtxgen"><a href="#configtxgen" class="headerlink" title="configtxgen"></a>configtxgen</h2><p>configtxgen模块用来生成<strong>orderer的初始化文件</strong>和<strong>channel的初始化文件</strong>， 配合cryptogen生成的组织结构身份文件使用，离线生成跟通道有关的配置信息</p><ul><li>configtxgen模块的配置文件 <code>configtx.yaml</code> 包括Fabric系统初始块、channel初始块文件等信息。</li><li>命令参数：<ul><li><strong>-asOrg</strong>    string    #所属组织，也就是为某个特定组织生成配置</li><li><strong>-channelID</strong>string    #channel名称，如果不指定默认是”testchainid”</li><li><strong>-inspectBlock</strong>    string    #打印指定区块文件中配置内容</li><li><strong>-inspectChannelCreateTx</strong>    string    #打印指定创建通道交易的配置文件</li><li><strong>-outputAnchorPeersUpdate</strong>    string    #生成一个更新锚点的更新channel配置信息</li><li><strong>-outputBlock</strong>    string    #输出区块文件路径</li><li><strong>-outputCreateChannelTx</strong>    string    #指定一个路径，来生成channel配置文件</li><li><strong>-profile</strong>    string    #配置文件中的节点，用于生成相关配置文件，默认是 “SampleInsecureSolo”)</li><li><strong>-version</strong>    #显示版本信息</li></ul></li></ul><p>用于生成通道配置的命令：</p><ol><li><p>生成Orderer服务启动的初始区块（即系统通道的创世区块文件）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ./config/genesis.block</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看通道配置</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> configtxgen -profile TwoOrgsOrdererGenesis -inspecBlock ./config/genesis.block</span></span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>生成新建应用通道的配置文件（即用于创建应用通道的配置交易文件）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./config/channel.tx -channelID mychannel</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看配置文件内容</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> configtxgen -profile TwoOrgsChannel -inspectChannelCreateTx ./config/channel.tx</span></span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>生成锚节点配置更新文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./config/Org1MSPanchors.tx -channelID mychannel -asOrg Org1MSP</span></span><br></pre></td></tr></table></figure></li></ol><blockquote><p>configtxgen的输出很大程度上受控于配置文件 <code>configtx.yaml</code> 的内容，该文件的搜索路径由 环境变量 <code>FABRIC_CFG_PATH</code> 指定。</p></blockquote><h2 id="Fabric-CA-命令行"><a href="#Fabric-CA-命令行" class="headerlink" title="Fabric CA 命令行"></a>Fabric CA 命令行</h2><p><a class="link" href="https://www.jianshu.com/p/2159f9043102">https://www.jianshu.com/p/2159f9043102<i class="fas fa-external-link-alt"></i></a></p><p>Hyperledger Fabric CA由server和client两部分组成。<br>设置两个环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export FABRIC_CA_SERVER_HOME=$&#123;PWD&#125;/test-network/organizations/fabric-ca/server</span><br><span class="line">export FABRIC_CA_CLIENT_HOME=$&#123;PWD&#125;/test-network/organizations/fabric-ca/client</span><br></pre></td></tr></table></figure><ul><li>注意在 <strong>fabric-sample</strong> 样例中<ul><li>FABRIC_CA_SERVER_HOME = <code>/fabric-ca/orgn</code></li><li>FABRIC_CA_CLIENT_HOME = <code>fabric-ca</code></li></ul></li></ul><h3 id="fabric-ca-server"><a href="#fabric-ca-server" class="headerlink" title="fabric-ca-server"></a>fabric-ca-server</h3><p>主要有两个操作 - 初始化server服务、启动server服务</p><p><strong>1、初始化server服务</strong></p><p>在server启动之前，需要至少有一个自我认证的身份存在，这个步骤主要会创建这个自我认证的身份。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在 <span class="variable">$&#123;FABRIC_CA_SERVER_HOME&#125;</span> 目录下执行</span></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;FABRIC_CA_SERVER_HOME&#125;fabric-ca-server init -b admin:adminpw</span></span><br></pre></td></tr></table></figure><p>命令执行完成后生成如下4个文件：</p><ul><li>server配置文件：<ul><li><code>$&#123;FABRIC_CA_SERVER_HOME&#125;/fabric-ca-server-config.yaml</code></li></ul></li><li>server内部存储数据库文件<ul><li><code>$&#123;FABRIC_CA_SERVER_HOME&#125;/fabric-ca-server.db</code></li><li>是一个sqlite文件，包含三个表</li></ul></li><li>自我认证身份的证书文件<ul><li><code>$&#123;FABRIC_CA_SERVER_HOME&#125;/ca-cert.pem</code></li></ul></li><li>自我认证身份的私钥(private key)文件<ul><li><code>$&#123;FABRIC_CA_SERVER_HOME&#125;/msp/keystore/*d_sk</code></li></ul></li></ul><p><strong>2、启动server服务</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;FABRIC_CA_SERVER_HOME&#125;/fabric-ca-server start -b admin:adminpw</span></span><br></pre></td></tr></table></figure><ul><li>启动过程使用默认的配置文件，即在初始化阶段生成的<code>$&#123;FABRIC_CA_SERVER_HOME&#125;/fabric-ca-server-config.yaml</code>，如果需要使用非默认配置文件，只需要通过命令行参数 <code>--config</code> 指定文件名即可。</li></ul><blockquote><p>另，我们看到server端的主要操作有两步完成，第一步初始化，第二步启动；实际上两步可以合并成一步，即直接执行第二步启动就可以，因为在启动过程中如果发现还没有进行过初始化，那么会自动执行初始化的操作；</p><p>那为什么需要分成两步呢？因为初始化完成之后用户可能需要对配置文件进行修改，调整参数和配置，然后在启动，而如果直接执行第二步就没有机会修改和调整配置了。</p></blockquote><p>启动完之后可以发送如下命令检查时候工作正常</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -i -uadmin:adminpw -X POST -H <span class="string">&quot;Content-type:application/json&quot;</span> http://localhost:7054/cainfo</span></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Date: Tue, 10 Oct 2017 05:42:16 GMT</span><br><span class="line">Content-Length: 1127</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;success&quot;:true,</span><br><span class="line">  &quot;result&quot;:&#123;</span><br><span class="line">                 &quot;CAName&quot;:&quot;&quot;,</span><br><span class="line">                 &quot;CAChain&quot;:&quot;LS0tLS1CRUdJT......tLS0K&quot;</span><br><span class="line">             &#125;,</span><br><span class="line">  &quot;errors&quot;:[],</span><br><span class="line">  &quot;messages&quot;:[]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fabric-ca-client"><a href="#fabric-ca-client" class="headerlink" title="fabric-ca-client"></a>fabric-ca-client</h3><p>管理身份（包括属性管理）和证书（包括续订和回收）</p><p><strong>3、完成自证管理员身份认证</strong></p><p>自证管理员是在server启动的时候就内置进去的；后面的很多操作都需要管理员的身份，所以这一步先要获取管理员的身份资格，才能往下操作，比如添加新的角色身份，添加新的管理员等等。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;FABRIC_CA_CLIENT_HOME&#125;</span>/fabric-ca-client enroll -u http://admin:adminpw@localhost:7054</span><br></pre></td></tr></table></figure><p>4、</p><p>5、</p><h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><h2 id="configtx-yaml"><a href="#configtx-yaml" class="headerlink" title="configtx.yaml"></a>configtx.yaml</h2><h2 id="crypto-config-yaml"><a href="#crypto-config-yaml" class="headerlink" title="crypto-config.yaml"></a>crypto-config.yaml</h2><p>fabric 网络用户拓扑关系配置文件</p><p>生成 <code>crypto-config.yaml</code> 的模版：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./bin/cryptogen showtemplate &gt; crypto-config.yaml</span></span><br></pre></td></tr></table></figure><ul><li>会在当前目录下生成 <code>crypto-config.yaml</code> 的模版示例</li></ul><h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><ul><li>Domain：相应组织的顶级域名</li><li>EnableNodeOUs：启用节点OU划分</li><li>Template.Count：表示组织下有几个节点，默认名字为peer0、peer1依次类推</li><li>Users.Count：表示组织下有几个User，默认有一个Admin，User命名从User1开始</li></ul><h2 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本部分主要讲解生产网络的部署&lt;/p&gt;
&lt;p&gt;因为所有的节点等都是在docker容器中跑的，所以&lt;/p&gt;
&lt;h1 id=&quot;网络配置&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="Notebook" scheme="https://jieyang-wei.github.io/categories/Notebook/"/>
    
    <category term="Blockchain" scheme="https://jieyang-wei.github.io/categories/Notebook/Blockchain/"/>
    
    <category term="Fabric" scheme="https://jieyang-wei.github.io/categories/Notebook/Blockchain/Fabric/"/>
    
    
    <category term="fabric" scheme="https://jieyang-wei.github.io/tags/fabric/"/>
    
    <category term="blockchain" scheme="https://jieyang-wei.github.io/tags/blockchain/"/>
    
  </entry>
  
  <entry>
    <title>网络爬虫</title>
    <link href="https://jieyang-wei.github.io/2021/03/20/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"/>
    <id>https://jieyang-wei.github.io/2021/03/20/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/</id>
    <published>2021-03-20T05:41:03.000Z</published>
    <updated>2021-04-19T06:44:49.942Z</updated>
    
    <content type="html"><![CDATA[<p>p2p基础</p><p>python包：</p><ul><li>request</li><li>webdriver</li><li>scrapy</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;p2p基础&lt;/p&gt;
&lt;p&gt;python包：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;request&lt;/li&gt;
&lt;li&gt;webdriver&lt;/li&gt;
&lt;li&gt;scrapy&lt;/li&gt;
&lt;/ul&gt;
</summary>
      
    
    
    
    <category term="Course" scheme="https://jieyang-wei.github.io/categories/Course/"/>
    
    <category term="Network" scheme="https://jieyang-wei.github.io/categories/Course/Network/"/>
    
    
    <category term="python" scheme="https://jieyang-wei.github.io/tags/python/"/>
    
    <category term="network" scheme="https://jieyang-wei.github.io/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>fabric-Tutorials</title>
    <link href="https://jieyang-wei.github.io/2021/03/19/fabric-Tutorials/"/>
    <id>https://jieyang-wei.github.io/2021/03/19/fabric-Tutorials/</id>
    <published>2021-03-19T03:33:34.000Z</published>
    <updated>2021-04-19T06:43:16.607Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本部分详细介绍了Hyperledger Fabric中的客户端应用程序和智能合约开发的关键功能。对功能的深入了解将帮助您设计和实施高效的解决方案。</p><h1 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h1><p>智能合约是高级编程抽象的一个示例，可以在链码容器中定义智能合约。将链码安装在对等方上并部署到通道后，其中的所有智能合约都可用于您的应用程序。</p><blockquote><p>一个智能合约只能属于一个chaincode，但一个chaincode中可以包含多个智能合约</p><ul><li><strong>合同名称在链码文件中必须唯一</strong>。某些代码编辑器会在部署之前检测到相同类名的多个定义。如果显式或隐式指定了多个具有相同协定名称的类，则链代码将返回错误。</li><li><strong>不指定链码中的合约将默认使用第一个合约</strong></li><li><strong>单个链码中存放多个相关合约是有意义的</strong>。<ul><li>例如，在不同的货币计价的可能有合同的商业票据<code>EuroPaperContract</code>， <code>DollarPaperContract</code>，  <code>YenPaperContract </code>这可能需要保持在它们所部署的通道相互同步。</li></ul></li></ul></blockquote><h2 id="链码"><a href="#链码" class="headerlink" title="链码"></a>链码</h2><p>链码是用于将代码部署到Hyperledger Fabric区块链网络的通用容器</p><p>当写好链码文件后（此例中为 commercialpaper.js），需要经过以下步骤：</p><ul><li>打包：peer chaincode package</li><li>下载到通道：peer chaincode install</li><li>组织管理员批准链码：peer chaincode approveformyorg</li><li>当满足制定策略之后，通道上任一节点均可提交此链码：peer chaincode commit</li></ul><h3 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h3><p>链码的namespace允许它保持其世界状态与其他链码分离。</p><ul><li><p>具体来说，具有相同链码的智能合约共享对同一世界状态的直接访问，而具有不同链码的智能合约不能直接访问彼此的世界状态。</p><ul><li><p>即Chaincode命名空间提供了不同世界状态之间的<strong>隔离</strong></p><blockquote><p>注意：不能选择链码名称空间。它由Hyperledger Fabric分配，并直接映射到链码的名称</p></blockquote></li></ul></li><li><p>如果智能合约需要访问另一个链码世界状态，则可以通过执行链码到链码的调用来做到这一点。</p></li><li><p>最后，区块链可以包含与不同世界状态相关的交易。</p></li></ul><blockquote><p>注意：</p><p>将同一个链码部署到不同peer的channel上时，将创建一个完全独立的区块链，并创建两个新的世界状态数据库。但是，peer和chaincode container不会增加，每个都将连接到多个通道。</p></blockquote><h3 id="同链码访问"><a href="#同链码访问" class="headerlink" title="同链码访问"></a>同链码访问</h3><p><strong>示例图：</strong></p><p>![截屏2021-03-19 下午9.02.21](fabric-Tutorials/截屏2021-03-19 下午9.02.21.png)</p><ul><li>应用程序与对等方进行通信，并且对等方将请求路由到适当的链码容器，然后容器可以访问DBMS。该路由由图中所示的对等<strong>核心</strong>组件完成。</li></ul><p><strong>示例代码：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> euroPaper = network.getContract(papers, euroPaper);</span><br><span class="line">paper1 = euroPaper.submit(issue, PAP11);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> yenPaper = network.getContract(papers, yenPaper);</span><br><span class="line">paper2 = yenPaper.submit(redeem, PAP21);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> euroBond = network.getContract(bonds, euroBond);</span><br><span class="line">bond1 = euroBond.submit(buy, BON31);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> yenBond = network.getContract(bonds, yenBond);</span><br><span class="line">bond2 = yenBond.submit(sell, BON41);</span><br></pre></td></tr></table></figure><ol><li><strong>应用程序</strong><ul><li>使用 <code>getContract()</code> API访问 <code>papers</code>链码中的 <code>euroPaper</code> 和 <code>yenPaper</code> 合约。<ul><li>参见交互点<strong>1a</strong>和<strong>2a</strong>。</li></ul></li><li>使用 <code>getContract()</code>。API访问 <code>bonds</code> 链码中的 <code>euroBond</code> 和 <code>yenBond</code> 合约。<ul><li>参见交互点<strong>3a</strong>和<strong>4a</strong>。</li></ul></li><li>使用 <code>euroPaper</code> 合约将 <code>issue</code> 交易提交到网络以获取商业票据 <code>PAP11</code>。参见相互作用点<strong>1a</strong>。结果在  <code>world state A</code> 中产生了商业票据 <code>PAP11</code>；相互作用点<strong>1b</strong>。该操作在交互点<strong>1c</strong>被捕获为区块链中的交易。</li><li>使用 <code>yenPaper</code> 合约将 <code>redeem</code> 交易提交到网络以获取商业票据 <code>PAP21</code>。参见交互点<strong>2a</strong>。这导致在<code>world state A</code> 中商业票据 <code>PAP21</code> 的状态为赎回中；交互点<strong>2b</strong>。该操作在交互点<strong>2c</strong>被捕获为区块链中的交易。</li><li>使用 <code>euroBond</code> 合约操作 <code>BON41</code> 进行 <code>buy</code> 交易并提交到网络。参见相互作用点<strong>3a</strong>。这导致在 <code>world state B</code> 中 <code>BON31</code> 的状态更新，相互作用点<strong>3b</strong>。该操作在交互点<strong>3c</strong>被捕获为区块链中的交易。</li><li>使用 <code>yenBond</code> 合约操作 <code>BON41</code> 进行 <code>sell</code> 交易并提交到网络。参见相互作用点<strong>4a</strong>。这导致在 <code>world state B</code> 中 <code>BON41</code> 的状态更新，相互作用点 <strong>4b</strong>。该操作在交互点<strong>4c</strong>被捕获为区块链中的交易。</li></ul></li></ol><ol start="2"><li><strong>了解智能合约如何与世界状态交互：</strong></li></ol><ul><li><code>euroPaper</code>和<code>yenPaper</code>合同可以直接访问 <code>world state A</code>，但不能直接访问 <code>world state B</code>。<code>World state A</code> 物理地存储在与链码 <code>papers</code> 相对应的数据库管理系统（DBMS）中的数据库中。</li><li><code>euroBond</code>和<code>yenBond</code>合同可以直接访问 <code>world state B</code>，但不能直接访问 <code>world state A</code>。<code>World state B</code> 物理地存储在与链码 <code>Bonds</code> 相对应的数据库管理系统（DBMS）中的数据库中。</li></ul><ol start="3"><li><strong>了解区块链如何捕获所有世界各州的交易：</strong></li></ol><ul><li>互动<strong>1C</strong>和<strong>2C</strong>对应的交易分别创建和更新商业票据<code>PAP11</code>和<code>PAP21</code>分别。这些都包含在 <code>world state A</code> 中</li><li>互动<strong>3c</strong>和<strong>4c</strong>对应于更新债券 <code>BON31</code> 和  <code>BON41</code> 的交易。这些都包含 <code>world state B</code> 中。</li><li>如果 <code>world state A</code> 或 <code>world state B</code> 由于某种原因被销毁，则可以通过重新执行区块链中的所有交易来重新创建它们。</li></ul><h3 id="跨链码访问"><a href="#跨链码访问" class="headerlink" title="跨链码访问"></a>跨链码访问</h3><p><strong>示例图</strong></p><p><img src="/2021/03/19/fabric-Tutorials/develop.diagram.51.png" alt="develop.diagram.51"></p><ol><li>链码和智能合约如何通过他们的链码间接访问其他世界状态<ul><li>该应用程序在 <code>euroPaper</code> 智能合约中提交 <code>issue</code> 来发行 <code>PAP11</code>。参见互动<strong>1a</strong>。</li><li>智能合约 <code>euroPaper</code> 中的 <code>issue</code> 交易需要调用 <code>euroBond</code> 智能合约中的 <code>query</code> 交易。参见相互作用点<strong>1b</strong>。</li><li>在智能合约  <code>euroBond</code> 中 <code>query</code> 交易能检索 <code>world state B</code> 的信息。参见相互作用点<strong>1c</strong>。</li><li>当控制权返回 <code>issue</code> 交易时，它可以使用响应中的信息对 paper 定价并更新 。<code>world state A</code> 的信息。参见相互作用点<strong>1d</strong>。</li><li>发行以Yen计价的商业票据的控制流程是相同的。参见交互点<strong>2a</strong>，<strong>2b</strong>，<strong>2c</strong>和<strong>2d</strong>。</li></ul></li></ol><blockquote><p>使用<code>invokeChaincode()</code> <a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#invokeChaincode__anchor">API<i class="fas fa-external-link-alt"></i></a>在链代码之间传递control。</p><ul><li>该API将control从一个链码传递到另一个链码。</li><li>如果只 <strong>query</strong> 被调用的链码世界状态，调用可以在与调用者的链码不同的通道中进行。</li><li>如果需要 <strong>update</strong> 被调用的链码世界状态，调用必须与调用者链码在同一通道中。</li></ul></blockquote><p>尽管在示例中我们仅讨论了查询交易，但是可以调用智能合约来更新被调用的链码的世界状态</p><h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><p>在commercial paper中，链码papercontract中只包含了一个名为 <code>org.papernet.commercialpaper</code> 的合约</p><ul><li><p>合约构造</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommercialPaperContract</span> <span class="keyword">extends</span> <span class="title">Contract</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// Unique name when multiple contracts per chaincode file</span></span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&#x27;org.papernet.commercialpaper&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果未指定显式合同名称，则将分配默认名称 - 类的名称。<ul><li>在我们的示例中，<strong>默认合同名称</strong>为 <code>CommercialPaperContract</code>。</li></ul></li><li>建议使用显式的<strong>DNS样式</strong>命名约定，以帮助组织清晰且有意义的名称<ul><li><code>org.papernet.commercialpaper</code> 表示PaperNet网络已经定义了标准的商业用纸智能合约</li></ul></li></ul></li></ul><ul><li>合同名称在链码文件中必须唯一。某些代码编辑器会在部署之前检测到相同类名的多个定义。如果显式或隐式指定了多个具有相同协定名称的类，则链代码将返回错误。</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>将链码安装到对等方并部署到通道后，应用程序即可访问其中的智能合约：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> network = <span class="keyword">await</span> gateway.getNetwork(<span class="string">`papernet`</span>);</span><br><span class="line"><span class="keyword">const</span> contract = <span class="keyword">await</span> network.getContract(<span class="string">&#x27;papercontract&#x27;</span>, <span class="string">&#x27;org.papernet.commercialpaper&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> issueResponse = <span class="keyword">await</span> contract.submitTransaction(<span class="string">&#x27;issue&#x27;</span>, <span class="string">&#x27;MagnetoCorp&#x27;</span>, <span class="string">&#x27;00001&#x27;</span>, <span class="string">&#x27;2020-05-31&#x27;</span>, <span class="string">&#x27;2020-11-30&#x27;</span>, <span class="string">&#x27;5000000&#x27;</span>);</span><br></pre></td></tr></table></figure><ul><li>CommercialPaperContract 使用名称 org.papernet.commercialpaper 调用父类Contract来构造实例</li><li>所以network可以通过此名称定为到 CommercialPaperContract 类</li><li>contract 对象再调用CommercialPaperContract 类中定义的方法进行交易</li></ul><h1 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h1><h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><ul><li><p>允许智能合约在交易调用之间定义和维护用户变量</p></li><li><p>可以包含任意数量的用户变量，例如 <code>paperList</code>。</p></li><li><p>注意到一个智能合约的初始化流程：(路径：contract/papercontract.js)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommercialPaperContext</span> <span class="keyword">extends</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="comment">// All papers are held in a list of papers</span></span><br><span class="line">        <span class="built_in">this</span>.paperList = <span class="keyword">new</span> PaperList(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommercialPaperContract</span> <span class="keyword">extends</span> <span class="title">Contract</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// Unique namespace when multiple contracts per chaincode file</span></span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&#x27;org.papernet.commercialpaper&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="function"><span class="title">createContext</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommercialPaperContext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">issue</span>(<span class="params">ctx, issuer, paperNumber, ...</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">await</span> ctx.paperList.addPaper(...);</span><br><span class="line">        <span class="keyword">await</span> ctx.stub.putState(...);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">buy</span>(<span class="params">ctx, issuer, paperNumber, ...</span>)</span>&#123; &#125;</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">redeem</span>(<span class="params">ctx, issuer, paperNumber, ...</span>)</span>&#123; &#125;</span><br><span class="line">    ... ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>构建智能合约时，开发人员可以选择内置的 <code>Context</code> 类 <code>createContext</code> 方法以创建自定义上下文</li><li>本例中，<code>CommercialPaperContext</code>专门用于 <code>CommercialPaperContract</code>。观察指定的 <code>context</code> 如何通过 <code>this</code> 关键字将 <code>PaperList</code> 添加到自己的成员中</li></ul></li></ul><p>transaction context还包含两个内置元素，这些元素提供对范围广泛的Fabric功能的访问，从提交交易的客户端应用程序到分类帐访问。</p><ul><li>**<code>ctx.stub</code>**：用于访问API，这些API从分类账提供各种交易处理操作<ul><li><code>putState()</code> 和 <code>getState()</code> 访问分类账，<code>getTxID()</code> 以检索当前交易ID。</li></ul></li><li>**<code>ctx.clientIdentity</code>**： 用于获取有关提交交易的用户身份的信息。</li></ul><p>一个智能合约通过 <code>stub </code>和 <code>clientIdentity</code> 可以访问一系列的功能：</p><img src="/2021/03/19/fabric-Tutorials/develop.diagram.41.png" alt="develop.diagram.41" style="zoom:45%;"><h3 id="Stub"><a href="#Stub" class="headerlink" title="Stub"></a>Stub</h3><p>API分类：</p><ol><li><strong>World state data APIs</strong> - 交互点**(1)**<ul><li>使智能合约能够使用其密钥从世界状态中获取，放置和删除与各个对象相对应的状态<ul><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getState__anchor">getState( )<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#putState__anchor">putState( )<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#deleteState__anchor">deleteState( )<i class="fas fa-external-link-alt"></i></a></li></ul></li><li>辅以<strong>query API</strong>：交互点**(2)** - 使合同能够检索一组状态而不是单个状态，该集合可以通过使用完整或部分键的键值范围来定义，也可以根据基础世界状态数据库中的值进行查询 。对于大型查询，可以对结果集进行分页以减少存储需求：<ul><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getStateByRange__anchor">getStateByRange( )<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getStateByRangeWithPagination__anchor">getStateByRangeWithPagination( )<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getStateByPartialCompositeKey__anchor">getStateByPartialCompositeKey( )<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getStateByPartialCompositeKeyWithPagination__anchor">getStateByPartialCompositeKeyWithPagination( )<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getQueryResult__anchor">getQueryResult( )<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getQueryResultWithPagination__anchor">getQueryResultWithPagination( )<i class="fas fa-external-link-alt"></i></a></li></ul></li></ul></li></ol><ol start="2"><li><strong>私有数据APIs</strong> - 交互点**(3)**<ul><li>这些API使智能合约能够与私有数据收集进行交互。它们类似于用于世界状态交互的API，但用于私有数据。有一些API可以通过其键获取，放置和删除私有数据状态：<ul><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getPrivateData__anchor">getPrivateData( )<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#putPrivateData__anchor">putPrivateData( )<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#deletePrivateData__anchor">deletePrivateData( )<i class="fas fa-external-link-alt"></i></a></li></ul></li><li>辅以<strong>query API</strong>：交互点**(4)** - 这些API允许智能合约根据一系列键值（全部或部分键）从私有数据集合中检索一组状态，或者根据基础<strong>世界状态数据库</strong>中的值进行查询 。当前没有用于私有数据收集的分页API。<ul><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getPrivateDataByRange__anchor">getPrivateDataByRange( )<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getPrivateDataByPartialCompositeKey__anchor">getPrivateDataByPartialCompositeKey( )<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getPrivateDataQueryResult__anchor">getPrivateDataQueryResult( )<i class="fas fa-external-link-alt"></i></a></li></ul></li></ul></li></ol><ol start="3"><li><strong>Transaction APIs</strong> - 交互点**(5)**<ul><li>智能合约使用这些API来检索有关智能合约正在处理的当前交易提议的详细信息。这包括交易标识符和创建交易提议的时间。<ul><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getTxID__anchor">getTxID( )<i class="fas fa-external-link-alt"></i></a>：返回当前交易建议的id。**(5)**</li><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getTxTimestamp__anchor">getTxTimestamp( )<i class="fas fa-external-link-alt"></i></a> ：返回应用程序创建当前交易建议时的时间戳。**(5)**</li><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getCreator__anchor">getCreator( )<i class="fas fa-external-link-alt"></i></a> ：返回交易建议创建者的原始身份（X.509或其他）。如果这是X.509证书，则通常更适合使用 <code>ctx.ClientIdentity</code>。</li><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getSignedProposal__anchor">getSignedProposal( )<i class="fas fa-external-link-alt"></i></a> ：返回智能合约正在处理的当前交易提议的签名副本。</li><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getBinding__anchor">getBinding( )<i class="fas fa-external-link-alt"></i></a> ：用于防止使用随机数恶意或意外重播交易。（出于实际目的，随机数是由客户端应用程序生成并包含在加密哈希中的随机数。）例如，智能合约可以在**(1)<strong>使用此API 来检测交易是否重播</strong>(5)**。</li><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getTransient__anchor">getTransient( )<i class="fas fa-external-link-alt"></i></a> ：允许智能合约访问应用程序传递给智能合约的临时数据。请参阅交互点**(9)<strong>和</strong>(10)<strong>。临时数据是应用程序-智能合约交互的私有数据。它没有记录在分类帐中，通常与私人数据收集</strong>(3)**结合使用。</li></ul></li></ul></li></ol><ol start="4"><li><strong>Key APIs</strong> - 交互点**(2)<strong>和</strong>(4)**<ul><li>是智能合约可以操纵世界状态或私有数据收集中的状态密钥</li><li>这些API中最简单的API允许智能合约从其单独的组件中形成和拆分组合密钥。<ul><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/%7BBRACNH%7D/api/fabric-shim.ChaincodeStub.html#createCompositeKey__anchor">createCompositeKey( )<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#splitCompositeKey__anchor">splitCompositeKey( )<i class="fas fa-external-link-alt"></i></a></li></ul></li><li><code>ValidationParameter()</code> ：稍微先进一些，这些 API可以获取和设置针对世界状态**(2)<strong>和私有数据</strong>(4)**的基于状态的endorsement。<ul><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#setStateValidationParameter__anchor">setStateValidationParameter( )<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getStateValidationParameter__anchor">getStateValidationParameter( )<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getPrivateDataValidationParameter__anchor">getPrivateDataValidationParameter( )<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#setPrivateDataValidationParameter__anchor">setPrivateDataValidationParameter( )<i class="fas fa-external-link-alt"></i></a></li></ul></li><li><code>getHistoryForKey()</code>：通过返回存储值的的集合来检索状态的历史记录，该存储值包括执行状态更新的交易得id，从而允许从区块链读取交易**(10)**。<ul><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getHistoryForKey__anchor">getHistoryForKey( )<i class="fas fa-external-link-alt"></i></a></li></ul></li></ul></li></ol><ol start="5"><li><strong>Event APIs</strong> - 交互点**(5)**<ul><li>用于在处理智能合约期间设置事件</li><li>智能合约使用此API将事件添加到交易响应中。请注意，在交易中只能创建一个事件，并且当合同通过 <code>invokeChaincode</code> 相互调用时，该事件必须起源于最外面的合同。这些事件最终记录在区块链上，并在交互点**(11)**发送到侦听应用程序 。<ul><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#setEvent__anchor">setEvent( )<i class="fas fa-external-link-alt"></i></a></li></ul></li></ul></li></ol><ol start="6"><li><strong>Utility APIs</strong><ul><li>是有用的API的集合，这些API并不容易放入预定义的类别中，因此我们将它们分组在一起！它们包括检索当前通道名称，并将控制权传递给同一对等方上的不同链码。</li><li>任何peer均可使用，来获取应用程序在<strong>哪个通道</strong>上调用了智能合约 - 交互点**(13)**<ul><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getChannelID__anchor">getChannelID( )<i class="fas fa-external-link-alt"></i></a></li></ul></li><li>（不懂）MagnetoCorp组织中的Peer3上安装了多个智能合约。这些智能合约可以使用此API相互调用。智能合约必须并置/collocated；无法在其他对等方上调用智能合约。 - 交互点**(14)**<ul><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#invokeChaincode__anchor">invokeChaincode( )<i class="fas fa-external-link-alt"></i></a></li></ul></li><li>其中一些API仅在使用低级链码而不是智能合约的情况下使用。这些API主要用于链码输入的详细操作。智能合约 <code>Contract</code> 类会自动为开发人员整理所有的参数。<ul><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getFunctionAndParameters__anchor">getFunctionAndParameters( )<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getStringArgs__anchor">getStringArgs( )<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ChaincodeStub.html#getArgs__anchor">getArgs( )<i class="fas fa-external-link-alt"></i></a></li></ul></li></ul></li></ol><h3 id="ClientIdentity"><a href="#ClientIdentity" class="headerlink" title="ClientIdentity"></a>ClientIdentity</h3><p>在大多数情况下，提交交易的应用程序将使用X.509证书。</p><p>在本示例中，由 <code>CA1</code> <strong>(7)**颁发的X.509证书</strong>(6)**被  <code>Isabella</code>  **(8)**在其应用程序中用来在交易 <code>t6</code> **(5)**中签署提案。</p><p><code>ClientIdentity </code> 接收  <code>getCreator()</code> 返回的信息，并将一组X.509实用程序API放在其顶部，以使其更易于在此常见用例中使用。</p><ul><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ClientIdentity.html#getX509Certificate__anchor">getX509Certificate( )<i class="fas fa-external-link-alt"></i></a>：返回交易提交者的完整X.509证书，包括其所有属性及其值 - 交互点**(6)**</li><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ClientIdentity.html#getAttributeValue__anchor">getAttributeValue( )<i class="fas fa-external-link-alt"></i></a>：返回特定X.509属性的值，例如，组织单位 <code>OU</code> 或专有名称 <code>DN</code> - 交互点**(6)**</li><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ClientIdentity.html#assertAttributeValue__anchor">assertAttributeValue( )<i class="fas fa-external-link-alt"></i></a>：返回<code>TRUE</code>，如果X.509属性的指定属性具有指定的值 - 交互点**(6)**</li><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ClientIdentity.html#getID__anchor">getID( )<i class="fas fa-external-link-alt"></i></a>：根据交易提交者的专有名称和颁发方CA的专有名称，返回交易提交者的唯一标识id，格式为 <code>x509::&#123;subject DN&#125;::&#123;issuer DN&#125;</code> - 交互点**(6)**。</li><li><a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/master/api/fabric-shim.ClientIdentity.html#getMSPID__anchor">getMSPID( )<i class="fas fa-external-link-alt"></i></a>：返回交易提交者的channel MSP。这使智能合约可以根据提交者的组织身份做出处理决策 - 交互点**(15)<strong>或</strong>(16)**</li></ul><h2 id="Transaction-handlers"><a href="#Transaction-handlers" class="headerlink" title="Transaction handlers"></a>Transaction handlers</h2><p>交易处理程序允许智能合约开发人员在应用程序与智能合约之间的交互过程中的关键点定义通用处理。</p><ul><li>交易处理程序是可选的，但如果定义，它们将在调用智能合约中的每个交易之前或之后获得控制。即使没有定义也并不影响智能合约的正常运行。</li><li>还有一个特定的处理程序，该处理程序在发出请求以调用智能合约中未定义的交易时接收控制。</li><li>一个智能合约最多可以定义每种类型的一个handler，如果需要执行多个功能，则需要在功能内进行协调</li></ul><p><strong>1、类型：</strong></p><img src="/2021/03/19/fabric-Tutorials/截屏2021-03-20 下午4.54.53.png" alt="截屏2021-03-20 下午4.54.53" style="zoom:50%;"><ul><li><strong>Before handler</strong>：<ul><li>在每个智能合约交易被调用之前触发</li><li>通常用来修改交易的 <code>context</code>。可以访问所有范围的Fabric API；</li><li>例如，它可以issue <code>getState()</code> 和 <code>putState()</code>。</li></ul></li><li><strong>After handler</strong>：<ul><li>在每个智能合约交易被调用之后触发</li><li>通常执行所有交易的后加工。可以访问所有范围的Fabric API；</li></ul></li><li><strong>Unknown handler</strong>：<ul><li>在尝试调用智能合约中没有定义的交易时触发</li><li>通常用来记录故障，以供管理员进行后续处理。可以访问所有范围的Fabric API；</li></ul></li></ul><p><strong>2、定义：</strong></p><p>交易处理程序将作为具有明确定义名称的方法添加到智能合约中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">CommercialPaperContract <span class="keyword">extends</span> Contract &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">beforeTransaction</span>(<span class="params">ctx</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// Write the transaction ID as an informational to the console</span></span><br><span class="line">        <span class="built_in">console</span>.info(ctx.stub.getTxID());</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">afterTransaction</span>(<span class="params">ctx, result</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// This handler interacts with the ledger</span></span><br><span class="line">        ctx.stub.cpList.putState(...);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">unknownTransaction</span>(<span class="params">ctx</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// This handler throws an exception</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Unknown transaction function&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>交易处理程序定义的形式对于所有处理程序类型都是相似的，但是请注意，<code>afterTransaction(ctx, result)</code> 也将接收交易返回的任何结果。</li><li>该<a class="link" href="https://hyperledger.github.io/fabric-chaincode-node/main/api/fabric-contract-api.Contract.html">API文档<i class="fas fa-external-link-alt"></i></a>您展示了这些处理器的确切形式。</li></ul><p><strong>3、过程</strong></p><p>将处理程序添加到智能合约后，将在交易处理期间将其调用。在处理期间，处理程序接收<code>ctx</code>， 也就是 <code>transaction context</code>，执行一些处理，并在完成时返回控制。处理继续如下：</p><ul><li><p><strong>在处理程序之前</strong>：如果处理程序成功完成，则使用更新的 <code>context</code> 调用交易。如果处理程序引发异常，则不会调用该交易，并且智能合约将失败，显示异常错误消息。</p></li><li><p><strong>处理程序之后</strong>：如果处理程序成功完成，则智能合约将根据所调用的交易确定完成。如果处理程序引发异常，则交易将失败，并显示异常错误消息。</p></li><li><p><strong>未知处理程序</strong>：处理程序应通过引发带有所需错误消息的异常来完成。如果未指定<strong>Unknown处理程序</strong>，或者未引发异常，则存在显式默认处理；智能合约将失败，并显示<strong>未知的交易</strong>错误消息。</p></li></ul><p>当处理程序需要访问函数和参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">beforeTransaction</span>(<span class="params">ctx</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// Retrieve details of the transaction</span></span><br><span class="line">    <span class="keyword">let</span> txnDetails = ctx.stub.getFunctionAndParameters();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.info(<span class="string">`Calling function: <span class="subst">$&#123;txnDetails.fcn&#125;</span> `</span>);</span><br><span class="line">    <span class="built_in">console</span>.info(util.format(<span class="string">`Function arguments : %j <span class="subst">$&#123;stub.getArgs()&#125;</span> `</span><span class="string">`);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>此处理程序通过<a class="link" href="https://hyperledger-fabric.readthedocs.io/en/latest/developapps/transactioncontext.html#stub">transaction context<i class="fas fa-external-link-alt"></i></a>对象调用 utility API <code>getFunctionAndParameters</code>。</li></ul><h1 id="背书策略"><a href="#背书策略" class="headerlink" title="背书策略"></a>背书策略</h1><p>背书策略定义了认可交易以使其生效所需的最小组织集合。</p><ul><li>要进行背书，组织的背书对等方需要运行与交易关联的智能合约并签署其结果。</li><li>当订购服务将交易发送给 committed 的对等方时，他们将分别检查交易中的背书是否满足背书策略。如果不满足，则该交易将无效，并且对世界状态没有任何影响。</li></ul><p>背书策略以两种不同的粒度起作用：</p><ul><li>可以为<strong>整个命名空间</strong>以及<strong>单个状态键</strong>设置它们。它们使用诸如 <code>AND</code> 和 <code>OR</code> 的基本逻辑表达式来表示。</li><li>例如，在PaperNet中，该方法可以按以下方式使用：从MagnetoCorp出售给DigiBank的paper的背书政策可以设置为 <code>AND(MagnetoCorp.peer, DigiBank.peer)</code>，要求对paper进行任何更改都必须由MagnetoCorp和DigiBank进行背书。</li></ul><h1 id="连接配置"><a href="#连接配置" class="headerlink" title="连接配置"></a>连接配置</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gateway.connect(connectionProfile, connectionOptions);</span><br></pre></td></tr></table></figure><h2 id="Connection-Profile"><a href="#Connection-Profile" class="headerlink" title="Connection Profile"></a>Connection Profile</h2><p>连接配置文件</p><p>应用程序主要使用连接配置文件来配置处理所有网络交互的<strong>网关</strong>，从而使其能够专注于业务逻辑。</p><ul><li><p>连接配置文件主要中来配置网关，通常由了解网络拓扑的<strong>管理员</strong>创建。</p></li><li><p><strong>静态连接配置文件</strong>通常由详细了解网络拓扑的管理员创建。这是因为静态配置文件可以包含很多信息，并且管理员需要在相应的连接配置文件中捕获此信息。相反，<strong>动态配置文件</strong>将所需的定义量减到最少。</p></li><li><p><strong>静态网关</strong>比动态网关需要更多的信息，因为<strong>动态网关</strong>可以使用<a class="link" href="https://hyperledger-fabric.readthedocs.io/en/latest/discovery-overview.html">服务发现<i class="fas fa-external-link-alt"></i></a>来动态扩展连接配置文件中的信息</p></li><li><p>连接配置文不应该是网络通道的详尽描述，它只需要包含足够的信息即可使用它的网关</p><ul><li>根据需要添加和删除对等方，订购方，证书颁发机构，渠道和组织。</li><li>组件可能会启动和停止，或者发生意外故障（例如断电）。</li><li>服务发现可以在连接配置文件中扩充信息。具体而言，可以使用最少的Fabric拓扑信息来配置动态网关。其余的可以发现。</li></ul></li><li><p><strong>语法</strong>：json或者yaml</p></li></ul><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> yaml = <span class="built_in">require</span>(<span class="string">&#x27;js-yaml&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; Gateway &#125; = <span class="built_in">require</span>(<span class="string">&#x27;fabric-network&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> connectionProfile = yaml.safeLoad(fs.readFileSync(<span class="string">&#x27;../gateway/paperNet.yaml&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>));</span><br><span class="line"><span class="keyword">const</span> gateway = <span class="keyword">new</span> Gateway();</span><br><span class="line"><span class="keyword">await</span> gateway.connect(connectionProfile, connectionOptions);</span><br></pre></td></tr></table></figure><ul><li>通过使用连接配置文件配置网关，<code>issue.js</code> 将为网关提供应用于处理交易的相关网络拓扑</li><li>对于任何给定的组织而言，连接配置文件定义一个以上的对等点都是一种很好的做法 – 它可以防止<strong>单点故障</strong>。这种做法也适用于动态网关。为服务发现提供多个起点。</li><li><code>connectionOptions</code> 传递给网关配合连接配置文件。它们允许应用程序声明网关希望使用连接配置文件的方式。SDK会对它们进行解释，以控制与网络组件的交互模式，例如，选择要与之连接的身份或用于事件通知的对等实体。阅读<a class="link" href="https://hyperledger-fabric.readthedocs.io/en/latest/developapps/connectionoptions.html">有关<i class="fas fa-external-link-alt"></i></a>可用连接选项的列表以及何时使用它们的信息。</li></ul><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>文件路径</strong>：<code>commercial-paper/organization/magnetocorp/gateway/paperNet.yaml</code></p><p><strong>结构：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="attr">x-type:</span> <span class="string">&quot;hlfv1&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;to descript this connection profile&quot;</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">&quot;1.0.0&quot;</span></span><br><span class="line"><span class="attr">channels:</span></span><br><span class="line">  <span class="attr">channelName:</span></span><br><span class="line">    <span class="attr">orderers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">orderer1.orgName.example.com</span></span><br><span class="line">    <span class="attr">peers:</span></span><br><span class="line">    <span class="attr">peer1.orgName.example.com:</span></span><br><span class="line">      <span class="attr">endorsingPeer:</span> <span class="literal">true</span></span><br><span class="line">      <span class="string">...</span></span><br><span class="line">    <span class="attr">peer2.orgName.example.com:</span></span><br><span class="line">    <span class="string">...</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">organizations:</span></span><br><span class="line"><span class="attr">org1Name:</span></span><br><span class="line"><span class="attr">mspid:</span> <span class="string">OrgNameMSP</span></span><br><span class="line"><span class="attr">peers:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">peer1.orgName.example.com</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">peer2.orgName.example.com</span></span><br><span class="line"><span class="attr">certificateAuthorities:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">ca-orgname</span></span><br><span class="line"><span class="attr">org2Name:</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"></span><br><span class="line"><span class="attr">orderers:</span></span><br><span class="line">  <span class="attr">orderer1.orgName.example.com:</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">grpc://localhost:7050</span></span><br><span class="line">    <span class="attr">grpcOptions:</span></span><br><span class="line">      <span class="attr">ssl-target-name-override:</span> <span class="string">orderer1.magnetocorp.example.com</span></span><br><span class="line"></span><br><span class="line"><span class="attr">peers:</span></span><br><span class="line"><span class="attr">peer1.orgName.example.com:</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">grpc://localhost:7251</span></span><br><span class="line">    <span class="attr">grpcOptions:</span></span><br><span class="line">      <span class="attr">ssl-target-name-override:</span> <span class="string">peer2.magnetocorp.example.com</span></span><br><span class="line">      <span class="attr">request-timeout:</span> <span class="number">120001</span></span><br><span class="line">  <span class="attr">peer2.orgName.example.com:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line"></span><br><span class="line"><span class="attr">certificateAuthorities:</span></span><br><span class="line"><span class="attr">ca1-orgname:</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">http://localhost:7054</span></span><br><span class="line">    <span class="attr">httpOptions:</span></span><br><span class="line">      <span class="attr">verify:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">registrar:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">enrollId:</span> <span class="string">admin</span></span><br><span class="line">        <span class="attr">enrollSecret:</span> <span class="string">adminpw</span></span><br><span class="line">    <span class="attr">caName:</span> <span class="string">ca-orgname</span></span><br></pre></td></tr></table></figure><p><strong>主要信息：</strong></p><ul><li><p>第9行： <code>name: &quot;papernet.magnetocorp.profile.sample&quot;</code></p><p>这是连接配置文件的名称。尝试使用DNS样式名称；它们是传达意义的一种非常简单的方法。</p></li><li><p>第16行： <code>x-type: &quot;hlfv1&quot;</code></p><p>用户可以添加自己 <code>x-</code> 的“application-specific”的属性，就像使用HTTP标头一样。它们主要是为将来使用而提供的。</p></li><li><p>第20行： <code>description: &quot;Sample connection profile for documentation topic&quot;</code></p><p>连接配置文件的简短描述。尝试使此功能对可能是第一次看到此内容的读者有所帮助！</p></li><li><p>第25行： <code>version: &quot;1.0&quot;</code></p><p>此连接配置文件的架构版本。当前仅支持1.0版，并且没有预见到该架构会经常更改。</p></li><li><p>第32行： <code>channels:</code></p><p>这是第一条真正重要的一行。</p><p><code>channels:</code> 标识此连接配置文件描述的<strong>所有</strong>通道属性。但是，优良作法是将不同的通道保留在不同的连接配置文件中，尤其是当它们彼此独立使用时。</p><ul><li><p>第36行： <code>papernet:</code></p><p>下面是有关 <code>papernet</code> 的详细信息，是此连接配置文件中的第一个channel</p></li><li><p>第41行： <code>orderers:</code></p><p><code>papernet</code> 中所有 orderers 的详细信息。</p><p> <code>orderer1.magnetocorp.example.com</code> 为此频道的orderer(45)。这只是一个逻辑名称；稍后在连接配置文件中（第134-147行），将详细介绍如何连接到这个orderer。</p><p> <code>orderer2.digibank.example.com</code> 不在此列表中。应用程序将用自己组织的订购者，而不是其他组织的订购者</p></li><li><p>第49行： <code>peers:</code></p><p><code>papernet</code> 中所有 peers 的详细信息</p><p>你可以看到从MagnetoCorp列出了三个同行： <code>peer1.magnetocorp.example.com</code>，<code>peer2.magnetocorp.example.com</code> 和  <code>peer3.magnetocorp.example.com</code>。</p><ul><li>无需像在此处列出的那样列出在MagnetoCorp的所有peer。比如DigiBank中只列出了一个peer：<code>peer9.digibank.example.com</code>; 现在我们将确认，包括该对等点开始意味着背书策略要求MagnetoCorp和DigiBank背书交易。</li></ul><blockquote><p>使用时最好有多个peer，以<strong>避免单点故障。</strong></p><p>每个peer下面，你可以看到四个非排他性的角色设置：<strong>endorsingPeer</strong>， <strong>chaincodeQuery</strong>，<strong>ledgerQuery</strong>和<strong>EventSource的</strong>。</p><ul><li>了解<code>peer1</code>以及 <code>peer2</code>如何在担任<code>papercontract</code>主人时扮演所有角色。</li><li>相比之下，<code>peer3</code> 只能用于通知或访问分类账的区块链组件而不是世界状态的分类账查询，因此不需要安装智能合约。</li><li>请注意<code>peer9</code>，除了背书之外，不应将其用于其他任何用途，因为MagnetoCorp的其他peer可以更好地担当这些角色。</li></ul><p>以上信息是通过peer的逻辑名称和角色来描述的，在配置文件的后面，我们将看到这些peer的物理信息。</p></blockquote></li></ul></li><li><p>第97行： <code>organizations:</code></p><p>配置<strong>所有通道</strong>上某组织的属性。请注意，尽管<code>papernet</code>目前是唯一列出的通道，但这些组织适用于所有通道。这是因为组织可以位于多个通道中，并且通道可以具有多个组织。而且，某些应用程序操作与组织有关，而不是与通道有关。</p><ul><li><p>例如，应用程序可以使用<a class="link" href="https://hyperledger-fabric.readthedocs.io/en/latest/developapps/connectionoptions.html">连接选项<i class="fas fa-external-link-alt"></i></a>从其组织内的一个或所有对等方或网络内的所有组织请求通知。为此，需要有一个组织到对等方的映射</p></li><li><p>第101行： <code>MagnetoCorp:</code></p><ul><li><p>第109 / 116行：<code>peers:</code> / <code>certificateAuthorities:</code></p><p>列出的所有peer都被认为MagnetoCorp的一部分：<code>peer1</code>， <code>peer2</code>和<code>peer3</code>。</p><p>证书颁发机构也是如此。</p><blockquote><p> 请注意此处仍使用逻辑名称，与本<code>channels:</code>节相同；物理信息将在配置文件的后面列出。</p></blockquote></li></ul></li><li><p>第121行： <code>DigiBank:</code></p><p>仅列出了DigiBank的一部分peer：<code>peer9</code></p><p>没有列出证书颁发机构。这是因为DigiBank其他的peer和DigiBank CA均与本连接配置文件的用户无关。</p></li></ul></li></ul><blockquote><p>以下是之前相关逻辑名称对应的物理信息</p></blockquote><ul><li><p>第134行： <code>orderers:</code></p><p>现在列出了 orderers 的物理信息。由于此连接配置文件仅提及 <code>papernet</code> 的一个订购者，所以只列出了 <code>orderer1.magnetocorp.example.com</code> 的详细信息。</p><p>其中包括其<strong>IP地址</strong>和<strong>端口</strong>，以及<strong>gRPC选项</strong> <code>ssl-target-name-override</code>，可以在需要时覆盖与订购者进行通信时使用的默认值。</p><p>与一样<code>peers:</code>，对于高可用性，指定多个订购者是一个好主意。</p></li><li><p>第152行： <code>peers:</code></p><p>现在列出了先前所有对等方的物理信息。此连接配置文件有MagnetoCorp的三个对等方： ，<code>peer1</code>，<code>peer2</code>和 <code>peer3</code>; 对于DigiBank，列出了单个对等方 <code>peer9 </code>的信息。</p><p>对于每个对等方，如orderer一样，将列出其<strong>IP地址</strong>和<strong>端口</strong>，并列出<strong>gRPC选项</strong>，这些选项可以覆盖与特定对等方进行通信时使用的默认值（如有必要）。</p></li><li><p>194行： <code>certificateAuthorities:</code></p><p>现在列出了证书颁发机构的物理信息。连接配置文件为MagnetoCorp列出了一个CA <code>ca1-magnetocorp</code>，其物理信息如下。</p><p>除了IP地址 <code>url:</code> 之外，<code>resigter:</code> 表示还允许将此CA用于证书签名请求（CSR）。这些用于请求本地生成的公用/专用密钥对的新证书。</p></li></ul><h2 id="Connection-Options"><a href="#Connection-Options" class="headerlink" title="Connection Options"></a>Connection Options</h2><p>配置选项：允许应用程序声明网关希望与连接配置文件交互的方式</p><p>连接选项与连接配置文件一起使用，以<strong>精确</strong>控制网关与网络的交互方式。使用网关可以使应用程序专注于<strong>业务逻辑</strong>，而不是网络拓扑。</p><blockquote><p>网络由<strong>连接配置文件</strong>标识，<strong>配置选项</strong>精确指定网关应如何与之交互。</p></blockquote><h3 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h3><p>以MagnetoCorp的 <code>issue.js</code>为示例 ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userName = <span class="string">&#x27;User1@org1.example.com&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> wallet = <span class="keyword">new</span> FileSystemWallet(<span class="string">&#x27;../identity/user/isabella/wallet&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> connectionOptions = &#123;</span><br><span class="line">  identity: userName,</span><br><span class="line">  wallet: wallet,</span><br><span class="line">  eventHandlerOptions: &#123;</span><br><span class="line">    commitTimeout: <span class="number">100</span>,</span><br><span class="line">    strategy: EventStrategies.MSPID_SCOPE_ANYFORTX</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> gateway.connect(connectionProfile, connectionOptions);</span><br></pre></td></tr></table></figure><ul><li><code>identity</code> 和 <code>wallet</code> 选项为 <code>connectionOptions</code> 对象的简单属性 。它们分别具有值 <code>userName</code> 和 <code>wallet</code>，这些值在代码的前面设置。</li><li><code>eventHandlerOptions</code> 本身就是对象的选项。它具有两个属性：<ul><li><code>commitTimeout: 100</code>:（以秒为单位）</li><li><code>strategy: EventStrategies.MSPID_SCOPE_ANYFORTX</code></li></ul></li></ul><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><img src="/2021/03/19/fabric-Tutorials/develop.diagram.35.png" alt="develop.diagram.35" style="zoom:45%;"><ul><li><p><code>wallet</code>：标识代表应用程序使用网关的钱包。**(1)** ; </p><ul><li>钱包是由应用程序指定的，但实际上是从中检索身份的网关。</li><li>必须指定一个钱包；决定使用的钱包<a class="link" href="https://hyperledger-fabric.readthedocs.io/en/latest/developapps/wallet.html#type">类型<i class="fas fa-external-link-alt"></i></a>是最重要的 - 文件系统，内存，HSM还是数据库。</li></ul></li><li><p><code>identity</code>：是应用程序将使用的来自 <code>wallet</code> 的用户身份。**(2a)** ; </p><ul><li><strong>用户身份由应用程序指定</strong>，并代表应用程序的用户Isabella**(2b)**。但身份实际上是由网关检索的。<ul><li>在我们的示例中，不同MSP**(2c)**， **(2d)**将使用Isabella的身份来标识她来自MagnetoCorp，并且在其中具有特定角色。这两个事实将相应地确定她对资源的许可，例如能够读取和写入分类帐。</li></ul></li><li><strong>必须指定用户身份</strong>。如您所见，此身份对于Hyperledger Fabric是一个<strong>permissioned</strong>网络 - 所有参与者都具有一个身份，包括应用程序，peers 和 oderers，这些身份决定了他们对资源的控制。您可以在会员服务<a class="link" href="https://hyperledger-fabric.readthedocs.io/en/latest/membership/membership.html">主题中<i class="fas fa-external-link-alt"></i></a>阅读有关此想法的更多信息。</li></ul></li><li><p><code>clientTlsIdentity</code>：是从钱包**(3a)<strong>检索并用于网关和不同通道组件（例如peers和orderers）之间的安全通信</strong>(3b)<strong>的</strong>identity**。</p><ul><li>请注意，此<strong>identity</strong>不同于用户身份。尽管  <code>clientTlsIdentity</code> 对于安全通信很重要，但它不如用户身份那么基础，因为它的范围不会扩展到安全网络通信之外。</li><li><code>clientTlsIdentity</code>是可选的。建议您在生产环境中进行设置。您应该始终使用跟  <code>identity</code>不同的 <code>clientTlsIdentity</code>，因为这些身份具有不同的含义和生命周期。<ul><li>例如，如果你的 <code>clientTlsIdentity</code> 受到了损害，那么你的 <code>identity</code> 也会受到损害。将它们分开是更安全的。</li></ul></li></ul></li><li><p><code>eventHandlerOptions</code></p><ul><li><p><code>commitTimeout</code>：是可选的。它以秒为单位指定在将控制权返回给应用程序之前，网关应等待对等方**(4a)**提交交易的最长时间（默认为300s）。</p></li><li><p><code>strategy</code>：是可选的。它标识网关应用于侦听交易已提交的通知的对等体的集合。例如，是侦听组织中的单个对等方还是所有对等方。它可以采用以下值之一：</p><ul><li><p><code>EventStrategies.MSPID_SCOPE_ANYFORTX</code>：侦听用户<strong>组织内</strong>的<strong>任何</strong>对等方**(4b)**。MagnetoCorp的对等体1，对等体2或对等体3中的任何一个都可以通知网关。</p></li><li><p><code>EventStrategies.MSPID_SCOPE_ALLFORTX</code>： 这是<strong>默认值</strong>。监听用户<strong>组织内</strong>的<strong>所有</strong>对等方**(4b)<strong>。MagnetoCorp的所有对等方</strong>都必须**已通知网关。不包括<code>stopped</code>或<code>falied</code>的对等方。</p></li><li><p><code>EventStrategies.NETWORK_SCOPE_ANYFORTX</code>：侦听整个<strong>网络通道</strong>中的<strong>任何</strong>对等方**(4b)<strong>和</strong>(4c)**。MagnetoCorp的对等方1-3或DigiBank的对等方7-9中的任何一个都可以通知网关。</p></li><li><p><code>EventStrategies.NETWORK_SCOPE_ALLFORTX</code>：侦听整个<strong>网络通道</strong>中的<strong>所有</strong>对等方**(4b)<strong>和</strong>(4c)<strong>。MagnetoCorp和DigiBank的所有对等方</strong>都必须**通知网关；对等1-3和对等7-9。不包括<code>stopped</code>或<code>falied</code>的对等方。</p></li><li><p>&lt; <code>PluginEventHandlerFunction</code>&gt;：用户定义的事件处理程序的名称。这允许用户定义自己的事件处理逻辑。了解如何<a class="link" href="https://hyperledger.github.io/fabric-sdk-node/main/tutorial-transaction-commit-events.html">定义<i class="fas fa-external-link-alt"></i></a>事件处理程序插件，并检查<a class="link" href="https://github.com/hyperledger/fabric-sdk-node/blob/main/test/integration/network-e2e/sample-transaction-event-handler.js">样本程序<i class="fas fa-external-link-alt"></i></a>。</p><blockquote><p>仅当有非常特定的事件处理要求时，才需要用户定义的事件处理程序。通常，使用内置事件策略之一就足够了。用户定义的事件处理程序的一个示例可能是等待组织中超过一半的对等方来确认交易已提交。</p><p>如果确实指定了用户定义的事件处理程序，则它不会影响您的应用程序逻辑。它与这完全不同。SDK在处理过程中会调用处理程序；它决定何时调用它，并使用其结果选择要用于事件通知的对等方。SDK完成处理后，应用程序将收到控制权。</p><p>如果未指定用户定义的事件处理程序，则使用<code>EventStrategies</code>的默认值 </p></blockquote></li></ul></li></ul></li><li><p><code>discovery</code></p><ul><li><code>enabled</code>：是可选的，并且可能具有<code>true</code>或值<code>false</code>。默认值为<code>true</code>。它确定网关是否使用<a class="link" href="https://hyperledger-fabric.readthedocs.io/en/latest/discovery-overview.html">服务发现<i class="fas fa-external-link-alt"></i></a>来扩展连接配置文件中指定的网络拓扑。**(6)** ; 网关使用的对等方gossip information。<ul><li>该值会被 <code>INITIALIIZE-WITH-DISCOVERY</code> 环境变量覆盖</li></ul></li><li><code>asLocalhost</code>：是可选的，并且可能具有<code>true</code>或值<code>false</code>。默认值为<code>true</code>。它确定是否把在服务发现期间找到的IP地址从docker网络转换为本地主机。<ul><li>通常，开发人员会编写使用docker容器作为其网络组件（例如peer，orderer和CA）的应用程序，但这些应用程序本身不会在docker容器中运行。这就是 <code>true</code> 默认设置的原因；</li><li>在生产环境中，应用程序可能会以与网络组件相同的方式在docker容器中运行，因此不需要地址转换。在这种情况下，应用程序应显式指定 <code>false</code> 或使用环境变量替代。</li><li>该值将被 <code>DISCOVERY-AS-LOCALHOST</code> 环境变量覆盖</li></ul></li></ul></li></ul><p><strong>注意事项：</strong></p><p>下面的注意事项列表在决定如何选择连接选项时会很有帮助。</p><ul><li><p><code>eventHandlerOptions.commitTimeout</code> 和 <code>eventHandlerOptions.strategy</code>一起工作。</p><ul><li>例如，<code>commitTimeout: 100</code> 和 <code>strategy: EventStrategies.MSPID_SCOPE_ANYFORTX</code>表示网关将等待多达100秒，以便<strong>任何一个</strong>对等方确认交易已提交。相反，<code>strategy: EventStrategies.NETWORK_SCOPE_ALLFORTX</code> 意味着网关将对<strong>所有</strong>组织中的<strong>所有</strong>对等方最多等待100秒。</li></ul></li><li><p>默认值 <code>eventHandlerOptions.strategy: EventStrategies.MSPID_SCOPE_ALLFORTX</code> 将等待应用程序组织中的所有对等方提交交易。</p><ul><li>这是一个很好的默认设置，因为应用程序可以确保所有对等方都拥有分类账的最新副本，从而最大程度地减少了并发问题</li><li>但是，随着组织中对等方数目的增加，等待所有对等方变得有点不必要，在这种情况下，使用**&lt;可插入事件处理程序&gt;**可以提供更有效的策略。例如，在共识将使所有分类帐保持同步的安全假设下，可以使用相同的一组对等方来提交交易和侦听通知。</li></ul></li><li><p>需要 <code>clientTlsIdentity</code> 来设置服务发现。</p><ul><li>这是因为与应用程序交换信息的对等方需要确信他们正在与自己信任的实体交换信息。如果 <code>clientTlsIdentity</code>未设置，则无论 <code>discovery</code> 是否设置，都将不服从。</li></ul></li><li><p>尽管应用程序可以在连接到网关时设置连接选项，但是管理员可能有必要覆盖这些选项。</p><ul><li>这是因为选项与网络交互有关，该交互可能随时间而变化。例如，管理员试图了解使用服务发现对网络性能的影响。</li><li>一种好的方法是在一个配置文件中定义应用程序的重写，当应用程序配置其与网关的连接时，该配置文件将由应用程序读取。</li><li>因为发现选项<code>enabled</code>和<code>asLocalHost</code>是管理员最经常需要覆盖的选项，所以提供了环境变量 <code>INITIALIIZE-WITH-DISCOVERY</code>和<code>DISCOVERY-AS-LOCALHOST</code>以便于使用。管理员应在应用程序的生产运行时环境中设置这些设置，该环境很可能是docker容器。</li></ul></li></ul><h1 id="wallet"><a href="#wallet" class="headerlink" title="wallet"></a>wallet</h1><p>钱包包含一组用户身份。用户运行的应用程序在连接到通道时会选择这些身份之一。结合MSP使用此身份确定对诸如分类帐之类的信道资源的访问权限。</p><p><strong>过程：</strong></p><img src="/2021/03/19/fabric-Tutorials/develop.diagram.10.png" alt="develop.diagram.10" style="zoom:45%;"><ul><li>当应用程序连接到诸如PaperNet之类的网络通道时，它会选择一个用户身份进行连接<code>ID1</code>。通道MSP将<code>ID1</code>与特定组织内的角色相关联，并且该角色最终将确定应用程序对通道资源的权利。例如，<code>ID1</code>可能将某个用户标识为可以读写账本的MagnetoCorp组织成员，而<code>ID2</code>可能会标识MagnetoCorp中可以向联盟添加新组织的管理员。</li></ul><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>钱包存储的三种不同类型：文件系统，内存和CouchDB。</p><ul><li><strong>文件系统</strong>：这是最常见的存放钱包的地方；文件系统无处不在，易于理解，并且可以通过网络安装。对于钱包来说，它们是一个很好的默认选择。</li><li><strong>内存中</strong>：应用程序存储中的钱包。当您的应用程序在受限环境中运行而无法访问文件系统时，请使用这种钱包。通常是网络浏览器。值得记住的是，这种钱包是易变的。应用程序正常结束或崩溃后，身份将丢失。</li><li><strong>CouchDB</strong>：存储在CouchDB中的钱包。这是最罕见的钱包存储形式，但是对于那些想要使用数据库备份和还原机制的用户，CouchDB钱包可以提供一个有用的选项来简化灾难恢复。</li></ul><blockquote><p>使用wallet类的工厂函数创建钱包</p></blockquote><h3 id="HSM"><a href="#HSM" class="headerlink" title="HSM"></a>HSM</h3><p>硬件安全模块（HSM）是一种超安全的防篡改设备，用于存储数字身份信息，尤其是私钥。HSM可以本地连接到您的计算机或可通过网络访问。大多数HSM提供了使用私钥执行机载加密的功能，这样私钥就永远不会离开HSM。</p><ul><li><p>HSM可以与任何钱包类型一起使用。在这种情况下，身份证书将存储在钱包中，私钥将存储在HSM中。</p></li><li><p>要启用使用HSM管理的身份，<code>IdentityProvider</code> 必须使用HSM连接信息配置并在钱包中注册。有关更多详细信息，请参阅《<a class="link" href="https://hyperledger.github.io/fabric-sdk-node/main/tutorial-wallet.html">使用钱包管理身份<i class="fas fa-external-link-alt"></i></a>》教程。</p></li></ul><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>单个钱包可以保存多个身份，每个身份由特定的证书颁发机构颁发。每个身份具有一个标准结构，该标准结构包括<strong>描述性标签</strong>，<strong>公钥</strong>，<strong>私钥</strong>和某些特定于Fabric的<strong>metadata的X.509证书</strong>。不同的<a class="link" href="https://hyperledger-fabric.readthedocs.io/en/latest/developapps/wallet.html#types">钱包类型<i class="fas fa-external-link-alt"></i></a>将此结构适当地映射到其存储机制。</p><p><img src="/2021/03/19/fabric-Tutorials/develop.diagram.11.png" alt="develop.diagram.11"></p><ul><li>Fabric钱包可以使用由不同证书颁发机构颁发的证书来保存多个身份。<ul><li>身份包括<strong>证书</strong>，<strong>私钥</strong>和<strong>结构元数据</strong>。</li></ul></li></ul><p>生成钱包：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> identity: X509Identity = &#123;</span><br><span class="line">    credentials: &#123;</span><br><span class="line">        certificate: certificatePEM,</span><br><span class="line">        privateKey: privateKeyPEM,</span><br><span class="line">    &#125;,</span><br><span class="line">    mspId: <span class="string">&#x27;Org1MSP&#x27;</span>,</span><br><span class="line">    type: <span class="string">&#x27;X.509&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// const identityLabel = &#x27;isabella&#x27;;</span></span><br><span class="line"><span class="keyword">await</span> wallet.put(identityLabel, identity);</span><br></pre></td></tr></table></figure><p>获取身份：</p><ul><li><code>Gateway</code> 类只需要 <code>mspId</code> 和 <code>type</code> 来标识一个身份，它使用MSP ID在连接配置文件中识别一个对等方</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">organizations:</span></span><br><span class="line">  <span class="attr">Org1:</span></span><br><span class="line">    <span class="attr">mspid:</span> <span class="string">Org1MSP</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">peers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">peer0.org1.example.com</span></span><br></pre></td></tr></table></figure><ul><li>通过 <code>get()</code> 方法获得身份 <code>fabric-network.Identit</code>，没有则返回 <code>undefined</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// const identityLabel = &#x27;isabella&#x27;;</span></span><br><span class="line"><span class="keyword">const</span> userExists = <span class="keyword">await</span> wallet.get(<span class="string">&#x27;identityLabel&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="运行方式"><a href="#运行方式" class="headerlink" title="运行方式"></a>运行方式</h2><p>不同的钱包类型都实现了一个通用的<a class="link" href="https://hyperledger.github.io/fabric-sdk-node/main/module-fabric-network.Wallet.html">电子钱包<i class="fas fa-external-link-alt"></i></a>接口，该接口提供了一组标准的API来管理身份。</p><p><strong>生命周期</strong>：可以创建或打开钱包，并且可以读取，添加和删除身份。</p><p><strong>示例代码</strong>：<code>commercial-paper/organization/magnetocorp/application/addToWallet.js </code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wallet = <span class="keyword">await</span> Wallets.newFileSystemWallet(<span class="string">&#x27;../identity/user/isabella/wallet&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cert = fs.readFileSync(path.join(credPath, <span class="string">&#x27;.../User1@org1.example.com-cert.pem&#x27;</span>)).toString();</span><br><span class="line"><span class="keyword">const</span> key = fs.readFileSync(path.join(credPath, <span class="string">&#x27;.../_sk&#x27;</span>)).toString();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> identityLabel = <span class="string">&#x27;User1@org1.example.com&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> identity = &#123;</span><br><span class="line">    credentials: &#123;</span><br><span class="line">        certificate: cert,</span><br><span class="line">        privateKey: key,</span><br><span class="line">    &#125;,</span><br><span class="line">    mspId: <span class="string">&#x27;Org1MSP&#x27;</span>,</span><br><span class="line">    type: <span class="string">&#x27;X.509&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> wallet.put(identityLabel, identity);</span><br></pre></td></tr></table></figure><ul><li>首次运行该程序时，会在本地文件系统上创建一个钱包 <code>.../isabella/wallet</code>。</li><li>证书<code>cert</code>和私有<code>key</code>文件是从文件系统加载的。</li><li>新的X.509身份使用 <code>cert</code>，<code>key</code> 和 <code>Org1MSP</code> 来创建。</li><li>使用 <code>wallet.put()</code> 将带有标签 <code>User1@org1.example.com</code> 的新身份添加到钱包中</li></ul><h1 id="Gateway"><a href="#Gateway" class="headerlink" title="Gateway"></a>Gateway</h1><p>网关代表应用程序管理网络交互，使其专注于业务逻辑。应用程序连接到网关，然后使用该网关的配置管理所有后续交互。</p><p><strong>使用方式：</strong></p><ol><li><strong>静态</strong>：网关配置完全在<a class="link" href="https://hyperledger-fabric.readthedocs.io/en/latest/developapps/connectionprofile.html">连接配置文件中<i class="fas fa-external-link-alt"></i></a>定义。<ul><li>应用程序可用的所有<strong>对等方</strong>，<strong>订购者</strong>和<strong>CA</strong>在用于配置网关的连接配置文件中静态定义。例如，对于对等方来说，包括其作为 endorsing peer 或event notification hub的角色。</li><li>SDK将结合网关<a class="link" href="https://hyperledger-fabric.readthedocs.io/en/latest/developapps/connectionoptions">连接选项<i class="fas fa-external-link-alt"></i></a>来使用此静态拓扑来管理交易的提交和通知过程。连接配置文件必须包含足够的网络拓扑，以允许网关代表应用程序与网络交互；这包括网络渠道，组织，订购者，对等方及其角色。</li></ul></li></ol><ol start="2"><li><strong>动态</strong>：网关配置只在连接配置文件中最少定义。<ul><li>通常，指定来自应用程序组织的一个或两个对等方，并且它们使用<a class="link" href="https://hyperledger-fabric.readthedocs.io/en/latest/discovery-overview.html">服务发现<i class="fas fa-external-link-alt"></i></a>来发现可用的网络拓扑。这包括对等方，订购者，渠道，已部署的智能合约及其认可策略。（在生产环境中，网关配置应至少指定两个对等方以确保可用性。）</li><li>SDK将使用文件中所有的静态定义部分和发现的拓扑信息以及网关连接选项来管理交易的提交和通知过程。作为其一部分，它还将智能地使用发现的拓扑。例如，它将使用发现的智能合约背书策略计算所需的最少背书对等体。</li></ul></li></ol><blockquote><p>静态或动态网关是否更好？权衡是在可预测性和响应性之间。静态网络始终会以相同的方式运行，因为它们将网络视为不变的。从这种意义上讲，它们是可预测的–如果可用，它们将始终使用相同的对等方和订购方。当动态网络了解网络的变化时，它们的响应速度更快–它们可以使用新添加的对等点和订购者，从而带来额外的弹性和可扩展性，但可能会在可预测性方面付出一些代价。通常，使用动态网络是可以的，实际上，这是网关的默认模式。</p><ul><li>请注意，可以静态或动态使用同一连接配置文件。显然，如果要静态使用配置文件，则它必须是全面的，而动态使用仅需要稀疏的填充即可。</li><li>两种样式的网关对应用程序都是透明的。无论使用静态还是动态网关，应用程序设计都不会改变。这也意味着某些应用程序可以使用服务发现，而其他应用程序则可以不使用。通常，使用动态发现意味着SDK的定义更少，情报更多。这是默认值。</li></ul></blockquote><p><strong>连接：</strong>（前面有详细的）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> gateway.connect(connectionProfile, connectionOptions);</span><br></pre></td></tr></table></figure><ul><li><p><strong>连接配置文件</strong>：<code>connectionProfile</code> 是网关配置，它将用于SDK的静态或动态交易处理。尽管可以在传递给网关时将其转换为JSON对象，但是可以使用<strong>YAML</strong>或<strong>JSON</strong>指定它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> connectionProfile = yaml.safeLoad(fs.readFileSync(<span class="string">&#x27;../gateway/paperNet.yaml&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>));</span><br></pre></td></tr></table></figure></li></ul><ul><li><strong>连接选项</strong>：<code>connectionOptions</code> 允许应用程序<strong>声明</strong>而不是实现所需的事务处理行为。SDK会解释连接选项，以控制与网络组件的交互模式，例如，选择要与之连接的身份或用于事件通知的对等对象。这些选项可在不影响功能的情况下显着降低应用程序的复杂性。这是可能的，因为SDK已实现了许多应用程序原本需要的低层逻辑。连接选项控制此逻辑流。</li></ul><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>静态网关定义网络的<strong>固定视图</strong>。</p><p>在MagnetoCorp <a class="link" href="https://hyperledger-fabric.readthedocs.io/en/latest/developapps/gateway.html#scenario">方案中<i class="fas fa-external-link-alt"></i></a>，网关可能会标识MagnetoCorp的单个对等方，DigiBank的单个对等方和MagentoCorp订购者。或者，网关可以定义MagnetCorp和DigiBank的 <em>所有</em> 对等方和订购方。在这两种情况下，网关都必须定义足以使商业票据交易获得认可和分发的网络视图。</p><ul><li>通过在API <code>gateway.connect()</code> 上显式指定connect选项 <code>discovery: &#123; enabled:false &#125;</code>，应用程序可以静态使用网关。或者，环境变量设置 <code>FABRIC_SDK_DISCOVERY=false</code> 将始终覆盖应用程序选择。</li><li>检查 MagnetoCorp的 <code>issue.js</code> 应用程序使用的<a class="link" href="https://github.com/hyperledger/fabric-samples/blob/main/commercial-paper/organization/magnetocorp/gateway/networkConnection.yaml">连接配置文件<i class="fas fa-external-link-alt"></i></a>。查看如何在此文件中指定所有对等方，订购者甚至CA，包括它们的角色。</li></ul><blockquote><p>注意：静态网关代表某个<strong>时刻</strong>的网络视图。随着网络的变化，将其反映在网关文件的变化中可能很重要。当应用程序重新加载网关文件时，它们将自动获取这些更改。</p></blockquote><h2 id="dynamic"><a href="#dynamic" class="headerlink" title="dynamic"></a>dynamic</h2><p>动态网关为网络定义了一个最小的<strong>固定起点</strong>。</p><p>在MagnetoCorp<a class="link" href="https://hyperledger-fabric.readthedocs.io/en/latest/developapps/gateway.html#scenario">方案中<i class="fas fa-external-link-alt"></i></a>，动态网关可能仅识别MagnetoCorp中的单个对等方。一切都会被发现！（为了预防单点故障，最好定义两个这样的引导对等点）</p><ul><li>如果应用程序选择了<a class="link" href="https://hyperledger-fabric.readthedocs.io/en/latest/discovery-overview.html">服务发现<i class="fas fa-external-link-alt"></i></a>，则网关文件中定义的拓扑将使用此过程生成的拓扑进行扩充。<ul><li>服务发现从网关定义开始，并使用<a class="link" href="https://hyperledger-fabric.readthedocs.io/en/latest/gossip.html"> gossip 协议<i class="fas fa-external-link-alt"></i></a>在MagnetoCorp组织中找到所有连接的对等方和订购方。</li><li>如果已为通道定义了<a class="link" href="https://hyperledger-fabric.readthedocs.io/en/latest/glossary.html#anchor-peer">anchor peer<i class="fas fa-external-link-alt"></i></a>，则服务发现将使用跨组织的 gossip 协议来发现连接的组织内的组件。此过程还将发现在对等方安装的智能合约及其在渠道级别定义的认可策略。</li><li>与静态网关一样，发现的网络必须足以批准和分发商业票据交易。</li></ul></li><li>动态网关是Fabric应用程序的默认设置。可以使用API <code>gateway.connect()</code> 上的连接选项 <code>discovery: &#123; enabled:true &#125;</code> 明确指定它们。或者，环境变量设置 <code>FABRIC_SDK_DISCOVERY=true</code> 将始终覆盖应用程序选择。</li></ul><blockquote><p>注意：动态网关代表网络的最新视图。随着网络的变化，服务发现将确保网络视图正确反映了应用程序可见的拓扑。应用程序将自动获取这些更改；他们甚至不需要重新加载网关文件。</p></blockquote><h2 id="multiple"><a href="#multiple" class="headerlink" title="multiple"></a>multiple</h2><p>对于应用程序而言，定义相同或不同网络的多个网关非常简单。此外，应用程序可以静态和动态使用名称网关。</p><p>拥有多个网关可能会有所帮助。原因如下：</p><ul><li>代表不同用户处理请求。</li><li>同时连接到不同的网络。</li><li>通过同时比较其行为与现有配置来测试网络配置。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本部分详细介绍了Hyperledger Fabric中的客户端应用程序和智能合约开发的关键功能。对功能的深入了解将帮助您设计和实施高效的解决</summary>
      
    
    
    
    <category term="Notebook" scheme="https://jieyang-wei.github.io/categories/Notebook/"/>
    
    <category term="Blockchain" scheme="https://jieyang-wei.github.io/categories/Notebook/Blockchain/"/>
    
    <category term="Fabric" scheme="https://jieyang-wei.github.io/categories/Notebook/Blockchain/Fabric/"/>
    
    
    <category term="fabric" scheme="https://jieyang-wei.github.io/tags/fabric/"/>
    
    <category term="blockchain" scheme="https://jieyang-wei.github.io/tags/blockchain/"/>
    
  </entry>
  
  <entry>
    <title>fabric-Developing Application</title>
    <link href="https://jieyang-wei.github.io/2021/03/16/fabric-Developing%20Application/"/>
    <id>https://jieyang-wei.github.io/2021/03/16/fabric-Developing%20Application/</id>
    <published>2021-03-16T09:08:51.000Z</published>
    <updated>2021-04-19T06:42:53.947Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本部分主要讲解智能合约的部署，已经commercial paper部分的使用和代码解析</p><ol><li><p>end users通过调用智能合约与区块链分类账进行交互。在Hyperledger Fabric中，智能合约部署在称为chaincode的程序包中。想要验证交易或查询分类帐的组织需要在其peer上安装chaincode。在已加入channel的peer上安装 chaincode后，通道成员可以将链码部署到通道，并使用链码中的智能合约在通道分类帐上创建或更新资产。</p></li><li><p>使用称为Fabric chaincode lifecycle的程序将链码部署到通道。Fabric chaincode lifecycle允许多个组织在使用链码创建事务之前就如何操作链码达成共识。例如，虽然背书策略指定哪些组织需要执行链码以验证交易，但渠道成员需要使用Fabric链码生命周期来同意链码背书策略。</p></li></ol><h1 id="应用部署"><a href="#应用部署" class="headerlink" title="应用部署"></a>应用部署</h1><p>使用 fabric-sample 中的示例 <strong>commercial-paper</strong> 和 <strong>asset-transfer-basic</strong> 来进行演示</p><p>首先要先启动测试网络 test-network ，并创建通道 mychannel</p><p>网络中将有两个组织org1和org2（）以及一个排序节点order</p><h2 id="日志监控"><a href="#日志监控" class="headerlink" title="日志监控"></a>日志监控</h2><p>在开始进行完整的商业流程实现之前，需要Logspout工具以便监控过程中所有的日志信息</p><ul><li>启动</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> fabric-sample/commercial-paper/organization/digibank/configuration/cli/monitordocker.sh</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./monitordocker.sh fabric_test</span></span><br></pre></td></tr></table></figure><h2 id="chaincode"><a href="#chaincode" class="headerlink" title="chaincode"></a>chaincode</h2><p>设置环境变量，让Org1以admin用户的身份使用 <code>peer</code> 指令操作链码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> CORE_PEER_TLS_ENABLED=<span class="literal">true</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> CORE_PEER_LOCALMSPID=<span class="string">&quot;Org1MSP&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> CORE_PEER_TLS_ROOTCERT_FILE=<span class="variable">$&#123;PWD&#125;</span>/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> CORE_PEER_MSPCONFIGPATH=<span class="variable">$&#123;PWD&#125;</span>/organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> CORE_PEER_ADDRESS=localhost:7051</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>链码部署过程</strong>：package - install - approveformyorg - commit</p><p><strong>查看部署情况</strong>：queryinstalled - checkcommitreadiness - querycommitted</p></blockquote><h3 id="打包智能合约"><a href="#打包智能合约" class="headerlink" title="打包智能合约"></a>打包智能合约</h3><p>此处以go语言为例，使用目录 <code>fabric-samples/asset-transfer-basic/chaincode-go</code> 下的智能合约</p><ul><li>go.mod：列出合约依赖项<ul><li>将Fabric合约API导入到智能合约包中。</li><li>可以<code>asset-transfer-basic/chaincode-go/chaincode/smartcontract.go</code>在文本编辑器中打开以查看如何<code>SmartContract</code>在智能合约开始时使用合约API定义类型</li></ul></li></ul><ol><li>安装合约依赖关系</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> fabric-samples/asset-transfer-basic/chaincode-go</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> GO111MODULE=on go mod vendor</span></span><br></pre></td></tr></table></figure><ol start="2"><li>使用 <code>peer</code> 指令打包所需链码</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> PATH=<span class="variable">$&#123;PWD&#125;</span>/../../bin:<span class="variable">$PATH</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> FABRIC_CFG_PATH=<span class="variable">$PWD</span>/../../config/</span></span><br></pre></td></tr></table></figure><ul><li>主要是指出bin和config两个二进制文件夹所在的位置（fabric-sample目录下）</li><li>根据你的当前位置写路径</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> peer lifecycle chaincode package basic.tar.gz --path ./ --lang golang --label basic_1.0</span></span><br></pre></td></tr></table></figure><ul><li>参数：<ul><li>basic.tar.gz：打包后的文件名</li><li><strong>–path</strong>：提供智能合约代码的位置<ul><li>当前位置 <code>fabric-sample/asset-transfer-basic/chaincode-go</code> 的相对路径</li></ul></li><li><strong>–lang</strong>：指定链码语言</li><li><strong>–label</strong>：指定一个链码标签，该标签将在安装后识别您的链码。<ul><li>建议您的标签包含链码名称和版本</li></ul></li></ul></li><li>此时已在当前路径下创建了一个链码包（basic.tar.gz），之后可以使用此包安装链码</li></ul><h3 id="部署智能合约到channel"><a href="#部署智能合约到channel" class="headerlink" title="部署智能合约到channel"></a>部署智能合约到channel</h3><h4 id="安装chaincode包"><a href="#安装chaincode包" class="headerlink" title="安装chaincode包"></a>安装chaincode包</h4><ol><li>使用 <code>peer chaincode install</code> 命令在对等方上安装链码</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> peer lifecycle chaincode install basic.tar.gz</span></span><br></pre></td></tr></table></figure><ul><li>如果命令成功，则对等方将生成并返回包标识符</li><li>此程序包ID将用于批准链码</li></ul><ol start="2"><li>根据fabric的背书策略，链码需要mychannel上认可交易的每个对等方安装链码，所以我们切换 <code>peer</code> 到Org2 admin用户</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置环境变量</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> CORE_PEER_LOCALMSPID=<span class="string">&quot;Org2MSP&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> CORE_PEER_TLS_ROOTCERT_FILE=<span class="variable">$&#123;PWD&#125;</span>/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> CORE_PEER_TLS_ROOTCERT_FILE=<span class="variable">$&#123;PWD&#125;</span>/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> CORE_PEER_MSPCONFIGPATH=<span class="variable">$&#123;PWD&#125;</span>/organizations/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> CORE_PEER_ADDRESS=localhost:9051</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装链码包</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> peer lifecycle chaincode install basic.tar.gz</span></span><br></pre></td></tr></table></figure><h4 id="批准chaincode包"><a href="#批准chaincode包" class="headerlink" title="批准chaincode包"></a>批准chaincode包</h4><p>注意：</p><ul><li>在部署链码之前需要批准链码的一组通道成员受 <code>/Channel/Application/LifecycleEndorsement</code> 策略控制。<ul><li>默认情况下，此策略要求大多数频道成员需要批准链码后才能在频道上使用。因为渠道上只有两个组织，而2个中的大多数是2个，所以我们需要批准资产转移（基本）的链码定义为Org1和Org2。</li></ul></li><li>如果组织已在其对等方上安装了链码，则他们需要在其组织批准的链码定义中包括packageID。程序包ID用于将对等方上安装的链码与批准的链码定义相关联，并允许组织使用链码对交易进行背书。您可以使用对 <code>peer lifecycle chaincode queryinstalled</code> 命令来查询对等节点，从而找到链代码的程序包ID 。</li></ul><ol><li>查询安装的链码包的 <code>PACKEDGE_ID</code></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> peer lifecycle chaincode queryinstalled</span></span><br><span class="line">Installed chaincodes on peer:</span><br><span class="line">Package ID: basic_1.0:(一串数字即为package id)</span><br></pre></td></tr></table></figure><ol start="2"><li>先在当前org2组织上批准链码包</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置环境变量</span></span><br><span class="line">$ <span class="built_in">export</span> CC_PACKAGE_ID=basic_1.0:(那串package id的数字)</span><br><span class="line"><span class="comment"># 批准</span></span><br><span class="line">$ peer lifecycle chaincode approveformyorg -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --channelID mychannel --name basic --version 1.0 --package-id <span class="variable">$CC_PACKAGE_ID</span> --sequence 1 --tls --cafile <span class="string">&quot;<span class="variable">$&#123;PWD&#125;</span>/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem&quot;</span></span><br></pre></td></tr></table></figure><ul><li>参数：<ul><li>–tls：是否启动tls</li><li>–cafile：ca证书的路径</li><li>–channelID：智能合约安装的通道名称</li><li>–name：合约名称</li><li>–version：合约版本</li><li><strong>–package-id</strong>：在链码定义中包含程序包标识符</li><li><strong>–sequence</strong>：一个整数，用于跟踪已定义或更新链码的次数<ul><li>由于链码是第一次部署到通道，因此序列号为1。升级链码时，序列号将增加为2。</li><li><strong>–init-required</strong>：如果使用的是提供的低级API通过Fabric Chaincode Shim API，您可以使用此标志传递给上面的命令，以请求执行Init函数来初始化链码。</li><li><strong>–isInit</strong>：链代码的第一次调用需要以Init函数为目标并包括该<code>--isInit</code>标志，然后才能使用链代码中的其他函数与分类帐进行交互。</li></ul></li><li>-<strong>-signature-policy / –channel-config-policy</strong>：指定链码背书策略<ul><li>默认背书策略是需要得到channel上的大多数成员的认可</li></ul></li><li>–waitForEvent：等待peer提交交易返回</li><li>–init-required：合约是否必须执行init</li></ul></li></ul><ol start="3"><li>切换 <code>peer</code> 到Org1 admin用户来批准之前安装的链码包</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> CORE_PEER_LOCALMSPID=<span class="string">&quot;Org1MSP&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> CORE_PEER_MSPCONFIGPATH=<span class="variable">$&#123;PWD&#125;</span>/organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> CORE_PEER_TLS_ROOTCERT_FILE=<span class="variable">$&#123;PWD&#125;</span>/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> CORE_PEER_ADDRESS=localhost:7051</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> peer lifecycle chaincode approveformyorg -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --channelID mychannel --name basic --version 1.0 --package-id <span class="variable">$CC_PACKAGE_ID</span> --sequence 1 --tls --cafile <span class="string">&quot;<span class="variable">$&#123;PWD&#125;</span>/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem&quot;</span></span></span><br></pre></td></tr></table></figure><blockquote><p>虽然只有大多数组织需要批准链码定义（具有默认策略），但是所有组织都需要批准链码定义才能在其对等方启动链码。</p><p>如果您在渠道成员批准链码之前提交定义，则组织将无法批准交易。所以，建议所有通道成员在提交链码定义之前批准链码。</p></blockquote><h4 id="提交链码定义"><a href="#提交链码定义" class="headerlink" title="提交链码定义"></a>提交链码定义</h4><p>在足够多的组织批准了链码定义之后，一个组织可以将链码定义提交给渠道。如果大多数通道成员已批准该定义，则提交事务将成功，并且链码定义中同意的参数将在该通道上实现。</p><ol><li>查看channel成员是否已经批准了此链码</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ peer lifecycle chaincode checkcommitreadiness --channelID mychannel --name basic --version 1.0 --sequence 1 --tls --cafile <span class="string">&quot;<span class="variable">$&#123;PWD&#125;</span>/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem&quot;</span> --output json</span><br></pre></td></tr></table></figure><ul><li><p>此命令标志与批准链码的标志 <code>approveformyorg</code> 相同，所以不需要 <code>--package-id</code> 标志。</p></li><li><p>该命令将生成一个JSON映射，显示通道成员是否批准链码</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;Approvals&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;Org1MSP&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;Org2MSP&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>当多数人都批准了之后，管理员就可以将链码定义提交到channel</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> peer lifecycle chaincode commit -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --channelID mychannel --name basic --version 1.0 --sequence 1 --tls --cafile <span class="string">&quot;<span class="variable">$&#123;PWD&#125;</span>/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem&quot;</span> --peerAddresses localhost:7051 --tlsRootCertFiles <span class="string">&quot;<span class="variable">$&#123;PWD&#125;</span>/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt&quot;</span> --peerAddresses localhost:9051 --tlsRootCertFiles <span class="string">&quot;<span class="variable">$&#123;PWD&#125;</span>/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt&quot;</span></span></span><br></pre></td></tr></table></figure><ul><li>参数：<ul><li>–tls：是否启动tls</li><li>–channelID：智能合约安装通道</li><li>–name：合约名</li><li>–version：合约版本</li><li>–cafile：ca证书路径</li><li><strong>–peerAddresses</strong>：节点路径，上面标示<code>peer0.org1.example.com</code>从Org1和<code>peer0.org2.example.com</code>Org2进行定位。</li><li><strong>–tlsRootCertFiles</strong>：节点ca根证书路径<ul><li><code>--peerAddresses</code> <code>--tlsRootCertFiles</code> 连用，可多个节点，多个节点即将合约部署到对应节点集合上</li></ul></li><li>–package-id：queryinstalled查询的合约ID</li><li>–sequence：序列号</li><li>–waitForEvent：等待peer提交交易返回</li><li>–init-required：合约是否必须执行init</li></ul></li><li>该<code>commit</code>交易被提交到加入该频道来查询被批准经营的同行组织的chaincode定义的peer。该命令需要针对足够数量的组织中的对等方，以满足部署链码的策略。由于批准是在每个组织内分配的，因此您可以定位属于渠道成员的任何对等方。</li><li>通道成员对链码定义的 <code>approve</code> 将提交给ordering service，以添加到区块中并分发给通道。然后，通道上的对等方将验证是否有足够的组织批准了链码定义。<code>peer lifecycle chaincode commit</code>命令将在返回响应之前等待对等方的验证。</li></ul><ol start="3"><li>确认chaincode定义已提交给channel</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> peer lifecycle chaincode querycommitted --channelID mychannel --name basic --cafile <span class="string">&quot;<span class="variable">$&#123;PWD&#125;</span>/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem&quot;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回 sequence 和 version</span></span><br><span class="line">Committed chaincode definition for chaincode &#x27;basic&#x27; on channel &#x27;mychannel&#x27;:</span><br><span class="line">Version: 1.0, Sequence: 1, Endorsement Plugin: escc, Validation Plugin: vscc, Approvals: [Org1MSP: true, Org2MSP: true]</span><br></pre></td></tr></table></figure><h3 id="调用合约"><a href="#调用合约" class="headerlink" title="调用合约"></a>调用合约</h3><p>fabric智能合约操作主要有 <strong><code>invoke</code></strong> 跟 <strong><code>query</code></strong> </p><ol><li>调用链码 <code>InitLedger</code> 方法</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> peer chaincode invoke -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile <span class="string">&quot;<span class="variable">$&#123;PWD&#125;</span>/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem&quot;</span> -C mychannel -n basic --peerAddresses localhost:7051 --tlsRootCertFiles <span class="string">&quot;<span class="variable">$&#123;PWD&#125;</span>/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt&quot;</span> --peerAddresses localhost:9051 --tlsRootCertFiles <span class="string">&quot;<span class="variable">$&#123;PWD&#125;</span>/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt&quot;</span> -c <span class="string">&#x27;&#123;&quot;function&quot;:&quot;InitLedger&quot;,&quot;Args&quot;:[]&#125;&#x27;</span></span></span><br></pre></td></tr></table></figure><ol start="2"><li>查询集合</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> peer chaincode query -C mychannel -n basic -c <span class="string">&#x27;&#123;&quot;Args&quot;:[&quot;GetAllAssets&quot;]&#125;&#x27;</span></span></span><br></pre></td></tr></table></figure><h3 id="合约升级"><a href="#合约升级" class="headerlink" title="合约升级"></a>合约升级</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> ORDERER_CA=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> peer chaincode upgrade -o orderer.example.com:7050 --tls --cafile <span class="variable">$ORDERER_CA</span> -C mychannel -n basic -v 1.2 -c <span class="string">&#x27;&#123;&quot;Args&quot;:[&quot;init&quot;,&quot;a&quot;,&quot;100&quot;,&quot;b&quot;,&quot;200&quot;,&quot;c&quot;,&quot;300&quot;]&#125;&#x27;</span> -P <span class="string">&quot;AND (&#x27;Org1MSP.peer&#x27;,&#x27;Org2MSP.peer&#x27;)&quot;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="CouchDB"><a href="#CouchDB" class="headerlink" title="CouchDB"></a>CouchDB</h2><p>CouchDB与对等方一起作为独立的数据库进程运行</p><p>需要为每个对等方设置一个CouchDB容器，并通过更改配置文件<code>core.yaml</code>以指向CouchDB容器来更新每个对等方 容器。该<code>core.yaml</code> 文件必须位于环境变量FABRIC_CFG_PATH指定的目录中：</p><ul><li>对于Docker部署，它<code>core.yaml</code>是预先配置的，位于对等容器<code>FABRIC_CFG_PATH</code>文件夹中。但是，在使用Docker环境时，您可以传递环境变量以覆盖core.yaml属性，例如<code>CORE_LEDGER_STATE_COUCHDBCONFIG_COUCHDBADDRESS</code>，设置CouchDB地址。</li><li>对于本机二进制部署，<code>core.yaml</code>包含在发布工件分发中。</li></ul><p>编辑的<code>stateDatabase</code>部分<code>core.yaml</code>。指定<code>CouchDB</code>为 <code>stateDatabase</code>并填写关联的<code>couchDBConfig</code>属性。有关更多信息，请参见<a class="link" href="https://hyperledger-fabric.readthedocs.io/en/latest/couchdb_as_state_database.html#couchdb-configuration">CouchDB配置<i class="fas fa-external-link-alt"></i></a>。</p><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><h3 id="建立通道"><a href="#建立通道" class="headerlink" title="建立通道"></a>建立通道</h3><p>peer create channel</p><h3 id="添加组织到通道"><a href="#添加组织到通道" class="headerlink" title="添加组织到通道"></a>添加组织到通道</h3><h3 id="更新通道配置"><a href="#更新通道配置" class="headerlink" title="更新通道配置"></a>更新通道配置</h3><h1 id="commercial-paper"><a href="#commercial-paper" class="headerlink" title="commercial-paper"></a>commercial-paper</h1><h2 id="启动网络"><a href="#启动网络" class="headerlink" title="启动网络"></a>启动网络</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> fabric-samples/commercial-paper</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./network-starter.sh</span></span><br></pre></td></tr></table></figure><ul><li>可以使用 <code>docker ps</code> 命令查看本地计算机上运行的Fabric节点</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> commercial-paper/organization/magnetocorp/configuration/cli</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./monitordocker.sh fabric_test &lt;port_number&gt;</span></span><br></pre></td></tr></table></figure><ul><li>在新的窗口下监视 MagnetoCorp 的日志信息</li></ul><h2 id="部署智能合约"><a href="#部署智能合约" class="headerlink" title="部署智能合约"></a>部署智能合约</h2><p>在<code>papercontract</code>被应用程序调用之前，必须将其安装到测试网络的适当对等节点上，然后使用 <code>peer lifecycle</code> 在通道上进行定义。Fabric链码生命周期允许多个组织在将链码部署到通道之前就链码的参数达成一致。因此，我们需要以MagnetoCorp和DigiBank的管理员身份安装和批准链式代码。</p><ol><li>打包智能合约为文件 <code>cp.tar.gz</code></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> commercial-paper/organization/magnetocorp</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> magnetocorp.sh</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> peer lifecycle chaincode package cp.tar.gz --lang node --path ./contract --label cp_0</span></span><br></pre></td></tr></table></figure><ul><li>在 magnetocorp 的目录下，第二条命令用来设置示例所需的环境变量</li></ul><ol start="2"><li>在channel上安装智能合约</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> peer lifecycle chaincode install cp.tar.gz</span></span><br></pre></td></tr></table></figure><ol start="3"><li>批准合约</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查询package id</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> peer lifecycle chaincode queryinstalled</span></span><br><span class="line">Installed chaincodes on peer:</span><br><span class="line">Package ID: cp_0:(一串数字即为package id)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置package id环境变量</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> PACKAGE_ID=cp_0:(那串package id的数字)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行命令批准合约</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> peer lifecycle chaincode approveformyorg --orderer localhost:7050 --ordererTLSHostnameOverride orderer.example.com --channelID mychannel --name papercontract -v 0 --package-id <span class="variable">$PACKAGE_ID</span> --sequence 1 --tls --cafile <span class="variable">$ORDERER_CA</span></span></span><br></pre></td></tr></table></figure><ol start="4"><li>再以 DigiBank 的身份部署合约</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 打包合约</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> commercial-paper/organization/digibank/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装合约</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> digibank.sh</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> peer lifecycle chaincode package cp.tar.gz --lang node --path ./contract --label cp_0</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> peer lifecycle chaincode install cp.tar.gz</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查询设置package id</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> peer lifecycle chaincode queryinstalled</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> PACKAGE_ID=cp_0:...</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 批准合约</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> peer lifecycle chaincode approveformyorg --orderer localhost:7050 --ordererTLSHostnameOverride orderer.example.com --channelID mychannel --name papercontract -v 0 --package-id <span class="variable">$PACKAGE_ID</span> --sequence 1 --tls --cafile <span class="variable">$ORDERER_CA</span></span></span><br></pre></td></tr></table></figure><h2 id="提交链码到channel"><a href="#提交链码到channel" class="headerlink" title="提交链码到channel"></a>提交链码到channel</h2><ol><li>查看通道上 approve 的情况，是否满足 commit 的条件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> peer lifecycle chaincode checkcommitreadiness --channelID mychannel --name papercontract --version 0 --sequence 1</span></span><br></pre></td></tr></table></figure><ol start="2"><li>当 MagnetoCorp 和 DigiBank 均批准了链码之后，我们就可以提交链码定义了</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> peer lifecycle chaincode commit -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --peerAddresses localhost:7051 --tlsRootCertFiles <span class="variable">$&#123;PEER0_ORG1_CA&#125;</span> --peerAddresses localhost:9051 --tlsRootCertFiles <span class="variable">$&#123;PEER0_ORG2_CA&#125;</span> --channelID mychannel --name papercontract -v 0 --sequence 1 --tls --cafile <span class="variable">$ORDERER_CA</span> --waitForEvent</span></span><br></pre></td></tr></table></figure><ol start="3"><li>查看提交的链码</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 查看通道 mychannel 上安装了哪些链码</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> peer lifecycle chaincode querycommitted -C mychannel</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出：</span></span><br><span class="line">Committed chaincode definitions on channel &#x27;mychannel&#x27;:</span><br><span class="line">Name: papercontract, Version: 0, Sequence: 1, Endorsement Plugin: escc, Validation Plugin: vscc</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 查看通道 mychannel 上安装的链码 papercontract 的详情</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> peer lifecycle chaincode querycommitted -C mychannel --name papercontract</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出：</span></span><br><span class="line">Committed chaincode definition for chaincode &#x27;papercontract&#x27; on channel &#x27;mychannel&#x27;:</span><br><span class="line">Version: 0, Sequence: 1, Endorsement Plugin: escc, Validation Plugin: vscc, Approvals: [Org1MSP: true, Org2MSP: true]</span><br></pre></td></tr></table></figure><ul><li>-C / –channelID：通道名称</li><li>–name：链码名称</li></ul><h2 id="更新链码"><a href="#更新链码" class="headerlink" title="更新链码"></a>更新链码</h2><p>在fabric2.0新增的命令<code>peer lifecycle chaincode</code>下，链码更新的步骤和部署链码的步骤相同。</p><ul><li>sequence：版本，表示这是本链码的第几个版本</li><li>version：版本号，表示本链码此版本的版本号</li><li>比如下面演示部分就是将链码更新为版本号为1的第二个版本</li></ul><ol><li>打包成版本 1.0</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> commercial-paper/organization/magnetocorp</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> magnetocorp.sh</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> peer lifecycle chaincode package cp.tar.gz --lang node --path ./contract --label cp_1</span></span><br></pre></td></tr></table></figure><ol start="2"><li>安装链码 1.0 版本</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> peer lifecycle chaincode install cp.tar.gz</span></span><br></pre></td></tr></table></figure><ol start="3"><li>批准链码</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查询package id</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> peer lifecycle chaincode queryinstalled</span></span><br><span class="line">Installed chaincodes on peer:</span><br><span class="line">Package ID: cp_1:(一串数字即为package id)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置package id环境变量</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> PACKAGE_ID=cp_1:(那串package id的数字)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行命令批准合约</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> peer lifecycle chaincode approveformyorg --orderer localhost:7050 --ordererTLSHostnameOverride orderer.example.com --channelID mychannel --name papercontract -v 1 --package-id <span class="variable">$PACKAGE_ID</span> --sequence 2 --tls --cafile <span class="variable">$ORDERER_CA</span></span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>，此处版本号为1，因为是第二个版本，所以 sequence 为2</p></blockquote><ol start="4"><li>如果要在 DigiBank 上也更新的话，需要执行相同的流程</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 打包合约</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> commercial-paper/organization/digibank/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装合约</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> digibank.sh</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> peer lifecycle chaincode package cp.tar.gz --lang node --path ./contract --label cp_1</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> peer lifecycle chaincode install cp.tar.gz</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查询设置package id</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> peer lifecycle chaincode queryinstalled</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> PACKAGE_ID=cp_1:...</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 批准合约</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> peer lifecycle chaincode approveformyorg --orderer localhost:7050 --ordererTLSHostnameOverride orderer.example.com --channelID mychannel --name papercontract -v 1 --package-id <span class="variable">$PACKAGE_ID</span> --sequence 2 --tls --cafile <span class="variable">$ORDERER_CA</span></span></span><br></pre></td></tr></table></figure><ol start="5"><li>提及更新后的链码<ul><li>只有下载并提交了新链码的peer才能使用<strong>新链码</strong>，否则依然使用<strong>旧链码</strong></li></ul></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看 approve 的情况</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> peer lifecycle chaincode checkcommitreadiness --channelID mychannel --name papercontract --version 1 --sequence 2</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> peer lifecycle chaincode commit -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --peerAddresses localhost:7051 --tlsRootCertFiles <span class="variable">$&#123;PEER0_ORG1_CA&#125;</span> --peerAddresses localhost:9051 --tlsRootCertFiles <span class="variable">$&#123;PEER0_ORG2_CA&#125;</span> --channelID mychannel --name papercontract -v 1 --sequence 2 --tls --cafile <span class="variable">$ORDERER_CA</span> --waitForEvent</span></span><br></pre></td></tr></table></figure><ol start="6"><li>之后调用链码 <code>papercontract</code>时便是使用的更新后的版本</li></ol><h2 id="应用结构及代码"><a href="#应用结构及代码" class="headerlink" title="应用结构及代码"></a>应用结构及代码</h2><blockquote><p>每次运行 Application 前，都需要删除 identity 文件夹，清除上次运行分发的身份，重新enroll当前网络</p></blockquote><h3 id="MagnetoCorp"><a href="#MagnetoCorp" class="headerlink" title="MagnetoCorp"></a>MagnetoCorp</h3><p>目录：<code>fabric-samples/commercial-paper/organization/magnetocorp/application</code></p><ol><li>安装依赖</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install</span></span><br></pre></td></tr></table></figure><ol start="2"><li>注册用户，生成用户钱包</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> node enrollUser.js</span></span><br></pre></td></tr></table></figure><ol start="2"><li>发行commercial paper</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> node issue.js</span></span><br></pre></td></tr></table></figure><h3 id="DigiBank"><a href="#DigiBank" class="headerlink" title="DigiBank"></a>DigiBank</h3><p>目录：<code>fabric-samples/commercial-paper/organization/digibank/application</code></p><ol><li>安装依赖</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install</span></span><br></pre></td></tr></table></figure><ol start="2"><li>注册用户，生成用户钱包</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> node enrollUser.js</span></span><br></pre></td></tr></table></figure><ol start="3"><li>购买commercial paper</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> node buy.js</span></span><br></pre></td></tr></table></figure><ol start="4"><li>赎回</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> node reedem.js</span></span><br></pre></td></tr></table></figure><h3 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h3><p>应用程序<strong>提交交易</strong>步骤：</p><ul><li>（前提是用户已经加入到网络中，拥有了一个身份）</li><li>从钱包中选择一个身份</li><li>连接到网关</li><li>访问所需的网络</li><li>构建智能合约的交易请求</li><li>将交易提交到网络</li><li>处理回应</li></ul><p><strong>代码框架</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Wallets, Gateway &#125; = <span class="built_in">require</span>(<span class="string">&#x27;fabric-network&#x27;</span>);</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 得到钱包</span></span><br><span class="line">    <span class="keyword">const</span> wallet = <span class="keyword">await</span> Wallets.newFileSystemWallet(<span class="string">&#x27;../identity/user/isabella/wallet&#x27;</span>);</span><br><span class="line">    <span class="comment">// 接入网关</span></span><br><span class="line"><span class="keyword">const</span> gateway = <span class="keyword">new</span> Gateway();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> userName = <span class="string">&#x27;isabella.issuer@magnetocorp.com&#x27;</span>;</span><br><span class="line">        <span class="keyword">let</span> connectionProfile = yaml.safeLoad(fs.readFileSync(<span class="string">&#x27;../gateway/connection-org2.yaml&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>));</span><br><span class="line">        <span class="keyword">let</span> connectionOptions = &#123;</span><br><span class="line">    identity: userName,</span><br><span class="line">     wallet: wallet,</span><br><span class="line">    discovery: &#123; <span class="attr">enabled</span>:<span class="literal">true</span>, <span class="attr">asLocalhost</span>: <span class="literal">true</span> &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">await</span> gateway.connect(connectionProfile, connectionOptions); </span><br><span class="line">        ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>Wallet</strong><ul><li>钱包包含一组身份（X.509数字证书），可用于访问PaperNet或任何其他Fabric网络</li></ul></li></ol><ol start="2"><li><p><strong>Gateway</strong></p><ul><li><p>网关标识一个或多个对等网络，这些对等网络提供对网络的访问权限 - 示例中的PaperNet</p></li><li><p>负责使用<strong>连接配置文件</strong>和<strong>连接选项</strong>将交易建议发送到网络中正确的对等节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> gateway.connect(connectionProfile, connectionOptions); </span><br></pre></td></tr></table></figure><ul><li><p><strong>connectionProfile</strong>：<strong>连接配置文件</strong>的系统位置，该配置文件将一组对等方标识为PaperNet的网关</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载并转换为JSON对象</span></span><br><span class="line"><span class="keyword">let</span> connectionProfile = yaml.safeLoad(fs.readFileSync(<span class="string">&#x27;../gateway/connection-org2.yaml&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>));</span><br></pre></td></tr></table></figure></li><li><p><strong>connectionOptions</strong>：用于控制 <code>issue.js</code> 与PaperNet<strong>交互方式</strong>的一组选项</p></li></ul></li></ul></li></ol><h3 id="Contract"><a href="#Contract" class="headerlink" title="Contract"></a>Contract</h3><p>目录结构：</p><img src="/2021/03/16/fabric-Developing%20Application/截屏2021-03-18 下午6.21.17.png" alt="截屏2021-03-18 下午6.21.17" style="zoom:50%;"><ul><li><p>lib：主要的paper相关操作</p><ul><li><p><strong>paper.js</strong>：定义 commercial paper 相关属性的set、get、is…和相关静态方法（序列化、反序列化等）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommercialPaper</span> <span class="keyword">extends</span> <span class="title">State</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>papercontract.js</strong>：定义了交易逻辑（此处包括issue、buy、redeem、transfer等）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommercialPaperContext</span> <span class="keyword">extends</span> <span class="title">Context</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommercialPaperContract</span> <span class="keyword">extends</span> <span class="title">Contract</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>CommercialPaperContext：创建并维护 paperList，用来定位到所需操作的paper</li><li>CommercialPaperContract：定义交易主要逻辑，在交易中完成paper的状态转移</li></ul></li><li><p><strong>paperlist.js</strong>：维护 paperList 相关的方法 - add、get、update</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaperList</span> <span class="keyword">extends</span> <span class="title">StateList</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>ledger-api：</p><ul><li><p><strong>state.js</strong>：主要控制 paper 的 stateClass 和 keyParts</p></li><li><p><strong>statelist.js</strong>：根据paper的state和key来控制paperlist的状态，并调用fabric-contract-api与区块链交互</p><blockquote><p>该类不存储任何单个状态或者状态列表，而是委派给Fabric数据库</p><ul><li>这是一种重要的设计模式–减少了Hyperledger Fabric中分类账<strong>MVCC冲突</strong>的机会。</li></ul></blockquote><ul><li><pre><code class="javascript">async addState(state) &#123;    let key = this.ctx.stub.createCompositeKey(this.name, state.getSplitKey());    let data = State.serialize(state);    await this.ctx.stub.putState(key, data);&#125;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  * **分类账**：每个状态数据都需要以下两个基本元素</span><br><span class="line"></span><br><span class="line">    1. **密钥**：&#96;key&#96; 是 &#96;createCompositeKey()&#96; 使用固定名称和 &#96;state&#96; 的密钥形成的。</span><br><span class="line">       * &#96;this.name&#96; 是在 &#96;PaperList&#96; 构造对象时分配的</span><br><span class="line">       * &#96;state.getSplitKey()&#96;确定每个状态的唯一键。</span><br><span class="line">    2. **数据**：&#96;data &#96;只是使用 &#96;State.serialize()&#96; 实用程序方法创建的commercial paper状态的序列化形式。</span><br><span class="line">       *  &#96;State&#96; 类使用JSON来序列化和反序列化数据，state的对象类需要，在我们的例子&#96;CommercialPaper&#96;中， &#96;PaperList&#96; 对象构建时需要重定义。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># fabcar</span><br><span class="line"></span><br><span class="line">提供了Fabric功能的广泛演示</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"># 代码工具</span><br><span class="line"></span><br><span class="line">[工具使用](http:&#x2F;&#x2F;cw.hubwiz.com&#x2F;card&#x2F;c&#x2F;fabric-command-manual&#x2F;1&#x2F;1&#x2F;27&#x2F;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## peer</span><br><span class="line"></span><br><span class="line">[汇智网命令大全](http:&#x2F;&#x2F;cw.hubwiz.com&#x2F;card&#x2F;c&#x2F;fabric-command-manual&#x2F;1&#x2F;1&#x2F;1&#x2F;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">有以下5个子命令</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;shell</span><br><span class="line">$ peer chaincode [option] [flags]</span><br><span class="line">$ peer channel   [option] [flags]</span><br><span class="line">$ peer logging   [option] [flags]</span><br><span class="line">$ peer node      [option] [flags]</span><br><span class="line">$ peer version   [option] [flags]</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul></li></ul><p>**通用 [flag]**：</p><ul><li><strong>–cafile</strong>    string<ul><li>Path to file containing PEM-encoded trusted certificate(s) for the ordering endpoint</li><li>包含用于订购端点的PEM编码的受信任证书的文件的路径</li></ul></li><li><strong>–certfile</strong>    string<ul><li>Path to file containing PEM-encoded X509 public key to use for mutual TLS communication with the orderer endpoint</li><li>包含用于与订购者端点进行相互TLS通信的PEM编码X509公钥的文件的路径</li></ul></li><li><strong>–clientauth</strong><ul><li>Use mutual TLS when communicating with the orderer endpoint</li></ul></li><li><strong>–connTimeout duration</strong><ul><li>Timeout for client to connect (default 3s)</li></ul></li><li><strong>-h, –help</strong><ul><li>help for channel</li></ul></li><li><strong>–keyfile</strong>    string<ul><li>Path to file containing PEM-encoded private key to use for mutual TLS communication with the orderer endpoint</li><li>包含用于与订购者端点进行相互TLS通信的PEM编码的私钥的文件的路径</li></ul></li><li><strong>-o, –orderer</strong>    string<ul><li>Ordering service endpoint</li><li>订购服务端点指定为 <code>&lt;hostname or IP address&gt;:&lt;port&gt;</code></li></ul></li><li><strong>–ordererTLSHostnameOverride</strong>    string<ul><li>The hostname override to use when validating the TLS connection to the orderer.</li><li>验证与订购者的TLS连接时要使用的主机名覆盖</li></ul></li><li><strong>–tls</strong><ul><li>Use TLS when communicating with the orderer endpoint</li><li>与订购者端点进行通信时使用TLS</li></ul></li><li><strong>–transient</strong>    string<ul><li>JSON编码中的参数的瞬时映射</li></ul></li></ul><h3 id="peer-chaincode"><a href="#peer-chaincode" class="headerlink" title="peer chaincode"></a>peer chaincode</h3><p><code>peer chaincode invoke</code></p><p><code>peer chaincode query</code></p><p><code>peer chaincode install</code></p><p><code>peer chaincode instantiate</code></p><p><code>peer chaincode list</code></p><p><code>peer chaincode package</code></p><p><code>peer chaincode signpackage</code></p><p><code>peer chaincode upgrade</code></p><h3 id="peer-channel"><a href="#peer-channel" class="headerlink" title="peer channel"></a>peer channel</h3><p>peer channel list：列出当前组织所属的所有通道列表</p><h3 id="peer-lifecycle-chaincode"><a href="#peer-lifecycle-chaincode" class="headerlink" title="peer lifecycle chaincode"></a>peer lifecycle chaincode</h3><p>包含以下<strong>子命令</strong>:</p><ul><li><p>package：                            打包链码<br>* </p></li><li><p>install：                                安装链码<br>* </p></li><li><p>queryinstalled：                 查询指定peer节点上已经安装的链码</p><ul><li></li></ul></li><li><p>approveformyorg：           批准链码定义<br>* </p></li><li><p>checkcommitreadiness： 检查链码是否可以向通道提交<br>* </p></li><li><p>commit：                             向通道提交链码定义<br>* </p></li><li><p>querycommitted：             按通道查询已经提交的链码定义<br>* </p></li><li><p>getinstalledpackage：       从peer节点获取已经安装的链码包</p><ul><li></li></ul></li></ul><p>可用<strong>标志</strong>:</p><ul><li>–cafile string                       PEM编码的CA证书文件路径</li><li>–certfile string                     双向TLS通讯所需的PEM编码的X509证书文件路径</li><li>–clientauth                          与排序节点的通讯是否启用双向TLS</li><li>–connTimeout duration    客户端连接超时，默认值：3秒</li><li>-h, –help                               帮助信息</li><li>–keyfile string                      双向TLS通讯所需的PEM编码的私钥文件</li><li>-o, –orderer string               排序节点地址</li><li>–ordererTLSHostnameOverride string     验证TLS连接时使用的排序节点主机名</li><li>–tls                                         与排序节点通信时是否启用TLS</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本部分主要讲解智能合约的部署，已经commercial paper部分的使用和代码解析&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;end users通</summary>
      
    
    
    
    <category term="Notebook" scheme="https://jieyang-wei.github.io/categories/Notebook/"/>
    
    <category term="Blockchain" scheme="https://jieyang-wei.github.io/categories/Notebook/Blockchain/"/>
    
    <category term="Fabric" scheme="https://jieyang-wei.github.io/categories/Notebook/Blockchain/Fabric/"/>
    
    
    <category term="fabric" scheme="https://jieyang-wei.github.io/tags/fabric/"/>
    
    <category term="blockchain" scheme="https://jieyang-wei.github.io/tags/blockchain/"/>
    
  </entry>
  
  <entry>
    <title>fabric-Getting Start</title>
    <link href="https://jieyang-wei.github.io/2021/03/14/fabric-Getting%20Start/"/>
    <id>https://jieyang-wei.github.io/2021/03/14/fabric-Getting%20Start/</id>
    <published>2021-03-14T04:08:44.000Z</published>
    <updated>2021-04-19T06:43:03.296Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本部分主要设计fabric环境安装，已经 <code>fabric-sample</code> 中 <code>test-network</code> 和 <code>asset-transfer-basic</code> 样例的运行</p><p>Fabric应用程序堆栈有五层：</p><img src="/2021/03/14/fabric-Getting%20Start/getting_started_image2.png" alt="织物应用堆栈" style="zoom: 20%;"><ul><li>必备软件：运行该软件所需的基础层，例如Docker。</li><li>Fabric和Fabric示例：Fabric可执行文件与示例代码一起运行Fabric网络。</li><li>合约API：开发在Fabric网络上执行的智能合约。</li><li>应用程序SDK：开发您的区块链应用程序。</li><li>应用程序：您的区块链应用程序将利用应用程序SDK调用在Fabric网络上运行的智能合约。</li></ul><p><strong>fabric核心模块</strong></p><table><thead><tr><th align="center">模块名词</th><th align="center">功能</th><th align="center">类型</th></tr></thead><tbody><tr><td align="center">peer</td><td align="center">主节点模块，负责存储区块链数据，运行维护代码</td><td align="center">系统模块</td></tr><tr><td align="center">order</td><td align="center">交易打包，排序模块</td><td align="center">系统模块</td></tr><tr><td align="center">cryptogen</td><td align="center">组织和证书生成模块</td><td align="center">工具模块</td></tr><tr><td align="center">configtxgen</td><td align="center">区块和交易生成模块</td><td align="center">工具模块</td></tr><tr><td align="center">configtxlator</td><td align="center">区块和交易解析模块</td><td align="center">工具模块</td></tr></tbody></table><ul><li>工具模块负责证书文件，区块链创始块，通道创始块等相关文件和证书的生成工作，不参与系统的运行。</li><li><strong>cryptogen</strong>：模块主要用于生成组织结构和账号相关文件，任何fabric系统的开发都是从cryptogen模块开始，在系统设计完成后首要工作就是根据系统设计编写cryptogen的配置文件。</li><li><strong>configtxgen</strong>：</li></ul><h1 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h1><p><a class="link" href="https://hyperledger-fabric.readthedocs.io/en/latest/getting_started.html">官方文档<i class="fas fa-external-link-alt"></i></a></p><p>系统：MacOS</p><h2 id="必备软件"><a href="#必备软件" class="headerlink" title="必备软件"></a>必备软件</h2><p>Prerequisites - 先决条件</p><ul><li><strong>Homebrew</strong>：仅mac系统需要，用来管理下面所需要的软件包</li><li><strong>git</strong>：<strong>版本管理</strong>工具</li><li><strong>cURL</strong>：curl命令是个功能强大的<strong>网络工具</strong>，支持通过http、ftp等方式下载文件、上传文件</li><li><strong>Docker &amp; Docker-compose</strong>：一个开源的<strong>应用容器引擎</strong>，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化</li><li><strong>Go</strong>：Docker是基于go语言的<ul><li>(only required if you will be writing Go chaincode or SDK applications)</li></ul></li><li><strong>JQ</strong>：既JQuery，一个优秀的javascript类库<ul><li>(only required for the tutorials related to channel configuration transactions)</li></ul></li></ul><h3 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a>Homebrew</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> /bin/bash -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)</span>&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> brew --version</span></span><br><span class="line">Homebrew 3.0.4</span><br><span class="line">Homebrew/homebrew-core (git revision 89d933; last commit 2020-04-01)</span><br></pre></td></tr></table></figure><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><blockquote><img src="/2021/03/14/fabric-Getting%20Start/截屏2021-03-07 下午5.22.32.png" alt="截屏2021-03-07 下午5.22.32" style="zoom:50%;"><ol><li>Error: Unknown command: cask<ul><li>Homebrew 2.5.x 之后删掉了<code>brew cask</code></li><li>直接使用<code>brew</code>，或者<code>brew --cask</code>即可</li></ul></li></ol><img src="/2021/03/14/fabric-Getting%20Start/截屏2021-03-07 下午5.21.56.png" alt="截屏2021-03-07 下午5.21.56" style="zoom:50%;"><ol start="2"><li><p>升级后核心不可用<code>homebrew-core is a shallow clone</code></p><ul><li>先按照提示执行<code>git -C /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core fetch --unshallow</code></li></ul><img src="/2021/03/14/fabric-Getting%20Start/截屏2021-03-07 下午7.57.58.png" alt="截屏2021-03-07 下午7.57.58" style="zoom:50%;"><ul><li>如果系统不支持<code>unshallow</code>，则删掉核心后再update</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rm -rf /usr/<span class="built_in">local</span>/Homebrew/Library/Taps/homebrew/homebrew-core</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> brew update</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew install git</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git --version</span></span><br><span class="line">git version 2.24.3 (Apple Git-128)</span><br></pre></td></tr></table></figure><h3 id="cURL"><a href="#cURL" class="headerlink" title="cURL"></a>cURL</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew install curl</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl --version</span></span><br><span class="line">curl 7.63.0 (x86_64-apple-darwin13.4.0) libcurl/7.63.0 OpenSSL/1.1.1b zlib/1.2.11 libssh2/1.8.0</span><br><span class="line">Release-Date: 2018-12-12</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><ul><li>Since Docker Desktop is a UI application on Mac, use <code>cask</code> to install it.</li></ul><p>Homebrew v2.x:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew cask install --appdir=<span class="string">&quot;/Applications&quot;</span> docker</span></span><br></pre></td></tr></table></figure><p>Homebrew v3.x:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew install --cask --appdir=<span class="string">&quot;/Applications&quot;</span> docker</span></span><br></pre></td></tr></table></figure><ul><li>Docker Desktop must be launched to complete the installation so be sure to open the application after installing it:</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> open /Applications/Docker.app</span></span><br></pre></td></tr></table></figure><ul><li>Once installed, confirm the latest versions of both <code>docker</code> and <code>docker-compose</code> executables were installed.</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker --version</span></span><br><span class="line">Docker version 20.10.5, build 55c4c88</span><br><span class="line"><span class="meta">$</span><span class="bash"> docker-compose --version</span></span><br><span class="line">docker-compose version 1.28.5, build c4eb3a1f</span><br></pre></td></tr></table></figure><h4 id="加速"><a href="#加速" class="headerlink" title="加速"></a>加速</h4><ul><li><p>docker镜像在国外，为了后续下载加速，配置文件将镜像换成国内的</p><ul><li><p>在<code>/etc/docker/daemon.json</code>文件中配置或者如下图所示在软件中配置：</p></li><li><p><code>&#123;&quot;registry-mirrors&quot;:[&quot;https://reg-mirror.qiniu.com/&quot;]&#125;</code></p><p>![截屏2021-03-07 下午9.55.31](fabric-Getting Start/截屏2021-03-07 下午9.55.31.png)</p></li></ul></li></ul><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew install go</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> go version</span></span><br><span class="line">go version go1.16 darwin/amd64</span><br></pre></td></tr></table></figure><ul><li>可以根据喜好设置项目目录，下面为推荐目录结构</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> GOPATH:<span class="variable">$Home</span>/&lt;user-defined-workspace&gt;/go</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> go env GOPATH</span></span><br><span class="line">/Users/weijieyang/go</span><br></pre></td></tr></table></figure><h3 id="JQ"><a href="#JQ" class="headerlink" title="JQ"></a>JQ</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew install jq</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> jq --version</span></span><br><span class="line">jq-1.6</span><br></pre></td></tr></table></figure><h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><blockquote><img src="/2021/03/14/fabric-Getting%20Start/截屏2021-03-08 下午1.26.23.png" alt="截屏2021-03-08 下午1.26.23" style="zoom:50%;"><ol><li>python版本问题<ul><li>按照给出的指令顺序操作</li><li><code>--overwrite</code> 表示强制</li></ul></li></ol><img src="/2021/03/14/fabric-Getting%20Start/截屏2021-03-08 下午1.32.00.png" alt="截屏2021-03-08 下午1.32.00" style="zoom:50%;"></blockquote><h2 id="fabric"><a href="#fabric" class="headerlink" title="fabric"></a>fabric</h2><p>下载fabric</p><ul><li>github：<a class="link" href="https://github.com/hyperledger/fabric.git">fabric<i class="fas fa-external-link-alt"></i></a></li><li>code china：<a class="link" href="https://codechina.csdn.net/mirrors/hyperledger/fabric">fabric<i class="fas fa-external-link-alt"></i></a> </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/hyperledger</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> git@github.com:hyperledger/fabric.git</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换fabric版本，也可以直接使用当前版本</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> fabric</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b release-1.1 origin/release-1.1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 生成所有工具模块的二进制可执行文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make all</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者只单独生成所需工具模块的可执行文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make configtxgen</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make cryptogen</span></span><br></pre></td></tr></table></figure><ul><li>make将会在 <code>build/bin</code> 目录下生成二进制可执行文件</li></ul><h3 id="bootstrap-sh"><a href="#bootstrap-sh" class="headerlink" title="bootstrap.sh"></a>bootstrap.sh</h3><p><strong>路径</strong>：<code>fabric/script/bootstrap.sh</code></p><p><strong>主要功能</strong>：</p><img src="/2021/03/14/fabric-Getting%20Start/截屏2021-03-28 下午1.17.26.png" alt="截屏2021-03-28 下午1.17.26" style="zoom:50%;"><ul><li><p>SAMPLES：克隆fabric-samples</p></li><li><p>BINARIES：安装二进制文件</p></li><li><p>DOCKER：下载docker镜像</p></li></ul><p><strong>执行</strong>：</p><h3 id="focker-image"><a href="#focker-image" class="headerlink" title="focker image"></a>focker image</h3><table><thead><tr><th align="center">镜像名称</th><th align="center">是否可选</th><th align="center">镜像说明</th></tr></thead><tbody><tr><td align="center">hyperledger/fabric-tools</td><td align="center">可选</td><td align="center">包含crytogen、configtxgen、configtxlator我第二次工具的镜像文件</td></tr><tr><td align="center">hyperledger/fabric-couchdb</td><td align="center">可选</td><td align="center">CouchDB的数据库镜像文件、状态数据库选择CouchDB的时候才需要</td></tr><tr><td align="center">hyperledger/fabric-kafka</td><td align="center">可选</td><td align="center">Kafka的镜像文件</td></tr><tr><td align="center">hyperledger/fabric-zookeeper</td><td align="center">可选</td><td align="center">Zookeeper的镜像文件</td></tr><tr><td align="center">hyperledger/fabric-peer</td><td align="center">必选</td><td align="center">Peer节点的镜像文件</td></tr><tr><td align="center">hyperledger/fabric-orderer</td><td align="center">必选</td><td align="center">排序服务节点的镜像文件</td></tr><tr><td align="center">hyperledger/fabric-javaenv</td><td align="center">可选</td><td align="center">java链码的基础镜像文件</td></tr><tr><td align="center">hyperledger/fabric-ccenv</td><td align="center">必选</td><td align="center">Golang链码的基础镜像文件</td></tr><tr><td align="center">hyperledger/fabric-ca</td><td align="center">可选</td><td align="center">fabric-ca的镜像文件，用到fabric-ca的时候才需要</td></tr></tbody></table><h2 id="fabric-sample"><a href="#fabric-sample" class="headerlink" title="fabric-sample"></a>fabric-sample</h2><p>github源码：</p><ul><li><a class="link" href="https://github.com/hyperledger/fabric-samples.git">fabric-samples<i class="fas fa-external-link-alt"></i></a></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir -p <span class="variable">$HOME</span>/go/src/github.com/&lt;your_github_userid&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> <span class="variable">$HOME</span>/go/src/github.com/&lt;your_github_userid&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl -sSL https://bit.ly/2ysbOFE | bash -s</span></span><br></pre></td></tr></table></figure><ul><li>创建go项目目录并使用curl下载sample文件</li></ul><ul><li><p>上面的curl命令将会执行以下步骤：</p><ol><li><p>克隆<a class="link" href="https://github.com/hyperledger/fabric-samples.git">hyperledger / fabric-samples<i class="fas fa-external-link-alt"></i></a>存储库。</p></li><li><p>下载最新的Hyperledger Fabric Docker映像并将其标记为 <code>latest</code></p></li><li><p>将以下特定于平台<strong>编译好的</strong>的Hyperledger Fabric CLI工具<strong>二进制文件</strong>和<strong>配置文件</strong>下载到<code>fabric-samples</code> <code>/bin</code>和<code>/config</code>目录中。这些二进制文件将帮助您与测试网络进行交互。</p><img src="/2021/03/14/fabric-Getting%20Start/截屏2021-03-09 下午10.05.11.png" alt="截屏2021-03-09 下午10.05.11" style="zoom:50%;"></li></ol></li></ul><h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h3><blockquote><p><strong>报错</strong>：</p><img src="/2021/03/14/fabric-Getting%20Start/截屏2021-03-08 下午8.49.03.png" alt="截屏2021-03-08 下午8.49.03" style="zoom:50%;"><ul><li>此处网站 <code>https://bit.ly/2ysbOFE</code> 需要科学上网，在国内访问不了</li></ul><p>（针对Ubuntu / CentOS系统）</p><ol><li><p>如果无法访问上述github文件，可以考虑添加docker镜像源</p><img src="/2021/03/14/fabric-Getting%20Start/截屏2021-03-08 下午9.29.57.png" alt="截屏2021-03-08 下午9.29.57" style="zoom:50%;"><ul><li><p>在文件 <code>/etc/docker/daemon.json</code> 中添加镜像源：</p><p><code>&quot;registry-mirrors&quot;:[&quot;https://registry.docker-cn.com&quot;]</code></p></li><li><p>查看镜像源：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker info|grep Mirrors -A 1</span></span><br><span class="line"> Registry Mirrors:</span><br><span class="line">  https://registry.docker-cn.com/</span><br></pre></td></tr></table></figure></li><li><p>重启网络</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Ubuntu</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo /etc/init.d/networking restart</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> CentOS</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo /etc/init.d/network restart</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Mac</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo ifconfig en0 down/up</span></span><br></pre></td></tr></table></figure></li><li><p>再次执行curl指令</p></li></ul></li></ol><p>（还是无法链接网站）</p><ol start="2"><li>上面的网站主要是为了获得一个<code>bootstrap.sh</code>的脚本文件并执行</li></ol><ul><li><p>我们只需要去fabric中下载<a class="link" href="https://github.com/hyperledger/fabric/blob/master/scripts/bootstrap.sh">bootstrap.sh源码<i class="fas fa-external-link-alt"></i></a>即可</p><ul><li>需要先下载zip <code>https://github.com/hyperledger/fabric.git</code> (master分支)</li><li>再将文件<code>fabric/scripts/bootstrap.sh</code> 移动到目录<code>$HOME/go/src/github.com/&lt;your_github_userid&gt;</code>下</li><li>或者使用github单个文件下载工具<a class="link" href="https://minhaskamal.github.io/DownGit/#/home">DownGit<i class="fas fa-external-link-alt"></i></a></li><li>之后在此脚本目录下执行下面的指令即可</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat bootstrap.sh |bash -s</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>运行 bootstrap.sh 时如果发现无法下载fabric的<strong>二进制可执行文件</strong>和<strong>配置文件</strong>，如下图：</p><img src="/2021/03/14/fabric-Getting%20Start/截屏2021-03-09 下午3.39.33.png" alt="截屏2021-03-09 下午3.39.33" style="zoom:50%;"><ul><li><p>可能是因为网络不稳定，换一个好点的网络重新运行</p></li><li><p>也可以将这部分的代码单独拉出来执行</p><blockquote><p>注意文件版本，根据自己的系统选择，darwin（=MacOS）、linux、win等</p></blockquote><ol><li>点击下面两个链接即可自动下载</li></ol><ul><li><a class="link" href="https://github.com/hyperledger/fabric/releases/download/v2.3.1/hyperledger-fabric-darwin-amd64-2.3.1.tar.gz">fabric-darwin-amd64-2.3.1.tar.gz<i class="fas fa-external-link-alt"></i></a><ul><li><a class="link" href="https://github.com/hyperledger/fabric-ca/releases/download/v1.4.9/hyperledger-fabric-ca-darwin-amd64-1.4.9.tar.gz">fabric-ca-darwin-amd64-1.4.9.tar.gz<i class="fas fa-external-link-alt"></i></a></li></ul></li></ul><ol start="2"><li><p>或者在终端中执行下面的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">       </span><br></pre></td></tr></table></figure><h1 id="失败重复5次，重复间隔时间为3s，并保存为-tar-gz-形式"><a href="#失败重复5次，重复间隔时间为3s，并保存为-tar-gz-形式" class="headerlink" title="失败重复5次，重复间隔时间为3s，并保存为 .tar.gz 形式"></a>失败重复5次，重复间隔时间为3s，并保存为 .tar.gz 形式</h1><p>$ curl -L –retry 5 –retry-delay 3 “<a class="link" href="https://github.com/hyperledger/fabric/releases/download/v2.3.1/hyperledger-fabric-darwin-amd64-2.3.1.tar.gz&quot;">https://github.com/hyperledger/fabric/releases/download/v2.3.1/hyperledger-fabric-darwin-amd64-2.3.1.tar.gz&quot;<i class="fas fa-external-link-alt"></i></a> | tar xz</p></li></ol><p>$ curl -L –retry 5 –retry-delay 3 “<a class="link" href="https://github.com/hyperledger/fabric-ca/releases/download/v1.4.9/hyperledger-fabric-ca-darwin-amd64-1.4.9.tar.gz&quot;">https://github.com/hyperledger/fabric-ca/releases/download/v1.4.9/hyperledger-fabric-ca-darwin-amd64-1.4.9.tar.gz&quot;<i class="fas fa-external-link-alt"></i></a> | tar xz</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"> 3. 或者自行编译[fabric](https:&#x2F;&#x2F;github.com&#x2F;hyperledger&#x2F;fabric.git)和[fabric-ca](https:&#x2F;&#x2F;github.com&#x2F;hyperledger&#x2F;fabric-ca.git)源码得到，需要go环境依赖</span><br><span class="line"> </span><br><span class="line">    &#96;&#96;&#96;shell</span><br><span class="line">    # 编译fabric</span><br><span class="line">    $ cd fabric</span><br><span class="line">$ make release</span><br><span class="line">    $ cd $GOPATH&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;release&#x2F;linux-amd64&#x2F;bin&#x2F;</span><br><span class="line"> </span><br><span class="line">    # 编译fabric-ca</span><br><span class="line">    $ cd fabric-ca</span><br><span class="line">    $ make fabric-ca-server</span><br><span class="line">    $ make fabric-ca-client</span><br><span class="line">$ cd bin</span><br></pre></td></tr></table></figure></li><li><p>解压后得到两个bin文件夹和一个config文件夹，合并bin文件夹后将两者放到fabric-sample中</p><ul><li>这些二进制文件将帮助您与测试网络进行交互</li></ul></li></ul></li></ul></blockquote><h1 id="sample测试"><a href="#sample测试" class="headerlink" title="sample测试"></a>sample测试</h1><h2 id="运行测试网络"><a href="#运行测试网络" class="headerlink" title="运行测试网络"></a>运行测试网络</h2><h3 id="普通网络"><a href="#普通网络" class="headerlink" title="普通网络"></a>普通网络</h3><p>运行脚本 <code>network.sh</code> 来启动测试网络，该脚本使用本地计算机上的Docker映像站立在Fabric网络上</p><ul><li>到目录 <code>fabric-samples/test-network</code> 下执行命令</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./network.sh up</span><br></pre></td></tr></table></figure><ul><li>启动网络</li><li>此命令创建一个结构网络，该结构网络由<strong>两个对等节点</strong>，<strong>一个订购节点</strong>组成。您在运行时不会创建任何渠道，如果命令成功完成，您将看到正在创建的节点的日志</li></ul><p>![截屏2021-03-09 下午10.13.09](fabric-Getting Start/截屏2021-03-09 下午10.13.09.png)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./network.sh down</span><br></pre></td></tr></table></figure><ul><li>从以前的任何运行中删除任何容器或工件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE                               COMMAND             CREATED              STATUS              PORTS                                            NAMES</span><br><span class="line">fcb443d2c66a   hyperledger/fabric-tools:latest     <span class="string">&quot;/bin/bash&quot;</span>         About a minute ago   Up About a minute                                                    cli</span><br><span class="line">bd07774d282d   hyperledger/fabric-orderer:latest   <span class="string">&quot;orderer&quot;</span>           About a minute ago   Up About a minute   0.0.0.0:7050-&gt;7050/tcp, 0.0.0.0:7053-&gt;7053/tcp   orderer.example.com</span><br><span class="line">5257b92a5b00   hyperledger/fabric-peer:latest      <span class="string">&quot;peer node start&quot;</span>   About a minute ago   Up About a minute   0.0.0.0:7051-&gt;7051/tcp                           peer0.org1.example.com</span><br><span class="line">8a8cd2ea75e4   hyperledger/fabric-peer:latest      <span class="string">&quot;peer node start&quot;</span>   About a minute ago   Up About a minute   7051/tcp, 0.0.0.0:9051-&gt;9051/tcp                 peer0.org2.example.com</span><br></pre></td></tr></table></figure><ul><li>列出计算机上运行的所有Docker容器<ul><li>网络中的每个对等方都必须属于一个组织。在测试网络中，每个组织各自运营一个对等方，<code>peer0.org1.example.com</code> 和 <code>peer0.org2.example.com</code>。</li><li>每个Fabric网络还包括订购服务，可以看到订购节点 <code>orderer.example.com</code>。</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./network.sh createChannel -c channelName</span></span><br></pre></td></tr></table></figure><ul><li>创建Channel，系统默认命名为 <code>mychannel</code> </li><li>channel名称限制<ul><li>仅包含小写ASCII字母数字，点“。”和破折号“-”</li><li>少于250个字符</li><li>以字母开头</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./network.sh deployCC -ccn basic -ccp ../asset-transfer-basic/chaincode-go -ccl go</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> deployCC = deploy chaincode</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -ccn <span class="built_in">set</span> chaincode name</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -ccp <span class="built_in">set</span> chaincode path</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -ccl <span class="built_in">set</span> chaincode language</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -c 指定部署链码的通道名称，默认在 mychannel 上部署</span></span><br></pre></td></tr></table></figure><ul><li>在channel上启动链码（此链码将在名为 <code>mychannel</code> 的通道上执行）</li><li>可以在 <code>fabric-sample</code> 的 <code>asset-transfer-basic</code> 文件夹中找到资产转移的示例代码</li><li>第一次部署链码的话，该脚本将安装链码依赖项</li></ul><hr><p><strong>报错</strong></p><ol><li><p>第一次部署时无法下载依赖</p><img src="/2021/03/14/fabric-Getting%20Start/截屏2021-03-15 上午10.56.46.png" alt="截屏2021-03-15 上午10.56.46" style="zoom:50%;"><ul><li><p>只需要执行两个命令更改GO为国内代理即可，再此执行将成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go env -w GOPROXY=https://goproxy.io,direct</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> go env -w GO111MODULE=on</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><ol start="2"><li><p>无法下载组建 InstallChaincode</p><img src="/2021/03/14/fabric-Getting%20Start/截屏2021-03-15 上午11.15.27.png" alt="截屏2021-03-15 上午11.15.27" style="zoom:50%;"><ul><li><p>网络问题，重启网络，再重新创建myChannel即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./network.sh down</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./network.sh up</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./network.sh createChannel</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./network.sh deployCC -ccn basic -ccp ../asset-transfer-basic/chaincode-go -ccl go</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><hr><p><strong>与网络互动，配置peer指令</strong></p><ul><li>均在 <code>test-network</code> 文件夹下执行</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将fabroc-sample/bin下的二进制文件添加到CLI路径中（）</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> PATH=<span class="variable">$&#123;PWD&#125;</span>/../bin:<span class="variable">$PATH</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置FABRIC_CFG_PATH指向fabric-sample中的core.yaml文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> FABRIC_CFG_PATH=<span class="variable">$&#123;PWD&#125;</span>/../config/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Environment variables <span class="keyword">for</span> Org1</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> CORE_PEER_TLS_ENABLED=<span class="literal">true</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> CORE_PEER_LOCALMSPID=<span class="string">&quot;Org1MSP&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> CORE_PEER_TLS_ROOTCERT_FILE=<span class="variable">$&#123;PWD&#125;</span>/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> CORE_PEER_MSPCONFIGPATH=<span class="variable">$&#123;PWD&#125;</span>/organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> CORE_PEER_ADDRESS=localhost:7051</span></span><br></pre></td></tr></table></figure><ul><li>该 <code>CORE_PEER_TLS_ROOTCERT_FILE</code> 和 <code>CORE_PEER_MSPCONFIGPATH</code> 环境变量指向的ORG1加密材料 <code>organizations</code> 文件夹。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> peer channel list</span></span><br></pre></td></tr></table></figure><ul><li>列出网络中所有的channel</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> peer chaincode invoke -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile <span class="string">&quot;<span class="variable">$&#123;PWD&#125;</span>/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem&quot;</span> -C mychannel -n basic --peerAddresses localhost:7051 --tlsRootCertFiles <span class="string">&quot;<span class="variable">$&#123;PWD&#125;</span>/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt&quot;</span> --peerAddresses localhost:9051 --tlsRootCertFiles <span class="string">&quot;<span class="variable">$&#123;PWD&#125;</span>/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt&quot;</span> -c <span class="string">&#x27;&#123;&quot;function&quot;:&quot;InitLedger&quot;,&quot;Args&quot;:[]&#125;&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 成功的日志信息</span></span><br><span class="line">2021-03-15 11:30:18.970 CST [chaincodeCmd] chaincodeInvokeOrQuery -&gt; INFO 001 Chaincode invoke successful. result: status:200 </span><br></pre></td></tr></table></figure><ul><li>使用资产初始化分类帐</li><li>成功后就可以使用CLI来查询分类账</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> peer chaincode query -C mychannel -n basic -c <span class="string">&#x27;&#123;&quot;Args&quot;:[&quot;GetAllAssets&quot;]&#125;&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 成功查询后的输出</span></span><br><span class="line">[</span><br><span class="line">&#123;&quot;ID&quot;:&quot;asset1&quot;,&quot;color&quot;:&quot;blue&quot;,&quot;size&quot;:5,&quot;owner&quot;:&quot;Tomoko&quot;,&quot;appraisedValue&quot;:300&#125;,</span><br><span class="line">  &#123;&quot;ID&quot;:&quot;asset2&quot;,&quot;color&quot;:&quot;red&quot;,&quot;size&quot;:5,&quot;owner&quot;:&quot;Brad&quot;,&quot;appraisedValue&quot;:400&#125;,</span><br><span class="line">&#123;&quot;ID&quot;:&quot;asset3&quot;,&quot;color&quot;:&quot;green&quot;,&quot;size&quot;:10,&quot;owner&quot;:&quot;Jin Soo&quot;,&quot;appraisedValue&quot;:500&#125;,</span><br><span class="line">&#123;&quot;ID&quot;:&quot;asset4&quot;,&quot;color&quot;:&quot;yellow&quot;,&quot;size&quot;:10,&quot;owner&quot;:&quot;Max&quot;,&quot;appraisedValue&quot;:600&#125;,</span><br><span class="line">&#123;&quot;ID&quot;:&quot;asset5&quot;,&quot;color&quot;:&quot;black&quot;,&quot;size&quot;:15,&quot;owner&quot;:&quot;Adriana&quot;,&quot;appraisedValue&quot;:700&#125;,</span><br><span class="line">&#123;&quot;ID&quot;:&quot;asset6&quot;,&quot;color&quot;:&quot;white&quot;,&quot;size&quot;:15,&quot;owner&quot;:&quot;Michel&quot;,&quot;appraisedValue&quot;:800&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>获取已添加到渠道分类帐中的资产的列表</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> peer chaincode invoke -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile <span class="string">&quot;<span class="variable">$&#123;PWD&#125;</span>/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem&quot;</span> -C mychannel -n basic --peerAddresses localhost:7051 --tlsRootCertFiles <span class="string">&quot;<span class="variable">$&#123;PWD&#125;</span>/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt&quot;</span> --peerAddresses localhost:9051 --tlsRootCertFiles <span class="string">&quot;<span class="variable">$&#123;PWD&#125;</span>/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt&quot;</span> -c <span class="string">&#x27;&#123;&quot;function&quot;:&quot;InitLedger&quot;,&quot;Args&quot;:[]&#125;&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 成功的日志信息</span></span><br><span class="line">2021-03-15 11:36:04.958 CST [chaincodeCmd] chaincodeInvokeOrQuery -&gt; INFO 001 Chaincode invoke successful. result: status:200 </span><br></pre></td></tr></table></figure><ul><li>当网络成员要转移或更改分类帐上的资产时，将调用链码。</li><li>此命令通过调用 <code>asset-transfer-basic</code> 链码来更改分类帐上资产的所有者</li></ul><p>调用链代码后，我们可以使用另一个查询来查看该调用如何更改了区块链分类账上的资产。由于我们已经查询过Org1对等体，因此我们可以借此机会查询Org2对等体上运行的链码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Environment variables <span class="keyword">for</span> Org2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> CORE_PEER_TLS_ENABLED=<span class="literal">true</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> CORE_PEER_LOCALMSPID=<span class="string">&quot;Org2MSP&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> CORE_PEER_TLS_ROOTCERT_FILE=<span class="variable">$&#123;PWD&#125;</span>/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> CORE_PEER_MSPCONFIGPATH=<span class="variable">$&#123;PWD&#125;</span>/organizations/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> CORE_PEER_ADDRESS=localhost:9051</span></span><br></pre></td></tr></table></figure><ul><li>设置环境变量以作为Org2进行操作</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> peer chaincode query -C mychannel -n basic -c <span class="string">&#x27;&#123;&quot;Args&quot;:[&quot;ReadAsset&quot;,&quot;asset6&quot;]&#125;&#x27;</span></span></span><br></pre></td></tr></table></figure><ul><li><p>查询运行在 mychannel 上的 <code>asset-transfer-basic</code> 链码 <code>peer0.org2.example.com</code></p></li><li><p>结果显示 <code>&quot;asset6&quot;</code> 已转移到Christopher：</p><img src="/2021/03/14/fabric-Getting%20Start/截屏2021-03-15 上午11.39.59.png" alt="截屏2021-03-15 上午11.39.59" style="zoom:50%;"></li></ul><h3 id="与证书颁发机构建立网络"><a href="#与证书颁发机构建立网络" class="headerlink" title="与证书颁发机构建立网络"></a>与证书颁发机构建立网络</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./network.sh up -ca</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> tree命令并不是默认安装的，如果没有该命令，先安装</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> brew install tree</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在 fabric-sample/test-network 下执行</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tree organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/</span></span><br></pre></td></tr></table></figure><ul><li><p>显示MSP文件夹的结构和配置文件：</p><img src="/2021/03/14/fabric-Getting%20Start/截屏2021-03-14 下午1.15.18.png" alt="截屏2021-03-14 下午1.15.18" style="zoom:50%;"></li></ul><h2 id="运行结构应用程序"><a href="#运行结构应用程序" class="headerlink" title="运行结构应用程序"></a>运行结构应用程序</h2><h3 id="资产转移"><a href="#资产转移" class="headerlink" title="资产转移"></a>资产转移</h3><p><code>asset-transfer-basic</code> 样本演示了如何使用资产初始化分类帐，查询那些资产，创建新资产，基于资产ID查询单个资产，更新现有资产以及将资产转移给新所有者。它涉及以下两个组件：</p><ol><li><p><strong>示例应用程序</strong>：调用区块链网络，调用以链码（智能合约）实现的交易。该应用程序位于以下<code>fabric-samples</code>目录中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asset-transfer-basic&#x2F;application-javascript</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p><strong>智能合约本身</strong>，实现涉及与分类账交互的交易。智能合约（链码）位于以下<code>fabric-samples</code>目录中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asset-transfer-basic&#x2F;chaincode-(javascript, java, go, typescript)</span><br></pre></td></tr></table></figure></li></ol><p>请注意，在本教程中，术语链码和智能合约可互换使用。在此示例中，我们将使用javascript链码。</p><p>主要步骤：</p><ol><li><p><strong>建立开发环境。</strong>我们的应用程序需要与之交互的网络，因此我们将为我们的智能合约和应用程序部署一个基本的网络。<img src="/2021/03/14/fabric-Getting%20Start/AppConceptsOverview.png" alt="AppConceptsOverview" style="zoom:25%;"></p></li><li><p><strong>探索样本智能合约。</strong> 我们将检查示例assetTransfer（javascript）智能合约，以了解其中的交易以及应用程序如何使用它们查询和更新分类账。</p></li><li><p><strong>通过示例应用程序与智能合约进行交互。</strong>我们的应用程序将使用assetTransfer智能合约在分类账上创建，查询和更新资产。我们将深入研究应用程序及其创建的交易的代码，包括使用资产初始化分类账，查询资产，查询一系列资产，创建新资产以及将资产转让给新所有者。</p></li></ol><h4 id="启动网络"><a href="#启动网络" class="headerlink" title="启动网络"></a>启动网络</h4><ul><li>根据运行测试网络的步骤</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> open /Applications/Docker.app  <span class="comment"># mac上启动docker desktop的方式</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> fabric-samples/test-network</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./network.sh down</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./network.sh up createChannel -c mychannel -ca</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./network.sh deployCC -ccn basic -ccp ../asset-transfer-basic/chaincode-javascript/ -ccl javascript</span></span><br></pre></td></tr></table></figure><h4 id="申请样本"><a href="#申请样本" class="headerlink" title="申请样本"></a>申请样本</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> PATH=<span class="variable">$&#123;PWD&#125;</span>/../bin:<span class="variable">$PATH</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> FABRIC_CFG_PATH=<span class="variable">$PWD</span>/../config/</span></span><br></pre></td></tr></table></figure><ul><li>设置peer指令环境变量</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> fabric-sample/asset-transfer-basic/application-javascript</span></span><br></pre></td></tr></table></figure><ul><li>打开一个新的终端，进入到示例代码文件中，</li><li>该目录包含使用Fabric SDK for Node.js开发的示例程序。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> node app.js</span></span><br></pre></td></tr></table></figure><ul><li><p>运行 npm 命令以安装应用程序依赖项。最多可能需要一分钟才能完成。</p></li><li><p>此过程将安装在的应用程序中定义的关键应用程序依赖项 <code>package.json</code>。其中最重要的是 <code>fabric-network</code> Node.js模块；它使应用程序能够使用身份，钱包和网关来连接到渠道，提交交易并等待通知</p></li><li><p>运行完成后将得到以下文件</p><img src="/2021/03/14/fabric-Getting%20Start/截屏2021-03-16 上午11.23.37.png" alt="截屏2021-03-16 上午11.23.37" style="zoom:50%;"></li></ul><h4 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h4><p><code>fabric-sample/asset-transfer-basic/application-javascript/app.js</code></p><ul><li>仅调用方法<ul><li>方法定义在 <code>fabric-sample/test-application/javascript/</code> 的 <code>CAUtil.js</code> 和 <code>AppUtil.js</code> 中</li></ul></li></ul><h5 id="app-js："><a href="#app-js：" class="headerlink" title="app.js："></a>app.js：</h5><p>当我们启动Fabric测试网络时，创建了一个管理员用户（字面上称为<code>admin</code>）作为证书颁发机构（CA）的<strong>注册商</strong>。</p><img src="/2021/03/14/fabric-Getting%20Start/code.png" alt="截屏2021-03-16 下午3.01.28" style="zoom:50%;"><ol><li>调用函数 <code>enrollAdmin()</code> 生成 admin 的私钥，公钥和X.509证书。<ul><li>此过程使用<strong>证书签名请求</strong>（CSR）-专用密钥和公用密钥首先在本地生成，然后将公用密钥发送到CA，CA返回编码的证书供应用程序使用。</li><li>这些凭证然后存储在 <code>application-javascript/wallet</code> 中，使我们能够充当CA的管理员。</li><li>可以在<code>wallet/admin.id</code> 文件中找到管理员的证书和私钥</li></ul></li></ol><blockquote><p><strong>注意</strong></p><p>如果您决定通过断开网络并重新启动来重新开始，则必须<code>wallet</code>在重新运行javascript应用程序之前删除该文件夹及其标识，否则会出现错误。发生这种情况的原因是，在关闭测试网络时，关闭了证书颁发机构及其数据库，但是原始钱包仍保留在application-javascript目录中，因此必须将其删除。当您重新运行示例javascript应用程序时，将生成一个新的钱包和凭据。</p></blockquote><ol start="2"><li>调用 <code>registerAndEnrollUser()</code> 来注册并加入一个应用程序用户 <code>appUser</code>，该用户将用于与区块链网络进行交互<ul><li>与管理员注册类似，此功能使用<strong>CSR</strong>来注册，注册 <code>appUser</code> 和存储其凭据以及<code>admin</code>钱包中的凭据。</li><li>现在，我们拥有两个独立用户的身份，<code>admin</code>并且<code>appUser</code>该身份可以由我们的应用程序使用</li></ul></li></ol><img src="/2021/03/14/fabric-Getting%20Start/截屏2021-03-16 下午3.20.50.png" alt="截屏2021-03-16 下午3.20.50" style="zoom:50%;"><ol start="3"><li><p>应用程序正在通过网关 gateway 使用 <code>chaincodeName</code> 和 <code>channelName</code> 名称来引用合约</p><ul><li><p>（本例是在 mychannel 中使用 asset-transfer-basic 合约）</p></li><li><p>当链码包包含多个智能合约时，可以在<a class="link" href="https://hyperledger.github.io/fabric-sdk-node/release-2.2/module-fabric-network.Network.html#getContract">getContract（）API<i class="fas fa-external-link-alt"></i></a>上指定链码包的名称和要定位的特定智能合约。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> contract = <span class="keyword">await</span> network.getContract(<span class="string">&#x27;chaincodeName&#x27;</span>, <span class="string">&#x27;smartContractName&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>asLocalhost</code> set <code>true</code> 告知它以localhost连接。在不将客户端与其他结构节点在同一网络上运行的部署中，该 <code>asLocalhost</code> 选项将设置为 <code>false</code>。</p></li></ul></li></ol><img src="/2021/03/14/fabric-Getting%20Start/截屏2021-03-16 下午3.20.58.png" alt="截屏2021-03-16 下午3.20.58" style="zoom:50%;"><ol start="4"><li><code>SubmitTransaction()</code> 函数用于调用chaincode的 <code>InitLedger</code> 函数，以使用一些样本数据填充分类帐。<ul><li>在幕后，<code>submitTransaction()</code> 函数将使用服务发现来为链码找到一组所需的认可对等体，在所需数目的对等体上调用链码，从这些对等体收集链码认可的结果，最后将事务提交给订购服务。</li><li>对等体在assets中指定，然后使用 <code>ctx.stub.putState(...)</code> 来验证（chaincode-javascript中）</li></ul></li></ol><img src="/2021/03/14/fabric-Getting%20Start/截屏2021-03-16 下午3.45.11.png" alt="截屏2021-03-16 下午3.45.11" style="zoom:50%;"><img src="/2021/03/14/fabric-Getting%20Start/截屏2021-03-16 下午3.35.33.png" alt="截屏2021-03-16 下午3.35.33" style="zoom:50%;"><ol start="5"><li></li></ol><blockquote><p>require(‘fabric-network’); 模块中，定义在文件 fabric-network/lib/transaction.js 中</p></blockquote><p><strong>evaluateTransaction()</strong></p><ul><li>代表了区块链网络中与智能合约最简单的交互之一。只是查询账本内容而已</li><li>它只是选择一个在连接配置文件中定义的对等体，然后将请求发送到该对等体，并在此对其进行评估。智能合约查询对等方账本副本上的资产，并将结果返回给应用程序。</li><li>这种交互不会导致分类账的更新。</li></ul><p><strong>submitTransaction()</strong></p><ul><li>比 <code>evaluateTransaction()</code> 复杂得多，是一个完整的共识流程（提交-背书-检验）</li><li>SDK不会与单个peer进行交互，而是根据chaincode的背书政策，向区块链网络中每个需要的组织对等方发送 <code>proposal</code>。这些对等方中的每一个都将使用该 <code>proposal</code> 执行所请求的智能合约，以生成交易响应，该交易响应将对其背书（签署）并返回到SDK。SDK将所有已背书的交易响应收集到一个交易中，然后将其提交给oderer。oderer将来自各种应用程序客户端的交易收集并排序为一个交易块。这些块被分发到网络中的每个对等点，在此对每个事务进行验证和提交。最后，通过事件通知SDK，使其可以将控制权返回给应用程序。</li></ul><h5 id="CAUtil-js"><a href="#CAUtil-js" class="headerlink" title="CAUtil.js"></a>CAUtil.js</h5><p><strong>enrollAdmin</strong></p><p><strong>registerAndEnrollUser</strong></p><ul><li></li></ul><h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><p><a class="link" href="https://www.jianshu.com/p/248530bf31b8">https://www.jianshu.com/p/248530bf31b8<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本部分主要设计fabric环境安装，已经 &lt;code&gt;fabric-sample&lt;/code&gt; 中 &lt;code&gt;test-network&lt;/</summary>
      
    
    
    
    <category term="Notebook" scheme="https://jieyang-wei.github.io/categories/Notebook/"/>
    
    <category term="Blockchain" scheme="https://jieyang-wei.github.io/categories/Notebook/Blockchain/"/>
    
    <category term="Fabric" scheme="https://jieyang-wei.github.io/categories/Notebook/Blockchain/Fabric/"/>
    
    
    <category term="fabric" scheme="https://jieyang-wei.github.io/tags/fabric/"/>
    
    <category term="blockchain" scheme="https://jieyang-wei.github.io/tags/blockchain/"/>
    
  </entry>
  
  <entry>
    <title>go</title>
    <link href="https://jieyang-wei.github.io/2021/03/10/go/"/>
    <id>https://jieyang-wei.github.io/2021/03/10/go/</id>
    <published>2021-03-10T04:24:29.000Z</published>
    <updated>2021-04-19T06:43:44.838Z</updated>
    
    <content type="html"><![CDATA[<h3 id><a href="#" class="headerlink" title></a></h3><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h2><ol><li>Mac下使用Homebrew安装</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew install go</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> go version</span></span><br><span class="line">go version go1.16 darwin/amd64</span><br></pre></td></tr></table></figure><ol start="2"><li>或者在官网下载安装文件</li></ol><p>安装包下载地址为：<a class="link" href="https://golang.org/dl/">https://golang.org/dl/<i class="fas fa-external-link-alt"></i></a></p><p>如果打不开可以使用这个地址：<a class="link" href="https://golang.google.cn/dl/">https://golang.google.cn/dl/<i class="fas fa-external-link-alt"></i></a></p><ol start="3"><li>解压下载文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tar -C /usr/<span class="built_in">local</span> -xzf go1.4.linux-amd64.tar.gz</span></span><br></pre></td></tr></table></figure><ul><li>Mac用户直接双击<code>.pkg</code>文件，安装目录为<code>/usr/local/go</code></li></ul><ol start="4"><li>安装完成后将 <code>/usr/local/go/bin</code> 目录添加至PATH环境变量：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/go/bin</span></span><br></pre></td></tr></table></figure><h2 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h2><p>Go采用的是UTF-8编码的文本文件存放源代码，理论上使用任何一款文本编辑器都可以做Go语言开发，这里推荐使用<code>VS Code</code>和<code>Goland</code>。 <code>VS Code</code>是微软开源的编辑器，而<code>Goland</code>是jetbrains出品的付费IDE。</p><ol><li><strong>GoLand</strong></li></ol><p>GoLand 是 Jetbrains 家族的 Go 语言 IDE，有 30 天的免费试用期。</p><p>安装也很简单访问 <a class="link" href="https://www.jetbrains.com/go/">Gogland 的下载页面<i class="fas fa-external-link-alt"></i></a>，根据你当期的系统环境三大平台（Mac、Linux、Windows）下载对应的软件。</p><ol start="2"><li><strong>LiteIDE</strong></li></ol><p>LiteIDE 是一款开源、跨平台的轻量级 Go 语言集成开发环境（IDE）。</p><p>支持的 操作系统</p><ul><li>Windows x86 (32-bit or 64-bit)</li><li>Linux x86 (32-bit or 64-bit)</li></ul><p>下载地址 ：<a class="link" href="http://sourceforge.net/projects/liteide/files/">http://sourceforge.net/projects/liteide/files/<i class="fas fa-external-link-alt"></i></a></p><p>源码地址 ：<a class="link" href="https://github.com/visualfc/liteide">https://github.com/visualfc/liteide<i class="fas fa-external-link-alt"></i></a></p><ol start="3"><li><strong>VS Code</strong>(本人使用)</li></ol><p>VS Code的<a class="link" href="https://code.visualstudio.com/Download">官方下载地址<i class="fas fa-external-link-alt"></i></a></p><p>安装Go插件</p><img src="/2021/03/10/go/截屏2021-03-10 下午1.56.48.png" alt="截屏2021-03-10 下午1.56.48" style="zoom:40%;"><ul><li><p>配置包管理</p><ol><li>进入项目根目录<code>$GOPATH/src</code>，运行命令<code>$ go mode init</code> 生成**<code>go.mod</code><strong>包管理文件，此时在vs code中点击右上角的三角形即可成功运行（</strong>推荐**）</li><li>或者手动执行以下命令来添加</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">go get -u -v github.com/nsf/gocode</span><br><span class="line">go get -u -v github.com/rogpeppe/godef</span><br><span class="line">go get -u -v github.com/golang/lint/golint</span><br><span class="line">go get -u -v github.com/lukehoban/go-find-references</span><br><span class="line">go get -u -v github.com/lukehoban/go-outline</span><br><span class="line">go get -u -v sourcegraph.com/sqs/goreturns</span><br><span class="line">go get -u -v golang.org/x/tools/cmd/gorename</span><br><span class="line">go get -u -v github.com/tpng/gopkgs</span><br><span class="line">go get -u -v github.com/newhook/go-symbols</span><br></pre></td></tr></table></figure></li></ul><ol start="4"><li><strong>Idea</strong></li></ol><p>在plugins中安装go插件</p><p>打开项目目录<code>$GOPATH/src</code></p><p>创建一个项目文件夹<code>hello</code>，并添加第一个程序main.go</p><p>右上角设置运行环境<code>edit configurations</code></p><p>根据红框更改配置</p><img src="/2021/03/10/go/截屏2021-03-10 下午3.41.22.png" alt="截屏2021-03-10 下午3.41.22" style="zoom:50%;"><p>最后在终端中进入上面设置的 <code>/Users/weijieyang/go/src</code> 目录，运行命令<code>$ go mode init</code> 生成**<code>go.mod</code>**包管理文件</p><p>进入idea，点击右上角的三角形即可成功运行</p><h2 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h2><p>go没有一个自己的包管理平台。社区里go的第三方包托管在各个git托管平台。需要用到包时通过go get 命令工具安装，但这个工具没有版本描述性文件，在go的世界里没有“package.json”这种文件。这个给我们带来直接的影响就是依赖放在外网，而且没有版本约束，这个月下的版本，可能下个月更新了。有道是“工欲善其事，必先利其器”，这个时候我们就需要一个依赖管理工具。<br>目前依赖工具有很多，如：glide、godep、gomod等。</p><ul><li><a class="link" href="https://github.com/tools/godep">godep<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" href="https://github.com/golang/dep">dep<i class="fas fa-external-link-alt"></i></a>（官方）</li></ul><blockquote><p>dep和godep是两个东西</p></blockquote><h3 id="dep"><a href="#dep" class="headerlink" title="dep"></a>dep</h3><h4 id="下载："><a href="#下载：" class="headerlink" title="下载："></a>下载：</h4><ul><li><p>Mac：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew install dep</span></span><br></pre></td></tr></table></figure><ul><li>该工具将会被下载到 <code>/usr/local/Cellar/dep/0.5.4</code> 中去</li></ul></li><li><p>Debian：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install go-dep</span></span><br></pre></td></tr></table></figure></li><li><p>Other：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl https://raw.githubusercontent.com/golang/dep/master/install.sh | sh</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p><code>dep version</code></p><ul><li>查看dep、golang等版本</li></ul><p><code>dep init</code></p><ul><li>初始化dep管理环境</li><li>将在目录下生成 <code>Gopkg.lock</code>、<code>Gopkg.toml</code> 和 <code>vendor</code><ul><li><strong>Gopkg.lock</strong>：是生成的文件，不要手工修改 Gopkg.lock 官方文档。</li><li><strong>Gopkg.toml</strong>：是依赖管理的核心文件，可以生成也可以手动修改，<ul><li>一般情况下Gopkg.toml里面只定义直接依赖项，而Gopkg.lock里面除了包含Gopkg.toml中的所有项之外，还包含传递依赖项。比如我们的项目依赖项目A， 而项目A又依赖B、C，那么只有A会包含在Gopkg.toml中，而A、B、C都会定义在Gopkg.lock中。所以Gopkg.lock定义了所有依赖的项目的详细信息（commit ID和packages），使得每次build我们自己的项目时，始终基于确定不变的依赖项。Gopkg.toml 官方文档。</li></ul></li><li><strong>vendor</strong>目录：golang1.5 以后依赖管理目录，这个目录的依赖代码是优先加载的，类似 node 的 node_module 目录。</li></ul></li></ul><p><code>dep ensure</code></p><ul><li>将在 <code>vendor</code> 文件夹和 <code>Gopkg.lock</code> 文件中安装最新版本代码的依赖。</li><li>相当于 node 中的 npm install，但并其功能更加复杂</li></ul><blockquote><p>注意：删除依赖只需要确保代码中没有使用，并再次执行 <code>dep ensure</code> 即可</p></blockquote><p><code>dep ensure -add</code></p><ul><li>添加一条依赖<ul><li> <code>dep ensure -add github.com/bitly/go-simplejson</code></li><li><code>dep ensure -add github.com/bitly/go-simplejson@=0.4.3</code><ul><li>这里 @= 参数指定的是 某个 tag</li></ul></li></ul></li><li>添加后一定记住执行 <code>dep ensure</code> 来同步</li></ul><p><code>dep ensure -update -v </code></p><ul><li>更新依赖</li><li>-v：是为了更好的查看执行过程，建议加上。</li></ul><p><code>dep status</code></p><ul><li>列出应用程序中使用的版本以及开发人员发布的最新版本</li></ul><h3 id="mod"><a href="#mod" class="headerlink" title="mod"></a>mod</h3><p>go 会自动查找代码中的包，下载依赖包，并且把具体的依赖关系和版本写入到go.mod和go.sum文件中。<br>查看go.mod，它会变成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module test</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">github.com&#x2F;gohouse&#x2F;gorose v1.0.5</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>使用Go的包管理方式，依赖的第三方包被下载到了 <code>$GOPATH/pkg/mod</code> 路径下。</li><li>格式：<ul><li><strong>module</strong>：指定包的名字（路径），一般使用相对<code>$GOPATH/src</code>的路径最为包名</li><li><strong>require：</strong>指定依赖项模块，前面是包名，后面 v1.11.1 是引用的版本号</li><li><strong>replace</strong>：可以替换依赖项模块，比如可以替代远程github为本地包</li><li><strong>exclude</strong>：可以忽略的依赖项模块</li></ul></li></ul><p><code>go mod init hello</code></p><ul><li>初始化当前文件夹为名为<code>hello</code>的模块，并且生成 <code>go.mod</code> 记录当前依赖包名及版本信息，由程序自动维护</li></ul><p><code>go mod tidy</code></p><ul><li>下载缺少的依赖项，删除不需要的依赖项，并生成 <code>go.sum</code> 文件</li></ul><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看环境变量</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> go env NAME</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置环境变量</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1.仅在当前命令窗口设置，退出后将编绘原来的设置</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> NAME=...</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.直接更改go env环境变量</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> go env -w GOPARTH=<span class="variable">$HOME</span>/go</span></span><br></pre></td></tr></table></figure><p>下图为本机环境变量：</p><img src="/2021/03/10/go/B73C0FB2855C12EA5F08CF4CBD86DFD5.png" alt="B73C0FB2855C12EA5F08CF4CBD86DFD5" style="zoom:50%;"><p><strong>GO111MODULE</strong></p><ul><li>GO111MODULE=<strong>off</strong><ul><li>go命令行将不会支持module功能，寻找依赖包的方式将会沿用旧版本那种通过vendor目录或者GOPATH模式来查找。</li></ul></li><li>GO111MODULE=<strong>on</strong><ul><li>go命令行会使用modules，而一点也不会去GOPATH目录下查找。</li><li>1.12后，无论在<code>$GOPATH/src</code>里还是在外面，都会使用go.mod 里 require的包</li></ul></li><li>GO111MODULE=<strong>auto</strong><ul><li>默认值，go命令行将会根据当前目录来决定是否启用module功能。</li><li>项目在 <code>$GOPATH/src</code> 里会使用 <code>$GOPATH/src</code> 的依赖包</li><li>在 <code>$GOPATH/src</code> 外，就使用go.mod 里 require的包</li></ul></li></ul><p><strong>GOROOT</strong></p><ul><li>go的安装路径</li><li>默认为 <code>/usr/local/Cellar/go/1.16/libexec</code></li></ul><p><strong>GOPATH</strong></p><ul><li><code>go install</code> /。<code>go get</code>和 go的工具等会用到 <code>GOPATH</code> 环境变量. </li><li><code>GOPATH</code> 是作为编译后二进制的存放目的地和import包时的搜索路径 (其实也是你的工作目录, 你可以在src下创建你自己的go源文件, 然后开始工作)。<ol><li><code>GOPATH</code> 之下主要包含三个目录: bin、pkg、src</li><li><strong>bin</strong>目录主要存放可执行文件; </li><li><strong>pkg</strong>目录存放编译好的库文件, 主要是*.a文件;</li><li><strong>src</strong>目录下主要存放go的源文件</li></ol></li><li>不要把 <code>GOPATH</code> 设置成go的安装路径，一般可以设置为 <code>$HOME/go</code></li></ul><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>在进行Go语言开发的时候，我们的代码总是会保存在<code>$GOPATH/src</code>目录下。在工程经过<code>go build</code>、<code>go install</code>或<code>go get</code>等指令后，会将下载的第三方包源代码文件放在<code>$GOPATH/src</code>目录下， 产生的二进制可执行文件放在 <code>$GOPATH/bin</code>目录下，生成的中间缓存文件会被保存在 <code>$GOPATH/pkg</code> 下。</p><p>如果我们使用版本管理工具（Version Control System，VCS。常用如Git）来管理我们的项目代码时，我们只需要添加<code>$GOPATH/src</code>目录的源代码即可。<code>bin</code> 和 <code>pkg</code> 目录的内容无需版本控制。</p><p><strong>个人开发者</strong></p><p>我们知道源代码都是存放在<code>GOPATH</code>的<code>src</code>目录下，那我们可以按照下图来组织我们的代码</p><img src="/2021/03/10/go/1300537-20190325205527275-638377643.png" alt="1300537-20190325205527275-638377643" style="zoom: 90%;"><p>目前流行的项目框架</p><ul><li><p>Go语言中也是通过包来组织代码文件，我们可以引用别人的包也可以发布自己的包，但是为了防止不同包的项目名冲突，我们通常使用<code>顶级域名</code>来作为包名的前缀，这样就不担心项目名冲突的问题了。</p></li><li><p>因为不是每个个人开发者都拥有自己的顶级域名，所以目前流行的方式是使用个人的<code>github用户名</code>来区分不同的包。</p></li><li><p>以后我们从github上下载别人包的时候，如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go get github.com/username/package</span></span><br><span class="line">import &quot;github.com/username/package&quot;</span><br></pre></td></tr></table></figure></li></ul><img src="/2021/03/10/go/1300537-20190325205546430-23281384.png" alt="1300537-20190325205546430-23281384" style="zoom:80%;"><p><strong>企业开发者</strong></p><img src="/2021/03/10/go/1300537-20190325205654857-1473178176.png" alt="1300537-20190325205654857-1473178176" style="zoom:40%;"><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;/h3&gt;&lt;h1 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h1&gt;&lt;h2 id=&quot;运行环境&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="Notebook" scheme="https://jieyang-wei.github.io/categories/Notebook/"/>
    
    <category term="Programming language" scheme="https://jieyang-wei.github.io/categories/Notebook/Programming-language/"/>
    
    
    <category term="编程语言" scheme="https://jieyang-wei.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="go" scheme="https://jieyang-wei.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>ssh证书登陆</title>
    <link href="https://jieyang-wei.github.io/2021/03/08/ssh%E8%AF%81%E4%B9%A6%E7%99%BB%E9%99%86/"/>
    <id>https://jieyang-wei.github.io/2021/03/08/ssh%E8%AF%81%E4%B9%A6%E7%99%BB%E9%99%86/</id>
    <published>2021-03-08T06:07:39.000Z</published>
    <updated>2021-04-19T06:44:38.477Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文基于ubuntu20.04 LST版本，通过在mac上使用VMware安装linux虚拟机实现。</p><h1 id="SSH证书登陆"><a href="#SSH证书登陆" class="headerlink" title="SSH证书登陆"></a>SSH证书登陆</h1><p>Secure Shell(SSH) 是由 IETF(The Internet Engineering Task Force) 制定的建立在应用层基础上的安全网络协议。它是专为远程登录会话(甚至可以用Windows远程登录Linux服务器进行文件互传)和其他网络服务提供安全性的协议，可有效弥补网络中的漏洞。通过SSH，可以把所有传输的数据进行加密，也能够防止DNS欺骗和IP欺骗。还有一个额外的好处就是传输的数据是经过压缩的，所以可以加快传输的速度。目前已经成为Linux系统的标准配置。（<a class="link" href="https://blog.csdn.net/li528405176/article/details/82810342">摘自百度<i class="fas fa-external-link-alt"></i></a>）</p><p>SSH外壳安全协议，是一种可以用来远程登陆操作系统的协议，包括使用<code>密码登陆</code>和<code>证书登陆</code>，本文着重讲解证书登陆的实现过程（但这里其实应该是密钥登陆，真正的证书CA登陆可自行去百度）</p><h2 id="密码登陆"><a href="#密码登陆" class="headerlink" title="密码登陆"></a>密码登陆</h2><p>使用操作系统所在ip地址和此操作系统下的<code>用户账号</code>和<code>用户密码</code>进行远程登陆，但这样是不安全的，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh username@ip</span></span><br><span class="line"> * -o StrictHostKeyChecking=no：降低安全级别</span><br><span class="line"> * -p 输入密码</span><br></pre></td></tr></table></figure><h2 id="密钥登陆"><a href="#密钥登陆" class="headerlink" title="密钥登陆"></a>密钥登陆</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li>将客户端生成的公钥上传到服务器的配置文件中，使服务端允许此设备链接</li><li>此时当拥有私钥的客户端进行密钥登陆时，将会通过算法匹配此设备锁包含的私钥是否与服务器端的公钥相匹配，以便来验证登录信息。</li><li>如果需要了解详细的算法（rsa）过程可自行百度</li></ul><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><h4 id="客户机"><a href="#客户机" class="headerlink" title="客户机"></a>客户机</h4><ol><li>生成本机的公私钥</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen -t rsa</span></span><br><span class="line"> * -t 指定密钥生成算法，一般均使用rsa</span><br></pre></td></tr></table></figure><p>上面的命令将会默认在当前用户的家目录<code>～</code>/<code>$HOME</code>（一般是<code>/home/username</code>）下生成一个隐藏文件夹<code>.ssh</code>，里面包括了两个密钥文件</p><ul><li><code>id_rsa</code>：私钥，保存在自己手里，不要让别人知道</li><li><code>id_rsa.pub</code>：公钥，一般提交给各个服务器，用来进行权限配置<img src="/2021/03/08/ssh%E8%AF%81%E4%B9%A6%E7%99%BB%E9%99%86/login.png" alt="在这里插入图片描述" style="zoom:50%;"></li><li>生成密钥时将会询问文件生成目录，默认为<code>/home/usernam/.ssh</code>，当然也可以在此处自己指定</li><li>之后会让用户设置<code>passphrase</code>，即密钥的密码；如果此处设置了密码，在之后的密钥远程登陆的过程将会需要输入密码；如果不需要密码直接登录即可（为了安全考虑，此处建议设置密码）</li></ul><ol start="2"><li>配置私钥选择路径<br>上面提到，每次登陆需要匹配服务器出提前配置的公钥和客户端的私钥，所以需要知道客户端私钥存放路径，此时有两种方法：</li></ol><ul><li>如果默认放在家目录下，路径固定，可以不用更改</li></ul><ol><li>在登陆时使用<code>-i</code>指定私钥文件绝对路径</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh -i ～/.ssh/id_rsa blue@&lt;ssh_server_ip&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>到<code>etc/ssh/ssh_config</code>文件下配置默认路径</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 其实默认id_rsa就已经加入私钥的路径了,这里只是示例而已</span></span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果有其他的私钥，还要再加入其他私钥的路径</span></span><br><span class="line">IdentityFile ~/.ssh/blue_rsa</span><br></pre></td></tr></table></figure><p>到此客户端的配置就完成了</p><h4 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h4><ol><li>配置允许登陆的客户端到文件<code>~/.ssh/authorized_keys</code>下<ul><li>当然你也可以直接复制粘贴到文件末尾</li></ul></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> scp ～/.ssh/id_ras.pub username@ip:~</span>        </span><br><span class="line"><span class="meta">#</span><span class="bash"> 将文件传到服务器上</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat id_rsa.pub &gt;&gt; ～/.ssh/authorized_keys</span>   </span><br><span class="line"><span class="meta">#</span><span class="bash"> 在服务器端将文件内容写入文件末尾</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /etc/init.d/ssh restart</span>                    </span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启ssh服务</span></span><br></pre></td></tr></table></figure><ol start="2"><li>进行登陆配置<code>/etc/ssh/ssh_config</code>（也可能是文件<code>/etc/ssh/sshd_config</code>）</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PermitRootLogin no</span><br><span class="line"><span class="meta">#</span><span class="bash"> 取消root管理员用户的登陆权限，使得客户端只能登陆到服务器允许的用户账号上</span></span><br><span class="line"></span><br><span class="line">RSAAuthentication yes  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 是否允许用户自行使用成对的密钥系统进行登入行为 version 2</span></span><br><span class="line">PubkeyAuthentication yes  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 是否允许用户自行使用成对的密钥系统进行登入行为</span></span><br><span class="line">AuthorizedKeysFile   %h/.ssh/authorized_keys</span><br><span class="line"><span class="meta">#</span><span class="bash"> 公钥数据路径</span></span><br><span class="line"></span><br><span class="line">PasswordAuthentication no</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在确认证书登陆成功后，再关闭密码登陆</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果直接关闭，可能因为证书登陆配置失败导致再也无法登陆到服务器上</span></span><br></pre></td></tr></table></figure><ol start="3"><li>使用场景</li></ol><p>当多人协同服务一个大项目时，为了方便管理每个人所拥有的权限，所产生的信息，以及服务器安全等，我们可以为每个人设置一个服务器用户，单独为此用户分配权限，之后将该员工的公钥配置到对应用户的家目录下。这样与此员工相关的信息均与该服务器用户相关联，当删除用户时，与员工相关的所有信息都将被删除，同时公钥被删除了也就取消了该员工的登陆权限。</p><h2 id="证书登陆-CA"><a href="#证书登陆-CA" class="headerlink" title="证书登陆 CA"></a>证书登陆 CA</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文基于ubuntu20.04 LST版本，通过在mac上使用VMware安装linux虚拟机实现。&lt;/p&gt;
&lt;h1 id=&quot;SSH证书登陆</summary>
      
    
    
    
    <category term="Course" scheme="https://jieyang-wei.github.io/categories/Course/"/>
    
    <category term="Practice" scheme="https://jieyang-wei.github.io/categories/Course/Practice/"/>
    
    
    <category term="密码学" scheme="https://jieyang-wei.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>fabric</title>
    <link href="https://jieyang-wei.github.io/2021/03/07/fabric/"/>
    <id>https://jieyang-wei.github.io/2021/03/07/fabric/</id>
    <published>2021-03-07T14:12:46.000Z</published>
    <updated>2021-04-19T06:43:25.744Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>由IBM贡献的超级账本框架。它是一个利用现有成熟的技术来组合而成的一个区块链技术的实现。它是一种允许可插拔实现各种功能的的模块化架构。它具有强大的容器技术，来承载各种主流语言来编写的智能合约。</li><li>Fabric 是一个 Python (2.5-2.7) 的库和命令行工具，用来提高基于 SSH 的应用部署和系统管理效率<ul><li>一个让你通过 <strong>命令行</strong> 执行 <strong>无参数 Python 函数</strong> 的工具；</li><li>一个让通过 SSH 执行 Shell 命令更加<strong>容易</strong> 、 <strong>更符合 Python 风格</strong> 的命令库（建立于一个更低层次的库）。</li></ul></li></ul><ul><li>fabric和比特币与以太坊的最大的区别在于其身份识别能力，<strong>fabric是权限区块链</strong>，而后两者是匿名的非权限区块链</li></ul><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><strong>基本结构</strong>：</p><ul><li><img src="/2021/03/07/fabric/截屏2021-03-04 下午4.52.42-4848273.png" alt="截屏2021-03-04 下午4.52.42" style="zoom:35%;"></li></ul><p><strong>资产 Assets</strong></p><ul><li>理解为任何具有货币价值的东西，它们都可以通过网络进行交易，无论是有形资产还是无形资产都属于资产，Hyperledger Fabric提供了使用链码交易修改资产的功能。</li><li>资产在Fabric中以<code>键-值对集合</code>的形式存在，在通道（Channel）中各本地账本可以对其状态提交变更</li><li>资产可以用<strong>二进制</strong>或<strong>JSON</strong>形式表示</li><li></li></ul><p><strong>账本 ledger</strong></p><ul><li>Hyperledger Fabric具有一个账本子系统，该子系统包括两个组件：<strong>世界状态</strong>和<strong>事务日志</strong>。</li><li>每个参与者都有一份账本到他们所属的每个Hyperledger Fabric网络的副本。</li><li>分类帐是世界状态数据库和事务日志历史记录的组合。</li></ul><p><strong>世界状态</strong></p><ul><li>版本号：从0开始，每当状态更新时版本号就递增。状态更新时会首先检查版本号，以确保当前状态的版本与背书时的版本一致（避免并发更新）</li><li>描述分类帐在给定时间点的状态。这是分类帐的<strong>数据库</strong>。</li></ul><p><strong>事务日志</strong></p><ul><li>记录所有导致当前世界状态值的事务；这是世界状态的<strong>更新历史</strong>。</li></ul><p><strong>分类账功能</strong></p><ul><li><p>分类帐是结构中<strong>所有状态转换</strong>的有序，防篡改记录。状态转换是参与方提交的链码调用（“交易”）的结果。每笔交易都会产生一组资产键值对，这些键值对会在创建，更新或删除时提交到分类账。</p></li><li><p>分类帐由一个<strong>区块链</strong>（“ chain”）和一个<strong>状态数据库</strong>组成，该区块链将不可变的顺序记录存储在块中，该状态数据库用于维护当前的结构状态。每个频道有一个分类帐。每个对等方都为其所属的每个通道维护一个分类帐的副本。</p></li></ul><p>Fabric分类帐的一些功能：</p><ul><li>使用基于键的查找，范围查询和组合键查询来查询和更新分类帐</li><li>使用丰富查询语言的只读查询（如果使用CouchDB作为状态数据库）</li><li>只读历史记录查询—查询密钥的分类帐历史记录，从而启用数据出处场景</li><li>事务包括以链码（读集）读取的键/值的版本和以链码（写集）写入的键/值的版本。</li><li>交易包含每个背书对等方的签名，并提交给订购服务</li><li>交易被分为几大块，并从订购服务“交付”到渠道上的对等方</li><li>对等方根据背书政策验证交易并执行政策</li><li>在附加块之前，执行版本检查，以确保自链码执行以来，已读取资产的状态未发生变化。</li><li>交易一旦经过验证并提交，便具有不变性</li><li>通道的分类帐包含一个配置块，用于定义策略，访问控制列表和其他相关信息</li><li>通道包含<a class="link" href="https://hyperledger-fabric.readthedocs.io/en/latest/glossary.html#msp">成员资格服务提供程序<i class="fas fa-external-link-alt"></i></a>实例，允许从不同的证书颁发机构派生加密材料</li></ul><h2 id="区块结构"><a href="#区块结构" class="headerlink" title="区块结构"></a>区块结构</h2><ol><li><p><strong>区块头</strong>：包含三个属性（<strong>区块号</strong>、<strong>当前区块哈希</strong>、<strong>前一个区块的哈希</strong>），当一个区块被创建时写入。</p></li><li><p><strong>区块数据</strong>：包含的是<strong>排序后的交易列表</strong>。当区块被ordering service创建时写入。</p></li><li><p><strong>区块元数据</strong>：包括区块的<strong>写入时间</strong>，以及<strong>区块写入者的证书</strong>、<strong>公钥</strong>和<strong>签名。</strong></p></li></ol><p><strong>状态</strong></p><ul><li>整个区块链的状态可以看作是一个 versioned KVS（带有版本的 key-value store，类似于git仓库），这些kv通过chaincode（智能合约）进行更新，它只提供了put和get方法，所有的状态变更都有日志记录。</li></ul><h2 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h2><p>在fabric中指的就是对<strong>链代码（即智能合约）的操作</strong>，交易分为两种</p><ol><li><p><strong>部署交易（deploy transaction）</strong>：</p><ul><li>指的是<strong>创建新的链代码</strong>（chaincode），并且用一个程序作为参数，当一个部署交易成功执行时，链代码就被安装到区块链上了。</li></ul></li><li><p><strong>调用交易（invoke transaction）</strong>：</p><ul><li><p>指的是<strong>运行链代码</strong>，链代码执行时可能会修改相应的状态并返回输出。下图是一个交易的详细结构：</p><img src="/2021/03/07/fabric/15873283-087e0d4d80b57ca1.png" alt="15873283-087e0d4d80b57ca1" style="zoom:70%;"><ul><li><strong>交易头 H4</strong>：包含交易的元数据，如<strong>链码名称、版本</strong>等</li><li><strong>交易签名 S4</strong>：包含由客户端应用程序创建的<strong>加密签名</strong>，作用是判断交易是否被篡改</li><li><strong>交易提案 P4</strong>：作用是对由应用程序提供给智能合约的输入参数进行编码。当智能合约运行时，提案<strong>负责将参数传递过去</strong></li><li><strong>交易响应 R4</strong>：是<strong>智能合约的输出</strong>，包含的是世界状态在交易前后的值，以读写集的形式展示。</li></ul></li></ul></li><li><p>其实还可能存在query transaction（v1版本加入）和cross-chaincode transaction（v1之后的版本会加入），此处不做讨论</p></li></ol><h3 id="交易流程"><a href="#交易流程" class="headerlink" title="交易流程"></a>交易流程</h3><p>前提假设是各节点已经提前颁发好证书，且已正常启动，并加入已经创建好的通道。此流程介绍的是在<strong>已经实例化了</strong>的链码通道上从发起一个<strong>调用交易到最终结账的全过程</strong>。</p><img src="/2021/03/07/fabric/截屏2021-03-14 上午10.43.57.png" alt="截屏2021-03-14 上午10.43.57" style="zoom:45%;"><ol><li><strong>提交交易提案</strong><ul><li>应用程序（客户端节点）构造好<strong>交易提案</strong>（交易提案中包含本次交易要调用的<strong>合约标识</strong>、<strong>合约方法</strong>和<strong>参数信息</strong>以及<strong>客户端签名</strong>等）请求后，根据背书策略选择背书节点（多个）执行交易提案并进行背书签名。</li><li>背书节点是链代码中背书策略指定的节点。正常情况下背书节点执行后的结果是一致的，只有背书节点对结果的签名不一样。</li></ul></li><li><strong>模拟执行提案并进行背书</strong><ul><li>背书节点在收到交易提案后会进行一些验证，验证通过后，<strong>背书节点会根据当前账本数据模拟执行链码中的业务逻辑并生成读写集（RwSet）。</strong></li><li>模拟执行时不会更新账本数据。<strong>然后背书节点对这些读写集进行签名生成提案响应（proposal response）</strong>，然后返回给应用程序。</li></ul></li><li><strong>收集交易的背书</strong>（返回模拟执行结果）<ul><li>应用程序收到proposal response后会对背书节点的签名进行验证<strong>（所有节点接收到任何消息时都需要先验证消息的合法性）。</strong>如果链码只进行账本查询操作，应用程序只需要检查查询响应，并不会将交易提交给排序服务节点。如果链码对账本进行了invoke操作，则需要提交交易给排序服务进行账本更新（提交前会判断背书策略是否满足）。</li></ul></li><li><strong>构造交易请求并发送给排序服务节点</strong><ul><li>应用程序接收到所有背书节点的签名后，<strong>根据背书签名调用SDK生成交易，并广播给排序服务节点。</strong>其中生成交易的过程很简单，只需要确认所有背书节点的执行结果完全一致，再将<strong>交易提案</strong>、<strong>提案响应</strong>和<strong>背书签名</strong>打包生成交易即可。</li></ul></li><li><strong>排序服务节点对交易进行排序并生成区块</strong><ul><li>排序服务节点接收到网络中所有通道发出的交易信息，读取交易信封获取通道名称，按各个通道上交易的接收<strong>时间顺序</strong>对交易信息进行排序（多通道隔离），生成区块。（在这个过程中，排序服务节点不会关心交易是否正确，只是负责排序和打包。交易的有效性在第7步进行验证）</li></ul></li><li><strong>排序服务节点广播区块给主节点</strong><ul><li>排序服务节点生成区块后会广播给通道上不同组织的<strong>主节点</strong>。</li></ul></li><li><strong>记账节点验证区块内容并写入到账本</strong><ul><li>所有的peer节点都是记账节点，记录的是节点已加入通道的账本数据。记账节点接收到的排序服务节点生成的区块后，会<strong>验证区块交易的有效性</strong>，然后提交到本地账本并产生一个生成区块的事件，监听区块事件的应用程序会进行后续的处理。（如果接收的是配置区块，则会更新缓存的配置信息）</li></ul></li><li><strong>主节点在组织内部同步最新的区块</strong><ul><li>如果交易是无效的，也会更新区块，但不会更新世界状态。（<strong>区块存储的是操作语句，而世界状态存储的是被处理的数据</strong>）</li></ul></li></ol><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>区块链的通信实体，是一个逻辑概念，不同类型的多个节点可以运行在同一个物理服务器上。</p><ol><li><p><strong>客户端节点 client</strong></p><ul><li>客户端必须连接到某一个<strong>peer节点</strong>或<strong>排序服务节点</strong>上才能与区块链网络进行通信。</li></ul><ul><li>客户端<strong>向背书节点</strong>（endorser）<strong>提交交易提案</strong>（transaction proposal），当收集到足够背书后，<strong>向排序服务节点广播交易提案</strong>，进行排序，生成区块。</li></ul></li><li><p><strong>排序服务节点 orderer</strong></p><ul><li>接收包含背书签名的交易，对未打包的交易进行排序生成区块，广播给peer节点。</li></ul><ul><li>排序服务提供的是<strong>原子广播</strong>，保证同一个链上的节点接收到相同的信息，并且有相同的逻辑顺序。</li></ul><hr><p>orderer特性：</p><ol><li><strong>一致性</strong>：经过orderer deliver的交易，seqno一定时，blob和prevhash都一样</li><li><strong>hash链的完整性</strong>：对于deliver(seqno, hash0, blob0)和deliver(seqno-1, hash1, blob1)，HASH(seqno-1, hash1, blob1) == hash0</li><li><strong>不会凭空创造交易</strong>：每一次deliver，都是由于一次boardcast产生的。</li><li><strong>不会缺失交易</strong>：如果一个deliver(seqno, hash, blob)已经发生，那么一定有deliver(seqno-1, hash0, blob0) … deliver(0, default-hash, blob)</li><li><strong>不会重复交易</strong>：如果产生了两次 boardcast(blob)，boardcast(blob1)，则deliver(seqno1, hash, blob1)和deliver(seqno, hash0, blob)中，seqno1==seqno，<br>hash==hash0，blob==blob1</li></ol><hr></li><li><p><strong>CA节点：</strong></p><ul><li>fabric1.0的证书颁发机构，由服务器和客户端组成。</li></ul><ul><li>CA节点接收客户端的注册申请，返回注册密码用于用户登录，以便获取身份证书。</li><li>区块链上的所有操作都需要验证用户身份。</li></ul></li><li><p><strong>普通节点 peer</strong>：peer节点根据所承担的角色又可以分为记账节点（committer）、背书节点（endorser）、主节点（leader）和锚节点（anchor）。</p><hr><ul><li><strong>记账节点 Committer</strong><ul><li>所有的peer节点都是记账节点（committer）</li><li>负责<strong>验证排序服务节点区块里的交易</strong>，<strong>维护状态和总账（Ledger）的副本。</strong></li><li>该节点会定期从<strong>orderer节点</strong>获取包含交易的区块，在对这些区块进行核发验证之后，会把这些区块加入到区块链中。</li><li>记账节点无法通过配置文件配置，<strong>需要在当前客户端或者命令行发起交易请求的时候手动指定相关的committer节点</strong>。</li><li>记账节点可以有多个。</li></ul></li><li><strong>背书节点 endorser</strong><ul><li>部分节点还会<strong>执行交易并对结果进行签名背书</strong>，充当背书节点（endorser）的角色。</li><li>背书节点是<strong>动态</strong>的角色，是与具体链码绑定的。每个链码在实例化的时候都会设置<strong>背书策略</strong>，指定哪些节点对交易背书后交易才是有效的。</li><li>并且<strong>只有应用程序向它发起交易背书请求的时候才是背书节点</strong>，其他时候都是普通的记账节点，只负责验证交易并记账。</li><li>背书节点也无法通过配置文件指定，而是<strong>由发起交易请求的客户端指定</strong>。</li><li>背书节点可以有多个。</li></ul></li><li><strong>锚节点 anchor</strong><ul><li>锚节点主要<strong>负责代表组织和其他组织进行信息交换。</strong>每个组织都有一个锚节点，锚节点对于组织来说非常重要，如果锚节点出现问题，当前组织就会与其他组织失去联系。</li><li>锚节点的配置信息是<strong>在configtxgen模块的配置文件configtx.yaml中配置</strong>的。</li><li>锚节点只能有一个。</li></ul></li><li><strong>主节点 leader</strong><ul><li>能<strong>与排序服务节点通信</strong>，<strong>负责从排序服务节点获取最新的区块并在组织内部同步。</strong></li><li>主节点在整个组织中只能有一个。</li></ul></li></ul><hr></li></ol><h2 id="数据设计"><a href="#数据设计" class="headerlink" title="数据设计"></a>数据设计</h2><p>分类账状态</p><p>状态键 state key</p><p>多种状态</p><p>使用DNS命名法则：org.papernet.paper</p><ul><li>逻辑状态：维护一个paper list，将发行交易结果产生的新文件放进去</li></ul><ul><li>物理状态：使用org.papernet.paper、Issuer和paper的特性串行形成key值<ul><li>org.papernet.MagnetoCorp0001 + value（properties）</li><li>使得状态从标量变成向量</li></ul></li></ul><h2 id="系统逻辑结构"><a href="#系统逻辑结构" class="headerlink" title="系统逻辑结构"></a>系统逻辑结构</h2><img src="/2021/03/07/fabric/15873283-70ae13534abcc893.png" alt="15873283-70ae13534abcc893" style="zoom:80%;"><h3 id="org"><a href="#org" class="headerlink" title="org"></a>org</h3><ul><li>fabric系统是通过组织来划分的<strong>，每个组织内都有承担不同功能的peer节点，同时每个组织都有自己对应的fabric-ca服务器，fabric系统中所有的组织共用一个orderer集群。</strong></li><li>fabric中的组织在现实世界中可以是一个公司、一个企业，或者一个协会。在fabric中，组织是承担着数据信用责任的区块链系统参与方。</li><li>在设计一个fabric系统时，第一步就是要确定系统的参与方，然后从这些参与者中选出组织（生成对应的组织编号、域名、证书等），然后再确认组织的管理方式。组织的管理方式是指组织在遇到问题时的协作方式（如新组织的加入）。</li></ul><h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><ul><li>fabric的数据存储结构被设计成<strong>多账本体系</strong>，每个账本在fabric中被称为channel。每个channel中都有一个完全独立的账本。同一个channel中的所有peer节点都保存一份相同的数据。</li><li>通道由成员（组织）、每个成员的锚节点、账本、链码应用程序和排序服务节点定义。<ul><li>基本上，一个链由1个通道+ 1个账本+ N个成员组成</li></ul></li><li>网络上的每个交易都是在一个通道上执行的，在该通道上，每一方都必须经过身份验证和授权才能在该通道上进行交易。加入通道的每一个peer都有其自己的身份，由成员服务提供者（MSP）提供。</li></ul><h3 id="chaincode"><a href="#chaincode" class="headerlink" title="chaincode"></a>chaincode</h3><ul><li>链代码是一个按照一定规范实现的应用程序，运行于容器中，chaincode可以被安装到peer上，应用程序（客户端）通过发起交易请求，endsorer peer执行chaincode并进行签名，经过orderer的验证后，下发到对应的channel中，对账本进行更新。</li></ul><h3 id="PKI"><a href="#PKI" class="headerlink" title="PKI"></a>PKI</h3><p>Public Key Infrastructure，公钥基础结构</p><ul><li><p>Internet技术的集合，这些技术在网络中提供安全的通信。注意是PKI将 <strong>s</strong> 放入 <strong>https</strong> 中的</p></li><li><p>一种遵循标准的利用公钥加密技术为电子商务的开展提供一套安全基础平台的技术和规范。</p></li><li><p>底层采用P2P网络和gRPC协议实现对<strong>分布式账本结构的连通</strong>。通过Gossip协议<strong>进行状态同步、数据分发和成员探测。</strong></p></li></ul><p>公钥基础结构（PKI）的元素。PKI由证书颁发机构组成，证书颁发机构向各方（例如，服务的用户，服务提供商）颁发数字证书，然后由他们使用它们在环境中交换的消息中对自己进行身份验证。CA的证书吊销列表（CRL）构成了不再有效的证书的参考。吊销证书的原因有很多。例如，由于与证书关联的加密专用材料已被暴露，因此证书可能被吊销。</p><p>尽管区块链网络不只是通信网络，但它依赖于PKI标准来确保各种网络参与者之间的<strong>安全通信</strong>，并确保对发布在区块链上的消息进行正确的身份验证。因此，重要的是要了解PKI的基础知识，然后理解MSP为何如此重要。</p><p>PKI有四个关键要素：</p><ul><li><strong>数字证书</strong>：最常见的证书类型是符合<a class="link" href="https://en.wikipedia.org/wiki/X.509">X.509标准<i class="fas fa-external-link-alt"></i></a>的证书，该证书允许在其结构中对参与方的标识详细信息进行编码。<ul><li>只要CA安全地保存某些密码信息（即其自己的<strong>专用签名密钥</strong>），任何阅读证书的人都可以确保有关证书所有人的信息未被篡改 - 它始终具有证书所有人的那些特定属性。</li><li>即可视证书为无法更改的数字身份证</li></ul></li><li><strong>公钥和私钥</strong>：份验证和消息完整性是安全通信中的重要概念</li><li><strong>证书颁发机构</strong>：为组织的参与者提供了可验证的数字身份提供了基础。<ul><li>CA的有两种形式：<strong>根CA</strong>和<strong>中间CA</strong>。</li><li>由于<strong>根CA</strong>（赛门铁克，Geotrust等）必须<strong>安全地</strong>向互联网用户<strong>分发</strong>数亿个证书，因此有必要将此过程<strong>分散到</strong>所谓的<strong>中间CA中</strong>。这些中间CA的证书由根CA或其他中间机构颁发，从而可以为链中任何CA颁发的任何证书建立“信任链”。</li><li>追溯到根CA的能力不仅可以扩展CA的功能，同时仍提供安全性-允许使用证书的组织放心地使用中间CA-它限制了根CA的暴露，如果受到损害，这将使根CA暴露危害整个信任链。另一方面，如果中级CA受到威胁，则风险会小得多。</li></ul></li><li><strong>证书吊销列表</strong>：只是CA已知由于某种原因而吊销的证书引用列表。CRL就像一张被盗信用卡的清单。</li></ul><h3 id="CA"><a href="#CA" class="headerlink" title="CA"></a>CA</h3><ol><li><strong>Enrollment CA</strong><ul><li>用于（通过称为“注册”的过程）生成组织管理员，该组织的MSP和任何节点的证书仅为该组织所拥有。</li><li>此CA还将为任何其他用户生成证书。由于其在“注册”身份中的作用，因此有时将CA称为“注册CA”或“证书CA”。</li></ul></li></ol><ul><li>另一个CA生成用于保护传输层安全性（TLS）上的通信的证书。因此，该CA通常被称为“ TLS CA”。</li></ul><ol start="2"><li><strong>TLS CA</strong><ul><li>用于保护传输层安全性（TLS）上的通信的证书</li><li>将这些TLS证书附加到操作中，以防止“中间人”攻击。请注意，TLS CA仅用于为节点颁发证书，并且在该活动完成后可以将其关闭。</li><li>用户可以选择使用一种方式（仅客户端）TLS以及两种方式（服务器和客户端）TLS，后者也称为“相互TLS”。</li><li>由于应在部署“注册” CA（确定此CA的配置的YAML文件具有用于启用TLS的字段）之前确定指定网络将使用TLS（建议），因此，应首先部署TLS CA，在引导注册CA时使用TLS CA的证书。这个TLS证书也会在为用户和节点连接到注册CA注册身份时被 <code>fabric-ca client</code> 使用</li></ul></li></ol><h3 id="MSP"><a href="#MSP" class="headerlink" title="MSP"></a>MSP</h3><p>Membership Service Provider</p><ul><li>负责联盟链成员的证书管理，<strong>它定义了哪些RCA以及ICA在链里是可信任的</strong>，包括<strong>定义了channel上的合作者。</strong></li><li>每个组织都有自己的证书管理（CA）及MSP，CA给每个peer颁发证书，MSP授权，赋予相应权限策略。</li><li>对于peer和client来说，对于交易的结果和交易本身，都需要进行授权</li><li>Peer ，applications，end users, administrators orders 必须拥有CA和MSP才能访问链网。</li></ul><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>Hyperledger Fabric 项目中，目前可以支持的状态数据库有两种：</p><ol><li><p>LevelDB：LevelDB 是嵌入在 Peer 中的默认键值对（key-value）状态数据库。</p></li><li><p>CouchDB：CouchDB 是一种可选的替代 levelDB 的状态数据库。与 LevelDB 键值存储一样，CouchDB 不仅可以根据 key 进行相应的查询，<strong>还可以根据不同的应用场景需求实现复杂查询。</strong></p></li></ol><h1 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h1><p>fabric的底层主要由四种服务构成，分别是：身份服务、策略服务、区块链服务、智能合约服务。在这些基础服务之上，通过一些API、SDK、CLI为上层业务应用提供一些可以编程的接口服务。 </p><p><img src="/2021/03/07/fabric/20180523213138295.png" alt="20180523213138295"></p><h2 id="身份服务"><a href="#身份服务" class="headerlink" title="身份服务"></a>身份服务</h2><p>首先明确一点，fabric和比特币与以太坊的最大的区别在于其身份识别能力，<strong>fabric是权限区块链</strong>，而后两者是匿名的非权限区块链。明确这一点后，fabric的身份识别主要表现在fabric的账本中的各类事件个交易中，参与者和对象都具有明确的身份信息。这些信息主要包括参与者的组织、验证者、交易者，账本中的资产和智能合约，以及系统组件包括网络和服务器、运行环境等等这些信息。验证者在fabric网络建立的时候就可以确定参加交易的权限级别。 </p><p><a class="link" href="https://tech.lock-in.cn/news/a74a120208ac49c0a457e54e9efed4bb">参考: https://tech.lock-in.cn/news/a74a120208ac49c0a457e54e9efed4bb<i class="fas fa-external-link-alt"></i></a></p><ol><li><strong>cacerts</strong></li></ol><p>文件夹放置的用于身份识别的ca根证书, 回忆下基础篇的会员身份使用PKI等数字签名技术用于识别客户身份(这里特指可连接到peer节点的客户端)。</p><p>一个组织对一个根CA(不考虑中间CA情况), 所以组织org1下的peer0和peer1实际配置的是<strong>同一个</strong> <code>ca.org1.example.com-cert.pem</code>， 所以这个文件夹应该放的是对应组织的CA根证书</p><ol start="2"><li><strong>config.yaml</strong></li></ol><p>主要配置的可采访的组织单元，也就是说X.509 PEM证书里面的OU(组织单元)要么是client或者peer才能采访当前节点。 </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">NodeOUs:</span></span><br><span class="line">  <span class="attr">Enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">ClientOUIdentifier:</span></span><br><span class="line">    <span class="attr">Certificate:</span> <span class="string">cacerts/ca.org1.example.com-cert.pem</span></span><br><span class="line">    <span class="attr">OrganizationalUnitIdentifier:</span> <span class="string">client</span></span><br><span class="line">  <span class="attr">PeerOUIdentifier:</span></span><br><span class="line">    <span class="attr">Certificate:</span> <span class="string">cacerts/ca.org1.example.com-cert.pem</span></span><br><span class="line">    <span class="attr">OrganizationalUnitIdentifier:</span> <span class="string">peer</span></span><br></pre></td></tr></table></figure><ul><li>对于这里的<strong>Certification</strong>配置也有一些疑惑, cacerts文件夹使用根CA证书确定了连接客户身份，这里的config.yaml算是第二层过滤吧, 每个不同类型的组织单元<strong>OUIdentifier</strong>的<strong>Certificate</strong>应该不能对应其它的CA根证书，应该只能是同一个CA根证书或者不同的中间CA证书。</li><li><strong>OU=client</strong>的证书实际上后面会看到admincerts是OU=client, org1下的<br><strong><a class="link" href="mailto:&#85;&#115;&#101;&#x72;&#49;&#64;&#111;&#x72;&#103;&#x31;&#46;&#x65;&#x78;&#97;&#x6d;&#x70;&#x6c;&#x65;&#46;&#99;&#111;&#109;">&#85;&#115;&#101;&#x72;&#49;&#64;&#111;&#x72;&#103;&#x31;&#46;&#x65;&#x78;&#97;&#x6d;&#x70;&#x6c;&#x65;&#46;&#99;&#111;&#109;<i class="fas fa-external-link-alt"></i></a></strong>用户也是OU=client, 貌似外部接入peer节点的用户都归到OU=client. </li><li>OU=peer的证书暂时只有peer节点自身的证书，例如peer0,peer1都是<code>OU=peer /mnt/sda3/fabric-samples/first-network/crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/msp/signcerts/peer0.org1.example.com-cert.pem </code></li><li>实际OU=client和peer的有什么不同权限，笔者估计是peer是标记不同peer节点的调用， 或者是在链码安装的时候可以指定不同的OU</li><li>config.yaml的配置是可选的, 它是通过crypto-config.yaml下org设置了 <code>EnableNodeOUs: true</code> 才默认会生成MSP模板。</li></ul><ol start="3"><li><strong>keystore</strong></li></ol><p>存放的peer0节点的私钥，可以用于数字签名。 </p><ol start="4"><li><strong>signcerts</strong></li></ol><p>存放的是peer0被ca.org1.example.com签名的证书。注意到蓝色部分, OU=peer</p><ol start="5"><li><strong>tlscacerts</strong></li></ol><p>如果peer0启用了TLS保证安全和校验，就必须指定tlscacerts证书了，一般使用与cacerts不同的ca证书会安全些。 证书内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Certificate:</span></span><br><span class="line">    <span class="attr">Data:</span></span><br><span class="line">        <span class="attr">Version:</span> <span class="number">3</span> <span class="string">(0x2)</span></span><br><span class="line">        <span class="attr">Serial Number:</span></span><br><span class="line">            <span class="string">7a:fa:31:77:69:bb:28:fc:b9:3d:81:98:7b:f3:83:64</span></span><br><span class="line">    <span class="attr">Signature Algorithm:</span> <span class="string">ecdsa-with-SHA256</span></span><br><span class="line">        <span class="attr">Issuer:</span> <span class="string">C=US,</span> <span class="string">ST=California,</span> <span class="string">L=San</span> <span class="string">Francisco,</span> <span class="string">O=org1.example.com,</span> <span class="string">CN=tlsca.org1.example.com</span></span><br><span class="line">        <span class="string">Validity</span></span><br><span class="line">            <span class="attr">Not Before:</span> <span class="string">Sep</span> <span class="number">29</span> <span class="number">02</span><span class="string">:27:16</span> <span class="number">2018 </span><span class="string">GMT</span></span><br><span class="line">            <span class="attr">Not After :</span> <span class="string">Sep</span> <span class="number">26</span> <span class="number">02</span><span class="string">:27:16</span> <span class="number">2028 </span><span class="string">GMT</span></span><br><span class="line">        <span class="attr">Subject:</span> <span class="string">C=US,</span> <span class="string">ST=California,</span> <span class="string">L=San</span> <span class="string">Francisco,</span> <span class="string">O=org1.example.com,</span> <span class="string">CN=tlsca.org1.example.com</span></span><br><span class="line">        <span class="attr">Subject Public Key Info:</span></span><br><span class="line">            <span class="attr">Public Key Algorithm:</span> <span class="string">id-ecPublicKey</span></span><br><span class="line">                <span class="attr">Public-Key:</span> <span class="string">(256</span> <span class="string">bit)</span></span><br><span class="line">                <span class="attr">pub:</span> </span><br><span class="line">                    <span class="attr">04:92:79:62:41:43:06:7d:30:65:ef:2c:ae:87:8e:</span></span><br><span class="line">                    <span class="attr">41:f6:12:27:f0:9f:a0:c1:3d:f1:03:3d:ee:e7:45:</span></span><br><span class="line">                    <span class="attr">87:58:72:f7:a0:24:85:d8:3d:01:42:d2:01:15:fc:</span></span><br><span class="line">                    <span class="attr">e1:8a:d8:6b:56:0c:25:e2:98:8d:09:fb:0e:a5:65:</span></span><br><span class="line">                    <span class="string">ea:4a:ec:a0:06</span></span><br><span class="line">                <span class="attr">ASN1 OID:</span> <span class="string">prime256v1</span></span><br><span class="line">                <span class="attr">NIST CURVE:</span> <span class="string">P-256</span></span><br><span class="line">        <span class="attr">X509v3 extensions:</span></span><br><span class="line">            <span class="attr">X509v3 Key Usage:</span> <span class="string">critical</span></span><br><span class="line">                <span class="string">Digital</span> <span class="string">Signature,</span> <span class="string">Key</span> <span class="string">Encipherment,</span> <span class="string">Certificate</span> <span class="string">Sign,</span> <span class="string">CRL</span> <span class="string">Sign</span></span><br><span class="line">            <span class="attr">X509v3 Extended Key Usage:</span> </span><br><span class="line">                <span class="string">Any</span> <span class="string">Extended</span> <span class="string">Key</span> <span class="string">Usage</span></span><br><span class="line">            <span class="attr">X509v3 Basic Constraints:</span> <span class="string">critical</span></span><br><span class="line">                <span class="string">CA:TRUE</span></span><br><span class="line">            <span class="attr">X509v3 Subject Key Identifier:</span> </span><br><span class="line">                <span class="number">25</span><span class="string">:41:EA:7D:4B:4F:14:0B:13:6D:E1:EE:09:AA:00:A6:90:66:B4:2B:2F:90:6B:DF:E2:EF:D6:59:AE:17:40:4B</span></span><br><span class="line">    <span class="attr">Signature Algorithm:</span> <span class="string">ecdsa-with-SHA256</span></span><br><span class="line">         <span class="attr">30:45:02:21:00:cd:3b:23:ed:fb:2b:de:bf:64:87:f0:af:f6:</span></span><br><span class="line">         <span class="attr">0a:02:5f:26:83:ff:32:08:58:16:23:ba:30:36:b5:ee:aa:c9:</span></span><br><span class="line">         <span class="attr">55:02:20:4b:40:a8:89:c7:2d:0c:8f:c0:b6:34:9a:72:f0:47:</span></span><br><span class="line">         <span class="string">0e:66:8a:85:7b:d6:51:d6:1f:75:1e:e6:03:40:95:09:c9</span></span><br></pre></td></tr></table></figure><ul><li>参考peer-base.yaml是开启了TLS的: <code>CORE_PEER_TLS_ENABLED=true</code></li></ul><ol start="6"><li><strong>admincerts</strong></li></ol><p>这里存放的是整个组织org1的管理员证书, 和<br><code>/mnt/sda3/fabric-samples/first-network/crypto-config/peerOrganizations/org1.example.com/users/Admin@org1.example.com</code>下的签名证书是一致的， peer1.org1.example.com节点也是如此。</p><ul><li>就是说执行 <code>cryptogen generate —config=./crypto-config.yaml</code> 默认就是让org1下的所有peer都有相同的admin.</li><li>如果peer0和peer1的<strong>admincerts</strong>不一样，应该会有问题,第二个问题我们会查看下创世块的具体内容，里面指定的是组织的admin而不会有节点的admin。</li><li>话说这个admin的权限就比较大了，可以把peer节点加入到channel, 可以安装和实例化chaincode。BYFN里面容器里面执行的peer命令实际对应的都是admin的msp.</li></ul><p>组织管理员证书的内容, OU=client</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Certificate:</span></span><br><span class="line">    <span class="attr">Data:</span></span><br><span class="line">        <span class="attr">Version:</span> <span class="number">3</span> <span class="string">(0x2)</span></span><br><span class="line">        <span class="attr">Serial Number:</span></span><br><span class="line">            <span class="number">48</span><span class="string">:15:46:a1:6c:25:63:98:c7:e9:c5:26:b8:67:f9:53</span></span><br><span class="line">    <span class="attr">Signature Algorithm:</span> <span class="string">ecdsa-with-SHA256</span></span><br><span class="line">        <span class="attr">Issuer:</span> <span class="string">C=US,</span> <span class="string">ST=California,</span> <span class="string">L=San</span> <span class="string">Francisco,</span> <span class="string">O=org1.example.com,</span> <span class="string">CN=ca.org1.example.com</span></span><br><span class="line">        <span class="string">Validity</span></span><br><span class="line">            <span class="attr">Not Before:</span> <span class="string">Sep</span> <span class="number">29</span> <span class="number">02</span><span class="string">:27:16</span> <span class="number">2018 </span><span class="string">GMT</span></span><br><span class="line">            <span class="attr">Not After :</span> <span class="string">Sep</span> <span class="number">26</span> <span class="number">02</span><span class="string">:27:16</span> <span class="number">2028 </span><span class="string">GMT</span></span><br><span class="line">        <span class="attr">Subject:</span> <span class="string">C=US,</span> <span class="string">ST=California,</span> <span class="string">L=San</span> <span class="string">Francisco,</span> <span class="string">OU=client,</span> <span class="string">CN=Admin@org1.example.com</span></span><br><span class="line">        <span class="attr">Subject Public Key Info:</span></span><br><span class="line">            <span class="attr">Public Key Algorithm:</span> <span class="string">id-ecPublicKey</span></span><br><span class="line">                <span class="attr">Public-Key:</span> <span class="string">(256</span> <span class="string">bit)</span></span><br><span class="line">                <span class="attr">pub:</span> </span><br><span class="line">                    <span class="attr">04:59:01:48:99:af:c8:30:17:e2:5a:b4:ee:5a:1c:</span></span><br><span class="line">                    <span class="attr">c6:79:a7:c5:3a:14:20:d1:a0:39:de:13:5e:99:c6:</span></span><br><span class="line">                    <span class="attr">d1:4e:9c:cd:63:fb:73:96:9f:b4:48:60:4f:8e:72:</span></span><br><span class="line">                    <span class="attr">10:ee:54:19:33:5f:dc:29:e2:94:39:b3:4e:f2:d3:</span></span><br><span class="line">                    <span class="string">cd:1f:3d:0a:54</span></span><br><span class="line">                <span class="attr">ASN1 OID:</span> <span class="string">prime256v1</span></span><br><span class="line">                <span class="attr">NIST CURVE:</span> <span class="string">P-256</span></span><br><span class="line">        <span class="attr">X509v3 extensions:</span></span><br><span class="line">            <span class="attr">X509v3 Key Usage:</span> <span class="string">critical</span></span><br><span class="line">                <span class="string">Digital</span> <span class="string">Signature</span></span><br><span class="line">            <span class="attr">X509v3 Basic Constraints:</span> <span class="string">critical</span></span><br><span class="line">                <span class="string">CA:FALSE</span></span><br><span class="line">            <span class="attr">X509v3 Authority Key Identifier:</span> </span><br><span class="line">                <span class="string">keyid:F3:40:31:60:A2:2B:B9:CB:B5:FD:10:24:E1:BA:65:D9:8D:2C:E4:E1:AB:51:FB:55:6B:17:35:E1:11:CF:6E:82</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">Signature Algorithm:</span> <span class="string">ecdsa-with-SHA256</span></span><br><span class="line">         <span class="attr">30:44:02:20:0c:be:41:5b:58:1e:df:7e:78:5d:77:00:44:c7:</span></span><br><span class="line">         <span class="attr">a1:c8:2f:e1:6b:bb:8a:ac:b2:26:aa:ab:35:f6:f5:4b:66:6d:</span></span><br><span class="line">         <span class="attr">02:20:46:b7:32:c2:4f:a1:d0:89:20:32:42:35:50:80:8e:9e:</span></span><br><span class="line">         <span class="string">ba:66:d6:b2:6b:55:1f:e0:b5:5f:2c:04:be:b0:6c:1e</span></span><br></pre></td></tr></table></figure><blockquote><p>PEER作为接入点, 主要也是靠本地的MSP去识别用户身份，判断用户是否是所信任的CA颁发证书， 再结合组织单元等确定用户是否可采访节点。</p></blockquote><h2 id="策略服务"><a href="#策略服务" class="headerlink" title="策略服务"></a>策略服务</h2><p>策略是Fabric工作方式的基础，因为策略允许将与请求相关联的身份（或一组身份）与与满足请求所需的资源相关联的策略进行检查。</p><ul><li>背书策略用于确定交易是否已得到适当背书。</li><li>通道配置中定义的策略以及访问控制都称为修改策略，并且在通道配置本身中定义。</li></ul><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><ol><li><strong>Signature策略</strong></li></ol><p>表明需要得到那些特定用户的签名才能采用</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Policies:</span></span><br><span class="line">  <span class="attr">MyPolicy:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">Signature</span></span><br><span class="line">    <span class="attr">Rule:</span> <span class="string">&quot;OR(&#x27;Org1.peer&#x27;, &#x27;Org2.peer&#x27;)&quot;</span></span><br></pre></td></tr></table></figure><ul><li>一个名叫 <code>MyPolicy</code> 的策略。只能通过具有“ Org1的对等方”或“ Org2的对等方”角色的身份签名来满足所命名的策略</li><li>签名政策支持任意组合 <code>AND</code>，<code>OR</code> 以及 <code>NOutOf</code><ul><li>允许极其强大的规则建设：“组织A的管理员和其他两名管理员，或20组织的管理员11”。</li></ul></li></ul><ol start="2"><li><strong>ImplicitMeta策略</strong></li></ol><p><code>ImplicitMeta</code> 策略聚合配置层次结构中更深层次的策略结果，这些策略最终由<strong>签名策略</strong>定义。</p><ul><li><p>他们支持默认规则，比如“组织中大多数管理员”。</p></li><li><p>这些策略使用的语法和 <code>Signature</code> 策略不同但是依旧很简单： <code>&lt;ALL|ANY|MAJORITY&gt; &lt;sub_policy&gt;</code> 。比如： <code>ANY</code> <code>Readers</code> 或者 <code>MAJORITY</code> <code>Admins</code> 。</p><blockquote><p>注意<strong>默认策略</strong>配置中：</p><ul><li><code>Admins</code> 具有操作角色。指定仅管理员（或管理员的某些子集）有权访问资源的策略往往是针对网络的敏感或可操作方面（例如，实例化通道上的链码）。</li><li><code>Writers</code> 能够提交账本更新（例如交易），但没有管理权限。</li><li><code>Readers</code> 拥有被动角色。他们可以访问信息，但没有权利提交账本更新，也不能执行管理任务。</li><li>这些默认策略可以被<strong>添加</strong>，<strong>编辑</strong>或<strong>补充</strong>，例如通过新的 <code>peer</code> 和 <code>client</code> 角色（如果您有 <code>NodeOU</code> 支持）。</li></ul></blockquote></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Policies:</span></span><br><span class="line">  <span class="attr">AnotherPolicy:</span></span><br><span class="line">    <span class="attr">Type:</span> <span class="string">ImplicitMeta</span></span><br><span class="line">    <span class="attr">Rule:</span> <span class="string">&quot;MAJORITY Admins&quot;</span></span><br></pre></td></tr></table></figure><ul><li>名为 <code>AnotherPolicy</code> 的策略，表明可以通过 <code>MAJORITY Admins</code>（大多数管理员同意）的方式来满足</li><li>其中 <code>Admins</code> 是通过 <code>Signature</code> 策略来满足的。</li></ul><h3 id="背书策略"><a href="#背书策略" class="headerlink" title="背书策略"></a>背书策略</h3><h2 id="区块链服务"><a href="#区块链服务" class="headerlink" title="区块链服务"></a>区块链服务</h2><h2 id="智能合约服务"><a href="#智能合约服务" class="headerlink" title="智能合约服务"></a>智能合约服务</h2><h1 id="系统链码"><a href="#系统链码" class="headerlink" title="系统链码"></a>系统链码</h1><p>链码中定义的智能合约为一群区块链组织共同认可的业务流程编码了领域相关规则。然而，链码还可以定义低级别程序代码，这些代码符合无关于领域的<em>系统</em>交互，但与业务流程的智能合约无关。</p><p>以下是不同类型的系统链码及其相关缩写：</p><ul><li><strong>_lifecycle</strong>：在所有 Peer 节点上运行，它负责管理节点上的链码安装、批准组织的链码定义、将链码定义提交到通道上。<ul><li>你可以在<a class="link" href="https://hyperledger-fabric.readthedocs.io/zh_CN/release-1.4/chaincode4noah.html#chaincode-lifecycle">这里<i class="fas fa-external-link-alt"></i></a>阅读更多关于 <code>_lifecycle</code> 如何实现 Fabric 链码生命周期的内容。</li></ul></li><li><strong>生命周期系统链码（LSCC）</strong>：负责为1.x版本的 Fabric 管理链码生命周期。<ul><li>该版本的生命周期要求在通道上实例化或升级链码。你可以阅读更多关于LSCC如何实现这一<a class="link" href="https://hyperledger-fabric.readthedocs.io/zh_CN/release-1.4/chaincode4noah.html#chaincode-lifecycle">过程<i class="fas fa-external-link-alt"></i></a>。</li><li>如果你的 V1_4_x 或更低版本设有通道应用程序的功能，那么你也可以使用LSCC来管理链码。</li></ul></li><li><strong>配置系统链码（CSCC）</strong>：在所有 Peer 节点上运行，以处理通道配置的变化，比如策略更新。<ul><li>你可以在<a class="link" href="https://hyperledger-fabric.readthedocs.io/zh_CN/release-1.4/configtx.html#configuration-updates">这里<i class="fas fa-external-link-alt"></i></a>阅读更多 CSCC 实现的内容。</li></ul></li><li><strong>查询系统链码（QSCC）</strong>：在所有 Peer 节点上运行，以提供账本 API（应用程序编码接口），其中包括区块查询、交易查询等。<ul><li>你可以在交易场景<a class="link" href="https://hyperledger-fabric.readthedocs.io/zh_CN/release-1.4/developapps/transactioncontext.html">主题<i class="fas fa-external-link-alt"></i></a>中查阅更多这些账本 API 的信息。</li></ul></li><li><strong>背书系统链码（ESCC）</strong>：在背书节点上运行，对一个交易响应进行密码签名。<ul><li>你可以在<a class="link" href="https://hyperledger-fabric.readthedocs.io/zh_CN/release-1.4/peers/peers.html#phase-1-proposal">这里<i class="fas fa-external-link-alt"></i></a>阅读更多 ESCC 实现的内容。</li></ul></li><li><strong>验证系统链码（VSCC）</strong>验证一个交易，包括检查背书策略和读写集版本。<ul><li>你可以在<a class="link" href="https://hyperledger-fabric.readthedocs.io/zh_CN/release-1.4/peers/peers.html#phase-3-validation">这里<i class="fas fa-external-link-alt"></i></a>阅读更多 LSCC 实现的内容。</li></ul></li></ul><h1 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h1><ul><li><strong>smart contract</strong>：智能合约，定义业务对象的不同状态，并控制在这些不同状态之间移动对象的流程。<ul><li>智能合约之所以重要，是因为它们使架构师和智能合约开发人员能够定义关键业务流程和数据，这些关键业务流程和数据是在区块链网络中进行协作的不同组织之间共享的。</li></ul></li></ul><ul><li><strong>chaincode：</strong> 链码，Fabric的<strong>智能合约</strong>写在链码里并在区块链外部应用程序要和账本发生交易的时候被外部应用程序调用。<ul><li>在大多数情况下，链码只和账本的数据库组件（<strong>世界状态</strong>）交互，而不和交易日志交互。</li></ul></li></ul><blockquote><p><strong>链码与智能合约的区别：</strong></p><ul><li><strong>链码</strong> - chaincode：是一种用于部署代码到 Hyperledger Fabric 区块链网络中的<strong>通用容器</strong>。链码中定义一个或多个相关联的智能合约。每个智能合约在链码中有一个唯一的标识名。应用程序通过合约名称去访问链码容器内的指定的智能合约<ul><li>通常在构造类时分配名称，如果没有明确指明合约名，则会分配一个默认的名字–类名。建议使用<strong>显式的 DNS 样式</strong>命名方法，对组织清晰、有意义的名称有帮助；</li><li>例如：peer0.org1.example.com</li></ul></li><li><strong>智能合约</strong> - contract：是一种<strong>高级编程抽象</strong>的例子，可以在链码容器中定义智能合约。当一个链码被安装和实例化时，则链码内所有的智能合约对于相关联的通道（Channel）来说都是可用的</li></ul></blockquote><ul><li><strong>账本</strong>：Fabric有一个账本子系统包含两个组件：<strong>世界状态和交易日志</strong>。每一个参与者有一份他们参与的每个Fabric网络的账本的副本。<ul><li>世界状态组件描述了一个给定时间点的账本状态。它是账本的数据库，存储的是<strong>账本当前值</strong>。</li><li>交易日志组件记录所有导致世界状态当前值的交易。<strong>它是世界状态的更新历史</strong>。这样，账本就是世界状态数据库和交易日志历史的组合体。</li></ul></li></ul><h1 id="共识机制"><a href="#共识机制" class="headerlink" title="共识机制"></a>共识机制</h1><p>Fabric区块链的网络节点本质上是<strong>互相复制的状态机</strong>，节点之间需要保持相同的账本状态。为了实现分布式节点的一致性，各个节点需要<strong>通过共识过程，对账本状态的变化达成一致性的认同。</strong></p><p><strong>共识过程</strong></p><img src="/2021/03/07/fabric/15873283-02a9f2f1bb4d0bfd.png" alt="15873283-02a9f2f1bb4d0bfd" style="zoom:55%;"><ol><li><strong>背书（endorsement）阶段</strong><ul><li><strong>背书节点</strong>对客户端发来的交易提案进行<strong>合法性校验</strong>，然后模拟执行链码得到交易结果，最后根据设定的背书逻辑判断是否支持该交易提案。如果背书逻辑决定支持交易提案，会把交易提案签名后发回给客户端。</li><li>客户端通常需要根据链码的<strong>背书策略</strong>，向一个或者多个成员的背书节点发出背书请求。背书策略会定义需要哪些节点背书交易才有效，例如需要5个成员的背书节点中至少3个同意；或者某个特殊身份的成员支持等。</li><li>客户端只有在收集<strong>足够多</strong>的背书节点的交易提案签名，交易才能被视为有效。</li></ul></li><li><strong>排序（ordering）阶段</strong><ul><li>由<strong>排序服务节点对</strong>交易进行排序，确定交易之间的时序关系。排序服务把一段时间内收到的交易进行排序，然后把排序后的批量交易<strong>打包成数据块</strong>（区块），再把区块<strong>广播</strong>给通道中的成员。</li><li>采用<strong>排序共识</strong>方式，各个成员收到的是一组发生顺序相同的交易，从而保证了所有节点的<strong>数据一致性。</strong>目前，Hyperledger Fabric有三种交易排序算法：Solo、Kafka、SBFT。<ol><li><strong>Solo</strong>：只有一个排序服务节点负责接收交易信息并排序，是最简单的一种排序算法，一般用于开发测试环境中。Solo共识模式属于<strong>中心化的处理</strong>方式，<strong>不支持</strong>拜占庭容错。</li><li><strong>Kafka</strong>：Kafka是Apache的一个开源项目，主要提供分布式的消息处理／分发服务，每个Kafka集群由多个服务节点组成。Hyperledger Fabric利用Kafka对交易信息进行排序处理，提供高吞吐、低延时的处理能力，并且在集群内部<strong>支持节点故障容错，但不支持拜占庭容错。</strong></li><li><strong>SBFT</strong>：简单拜占庭算法，<strong>支持拜占庭容错的可靠排序算法，包括容忍节点故障以及一定数量的恶意节点。</strong></li><li>排序服务是共识机制中重要的一环，所有交易都要通过排序服务的排序才可以达成全网共识，因此排序服务要避免成为网络上的性能瓶颈。</li></ol></li></ul></li><li><strong>校验（Validation）阶段</strong><ul><li>节点对排序后的交易进行一系列的检验，包括<strong>交易数据的完整性</strong>检查、是否<strong>重复交易</strong>、背书签名<strong>是否符合背书策略</strong>的要求、交易的<strong>读写集是否符合MVCC</strong>（Multiversion Concurrency Control，多版本并发控制）的校验等。</li><li>当交易通过了所有校验后，将被标注为合法并写入账本中。因为所有的确认节点都按照相同的顺序检验交易，并且把合法的交易依次写入账本中，因此不同确认节点的状态能够始终保持一致。</li></ul></li></ol><h2 id="solo"><a href="#solo" class="headerlink" title="solo"></a>solo</h2><h2 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a>kafka</h2><p>Kafka共识模块是可以用于生产环境的，它可以支持崩溃容错， 但无法对抗恶意攻击。</p><ul><li>多个排序节点通过Kafka实现<strong>同步</strong>， 而Kafka本身并不是排序节点，它只是将排序节点通过流连接起来</li></ul><p>Kafka本质上是一个消息处理系统，它使用的是经典的<strong>发布-订阅模型</strong>。消息的消费者订阅特定的主题，以便收到新消息的通知，生产者则负责消息的发布。</p><p>在fabric中的<strong>运行逻辑</strong>：</p><ul><li>对于每一条链，都有一个对应的分区</li><li>每个链对应一个单一的分区主题</li><li>排序节点负责将来自特定链的交易（通过广播RPC接收）中继到对应的分区</li><li>排序节点可以读取分区并获得在所有排序节点间达成一致的排序交易列表</li><li>一个链中的交易是定时分批处理的，也就是说当一个新的批次的第一个交易进来时，开始计时</li><li>当交易达到最大数量时或超时后进行批次切分，生成新的区块</li><li>定时交易是另一个交易，由上面描述的定时器生成</li><li>每个排序节点为每个链维护一个本地日志，生成的区块保存在本地账本中</li><li>交易区块通过分发RPC返回客户端</li><li>当发生崩溃时，可以利用不同的排序节点分发区块，因为所有的排序节点都维护有本地日志</li></ul><h3 id="崩溃容错"><a href="#崩溃容错" class="headerlink" title="崩溃容错"></a>崩溃容错</h3><p><strong>崩溃容错机制</strong>：通过在多个Kafka代理之间<strong>复制分区</strong>来实现的。因此如果一个代理由于软件或硬件故障挂掉，数据也不会丢失。</p><p><strong>领导-跟随机制</strong>：领导者持有分区， 跟随者则进行分区的复制。当领导者挂掉后，会有某个跟随者转变为新的领导者。</p><p><strong>注意</strong>：虽然在Hyperledger Fabric中Kafka被称为共识（Consensus），但是其核心是交易排序服务以及额外的崩溃容错能力。</p><h3 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h3><p>zookeeper是一个分布式key-value存储库，通常用于存储元数据及集群机制的实现。</p><p>zookeeper 允许服务（Kafka代理）的客户端订阅变化并获得实时通知。这就是代理如何确定应当使用哪个分区领导者的原因。</p><p>zookeeper有超强的故障容错能力，因此Kafka的运行严重依赖于它。</p><p>在zookeeper中存储的元数据包括：</p><ul><li>消费者分组在每个分区的读取偏移量</li><li>访问控制清单，用于访问授权与限制</li><li>生产者及消费者配额，每秒最多消息数量</li><li>分区领导者及健康信息</li></ul><h2 id="raft"><a href="#raft" class="headerlink" title="raft"></a>raft</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;由IBM贡献的超级账本框架。它是一个利用现有成熟的技术来组合而成的一个区块链技术的实现。它是一种允许可插拔实现各种功能的的模块化</summary>
      
    
    
    
    <category term="Notebook" scheme="https://jieyang-wei.github.io/categories/Notebook/"/>
    
    <category term="Blockchain" scheme="https://jieyang-wei.github.io/categories/Notebook/Blockchain/"/>
    
    <category term="Fabric" scheme="https://jieyang-wei.github.io/categories/Notebook/Blockchain/Fabric/"/>
    
    
    <category term="fabric" scheme="https://jieyang-wei.github.io/tags/fabric/"/>
    
    <category term="blockchain" scheme="https://jieyang-wei.github.io/tags/blockchain/"/>
    
  </entry>
  
  <entry>
    <title>区块链应用</title>
    <link href="https://jieyang-wei.github.io/2021/03/04/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8/"/>
    <id>https://jieyang-wei.github.io/2021/03/04/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8/</id>
    <published>2021-03-04T06:48:09.000Z</published>
    <updated>2021-04-19T06:41:54.364Z</updated>
    
    <content type="html"><![CDATA[<h1 id="crypto-currency，加密货币"><a href="#crypto-currency，加密货币" class="headerlink" title="crypto-currency，加密货币"></a>crypto-currency，加密货币</h1><ul><li><p>区块链是一种数据结构，而比特币和以太坊都是使用区块链这种数据结构实现的应用</p></li><li><p><a class="link" href="https://bitcoin.org/bitcoin.pdf">比特币白皮书<i class="fas fa-external-link-alt"></i></a></p></li><li><p><a class="link" href="https://www.cnblogs.com/coderzjz/p/13788649.html">别人好的笔记<i class="fas fa-external-link-alt"></i></a></p></li></ul><h1 id="比特币-BTC"><a href="#比特币-BTC" class="headerlink" title="比特币 BTC"></a>比特币 BTC</h1><p><strong>前提：</strong>大部分算力掌握在诚实的矿工手里</p><h2 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h2><h3 id="1-crypto-graphic-hash-function"><a href="#1-crypto-graphic-hash-function" class="headerlink" title="1. crypto graphic hash function"></a>1. crypto graphic hash function</h3><p>特性：</p><ol><li><p>collision resistance：抗碰撞性</p></li><li><p>hiding：x可以算出H(x)，但H(x)不能反推出x，即这个hash函数不会泄露x</p><ul><li><p>需要满足，不然可以通过蛮力求解</p><ol><li><p>输入空间大</p></li><li><p>均匀分布</p></li></ol></li><li><p>digital commitment / digital equivalent of a sealed envelope：密封预测结果</p></li></ul></li><li><p>puzzle friendly：H(x)是事先不可预测的</p></li></ol><p>H(block header) &lt;= target 目标域值（nBits：目标域值编码）</p><p>proof of work POW，工作证明</p><p>difficult to solve, but easy to verify</p><h3 id="2-签名"><a href="#2-签名" class="headerlink" title="2. 签名"></a><strong>2. 签名</strong></h3><p>账户 - public key, private key</p><ul><li>来源于非对称加密：asymmetric encryption algorithm</li><li>最早期是对称加密，symmetric encryption algorithm，但这样密钥分发是一个问题，所以有了公私钥</li></ul><p>a good source of randomness：使得生成的公钥相同的几率微乎其微</p><p><strong>SHA-256</strong>（Secure Hash Algorithm）</p><ul><li><a class="link" href="https://blog.csdn.net/u011583927/article/details/80905740">原理简介<i class="fas fa-external-link-alt"></i></a></li><li>和md5加密的效果一样，但是SHA-256更加的安全</li><li>都只能算是签名，加密算法是既能加密也能解密的算法，而签名就仅仅是起到校验和的作用</li></ul><hr><p>Mac, Linux hash命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> md5 file.txt    <span class="comment"># md5校验和</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> shasum -a 1 /tmp/hello.txt      <span class="comment"># SHA-1校验和</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> shasum -a 256 /tmp/hello.txt    <span class="comment"># SHA-256校验和</span></span></span><br><span class="line"><span class="meta"> #</span><span class="bash"> -a --algorithm</span></span><br></pre></td></tr></table></figure><img src="/2021/03/04/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8/截屏2020-12-27 上午10.44.14.png" alt="截屏2020-12-27 上午10.44.png" style="zoom:60%;"> <hr><h2 id="BTC-数据结构"><a href="#BTC-数据结构" class="headerlink" title="BTC 数据结构"></a>BTC 数据结构</h2><blockquote><p>区块链仅仅是一个<strong>数据结构</strong>，BTC是使用区块链这种数据结构实现的应用</p></blockquote><h3 id="hash-point"><a href="#hash-point" class="headerlink" title="hash point"></a>hash point</h3><ul><li>无环链表都可以用 hash point 代替普通的point</li></ul><ol><li>区块链</li></ol><p><img src="/2021/03/04/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8/IMG_0230-7744726.jpg" alt="IMG_0230"></p><ul><li><p>block chain is a linked list using hash pointers：用hash point 代替普通的指针</p><ul><li><p>genesis block：创世区块            most recent blcok：最近产生的区块      </p><p>H( )：hash point</p></li><li><p>tamper-evident log：最后一个hash值就能检查整个链表是否被修改过</p></li></ul></li></ul><blockquote><p>Merkle tree 不是区块链的信息存储结构，而是BTC使用过程中用到的数据结构，在节点验证交易正确性时，使用到的一个结构而已</p></blockquote><ol start="2"><li>Merkle tree<ul><li>与binary tree的区别<ol><li>用hash point代替普通的指针</li><li>只要记录<code>root hash</code>，就能检测对整棵树的修改</li></ol></li><li>block header：只保存<code>root hash</code>，</li><li>block body：保存所有的交易信息<code>tx</code>等</li><li>作用：<ul><li>提供<code>merkle proof</code></li></ul></li></ul></li></ol><blockquote><p><img src="/2021/03/04/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8/IMG_231E499E57D8-1.jpeg" alt="IMG_231E499E57D8-1"></p><ul><li><strong>proof of membership</strong>：轻节点想知道黄色交易是否在<code>merkle tree</code>上，只有一个<code>root hash</code>(在<code>block header</code>里面)</li></ul><ol><li>轻节点向某个全节点发出证明请求，请求一个能证明黄色交易包括在<code>merkle tree</code>里面的一个<code>merkle proof</code></li><li>全节点收到请求，会将图中红色的三个<code>hash值</code>发送给这个轻节点</li><li><strong>从下往上</strong>：轻节点会算出黄色交易的hash值绿1，绿1和红1一起算出hash值绿2，绿2和红2算出绿3，绿3和红3一起算出<code>root hash</code></li><li>轻节点比较这个算出来的<code>root hash</code>和<code>block header</code>的hash值</li></ol><blockquote><p><strong>注意</strong>：我们只能验证绿色的部分，不能验证红色部分的hash值</p></blockquote><blockquote><ul><li>如果考虑通过调整红色的部分，使得被篡改后的绿色的部分算出来hash不变，是不实际的</li><li>因为<code>Collision resistance</code>性质，这样的操作相当于人为的制造hash碰撞</li></ul></blockquote><ul><li><strong>proof of non-memership</strong>：轻节点想证明某个交易不存在</li></ul><ol><li></li></ol></blockquote><h2 id="数字货币"><a href="#数字货币" class="headerlink" title="数字货币"></a>数字货币</h2><ul><li>使用公私钥，非对成加密算法<ol><li>Double spending attack，双花攻击 - 花两次攻击：数字货币本质上是一个文件，带签名的数字货币可以复制</li></ol></li><li>每个数字货币上带编号（防范DSA，但是是中心化的）<ul><li>bank维护一个数据库，每个编号的数字货币在谁手里</li><li>每次验证数字货币的签名和编号，这个货币有没有发过，被谁花过</li></ul></li></ul><p><strong>BTC安全性</strong></p><ol><li><strong>密码学</strong>：别人没有私钥，不能伪造签名<ul><li>前提：系统中拥有大多数算力的矿工是好的，是遵守协议的，不会接受没有合法签名的交易</li></ul></li><li><strong>共识机制</strong>：</li></ol><h3 id="BTC解决去中心化的数字货币发行问题"><a href="#BTC解决去中心化的数字货币发行问题" class="headerlink" title="BTC解决去中心化的数字货币发行问题"></a>BTC解决去中心化的数字货币发行问题</h3><ul><li><img src="/2021/03/04/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8/IMG_9CCCEC7F3445-1.jpeg" alt="IMG_9CCCEC7F3445-1"><ul><li>交易中A的公钥表明是钱是哪儿来的，但是要将A和他的公钥联系在一起，不然E可以用自己的公钥冒充A的，再用自己的私钥签名<ul><li><strong>coinbase tx</strong>：需要验证A-&gt;B的钱的前一个交易（金币来源）中A的公钥，即金币来源的输出脚本，和交易中提供的A的公钥，即交易的输入脚本拼在一起合成一个程序，看能不能顺利执行</li></ul></li></ul></li></ul><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><h5 id="区块结构"><a href="#区块结构" class="headerlink" title="区块结构"></a>区块结构</h5><img src="/2021/03/04/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8/IMG_9EF94BC347FE-1.jpeg" alt="IMG_9EF94BC347FE-1" style="zoom:70%;"> <ul><li><strong>Block Header</strong><ul><li>区块信息：<ul><li>version：比特币版本</li><li>时间戳等</li></ul></li><li>hash of previous block header：指向前一个区块的指针（只算header的hash）<ul><li>创世区块的<code>previous hash</code>为0</li></ul></li><li>merkle root hash：整棵merkle tree的根hash值<ul><li>保证了<code>transaction list</code>是无法被篡改的</li></ul></li><li>nonce：随机数，256bits<ul><li>target：挖矿难度目标域值</li></ul></li></ul></li><li><strong>Block Body</strong><ul><li>transaction list</li><li>只存交易信息</li></ul></li></ul><h5 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h5><ul><li>full node（fully validating node，全节点）：</li><li>light node（light weight node，轻节点）：<ul><li>一般无法验证交易的合法性，只是利用区块链的信息做一个查询</li></ul></li></ul><h4 id="Consensus-in-BitCoin，比特币共识"><a href="#Consensus-in-BitCoin，比特币共识" class="headerlink" title="Consensus in BitCoin，比特币共识"></a>Consensus in BitCoin，比特币共识</h4><p>distributed consensus，分布式共识</p><ul><li>impossibility result：<ul><li>FLP：在一个异步的系统里（asynchronous），网络时延没有上线，哪怕系统中只要有一个用户是faulty的，都没有办法达成共识</li><li>CAP Theorem：以下三个性质中，最多满足两种<ul><li>一致性Consistency、可用性Availability、分区容错性Partition tolerance</li></ul></li></ul></li></ul><p>membership</p><p>hyperledger</p><p>联盟链 - fabric</p><p>sybil attacl，女巫攻击：找一个超级计算机，不停的产生用户节点，当总数超过一半时，就得到了这个链的控制权</p><ul><li>coinbase transaction：<ul><li>coinbase域：可以在里面写东西，永久保存，但只有获得记账权的节点才能使用</li><li>通过算例投票 puzzle friendly</li><li>hash rate</li><li>nonce</li></ul></li></ul><p>mining - 挖矿：比特币争夺记账权</p><ul><li>digital gold</li><li>miner</li></ul><h4 id="BTC系统实现"><a href="#BTC系统实现" class="headerlink" title="BTC系统实现"></a>BTC系统实现</h4><h5 id="transaction-based-ledger，基于交易的账本模式"><a href="#transaction-based-ledger，基于交易的账本模式" class="headerlink" title="transaction-based ledger，基于交易的账本模式"></a>transaction-based ledger，基于交易的账本模式</h5><ul><li>每个交易需要说清楚，币是从哪儿来的，它没有账户的概念</li></ul><p>全节点维护一个数据结构：</p><ul><li><p>UTXO，unspent Transaction Output：还没有被花掉的交易的输出集合</p><img src="/2021/03/04/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8/IMG_1019233284AC-1 .jpeg" alt="IMG_1019233284AC-1" style="zoom:50%;"><ul><li><strong>包括</strong> 2个数据就能定位UTXO的输出：<ol><li>产生这个输出的交易的hash 值</li><li>这个输出是交易中的第几个输出</li></ol></li><li><strong>作用</strong>：检测Double Spending<ul><li>total inputs = total outputs：i可以略大于o，中间的<code>transaction fee</code>可能给了拥有记账权的区块</li><li>transaction fee：大约只有零点零几个币</li></ul></li></ul></li></ul><p>account-based ledger，基于账户的模式</p><ul><li>系统需要显示的记录每个账户有多少个币，如以太坊ß</li></ul><h5 id="Bernoulli-trial"><a href="#Bernoulli-trial" class="headerlink" title="Bernoulli trial"></a>Bernoulli trial</h5><ul><li><p>a random experiment with binary outcome</p></li><li><p>每次求解nonce可以看作是Bernoulli trial</p></li></ul><p><strong>Bernoulli process</strong>：a sequence of independent Bernoulli</p><ul><li>大量实践的Bernoulli trial就组成了</li><li>性质：<ul><li>memoryless，无记忆的：实验结果和之前的实验结果是没有关系的</li></ul></li></ul><p>Poisson process：</p><p>exponential distribution，出块时间：服从指数分布</p><img src="/2021/03/04/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8/IMG_9A528FE35443-1.jpeg" alt="IMG_9A528FE35443-1" style="zoom:40%;"><ul><li>无记忆性：<ul><li>memory less：将来挖多少时间与之前已经挖了多少时间没有关系，即使等了10mins，下一挖到矿的时间仍然指数分布，平均是10mins</li><li>process free：过去的process是没用的，对挖矿公平性的保证</li></ul></li></ul><p>出块奖励</p><p>geometric series 几何级数</p><ul><li>BTC总数：21万 * 50 + 21万 * 25 + 21万 * 12.5 + ····<ul><li>= 21万 * 50 *（1 + 1/2 + 1/4 + ····）[等比求和，逐年减半]</li><li>= 2100万 [过去到未来的BTC总数]</li></ul></li></ul><p>Bitcoin is secured by mining</p><p>分岔攻击</p><p>回滚交易 - Double Spending Attack</p><ul><li>多等几个区块/确认 confirmation</li></ul><p>irrevocable ledger，不可篡改的账本</p><ul><li>不可篡改是该旅行的保证</li></ul><p>zero confirmation</p><ul><li>交易刚发出去，没有写进区块</li></ul><p>selfish mining</p><ul><li>我先不发布，等到挖到足够多的区块了，再一起发布，盖过其他的 - 分岔攻击</li><li>自己挖到两个的时候，不发布，等别人挖到一个，再一起发布，别人的那个就白发了</li><li>风险：<ul><li>不一定抢的赢别人</li></ul></li></ul><h4 id="BTC网络"><a href="#BTC网络" class="headerlink" title="BTC网络"></a>BTC网络</h4><p>BTC所有节点平等，没有super/master node</p><p>协议：</p><ul><li>application layer：BitCoin Block chain</li><li>network layer：P2P Overlay Network</li></ul><p>设计原则：simple简单，robot鲁棒，but not efficient不是高效</p><ul><li><p>消息节点：flooding方式</p></li><li><p>邻居节点：选取是随机的，不考虑底层的拓扑结构</p><ul><li>增强了鲁棒性，但是牺牲了效率</li></ul></li><li><p>每个节点维护一个等待上链的消息集合</p><ul><li>冲突交易</li></ul></li></ul><p>best effort，</p><blockquote><p>区块链是一种数据结构，而节点是在基于网络应用时，每一个连入区块的设备，比如手机就是轻节点，而矿池(后面有讲)就是一个全节点，保存所有的信息 - 现在BTC大约有100多G</p></blockquote><p><strong>全节点</strong>：保存所有的信息</p><ul><li>一直在线</li><li>在本地硬盘上维护完整的区块链信息</li><li>在内存里维护UTXO集合，以便快速检验交易的正确性</li><li>监听比特币网络上的交易信息，验证每个交易的合法性</li><li>决定哪些交易会被打包到区块里</li><li>监听别的矿工挖出来的区块，验证其合法性</li><li>挖矿：<ul><li>决定沿着那条链挖下去<ul><li>缺省情况下选择最长的链</li></ul></li><li>当出现等长的分岔的时候，选择哪一个分岔<ul><li>缺省情况下选择第一个发现的</li></ul></li></ul></li></ul><p><strong>轻节点</strong>：只保存block header（如手机上）</p><ul><li>不是一直在线</li><li>不用保存整个区块链，只要保存每个区块的块头</li><li>不用保存全部交易，只保存与自己相关的交易</li><li>无法检测大多数交易的合法性，只能检验与自己相关的那些交易的合法性</li><li>无法检测网上发布的区块的正确性<ul><li>因为无法知道区块里的交易是不是合法的</li></ul></li><li>可以验证挖矿的难度<ul><li>挖矿时计算hash值只需要用到块头的信息</li></ul></li><li>只能检测那个是最长的链，不知道哪个是最长的合法链<ul><li>只能知道这个链上的区块挖矿难度时符合要求的，但是无法验证每个区块里交易的合法性</li></ul></li></ul><h2 id="挖矿"><a href="#挖矿" class="headerlink" title="挖矿"></a>挖矿</h2><p>H(block header) &lt;= target</p><ul><li>target越小，难度越大</li><li>需要调整target值，使得出块时间保持稳定（BTC大约为10mins）</li></ul><p>hash算法：SHA-256</p><ul><li>取值空间：2^256</li><li>block header里面存nBits，只有4字节<ul><li>target有256位，32字节</li></ul></li></ul><h3 id="挖矿难度"><a href="#挖矿难度" class="headerlink" title="挖矿难度"></a>挖矿难度</h3><img src="/2021/03/04/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8/IMG_3A7CCA25FE75-1.jpeg" alt="IMG_3A7CCA25FE75-1" style="zoom:50%;"><ul><li>difficulty_1_target：挖矿难度等于1时的目标域值</li><li>1是最低难度</li><li>不调整target的话，出块时间会越来越短<ul><li>分岔，几个用户同时出块</li><li>系统不容易统一</li><li>51% attack：将大部分算力用来放在攻击的回滚区块的链上</li></ul></li></ul><p>orphan block</p><p>uncle reward</p><h3 id="难度调整"><a href="#难度调整" class="headerlink" title="难度调整"></a>难度调整</h3><p>每2016个区块调整目标域值，大约为2周（2016 * 10 / 60 * 24 = 14）</p><ul><li>调整公式：<img src="/2021/03/04/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8/IMG_E4D6502FBD91-1.jpeg" alt="IMG_E4D6502FBD91-1" style="zoom:40%;"><ul><li>如果实际时间超过了2周，那么平均出块时间超过了10mins，这个时候出块难度需要调整的低一点（右边分式大于1，target变大）</li></ul></li><li><img src="/2021/03/04/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8/IMG_D3AE8A16D3B4-1.jpeg" alt="IMG_D3AE8A16D3B4-1" style="zoom:70%;"></li></ul><h3 id="设备"><a href="#设备" class="headerlink" title="设备"></a>设备</h3><p><strong>早期1代 - CPU</strong>：</p><ul><li>随着挖矿难度增加，性价比极低</li><li>计算机中大部分内存都是闲置的，挖矿只用到了其中很少一部分内存</li><li>大部分不见也是闲置的，挖矿中hash值的计算只用到了通用计算机cpu中很少一部分指令</li><li>硬盘和其他资源也是闲置的</li></ul><blockquote><p> GPU主要用于大规模的并行计算，如深度学习</p></blockquote><p><strong>2代 - GPU</strong>：</p><ul><li>效率得到了很大的提高</li><li>但gpu主要是为了并行计算设计的，其中仍然有很多部件是闲置的，所以也不划算<ul><li>如用于浮点数运算的部件</li></ul></li><li>对于现在的挖矿的难度，GPU的算力已经不够了</li></ul><blockquote><p>ASIC：Application Specific Integrated  Circuit</p></blockquote><p><strong>现在 - ASIC芯片</strong></p><ul><li>专门为了BTC挖矿<strong>计算hash值</strong>所设计的，生产周期长（不能做全节点其他工作）</li><li>为某种加密货币设计的芯片，只能挖着一种货币（除非两种货币用同一个mining puzzle）<ul><li>merge mining：一个新的货币发行时，为了解决冷启动问题，吸引更多的用户，故意用一个已有的mining puzzle</li></ul></li><li><strong>Alternative mining puzzle</strong><ul><li>有的货币会设计这种puzzle，达到下面的效果</li><li>ASIC resistance：抗ASIC芯片化，为了让通用CPU也能参与挖矿</li></ul></li></ul><h3 id="矿池"><a href="#矿池" class="headerlink" title="矿池"></a>矿池</h3><ul><li>一个全节点去驱动很多的矿机（一个矿工负责全部的工作比较累）</li></ul><img src="/2021/03/04/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8/IMG_FFBC17D6F168-1.jpeg" alt="IMG_FFBC17D6F168-1" style="zoom:60%;"><ul><li><p>矿主：其他全节点的指责</p><ul><li>监听网上的交易，将这些交易组织打包成候选区块</li><li>同时关注是否有其他节点抢先发布了区块，如果有就需要作出调整等</li></ul></li><li><p>矿工：只负责计算hash值</p></li><li><p><strong>好处</strong>：</p><ul><li><p>减轻了矿工的工作量</p></li><li><p>解决单个矿工收入不稳定问题，以下两种方式</p><ol><li>像大型数据中心一样，矿池下有成千上万的矿机，属于一个机构，好分配</li><li>分布式，矿机来自不用的厂商，需要通过通讯协议与矿主联系，之后一起分红</li></ol><blockquote><p>如何解决矿工分红问题 - 工作量证明：</p><ul><li>降低挖矿难度，矿工提交 - share，almost valid block - 只能用来证明做了多少工作</li></ul></blockquote></li></ul></li><li><p>大型矿池的<strong>弊病</strong>：使得51%的攻击更加容易了</p><ul><li><strong>分叉攻击</strong>：对已经经过6次确认的交易分叉，利用51%算力将交易记录回滚。<ul><li>矿工只能计算哈希值，并不知道区块包含哪些交易，区块链状况是什么。所以，这些“群众”是无知的，容易被利用（《乌合之众》当中提出的观点，大多数人真的就能掌握真理吗？）。</li><li>此外，51%攻击只是一个概率问题，并非达到51%算力就能发动攻击，不能达到就无法发动攻击。此外，矿池本身算力也是在不断变化的。</li></ul></li><li><strong>封锁交易（Boycott）</strong>：<ul><li>假如攻击者不喜欢某个账户A，不想让A的交易上区块链，在监听到有其他人将A的交易发布到区块链上时，立刻发动分叉攻击，使A所在链无法成为”最长合法链“。这样，便实现了对A账户的封锁。</li><li>像不像即当裁判又当运动员？”堂下何人状告本官“？</li></ul></li><li><strong>盗币</strong>（将他人账户BTC转走）<ul><li>这个是<strong>不可能</strong>的，因为其并没有他人账户私钥。如果依仗算力强，强行将没有签名的转账发布到区块链，正常节点不会认为其合法，这样，即使这条链再长，其他人也不会认为其是最长合法链。</li></ul></li><li>on demand computing  -&gt;  on demand mining（潜在危害）</li></ul></li></ul><h2 id="BTC-使用的脚本语言"><a href="#BTC-使用的脚本语言" class="headerlink" title="BTC 使用的脚本语言"></a>BTC 使用的脚本语言</h2><ul><li>基于栈的编程语言：很简单，只有一个堆栈</li></ul><h3 id="交易结构"><a href="#交易结构" class="headerlink" title="交易结构"></a>交易结构</h3><img src="/2021/03/04/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8/IMG_0280.jpg" alt="IMG_0280" style="zoom:35%;"> <p><strong>交易的输入</strong></p><img src="/2021/03/04/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8/IMG_0281-9908278.jpg" alt="IMG_0281" style="zoom:38%;"> <p><strong>交易的输出</strong></p><img src="/2021/03/04/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8/IMG_0282.jpg" alt="IMG_0282" style="zoom:55%;"> <h3 id="交易验证"><a href="#交易验证" class="headerlink" title="交易验证"></a>交易验证</h3><img src="/2021/03/04/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8/IMG_0262.jpg" alt="IMG_0262" style="zoom:36%;"> <ul><li>早期是将输入输出脚本拼接到一起执行</li><li>后面处于安全考虑，输入输出两者分别执行，都为非0(True)则成功</li></ul><h4 id="脚本形式"><a href="#脚本形式" class="headerlink" title="脚本形式"></a>脚本形式</h4><blockquote><p>注：下面的脚本中，省略了<code>OP_</code>前缀</p><ul><li>如CHECKSIG -&gt; OP_CHECKSIG；DUP -&gt; OP_DUP；</li></ul></blockquote><ol><li><p><strong>P2PK ，Pay to Public Key</strong></p><ul><li>input script<ol><li><strong>PUSHDATA(SIG)**：将输入里提供的</strong><code>签名</code>**压入栈</li></ol></li><li>output script<ol start="2"><li><strong>PUSHDATA(PubKey)**：将输出里提供的</strong><code>公钥</code>**压入栈</li><li><strong>CHECKSIG</strong>：将栈顶的两个元素弹出来，用公钥检查签名是否正确<ul><li>正确则返回True，验证通过，否则执行出错，交易是非法的</li></ul></li></ol></li></ul></li><li><p><strong>P2PKH，Pay to Public Key Hash</strong></p><ul><li>input script<ol><li><strong>PUSHDATA(SIG)**：将输入里提供的</strong><code>签名</code>**压入栈</li><li><strong>PUSHDATA(PubKey)**：将</strong><code>公钥</code>**压入栈</li></ol></li><li>output script<ol start="3"><li><strong>DUP</strong>：将栈顶的元素复制一遍<ul><li>栈顶多了一个**<code>公钥</code>**</li></ul></li><li><strong>HASH160</strong>：将栈顶元素弹出，取hash，再将此hash值压入栈<ul><li>此时栈顶是**<code>公钥的hash-1</code>**</li></ul></li><li><strong>PUSHDATA(PubKeyHash)**：将输出中提供的</strong><code>公钥的hash-2</code>**值压入栈<ul><li>此时栈顶有两个公钥的hash</li></ul></li><li><strong>EQUALVERIFY</strong>：弹出栈顶的两个元素，比较是否相等<ul><li>防止有人冒名顶替，用自己的公钥冒充收款人的公钥</li><li>相等的话栈顶的两个**<code>PubKeyHash</code>**就消失了</li></ul></li><li><strong>CHECKSIG</strong>：将栈顶的两个元素弹出来，用公钥检查签名是否正确<ul><li>正确则返回True，验证通过，否则执行出错，交易是非法的</li></ul></li></ol></li></ul><blockquote><p>区别：第二种没有在输出中直接给出收款人的公钥，而是给出公钥的hash。公钥则是在输入脚本中给出的，其他的操作都是为了验证正确性。</p><p>第二种更常用</p></blockquote></li><li><p><strong>P2SH，Pay to Script Hash</strong></p><blockquote><p><strong>采用BIP16的方案</strong></p><p>输出脚本不提供收款人公钥的hash，而是收款人提供的脚本的hash</p><ul><li>redeemScript：赎回脚本</li><li>常见应用场景：对多重签名的支持-防止私钥的泄露</li></ul></blockquote><p><strong>验证分两步：</strong></p><ul><li>input script要给出一些签名（数目不定）及一段序列化的redeemScript<ol><li>验证序列化的<strong>redeemScript</strong>是否与<strong>output script</strong>中的hash值匹配</li><li>将输入脚本中给出的序列化的<strong>redeemScript</strong>反序列化并执行<strong>redeemScript</strong>，验证<strong>input script</strong>中给出的签名是否正确</li></ol></li></ul><blockquote><p>此处脚本中redeemScript内容采用<strong>P2PK形式</strong></p></blockquote><ul><li><p><strong>第一阶段</strong></p><ul><li><p>input script</p><ol><li><p><strong>PUSHDATA(Sig)**：将输入的</strong><code>签名</code>**压入栈</p></li><li><p><strong>PUSHDATA(serialized redeemScript)**：将赎回脚本</strong><code>seriRS</code>**压入栈</p></li></ol></li><li><p>output script</p><ol start="3"><li><strong>HASH160</strong>：将栈顶元素**<code>seriRS</code>**弹出，取hash，再将此hash值压入栈<ul><li>此时栈顶为**<code>RSH-1</code>**</li></ul></li><li><strong>PUSHDATA(redeemScriptHash)**：将输出脚本中给出的hash值</strong><code>RSH-2</code>**压入栈<ul><li>栈顶为两个<strong>RSH</strong></li></ul></li><li><strong>EQUAL</strong>：比较栈顶的两个RSH是否相等<ul><li>相等的话栈顶的两个**<code>RSH</code><strong>就消失了，栈中只剩一个</strong><code>Sig</code>**</li></ul></li></ol></li></ul></li><li><p><strong>第二阶段</strong></p><ul><li>执行反序列化之后的redeemScript<ol><li><strong>PUSHDATA(PubKey)**：将</strong><code>公钥</code>**压入栈</li><li><strong>CHECKSIG</strong>：检查输入给出的**<code>签名</code>**的正确性</li></ol></li></ul></li></ul></li></ol><h4 id="redeemScript"><a href="#redeemScript" class="headerlink" title="redeemScript"></a>redeemScript</h4><ol><li><p>P2PK形式</p><ul><li>PUSHDATA(PubKey)：将**<code>公钥</code>**压入栈</li><li>CHECKSIG：验证栈顶的**<code>公钥</code><strong>和</strong><code>签名</code>**是否匹配</li></ul></li><li><p>P2PKH形式</p></li><li><p>多重签名形式 - 下面的P2SH实现多重签名</p><blockquote><p><img src="/2021/03/04/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8/IMG_C6B93A3357A1-1.jpeg" alt="IMG_C6B93A3357A1-1" style="zoom:45%;">   <img src="/2021/03/04/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8/IMG_56F89D5B4A1F-1-9752549.jpeg" alt="IMG_56F89D5B4A1F-1" style="zoom:45%;"></p><ul><li>输出脚本提供N个公钥和一个域值M，输入脚本只需要提供这N个签名中任意M个合法的签名就能通过验证<ul><li>**<code>CHECKMULTISIG</code>**：验证堆栈中是否有N个签名中的M个</li></ul></li></ul></blockquote></li></ol><p>1、<strong>P2SH实现多重签名</strong> - 现在普遍采用的形式</p><ul><li><img src="/2021/03/04/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8/IMG_0272.jpg" alt="IMG_0272" style="zoom:30%;"> </li><li><strong>本质</strong>：将复杂度从输出脚本转移到了输入脚本 -&gt; 赎回脚本里面</li><li>赎回脚本在输入里面，由<strong>收款人</strong>提供，输出脚本只需要提供赎回脚本的hash值即可<ul><li>实际应用中，收款人不需要公布多重签名的公钥hash值，直接提供赎回脚本的hash值就可以了。则收款人采用什么形式的多重签名就可以隐藏起来</li></ul></li></ul><p>2、<strong>Proof of Burn</strong></p><ul><li>特殊的输出脚本形式，是销毁比特币的方法</li><li>output script，被称为<code>provably Unspendable/Prunable Outputs</code><ul><li><img src="/2021/03/04/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8/IMG_0279.jpg" alt="IMG_0279" style="zoom: 25%;"> </li><li>假如一个交易的input指向这个output，不论这个input里的input script如何设计，执行到<code>RETUEN</code>命令之后会直接返回false，不会执行后面的其他指令，所以这个output无法再被花出去，其对应的UTXO也就可以被剪枝了，无需保存</li></ul></li><li>应用场景<ol><li>一些小的币种(AltCoin，Alternative Coin)需要销毁一定数量的比特币来实现</li><li>向其中添加一些无法篡改的内容<ul><li>example - digital commitment，证明在某个时间知道某些事情：如将知识产权取hash之后存在<code>RETUEN</code>之后，之后可以证明你在这个时间知道某些事</li></ul></li></ol></li></ul><h2 id="fork-分岔"><a href="#fork-分岔" class="headerlink" title="fork, 分岔"></a>fork, 分岔</h2><p>state fork</p><p>forking attack</p><h1 id="以太坊-ETC"><a href="#以太坊-ETC" class="headerlink" title="以太坊 ETC"></a>以太坊 ETC</h1><h2 id="Consensus-Algorithm"><a href="#Consensus-Algorithm" class="headerlink" title="Consensus Algorithm"></a>Consensus Algorithm</h2><p>通过挖矿得到区块，算法分为一下两种</p><p>1、Ethash：及PoW，找nonce以生成区块</p><p>2、Clique：及PoA，投票选出权威节点Authority，由权威节点来验证区块的正确性</p><h1 id="Conflux"><a href="#Conflux" class="headerlink" title="Conflux"></a>Conflux</h1><p>Conflux共识机制是在比特币源代码基础上实现的。</p><p>Conflux的框架和比特币的矿机类似</p><ul><li>GossipNetwork：实现P2P网络交互</li><li>节点：维护TxPool，生成区块（Block Generator），以及维护区块状态</li></ul><p>GHost协议</p><p>epoch</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;crypto-currency，加密货币&quot;&gt;&lt;a href=&quot;#crypto-currency，加密货币&quot; class=&quot;headerlink&quot; title=&quot;crypto-currency，加密货币&quot;&gt;&lt;/a&gt;crypto-currency，加密货币&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="Botebook" scheme="https://jieyang-wei.github.io/categories/Botebook/"/>
    
    <category term="Blockchain" scheme="https://jieyang-wei.github.io/categories/Botebook/Blockchain/"/>
    
    
    <category term="blockchain" scheme="https://jieyang-wei.github.io/tags/blockchain/"/>
    
    <category term="BTC" scheme="https://jieyang-wei.github.io/tags/BTC/"/>
    
    <category term="Ethereum" scheme="https://jieyang-wei.github.io/tags/Ethereum/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统</title>
    <link href="https://jieyang-wei.github.io/2021/03/04/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    <id>https://jieyang-wei.github.io/2021/03/04/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/</id>
    <published>2021-03-04T06:11:00.000Z</published>
    <updated>2021-04-19T06:41:24.751Z</updated>
    
    <content type="html"><![CDATA[<h1 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h1><h2 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h2><p><a class="link" href="https://blog.csdn.net/moakun/article/details/83043493">CAP理论概述<i class="fas fa-external-link-alt"></i></a></p><ul><li>一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。</li></ul><h3 id="强-一致性-Consistency"><a href="#强-一致性-Consistency" class="headerlink" title="(强)一致性 Consistency"></a>(强)一致性 Consistency</h3><ul><li>一致性指“all nodes see the same data at the same time”，即更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致，所以，一致性，说的就是数据一致性。分布式的一致性</li><li>一致性是因为有<strong>并发读写才</strong>有的问题，因此在理解一致性的问题时，一定要注意结合考虑并发读写的场景。</li><li>对于一致性，可以分为从客户端和服务端两个不同的视角。</li><li><ul><li>从客户端来看，一致性主要指的是多并发访问时更新过的数据如何获取的问题。多进程并发访问时，更新过的数据在不同进程如何获取的不同策略，决定了不同的一致性。</li><li>从服务端来看，则是更新如何复制分布到整个系统，以保证数据最终一致。</li></ul></li></ul><p>三种一致性</p><ol><li>对于关系型数据库，要求更新过的数据能被后续的访问都能看到，这是<strong>强一致性</strong>。<ul><li>CAP中说，不可能同时满足的这个一致性指的是这个<strong>强一致性</strong></li></ul></li><li>如果能容忍后续的部分或者全部访问不到，则是<strong>弱一致性</strong>。</li><li>如果经过一段时间后要求能访问到更新后的数据，则是<strong>最终一致性</strong>。</li></ol><h3 id="可用性-Availability"><a href="#可用性-Availability" class="headerlink" title="可用性 Availability"></a>可用性 Availability</h3><ul><li>可用性指“Reads and writes always succeed”，即服务一直可用，而且是正常响应时间。</li><li>对于一个可用性的分布式系统，每一个非故障的节点必须对每一个请求作出响应。所以，一般我们在衡量一个系统的可用性的时候，都是通过停机时间来计算的。</li></ul><img src="/2021/03/04/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/1.png" alt="1" style="zoom:75%;"><ul><li>通常我们描述一个系统的可用性时，我们说淘宝的系统可用性可以达到5个9，意思就是说他的可用水平是99.999%，即全年停机时间不超过 (1-0.99999)<em>365</em>24*60 = 5.256 min，这是一个极高的要求。</li></ul><ul><li>好的可用性主要是指系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。一个分布式系统，上下游设计很多系统如负载均衡、WEB服务器、应用代码、数据库服务器等，任何一个节点的不稳定都可以影响可用性。</li></ul><h3 id="分区容错性-Partition-tolerance"><a href="#分区容错性-Partition-tolerance" class="headerlink" title="分区容错性 Partition tolerance"></a>分区容错性 Partition tolerance</h3><ul><li>分区容错性指“the system continues to operate despite arbitrary message loss or failure of part of the system”，即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。</li><li><strong>分区容错性</strong>和<strong>扩展性</strong>紧密相关。在分布式应用中，可能因为一些分布式的原因导致系统无法正常运转。好的分区容错性要求能够使应用虽然是一个分布式系统，而看上去却好像是在一个可以运转正常的整体。比如现在的分布式系统中有某一个或者几个机器宕掉了，其他剩下的机器还能够正常运转满足系统需求，或者是机器之间有网络异常，将分布式系统分隔未独立的几个部分，各个部分还能维持分布式系统的运作，这样就具有好的分区容错性。 </li><li>简单点说，就是在网络中断，消息丢失的情况下，系统如果还能正常工作，就是有比较好的分区容错性。</li></ul><h3 id="如何取舍"><a href="#如何取舍" class="headerlink" title="如何取舍"></a>如何取舍</h3><ol><li>CA: 优先保证一致性和可用性，放弃分区容错。 这也意味着放弃系统的扩展性，系统不再是分布式的，有违设计的初衷。</li><li>CP: 优先保证一致性和分区容错性，放弃可用性。在数据一致性要求比较高的场合(譬如:zookeeper,Hbase) 是比较常见的做法，一旦发生网络故障或者消息丢失，就会牺牲用户体验，等恢复之后用户才逐渐能访问。</li><li>AP: 优先保证可用性和分区容错性，放弃一致性。NoSQL中的Cassandra 就是这种架构。跟CP一样，放弃一致性不是说一致性就不保证了，而是逐渐的变得一致。</li></ol><h3 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h3><p>eureka、zookeeper、consul、nacos等</p><p>注册中心作用：</p><ol><li>微服务数量众多，要进行远程调用就需要知道服务端的ip地址和端口，注册中心帮助我们管理这些服务的ip和端口。</li><li>微服务会实时上报自己的状态，注册中心统一管理这些微服务的状态，将存在问题的服务踢出服务列表，客户端获取到可用的服务进行调用。</li><li></li></ol><h4 id="eureka"><a href="#eureka" class="headerlink" title="eureka"></a>eureka</h4><ul><li><p>服务发现框架</p></li><li><p>本身是一个基于REST的服务，主要用于定位运行在AWS域中的中间层服务，以达到负载均衡和中间层服务故障转移的目的。</p></li><li><p>Spring Cloud Eureka 是对Netflix公司的Eureka（它实现了服务治理的功能）的二次封装，集成在自己的子项目spring-cloud-netflix中，以实现SpringCloud的服务发现功能。</p></li><li><p>为什么要用eureka呢，因为分布式开发架构中，任何单点的服务都不能保证不会中断，因此需要服务发现机制，某个节点中断后，服务消费者能及时感知到保证服务高可用。</p></li></ul><p><a class="link" href="https://www.cnblogs.com/jing99/p/11576133.html">https://www.cnblogs.com/jing99/p/11576133.html<i class="fas fa-external-link-alt"></i></a></p><p><a class="link" href="https://blog.csdn.net/qq_18153015/article/details/108415307">https://blog.csdn.net/qq_18153015/article/details/108415307<i class="fas fa-external-link-alt"></i></a></p><p>【原理解析】</p><ul><li>Eureka包含两个组件，分为客户端和服务端</li><li><ul><li>客户端提供服务注册与注销、服务发现的功能</li><li><ul><li>Eureka Client是一个java客户端，用于简化与Eureka Server的交互，<strong>客户端同时也具备一个内置的、使用轮询(round-robin)负载算法的负载均衡器。在应用启动后</strong>，将会向Eureka Server发送心跳,<strong>默认周期为30秒</strong>，如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，Eureka Server将会从服务注册表中把这个**服务节点移除(默认90秒)**。</li><li>Eureka Client分为两个角色，分别是：</li><li><ol><li><strong>Application Service</strong>(Service Provider)： 服务提供方，是注册到Eureka Server中的服务。</li><li><strong>Application Client</strong>(Service Consumer)： 服务消费方，通过Eureka Server发现服务，并消费。</li><li>Application Service和Application Client不是绝对上的定义，因为Provider在提供服务的同时，也可以消费其他Provider提供的服务；Consumer在消费服务的同时，也可以提供对外服务。</li></ol></li></ul></li><li>服务端提供服务治理的功能。</li><li><ul><li>Eureka Server提供服务注册服务，各个节点启动后，会在Eureka Server中进行注册，这样Eureka Server中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观的看到。</li><li>Eureka Server本身也是一个服务，默认情况下会自动注册到Eureka注册中心。</li><li>如果<strong>搭建单机版的Eureka Server注册中心，则需要配置取消Eureka Server的自动注册逻辑。</strong>毕竟当前服务注册到当前服务代表的注册中心中是一个说不通的逻辑。</li><li>Eureka Server通过<strong>Register、Get、Renew</strong>等接口提供服务的<strong>注册、发现和心跳检测</strong>等服务。</li></ul></li></ul></li></ul><h5 id="1、Eureka架构"><a href="#1、Eureka架构" class="headerlink" title="1、Eureka架构"></a>1、Eureka架构</h5><p><strong>a、Eureka Server架构原理：</strong></p><img src="/2021/03/04/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/2.png" alt="1" style="zoom:75%;"><ul><li>Register(服务注册)：把自己的IP和端口注册给Eureka。</li><li>Renew(服务续约)：发送心跳包，每30秒发送一次。告诉Eureka自己还活着。</li><li>Cancel(服务下线)：当provider关闭时会向Eureka发送消息，把自己从服务列表中删除。防止consumer调用到不存在的服务。</li><li>Get Registry(获取服务注册列表)：获取其他服务列表。</li><li>Replicate(集群中数据同步)：eureka集群中的数据复制与同步。</li><li>Make Remote Call(远程调用)：完成服务的远程调用。</li></ul><p><strong>b、Eureka Server缓存架构</strong></p><img src="/2021/03/04/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/3.png" alt="1" style="zoom:75%;"><ul><li>为避免读写冲突，Eureka采用多层缓存的架构。</li><li>服务注册时，Eureka服务端会将服务实例更新到注册实例列表缓存（register）和读写缓存（readWriteCacheMap）中，然后Eureka服务端每隔30秒会将读写缓存（readWriteCacheMap）的数据更新到只读缓存（readOnlyCacheMap）中。</li><li>消费者从Eureka服务端获取实例列表时，是直接从只读缓存（readOnlyCacheMap）中获取。</li></ul><p><strong>c、Eureka健康检查，自我保护机制</strong></p><ul><li>为防止因为Eureka服务器网络问题，导致大部分服务实例被踢除，Eureka在进行服务定时更新时，会进行健康检查。</li><li>健康检查流程：</li><li><ul><li>当过期的服务数量比例超过阈值（可配置，默认为0.85）时，Eureka会启动自我保护机制，不会进行服务踢除操作</li></ul></li></ul><p><strong>d、Eureka分区</strong></p><p>为避免跨机房调用的网络消耗，Eureka支持通过配置实现优先使用本机房服务实例，当本机房实例不可用时，再使用其它机房的服务实例。</p><img src="/2021/03/04/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/4.png" alt="1" style="zoom:90%;"><ul><li>Eureka的分区概念分为区域（region）和机房（zone）。</li></ul><ul><li>如上图，区域（region）是北京，机房分为zone-1和zone-2。消费者（Consumer-1）调用服务时，会优先调用zone-1里面的服务提供者（Service-1），只有zone-1里面的服务提供者（Service-1）不可用，才会去调用zone-2里面的服务提供者（Service-2）。</li></ul><h5 id="2、功能原理"><a href="#2、功能原理" class="headerlink" title="2、功能原理"></a>2、功能原理</h5><p><strong>a、服务发现原理</strong></p><ul><li>eureka server可以集群部署，多个节点之间会进行（异步方式）数据同步，保证数据最终一致性，</li><li>Eureka Server作为一个开箱即用的服务注册中心，提供的功能包括：服务注册、接收服务心跳、服务剔除、服务下线等。</li><li>需要注意的是，Eureka Server同时也是一个Eureka Client，在不禁止Eureka Server的客户端行为时，它会向它配置文件中的其他Eureka Server进行拉取注册表、服务注册和发送心跳等操作。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* eureka server端通过appName和instanceInfoId来唯一区分一个服务实例，服务实例信息是保存在哪里呢？其实就是一个Map中：*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 第一层的key是appName，第二层的key是instanceInfoId */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt; registry</span><br><span class="line">   = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt;();</span><br></pre></td></tr></table></figure><p><strong>b、服务注册</strong></p><ul><li><p>Service Provider启动时会将服务信息（InstanceInfo）发送给eureka server，eureka server接收到之后会写入registry中，服务注册默认过期时间DEFAULT_DURATION_IN_SECS = 90秒。InstanceInfo写入到本地registry之后，然后同步给其他peer节点，对应方法：</p><p><code>com.netflix.eureka.registry.peerawareinstanceregistryimpl#replicateToPeers</code></p></li></ul><p><strong>c、写入本地registry</strong></p><ul><li><p>服务信息（InstanceInfo）保存在Lease中，写入本地registry对应方法：</p><p><code>com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl#register</code></p></li><li><p>Lease统一保存在内存的<strong>ConcurrentHashMap</strong>中，在服务注册过程中，首先加个读锁，然后从registry中判断该Lease是否已经存在，如果存在则比较<strong>lastDirtyTimestamp时间戳</strong>，取二者最大的服务信息，避免发生数据覆盖。使用<strong>InstanceInfo</strong>创建一个新的<strong>InstanceInfo</strong></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (existingLastDirtyTimestamp &gt; registrationLastDirtyTimestamp) &#123;</span><br><span class="line">  <span class="comment">// 已存在Lease则比较时间戳，取二者最大值</span></span><br><span class="line">  registrant = existingLease.getHolder();</span><br><span class="line">&#125;</span><br><span class="line">Lease&lt;InstanceInfo&gt; lease = <span class="keyword">new</span> Lease&lt;InstanceInfo&gt;(registrant, leaseDuration);</span><br><span class="line"><span class="keyword">if</span> (existingLease != null) &#123;</span><br><span class="line">  <span class="comment">// 已存在Lease则取上次up时间戳</span></span><br><span class="line">  lease.setServiceUpTimestamp(existingLease.getServiceUpTimestamp());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Lease</span><span class="params">(T r, <span class="keyword">int</span> durationInSecs)</span> </span>&#123;</span><br><span class="line">  holder = r;</span><br><span class="line">  registrationTimestamp = System.currentTimeMillis(); <span class="comment">// 当前时间</span></span><br><span class="line">  lastUpdateTimestamp = registrationTimestamp;</span><br><span class="line">  duration = (durationInSecs * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>d、同步给其他peer节点</strong></p><ul><li><p>InstanceInfo写入到本地registry之后，然后同步给其他peer节点，对应方法：</p><p><code>com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl#replicateToPeers</code></p></li><li><p>如果当前节点接收到的<strong>InstanceInfo</strong>本身就是另一个节点同步来的，则不会继续同步给其他节点，避免形成“广播效应”；<strong>InstanceInfo</strong>同步时会排除当前节点。</p></li><li><p>InstanceInfo的状态有依以下几种：</p></li><li><p>Heartbeat, Register, Cancel, StatusUpdate, DeleteStatusOverride，默认情况下同步操作是批量异步执行的，同步请求首先缓存到Map中，key为requestType+appName+id，然后由发送线程将请求发送到peer节点。</p></li><li><p>Peer之间的状态是采用异步的方式同步的，所以不保证节点间的状态一定是一致的，不过基本能保证最终状态是一致的。结合服务发现的场景，实际上也并不需要节点间的状态强一致。在一段时间内（比如30秒），节点A比节点B多一个服务实例或少一个服务实例，在业务上也是完全可以接受的（Service Consumer侧一般也会实现错误重试和负载均衡机制）。所以按照CAP理论，Eureka的选择就是放弃C，选择AP。</p></li><li><p>如果同步过程中，出现了异常怎么办呢，这时会根据异常信息做对应的处理，如果是读取超时或者网络连接异常，则稍后重试；如果其他异常则打印错误日志不再后续处理。</p></li></ul><p><strong>e、服务续约</strong></p><ul><li>Renew（服务续约）操作由Service Provider定期调用，类似于heartbeat。主要是用来告诉Eureka Server Service Provider还活着，避免服务被剔除掉。</li><li>renew接口实现方式和register基本一致：首先更新自身状态，再同步到其它Peer，服务续约也就是把过期时间设置为当前时间加上duration的值。</li><li>注意：服务注册如果InstanceInfo不存在则加入，存在则更新；而服务预约只是进行更新，如果InstanceInfo不存在直接返回false。</li></ul><p><strong>f、服务下线</strong></p><ul><li><p>Cancel（服务下线）一般在Service Provider shutdown的时候调用，用来把自身的服务从Eureka Server中删除，以防客户端调用不存在的服务，eureka从本地”删除“（设置为删除状态）之后会同步给其他peer，对应方法：</p><p><code>com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl#cancel</code></p></li></ul><p><strong>g、服务失效剔除</strong></p><ul><li><p>Eureka Server中有一个EvictionTask，用于检查服务是否失效。</p></li><li><p>Eviction（失效服务剔除）用来定期（默认为每60秒）在Eureka Server检测失效的服务，检测标准就是超过一定时间没有Renew的服务。默认失效时间为90秒，也就是如果有服务超过90秒没有向Eureka Server发起Renew请求的话，就会被当做失效服务剔除掉。</p></li><li><ul><li>失效时间可以通过<code>eureka.instance.leaseExpirationDurationInSeconds</code>进行配置，</li><li>定期扫描时间可以通过<code>eureka.server.evictionIntervalTimerInMs</code>进行配置。</li></ul></li><li><p>服务剔除#evict方法中有很多限制，都是为了保证Eureka Server的可用性：</p></li><li><p>比如自我保护时期不能进行服务剔除操作、过期操作是分批进行、服务剔除是随机逐个剔除，剔除均匀分布在所有应用中，防止在同一时间内同一服务集群中的服务全部过期被剔除，以致大量剔除发生时，在未进行自我保护前促使了程序的崩溃</p></li></ul><h5 id="3、Eureka-Server-Client流程"><a href="#3、Eureka-Server-Client流程" class="headerlink" title="3、Eureka Server/Client流程"></a>3、Eureka Server/Client流程</h5><p><strong>a、服务信息拉取</strong></p><ul><li>Eureka consumer服务信息的拉取分为<strong>全量式拉取</strong>和<strong>增量式拉取</strong>，eureka consumer启动时进行全量拉取，运行过程中由定时任务进行增量式拉取，如果网络出现异常，可能导致先拉取的数据被旧数据覆盖（比如上一次拉取线程获取结果较慢，数据已更新情况下使用返回结果再次更新，导致数据版本落后），产生脏数据。对此，eureka通过类型AtomicLong的<strong>fetchRegistryGeneration</strong>对数据版本进行跟踪，版本不一致则表示此次拉取到的数据已过期。</li><li><strong>fetchRegistryGeneration</strong>过程是在拉取数据之前，执行fetchRegistryGeneration.get获取当前版本号，获取到数据之后， 通过<code>fetchRegistryGeneration.compareAndSet</code>来判断当前版本号是否已更新</li><li>注意：如果增量式更新出现意外，会再次进行一次全量拉取更新。</li></ul><p><strong>b、Eureka Server的伸缩容</strong></p><ul><li><p>Eureka Server是怎么知道有多少Peer的呢？</p><ul><li>Eureka Server在启动后会调用<code>EurekaClientConfig.getEurekaServerServiceUrls</code>来获取所有的Peer节点，并且会定期更新。</li><li>定期更新频率可以通过<code>eureka.server.peerEurekaNodesUpdateIntervalMs</code>配置。</li></ul></li><li><p>这个方法的默认实现是从配置文件读取，所以如果Eureka Server节点相对固定的话，可以通过在配置文件中配置来实现。</p></li><li><p>如果希望能更灵活的控制Eureka Server节点，比如动态扩容/缩容，那么可以override <code>getEurekaServerServiceUrls</code>方法，提供自己的实现，比如我们的项目中会通过数据库读取Eureka Server列表。</p></li><li><p>eureka server启动时把自己当做是Service Consumer从其它Peer Eureka获取所有服务的注册信息。然后对每个服务信息，在自己这里执行<code>Register，isReplication=true</code>从而完成初始化。</p></li></ul><p><strong>c、Service Provider</strong></p><ul><li>Service Provider启动时首先时注册到Eureka Service上，这样其他消费者才能进行服务调用，除了在启动时之外，只要实例状态信息有变化，也会注册到Eureka Service。<ul><li>需要注意的是，需要确保配置<code>eureka.client.registerWithEureka=true</code>。register逻辑在方法<code>AbstractJerseyEurekaHttpClient.register</code>中，Service Provider会依次注册到配置的Eureka Server Url上，如果注册出现异常，则会继续注册其他的url。</li></ul></li><li>Renew操作会在Service Provider端定期发起，用来通知Eureka Server自己还活着。<ul><li>这里<code>instance.leaseRenewalIntervalInSeconds</code>属性表示Renew频率。默认是30秒，也就是每30秒会向Eureka Server发起Renew操作。这部分逻辑在HeartbeatThread类中。</li><li>在Service Provider服务shutdown的时候，需要及时通知Eureka Server把自己剔除，从而避免客户端调用已经下线的服务，逻辑本身比较简单，通过对方法标记<code>@PreDestroy</code>，从而在服务shutdown的时候会被触发。</li></ul></li></ul><p><strong>d、Service Consumer</strong></p><ul><li>Service Consumer这块的实现相对就简单一些，因为它只涉及到从Eureka Server获取服务列表和更新服务列表。</li><li>Service Consumer在启动时会从Eureka Server获取所有服务列表，并在本地缓存。需要注意的是，需要确保配置<code>eureka.client.shouldFetchRegistry=true</code>。由于在本地有一份Service Registries缓存，所以需要定期更新，定期更新频率可以通过<code>eureka.client.registryFetchIntervalSeconds</code>配置。</li></ul><h5 id="4、属性值"><a href="#4、属性值" class="headerlink" title="4、属性值"></a>4、属性值</h5><p><strong>a、客户端 eureka.client</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、RegistryFetchIntervalSeconds</span><br><span class="line"><span class="comment">// 从eureka服务器注册表中获取注册信息的时间间隔（s），默认为30秒</span></span><br><span class="line"><span class="number">2</span>、InstanceinfoReplicationIntervalSeconds</span><br><span class="line"><span class="comment">// 复制实例变化信息到eureka服务器所需要的时间间隔（s），默认为30秒</span></span><br><span class="line"><span class="number">3</span>、InitialInstanceInfoReplicationIntervalSeconds</span><br><span class="line"><span class="comment">// 最初复制实例信息到eureka服务器所需的时间（s），默认为40秒</span></span><br><span class="line"><span class="number">4</span>、EurekaServiceUrlPollIntervalSeconds</span><br><span class="line"><span class="comment">// 询问Eureka服务url信息变化的时间间隔（s），默认为300秒</span></span><br><span class="line"><span class="number">5</span>、ProxyHost</span><br><span class="line"><span class="comment">// 获取eureka服务的代理主机，默认为null</span></span><br><span class="line"><span class="number">6</span>、ProxyProxyPort</span><br><span class="line"><span class="comment">// 获取eureka服务的代理端口,默认为null</span></span><br><span class="line"><span class="number">7</span>、ProxyUserName</span><br><span class="line"><span class="comment">// 获取eureka服务的代理用户名，默认为null</span></span><br><span class="line"><span class="number">8</span>、ProxyPassword</span><br><span class="line"><span class="comment">// 获取eureka服务的代理密码，默认为null</span></span><br><span class="line"><span class="number">9</span>、GZipContent</span><br><span class="line"><span class="comment">// eureka注册表的内容是否被压缩，默认为true，并且是在最好的网络流量下被压缩</span></span><br><span class="line"><span class="number">10</span>、EurekaServerReadTimeoutSeconds</span><br><span class="line"><span class="comment">// eureka需要超时读取之前需要等待的时间，默认为8秒</span></span><br><span class="line"><span class="number">11</span>、EurekaServerConnectTimeoutSeconds</span><br><span class="line"><span class="comment">// eureka需要超时连接之前需要等待的时间，默认为5秒</span></span><br><span class="line"><span class="number">12</span>、BackupRegistryImpl</span><br><span class="line"><span class="comment">// 获取实现了eureka客户端在第一次启动时读取注册表的信息作为回退选项的实现名称</span></span><br><span class="line"><span class="number">13</span>、EurekaServerTotalConnections</span><br><span class="line"><span class="comment">// eureka客户端允许所有eureka服务器连接的总数目，默认是200</span></span><br><span class="line"><span class="number">14</span>、EurekaServerTotalConnectionsPerHost</span><br><span class="line"><span class="comment">// eureka客户端允许eureka服务器主机连接的总数目，默认是50</span></span><br><span class="line"><span class="number">15</span>、EurekaServerURLContext</span><br><span class="line"><span class="comment">// 表示eureka注册中心的路径，如果配置为eureka，则为http://x.x.x.x:x/eureka/，在eureka的配置文件中加入此配置表示eureka作为客户端向注册中心注册，从而构成eureka集群。此配置只有在eureka服务器ip地址列表是在DNS中才会用到，默认为null</span></span><br><span class="line"><span class="number">16</span>、EurekaServerPort</span><br><span class="line"><span class="comment">// 获取eureka服务器的端口，此配置只有在eureka服务器ip地址列表是在DNS中才会用到。默认为null</span></span><br><span class="line"><span class="number">17</span>、EurekaServerDNSName</span><br><span class="line"><span class="comment">// 获取要查询的DNS名称来获得eureka服务器，此配置只有在eureka服务器ip地址列表是在DNS中才会用到。默认为null</span></span><br><span class="line"><span class="number">18</span>、UseDnsForFetchingServiceUrls</span><br><span class="line"><span class="comment">// eureka客户端是否应该使用DNS机制来获取eureka服务器的地址列表，默认为false</span></span><br><span class="line"><span class="number">19</span>、RegisterWithEureka</span><br><span class="line"><span class="comment">// 实例是否在eureka服务器上注册自己的信息以供其他服务发现，默认为true</span></span><br><span class="line"><span class="number">20</span>、PreferSameZoneEureka</span><br><span class="line"><span class="comment">// 实例是否使用同一zone里的eureka服务器，默认为true，理想状态下，eureka客户端与服务端是在同一zone下</span></span><br><span class="line"><span class="number">21</span>、AllowRedirects</span><br><span class="line"><span class="comment">// 服务器是否能够重定向客户端请求到备份服务器。如果设置为false，服务器将直接处理请求，如果设置为true，它可能发送HTTP重定向到客户端。默认为false</span></span><br><span class="line"><span class="number">22</span>、LogDeltaDiff</span><br><span class="line"><span class="comment">// 是否记录eureka服务器和客户端之间在注册表的信息方面的差异，默认为false</span></span><br><span class="line"><span class="number">23</span>、DisableDelta(*)</span><br><span class="line"><span class="comment">// 默认为false</span></span><br><span class="line"><span class="number">24</span>、fetchRegistryForRemoteRegions</span><br><span class="line"><span class="comment">// eureka服务注册表信息里的以逗号隔开的地区名单，如果不这样返回这些地区名单，则客户端启动将会出错。默认为null</span></span><br><span class="line"><span class="number">25</span>、Region</span><br><span class="line"><span class="comment">// 获取实例所在的地区。默认为us-east-1</span></span><br><span class="line"><span class="number">26</span>、AvailabilityZones</span><br><span class="line"><span class="comment">// 获取实例所在的地区下可用性的区域列表，用逗号隔开。</span></span><br><span class="line"><span class="number">27</span>、EurekaServerServiceUrls</span><br><span class="line"><span class="comment">// Eureka服务器的连接，默认为http：//XXXX：X/eureka/,但是如果采用DNS方式获取服务地址，则不需要配置此设置。</span></span><br><span class="line"><span class="number">28</span>、FilterOnlyUpInstances（*）</span><br><span class="line"><span class="comment">// 是否获得处于开启状态的实例的应用程序过滤之后的应用程序。默认为true</span></span><br><span class="line"><span class="number">29</span>、EurekaConnectionIdleTimeoutSeconds</span><br><span class="line"><span class="comment">// Eureka服务的http请求关闭之前其响应的时间，默认为30秒</span></span><br><span class="line"><span class="number">30</span>、FetchRegistry</span><br><span class="line"><span class="comment">// 此客户端是否获取eureka服务器注册表上的注册信息，默认为true</span></span><br><span class="line"><span class="number">31</span>、RegistryRefreshSinglevipAddress</span><br><span class="line"><span class="comment">// 此客户端只对一个单一的VIP注册表的信息感兴趣。默认为null</span></span><br><span class="line"><span class="number">32</span>、HeartbeatExecutorThreadPoolSize(*)</span><br><span class="line"><span class="comment">// 心跳执行程序线程池的大小,默认为5</span></span><br><span class="line"><span class="number">33</span>、HeartbeatExecutorExponentialBackOffBound(*)</span><br><span class="line"><span class="comment">// 心跳执行程序回退相关的属性，是重试延迟的最大倍数值，默认为10</span></span><br><span class="line"><span class="number">34</span>、CacheRefreshExecutorThreadPoolSize(*)</span><br><span class="line"><span class="comment">// 执行程序缓存刷新线程池的大小，默认为5</span></span><br><span class="line"><span class="number">35</span>、CacheRefreshExecutorExponentialBackOffBound</span><br><span class="line"><span class="comment">// 执行程序指数回退刷新的相关属性，是重试延迟的最大倍数值，默认为10</span></span><br><span class="line"><span class="number">36</span>、DollarReplacement</span><br><span class="line"><span class="comment">// eureka服务器序列化/反序列化的信息中获取“$”符号的的替换字符串。默认为“_-”</span></span><br><span class="line"><span class="number">37</span>、EscapeCharReplacement</span><br><span class="line"><span class="comment">// eureka服务器序列化/反序列化的信息中获取“_”符号的的替换字符串。默认为“__”</span></span><br><span class="line"><span class="number">38</span>、OnDemandUpdateStatusChange（*）</span><br><span class="line"><span class="comment">// 如果设置为true,客户端的状态更新将会点播更新到远程服务器上，默认为true</span></span><br><span class="line"><span class="number">39</span>、EncoderName</span><br><span class="line"><span class="comment">// 这是一个短暂的编码器的配置，如果最新的编码器是稳定的，则可以去除，默认为null</span></span><br><span class="line"><span class="number">40</span>、DecoderName</span><br><span class="line"><span class="comment">// 这是一个短暂的解码器的配置，如果最新的解码器是稳定的，则可以去除，默认为null</span></span><br><span class="line"><span class="number">41</span>、ClientDataAccept（*）</span><br><span class="line"><span class="comment">// 客户端数据接收</span></span><br><span class="line"><span class="number">42</span>、Experimental（*）</span><br><span class="line"><span class="comment">// 当尝试新功能迁移过程时，为了避免配置API污染，相应的配置即可投入实验配置部分，默认为null</span></span><br></pre></td></tr></table></figure><p><strong>b、服务端 eureka.server</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、AWSAccessId</span><br><span class="line"><span class="comment">// 获取aws访问的id，主要用于弹性ip绑定，此配置是用于aws上的，默认为null</span></span><br><span class="line"><span class="number">2</span>、AWSSecretKey</span><br><span class="line"><span class="comment">// 获取aws私有秘钥，主要用于弹性ip绑定，此配置是用于aws上的，默认为null</span></span><br><span class="line"><span class="number">3</span>、EIPBindRebindRetries</span><br><span class="line"><span class="comment">// 获取服务器尝试绑定到候选的EIP的次数，默认为3</span></span><br><span class="line"><span class="number">4</span>、EIPBindingRetryIntervalMsWhenUnbound(*)</span><br><span class="line"><span class="comment">// 服务器检查ip绑定的时间间隔，单位为毫秒，默认为1 * 60 * 1000</span></span><br><span class="line"><span class="number">5</span>、EIPBindingRetryIntervalMs</span><br><span class="line"><span class="comment">// 与上面的是同一作用，仅仅是稳定状态检查，默认为5 * 60 * 1000</span></span><br><span class="line"><span class="number">6</span>、SelfPreservation模式，</span><br><span class="line"><span class="comment">// SelfPreservation模式，当出现出现网络分区、eureka在短时间内丢失过多客户端时，会进入SelfPreservation模式，即一个服务长时间没有发送心跳，eureka也不会将其删除，默认为true</span></span><br><span class="line"><span class="number">7</span>、RenewalPercentThreshold(*)</span><br><span class="line"><span class="comment">// 阈值因子，默认是0.85，如果阈值比最小值大，则SelfPreservation模式开启</span></span><br><span class="line"><span class="number">8</span>、RenewalThresholdUpdateIntervalMs</span><br><span class="line"><span class="comment">// 阈值更新的时间间隔，单位为毫秒，默认为15 * 60 * 1000</span></span><br><span class="line"><span class="number">9</span>、PeerEurekaNodesUpdateIntervalMs(*)</span><br><span class="line"><span class="comment">// 集群里eureka节点的变化信息更新的时间间隔，单位为毫秒，默认为10 * 60 * 1000</span></span><br><span class="line"><span class="number">10</span>、EnableReplicatedRequestCompression</span><br><span class="line"><span class="comment">// 复制的数据在发送请求时是否被压缩，默认为false</span></span><br><span class="line"><span class="number">11</span>、NumberOfReplicationRetries</span><br><span class="line"><span class="comment">// 获取集群里服务器尝试复制数据的次数，默认为5</span></span><br><span class="line"><span class="number">12</span>、PeerEurekaStatusRefreshTimeIntervalMs</span><br><span class="line"><span class="comment">// 服务器节点的状态信息被更新的时间间隔，单位为毫秒，默认为30 * 1000</span></span><br><span class="line"><span class="number">13</span>、WaitTimeInMsWhenSyncEmpty(*)</span><br><span class="line"><span class="comment">// 在Eureka服务器获取不到集群里对等服务器上的实例时，需要等待的时间，单位为毫秒，默认为1000 * 60 * 5</span></span><br><span class="line"><span class="number">14</span>、PeerNodeConnectTimeoutMs</span><br><span class="line"><span class="comment">// 连接对等节点服务器复制的超时的时间，单位为毫秒，默认为200</span></span><br></pre></td></tr></table></figure><p><strong>c、实例微服务端配置</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、InstanceId</span><br><span class="line"><span class="comment">// 此实例注册到eureka服务端的唯一的实例ID,其组成为$&#123;spring.application.name&#125;:$&#123;spring.application.instance_id:$&#123;random.value&#125;&#125;</span></span><br><span class="line"><span class="number">2</span>、Appname</span><br><span class="line"><span class="comment">// 获得在eureka服务上注册的应用程序的名字，默认为unknow</span></span><br><span class="line"><span class="number">3</span>、AppGroupName</span><br><span class="line"><span class="comment">// 获得在eureka服务上注册的应用程序组的名字，默认为unknow</span></span><br><span class="line"><span class="number">4</span>、InstanceEnabledOnit（*）</span><br><span class="line"><span class="comment">// 实例注册到eureka服务器时，是否开启通讯，默认为false</span></span><br><span class="line"><span class="number">5</span>、NonSecurePort</span><br><span class="line"><span class="comment">// 获取该实例应该接收通信的非安全端口。默认为80</span></span><br><span class="line"><span class="number">6</span>、SecurePort</span><br><span class="line"><span class="comment">// 获取该实例应该接收通信的安全端口，默认为443</span></span><br><span class="line"><span class="number">7</span>、NonSecurePortEnabled</span><br><span class="line"><span class="comment">// 该实例应该接收通信的非安全端口是否启用，默认为true</span></span><br><span class="line"><span class="number">8</span>、SecurePortEnabled</span><br><span class="line"><span class="comment">// 该实例应该接收通信的安全端口是否启用，默认为false</span></span><br><span class="line"><span class="number">9</span>、LeaseRenewalIntervalInSeconds</span><br><span class="line"><span class="comment">// eureka客户需要多长时间发送心跳给eureka服务器，表明它仍然活着,默认为30秒</span></span><br><span class="line"><span class="number">10</span>、LeaseExpirationDurationInSeconds</span><br><span class="line"><span class="comment">// Eureka服务器在接收到实例的最后一次发出的心跳后，需要等待多久才可以将此实例删除，默认为90秒</span></span><br><span class="line"><span class="number">11</span>、VirtualHostName</span><br><span class="line"><span class="comment">// 此实例定义的虚拟主机名，其他实例将通过使用虚拟主机名找到该实例。</span></span><br><span class="line"><span class="number">12</span>、SecureVirtualHostName</span><br><span class="line"><span class="comment">// 此实例定义的安全虚拟主机名</span></span><br><span class="line"><span class="number">13</span>、ASGName（*）</span><br><span class="line"><span class="comment">// 与此实例相关联AWS自动缩放组名称。此项配置是在AWS环境专门使用的实例启动，它已被用于流量停用后自动把一个实例退出服务。</span></span><br><span class="line"><span class="number">14</span>、HostName</span><br><span class="line"><span class="comment">// 与此实例相关联的主机名，是其他实例可以用来进行请求的准确名称</span></span><br><span class="line"><span class="number">15</span>、MetadataMap(*)</span><br><span class="line"><span class="comment">// 获取与此实例相关联的元数据(key,value)。这个信息被发送到eureka服务器，其他实例可以使用。</span></span><br><span class="line"><span class="number">16</span>、DataCenterInfo（*）</span><br><span class="line"><span class="comment">// 该实例被部署在数据中心</span></span><br><span class="line"><span class="number">17</span>、IpAddress</span><br><span class="line"><span class="comment">// 获取实例的ip地址</span></span><br><span class="line"><span class="number">18</span>、StatusPageUrlPath（*）</span><br><span class="line"><span class="comment">// 获取此实例状态页的URL路径，然后构造出主机名，安全端口等，默认为/info</span></span><br><span class="line"><span class="number">19</span>、StatusPageUrl(*)</span><br><span class="line"><span class="comment">// 获取此实例绝对状态页的URL路径，为其他服务提供信息时来找到这个实例的状态的路径，默认为null</span></span><br><span class="line"><span class="number">20</span>、HomePageUrlPath（*）</span><br><span class="line"><span class="comment">// 获取此实例的相关主页URL路径，然后构造出主机名，安全端口等，默认为/</span></span><br><span class="line"><span class="number">21</span>、HomePageUrl(*)</span><br><span class="line"><span class="comment">// 获取此实例的绝对主页URL路径，为其他服务提供信息时使用的路径,默认null</span></span><br><span class="line"><span class="number">22</span>、HealthCheckUrlPath</span><br><span class="line"><span class="comment">// 获取此实例的相对健康检查URL路径，默认为/health</span></span><br><span class="line"><span class="number">23</span>、HealthCheckUrl</span><br><span class="line"><span class="comment">// 获取此实例的绝对健康检查URL路径,默认为null</span></span><br><span class="line"><span class="number">24</span>、SecureHealthCheckUrl</span><br><span class="line"><span class="comment">// 获取此实例的绝对安全健康检查网页的URL路径，默认为null</span></span><br><span class="line"><span class="number">25</span>、DefaultAddressResolutionOrder</span><br><span class="line"><span class="comment">// 获取实例的网络地址，默认为[]</span></span><br><span class="line"><span class="number">26</span>、Namespace</span><br><span class="line"><span class="comment">// 获取用于查找属性的命名空间，默认为eureka</span></span><br></pre></td></tr></table></figure><h2 id="FLP-impossibility"><a href="#FLP-impossibility" class="headerlink" title="FLP impossibility"></a>FLP impossibility</h2><p><strong>FLP不可能原理</strong>：在网络可靠，存在节点失效（即便只有一个）的最小化异步模型系统中，不存在一个可以解决一致性问题的确定性算法。</p><ul><li>1985年 FLP 原理实际上说明对于允许节点失效情况下，纯粹异步系统无法确保一致性在有限时间内完成。</li><li> 科学告诉你什么是不可能的；工程则告诉你，付出一些代价，我可以把它变成可能。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;理论&quot;&gt;&lt;a href=&quot;#理论&quot; class=&quot;headerlink&quot; title=&quot;理论&quot;&gt;&lt;/a&gt;理论&lt;/h1&gt;&lt;h2 id=&quot;CAP&quot;&gt;&lt;a href=&quot;#CAP&quot; class=&quot;headerlink&quot; title=&quot;CAP&quot;&gt;&lt;/a&gt;CAP&lt;/h2&gt;&lt;p</summary>
      
    
    
    
    <category term="Notebook" scheme="https://jieyang-wei.github.io/categories/Notebook/"/>
    
    <category term="Others" scheme="https://jieyang-wei.github.io/categories/Notebook/Others/"/>
    
    
    <category term="理论知识" scheme="https://jieyang-wei.github.io/tags/%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/"/>
    
    <category term="distributed system" scheme="https://jieyang-wei.github.io/tags/distributed-system/"/>
    
  </entry>
  
  <entry>
    <title>植物大战僵尸破解</title>
    <link href="https://jieyang-wei.github.io/2021/02/23/%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8%E7%A0%B4%E8%A7%A3/"/>
    <id>https://jieyang-wei.github.io/2021/02/23/%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8%E7%A0%B4%E8%A7%A3/</id>
    <published>2021-02-23T08:46:34.000Z</published>
    <updated>2021-04-19T06:42:22.879Z</updated>
    
    <content type="html"><![CDATA[<p><a class="link" href="https://pan.baidu.com/s/16ub4mIS-JaPH-K7nytCQew">植物大战僵尸95单机中文版，提取码4ni2<i class="fas fa-external-link-alt"></i></a></p><h1 id="目录构成"><a href="#目录构成" class="headerlink" title="目录构成"></a>目录构成</h1><img src="/2021/02/23/%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8%E7%A0%B4%E8%A7%A3/5C20B17C1811FAAC73E63331E1FB2AFA.png" alt="5C20B17C1811FAAC73E63331E1FB2AFA" style="zoom:80%;"><ul><li>images、reanim、particles：均为图片等素材文件</li><li>main.pak：游戏素材包</li><li>base.dll：库文件</li></ul><h1 id="本地数据文件"><a href="#本地数据文件" class="headerlink" title="本地数据文件"></a>本地数据文件</h1><p>游戏数据路径：<code>C:\ProgramData\PopCap Games\PlantsVsZombies</code></p><ul><li><p><strong>注意</strong>：每次需要关闭游戏后再对文件进行改动，不然不生效</p></li><li><p>cache：游戏缓存</p></li><li><p>userdata：用户数据文件夹，内容如下</p><ul><li><img src="/2021/02/23/%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8%E7%A0%B4%E8%A7%A3/829EB5D66DE961B5BBFCB81752AFD1C2.png" alt="829EB5D66DE961B5BBFCB81752AFD1C2" style="zoom:90%;">* users.bat：用户列表，仅存储用户名字和顺序* user[n].bat：第n个创建的用户的游戏相关参数缓存  * 包括关卡、金钱数、道具等，但不存储用户名* game[n_0].bat：游戏进度存储</li></ul></li></ul><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><p>二进制文件编辑：Hex</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a class=&quot;link&quot; href=&quot;https://pan.baidu.com/s/16ub4mIS-JaPH-K7nytCQew&quot;&gt;植物大战僵尸95单机中文版，提取码4ni2&lt;i class=&quot;fas fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;</summary>
      
    
    
    
    <category term="Course" scheme="https://jieyang-wei.github.io/categories/Course/"/>
    
    <category term="Practice" scheme="https://jieyang-wei.github.io/categories/Course/Practice/"/>
    
    
    <category term="binary" scheme="https://jieyang-wei.github.io/tags/binary/"/>
    
  </entry>
  
  <entry>
    <title>WebSocket</title>
    <link href="https://jieyang-wei.github.io/2021/01/25/WebSocket/"/>
    <id>https://jieyang-wei.github.io/2021/01/25/WebSocket/</id>
    <published>2021-01-25T06:37:08.000Z</published>
    <updated>2021-04-19T06:44:46.062Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>WebSocket API 是 HTML5 标准的一部分， 但这并不代表 WebSocket 一定要用在 HTML 中，或者只能在基于浏览器的应用程序中使用。</p><p>实际上，许多语言、框架和服务器都提供了 WebSocket 支持：</p><ul><li>基于 <strong>C</strong> 的 libwebsocket.org</li><li>基于 <strong>Node.js</strong> 的 Socket.io</li><li>基于 <strong>Python</strong> 的 ws4py</li><li>基于 <strong>C++</strong> 的 WebSocket++</li><li><strong>Apache</strong> 对 WebSocket 的支持： Apache Module mod_proxy_wstunnel</li><li><strong>Nginx</strong> 对 WebSockets 的支持： NGINX as a WebSockets Proxy 、 NGINX Announces Support for WebSocket Protocol 、WebSocket proxying</li><li><strong>lighttpd</strong> 对 WebSocket 的支持：mod_websocket</li></ul><h2 id="nodejs"><a href="#nodejs" class="headerlink" title="nodejs"></a>nodejs</h2><h2 id="java"><a href="#java" class="headerlink" title="java"></a>java</h2><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><p>c++下没有原生的websocket低矮用，但是可以使用一些开源库实现，如<a class="link" href="https://download.csdn.net/download/weixin_34196559/10750141">websocketpp<i class="fas fa-external-link-alt"></i></a>等，下面讲解的是socket通信相关的实现</p><h3 id="IOS"><a href="#IOS" class="headerlink" title="IOS"></a>IOS</h3><p><a class="link" href="https://blog.csdn.net/xuqiang918/article/details/16841343?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-10&spm=1001.2101.3001.4242">IOS网络通信<i class="fas fa-external-link-alt"></i></a></p><p><a class="link" href="https://github.com/ok-fine/Socket-Cpp.git">代码 - master分支<i class="fas fa-external-link-alt"></i></a></p><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p><code>sockaddr</code>和<code>sockaddr_in</code>在字节长度上都为16个BYTE，可以进行转换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 通用的socket地址 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span>&#123;</span>  </span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> sa_family;    <span class="comment">//2 </span></span><br><span class="line">  <span class="keyword">char</span> sa_data[<span class="number">14</span>];            <span class="comment">//14</span></span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Internet socket */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>&#123;</span></span><br><span class="line">  <span class="keyword">short</span> <span class="keyword">int</span> sin_family;        <span class="comment">//2</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> sin_port; <span class="comment">//2</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>     <span class="comment">//4</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="number">8</span>];   <span class="comment">//8</span></span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 表示32位的IPv4地址 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span> u_char s_b1,s_b2,s_b3,s_b4; &#125; S_un_b;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span> u_short s_w1,s_w2; &#125; S_un_w;</span><br><span class="line">    u_long S_addr; </span><br><span class="line">  &#125; S_un;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> s_addr  S_un.S_addr</span></span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 或者 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>&#123;</span></span><br><span class="line">  <span class="keyword">in_addr_t</span> s_addr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>**inet_addr(“192.168.0.1”)**：将一个点分制的IP地址(如192.168.0.1)转换为上述结构中需要的32位二进制方式的IP地址</li></ul><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line"><span class="keyword">int</span> server_socket = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>domain</strong>（IOS系统使用 <code>AT_</code> ）<ul><li>PF_UNIX          Unix IPC通信 </li><li>PF_INET           IPV4通信（默认）</li><li>PF_INET6         IPV6 </li><li>PF_IPX              Novell IPX </li><li>PF_NETLINK    Kernel用户接口驱动程序 </li><li>PF_X25             X.25 </li><li>PF_AX25          AX.25 </li><li>PF_ATMPVC    ATM PVC </li><li>PF_APPLETALK    AppleTalk协议 </li><li>PF_PACKET     低级包接口 </li></ul></li><li><strong>type</strong><ul><li>SOCK_STREAM          使用TCP面向连接的通信包（默认）</li><li>SOCK_DGRAM           使用UDP无连接的通信包</li><li>SOCK_SEQPACKET    使用有固定最大长度的面向连接的通信包 </li><li>SOCK_RAW                 使用原IP包 </li><li>SOCK_RDM                 使用不保证次序的可靠数据报 </li></ul></li><li><strong>Protocol</strong><ul><li>一般使用与type对应的默认协议，用0表示。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recv</span><span class="params">(SOCKET socket, <span class="keyword">char</span> *buf, <span class="keyword">int</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="keyword">char</span> recv_msg[<span class="number">1024</span>];</span><br><span class="line">bzero(recv_msg, <span class="number">1024</span>);</span><br><span class="line"><span class="keyword">long</span> byte_num = recv(client_socket, recv_msg, <span class="number">1024</span>, <span class="number">0</span>);</span><br><span class="line">recv_msg[byte_num] = <span class="string">&#x27;\0&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>参数：<ul><li><strong>socket</strong>：已建立连接的套接字；</li><li><strong>buf</strong>：存放接收到的数据的缓冲区指针；</li><li><strong>len</strong>：buf的长度</li><li><strong>flags</strong>：调用方式： <ul><li><strong>0</strong>：接收的是正常数据，无特殊行为。 </li><li><strong>MSG_PEEK</strong>：系统缓冲区数据复制到提供的接收缓冲区，但是系统缓冲区内容并没有删除。 </li><li><strong>MSG_OOB</strong>：表示处理带外数据。 </li></ul></li></ul></li><li>返回值：接收成功时返回接收到的数据长度，连接结束时返回0，连接失败时返回SOCKET_ERROR。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">send</span><span class="params">(SOCKET socket, <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> len, <span class="keyword">int</span> flags)</span></span></span><br><span class="line">char send_msg[1024];</span><br><span class="line">bzero(send_msg, <span class="number">1024</span>);</span><br><span class="line">send(client_socket, send_msg, <span class="number">1024</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><ul><li>参数<ul><li><strong>socket</strong>：已建立连接的套接字</li><li><strong>buf</strong>：存放将要发送的数据的缓冲区指针；</li><li><strong>len</strong>：发送缓冲区中的字符数</li><li><strong>flags</strong>：控制数据传输方式： <ul><li><strong>0</strong>：接收的是正常数据，无特殊行为。 </li><li><strong>MSG_DONTROUTE</strong>：表示目标主机就在本地网络中，无需路由选择。 </li><li><strong>MSG_OOB</strong>：表示处理带外数据。 </li></ul></li></ul></li><li>返回值：发送成功时返回发送的数据长度，连接结束时返回0，连接失败时返回SOCKET_ERROR。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">bzero</span><span class="params">(<span class="keyword">void</span> *s, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="keyword">char</span> msg[<span class="number">1024</span>];</span><br><span class="line">bzero(msg, <span class="number">1024</span>);  </span><br><span class="line"><span class="comment">/* 相当于 */</span></span><br><span class="line"><span class="built_in">memset</span>(msg, <span class="number">0</span>, <span class="number">1024</span>);</span><br></pre></td></tr></table></figure><ul><li>头文件：#include &lt;string.h&gt;</li><li>功能：置字节字符串s的前n个字节为零且包括‘\0’</li><li>描述：<ul><li>string.h曾经是posix标准的一部分，但是在POSIX.1-2001标准里面，这些函数被标记为了遗留函数而不推荐使用。在POSIX.1-2008标准里已经没有这些函数了。推荐使用<code>memset</code>替代<code>bzero</code>。</li><li>bzero函数TC和VC中都没有，gcc中提供了</li></ul></li><li>无返回值</li></ul><blockquote><p>使用无阻塞的I/O方法 </p><p>什么是阻塞?<br>比如使用recv(),如果函数接受不到数据，就会阻塞程序的继续执行。 </p><p>如何防止阻塞?<br>使用fcntl()函数，把套接字设置为无阻塞模式。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">int</span> newsocket; </span><br><span class="line">&gt;newsocket = socket(PF_INET, SOCK_STREAM, <span class="number">0</span> ); </span><br><span class="line">&gt;fcntl( newsocket, F_SETEL, O_NONBLOCK ); </span><br></pre></td></tr></table></figure><p>以后使用recv()就不会阻塞了。 </p><p>另一种方式是使用多路套接字<code>select()</code> </p></blockquote><h5 id="select"><a href="#select" class="headerlink" title="select"></a>select</h5><p>select这个系统调用，是一种多路复用IO方案，可以同时对多个文件描述符进行监控，从而知道哪些<a class="link" href="https://blog.csdn.net/test1280/article/details/80293294">文件描述符(File Descriptor，FD)<i class="fas fa-external-link-alt"></i></a>可读，可写或者出错，不过select方法是阻塞的，可以设定超时时间。 </p><p>select使用的步骤如下:</p><ol><li>创建一个<code>fd_set</code>变量（fd_set实为包含了一个整数数组的结构体），用来存放所有的待检查的文件描述符</li><li>清空<code>fd_set</code>变量，并将需要检查的所有文件描述符加入<code>fd_set</code></li><li>调用select。若返回-1，则说明出错;返回0,则说明超时，返回正数，则为发生状态变化的文件描述符的个数</li><li>若select返回大于0,则依次查看哪些文件描述符变的可读，并对它们进行处理</li><li>返回步骤2，开始新一轮的检测</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfd, fd_set *rdset, fd_set *wrset, fd_set *exset, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>参数：<ul><li>maxfd：需要监视的最大的文件描述符值+1；</li><li>rdset：需要检测的可读文件描述符的集合</li><li>wrset：可写文件描述符的集合</li><li>exset：异常文件描述符的集合</li><li>timeval：用于描述一段时间长度，如果在这个时间内，需要监视的描述符没有事件发生则函数返回，返回值为0。</li></ul></li></ul><p><code>fd_set</code>类型通过下面四个宏来操作：</p><ol><li><code>FD_ZERO(fd_set *fdset);</code>将指定的文件描述符集清空，在对文件描述符集合进行设置前，必须对其进行初始化，如果不清空，由于在系统分配内存空间后，通常并不作清空处理，所以结果是不可知的。</li><li><code>FD_SET(fd_set *fdset);</code>用于在文件描述符集合中增加一个新的文件描述符。</li><li><code>FD_CLR(fd_set *fdset);</code>用于在文件描述符集合中删除一个文件描述符。 </li><li><code>FD_ISSET(int fd, fd_set *fdset);</code>用于测试指定的文件描述符是否在该集合中。</li></ol><h5 id="kqueue"><a href="#kqueue" class="headerlink" title="kqueue"></a>kqueue</h5><p>Mac是基于BSD的内核，所使用的是kqueue（kernel event notification mechanism，详细内容可以Mac中 <code>man 2 kqueue</code>）</p><ul><li>kqueue比select先进的地方就在于使用<strong>事件触发</strong>的机制，且其调用无需每次对所有的文件描述符进行遍历，返回的时候只返回需要处理的事件，而不像select中需要自己去一个个通过FD_ISSET检查。</li><li>kqueue默认的触发方式是level 水平触发，可以通过设置event的flag为<code>EV_CLEAR</code> 使得这个事件变为边沿触发,可能epoll的触发方式无法细化到单个event，需要查证。</li><li></li></ul><p>kqueue中涉及两个系统调用，kqueue()和kevent()</p><ul><li><code>kqueue()</code>创建kernel级别的事件队列，并返回队列的文件描述符</li><li><code>kevent()</code>往事件队列中加入订阅事件，或者返回相关的事件数组</li></ul><p>kqueue使用的流程一般如下：</p><ul><li>创建kqueue</li><li>创建<code>struct kevent</code>变量（注意这里的kevent是结构体类型名），可以通过<code>EV_SET</code>这个宏提供的快捷方式进行创建</li><li>通过kevent系统调用将创建好的kevent结构体变量加入到kqueue队列中，完成对指定文件描述符的事件的订阅</li><li>通过kevent系统调用获取满足条件的事件队列，并对每一个事件进行处理</li></ul><h4 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h4><img src="/2021/01/25/WebSocket/1.png" alt="截屏2021-01-31 下午2.57.07" style="zoom:45%;"> <p><strong>1. sever</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 绑定server socket的ip、端口等信息 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">server_addr.sin_len = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">server_addr.sin_family = AF_INET;<span class="comment">//Address families AF_INET互联网地址簇</span></span><br><span class="line">server_addr.sin_port = htons(<span class="number">11332</span>);</span><br><span class="line">server_addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">bzero(&amp;(server_addr.sin_zero),<span class="number">8</span>);</span><br></pre></td></tr></table></figure><ul><li><p>一般情况下都用<code>server_addr.sin_addr.s_addr = htonl(INADDR_ANY)</code></p><blockquote><p>比如你的机器有三个ip<br> 192.168.1.1<br> 202.202.202.202<br> 61.1.2.3  </p><p> 如果你serv.sin_addr.s_addr=inet_addr(“192.168.1.1”);  </p><p> 然后监听100端口  </p><p> 这时其他机器只有connect  192.168.1.1:100端口才能成功。<br> connect  202.202.202.202:100和connect  61.1.2.3:100都会失败。  </p><p> 如果serv.sin_addr.s_addr=htonl(INADDR_ANY);  的话，无论连接哪个ip都可以连上的，这就是为什么这样选择的理由</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* server socket工作流程 */</span></span><br><span class="line"><span class="comment">//创建socket</span></span><br><span class="line"><span class="keyword">int</span> server_socket = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);<span class="comment">//SOCK_STREAM 有连接</span></span><br><span class="line"><span class="keyword">if</span> (server_socket == <span class="number">-1</span>) &#123;</span><br><span class="line">  perror(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//绑定socket</span></span><br><span class="line"><span class="comment">//将创建的socket绑定到本地的IP地址和端口，此socket是半相关的，只是负责侦听客户端的连接请求，并不能用于和客户端通信</span></span><br><span class="line"><span class="keyword">int</span> bind_result = bind(server_socket, (struct sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line"><span class="keyword">if</span> (bind_result == <span class="number">-1</span>) &#123;</span><br><span class="line">  perror(<span class="string">&quot;bind error&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//listen侦听</span></span><br><span class="line"><span class="comment">//第一个参数是套接字</span></span><br><span class="line"><span class="comment">//第二个参数为等待接受的连接的队列的大小，在connect请求过来的时候,完成三次握手后先将连接放到这个队列中，直到被accept处理。如果这个队列满了，且有新的连接的时候，对方可能会收到出错信息。</span></span><br><span class="line"><span class="keyword">if</span> (listen(server_socket, <span class="number">5</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">  perror(<span class="string">&quot;listen error&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//accept接收来自客户端的链接请求(使用下面的select不需要这一部分)</span></span><br><span class="line"><span class="comment">//返回的client_socket为一个全相关的socket，其中包含client的地址和端口信息，通过client_socket可以和客户端进行通信。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>;</span></span><br><span class="line"><span class="keyword">socklen_t</span> address_len;</span><br><span class="line"><span class="keyword">int</span> client_socket = accept(server_socket, (struct sockaddr *)&amp;client_address, &amp;address_len);</span><br><span class="line"><span class="keyword">if</span> (client_socket == <span class="number">-1</span>) &#123;</span><br><span class="line">  perror(<span class="string">&quot;accept error&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 信息交流 */</span></span><br><span class="line">fd_set server_fd_set;</span><br><span class="line"><span class="keyword">int</span> max_fd = <span class="number">-1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">tv.tv_sec = <span class="number">20</span>;  <span class="comment">// seconds</span></span><br><span class="line">tv.tv_usec = <span class="number">0</span>;  <span class="comment">// microseconds</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">  FD_ZERO(&amp;server_fd_set);</span><br><span class="line">  <span class="comment">//标准输入</span></span><br><span class="line">  FD_SET(STDIN_FILENO, &amp;server_fd_set);</span><br><span class="line">  <span class="keyword">if</span> (max_fd &lt; STDIN_FILENO) &#123;</span><br><span class="line">    max_fd = STDIN_FILENO;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//服务器端socket</span></span><br><span class="line">  FD_SET(server_sock_fd, &amp;server_fd_set);</span><br><span class="line">  <span class="keyword">if</span> (max_fd &lt; server_sock_fd) &#123;</span><br><span class="line">    max_fd = server_sock_fd;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//客户端连接</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CONCURRENT_MAX; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (client_fds[i]!=<span class="number">0</span>) &#123;</span><br><span class="line">      FD_SET(client_fds[i], &amp;server_fd_set);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (max_fd &lt; client_fds[i]) &#123;</span><br><span class="line">        max_fd = client_fds[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> ret = select(max_fd+<span class="number">1</span>, &amp;server_fd_set, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;tv);</span><br><span class="line">  <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;select 出错\n&quot;</span>);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;select 超时\n&quot;</span>);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//ret为未状态发生变化的文件描述符的个数</span></span><br><span class="line">    <span class="keyword">if</span> (FD_ISSET(STDIN_FILENO, &amp;server_fd_set)) &#123;</span><br><span class="line">      <span class="comment">//标准输入</span></span><br><span class="line">      bzero(input_msg, BUFFER_SIZE);</span><br><span class="line">      fgets(input_msg, BUFFER_SIZE, <span class="built_in">stdin</span>);</span><br><span class="line">      <span class="comment">//输入 &quot;.quit&quot; 则退出服务器</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strcmp</span>(input_msg, QUIT_CMD) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;CONCURRENT_MAX; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (client_fds[i]!=<span class="number">0</span>) &#123;</span><br><span class="line">          send(client_fds[i], input_msg, BUFFER_SIZE, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (FD_ISSET(server_sock_fd, &amp;server_fd_set)) &#123;</span><br><span class="line">      <span class="comment">//有新的连接请求</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>;</span></span><br><span class="line">      <span class="keyword">socklen_t</span> address_len;</span><br><span class="line">      <span class="keyword">int</span> client_socket_fd = accept(server_sock_fd, (struct sockaddr *)&amp;client_address, &amp;address_len);</span><br><span class="line">      <span class="keyword">if</span> (client_socket_fd &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CONCURRENT_MAX; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (client_fds[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            index = i;</span><br><span class="line">            client_fds[i] = client_socket_fd;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;新客户端(%d)加入成功 %s:%d \n&quot;</span>,index,inet_ntoa(client_address.sin_addr),ntohs(client_address.sin_port));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          bzero(input_msg, BUFFER_SIZE);</span><br><span class="line">          <span class="built_in">strcpy</span>(input_msg, <span class="string">&quot;服务器加入的客户端数达到最大值,无法加入!\n&quot;</span>);</span><br><span class="line">          send(client_socket_fd, input_msg, BUFFER_SIZE, <span class="number">0</span>);</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;客户端连接数达到最大值，新客户端加入失败 %s:%d \n&quot;</span>,inet_ntoa(client_address.sin_addr),ntohs(client_address.sin_port));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;CONCURRENT_MAX; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (client_fds[i]!=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(client_fds[i], &amp;server_fd_set)) &#123;</span><br><span class="line">          <span class="comment">//处理某个客户端过来的消息</span></span><br><span class="line">          bzero(recv_msg, BUFFER_SIZE);</span><br><span class="line">          <span class="keyword">long</span> byte_num = recv(client_fds[i],recv_msg,BUFFER_SIZE,<span class="number">0</span>);</span><br><span class="line">          <span class="keyword">if</span> (byte_num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (byte_num &gt; BUFFER_SIZE) &#123;</span><br><span class="line">              byte_num = BUFFER_SIZE;</span><br><span class="line">            &#125;</span><br><span class="line">            recv_msg[byte_num] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端(%d):%s\n&quot;</span>,i,recv_msg);</span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span>(byte_num &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;从客户端(%d)接受消息出错.\n&quot;</span>,i);</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            FD_CLR(client_fds[i], &amp;server_fd_set);</span><br><span class="line">            client_fds[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端(%d)退出了\n&quot;</span>,i);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. client</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建需要通信的server socket的IP、端口等信息 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">server_addr.sin_len = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">server_addr.sin_family = AF_INET;</span><br><span class="line">server_addr.sin_port = htons(<span class="number">11332</span>);</span><br><span class="line">server_addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">bzero(&amp;(server_addr.sin_zero),<span class="number">8</span>);</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建socket通信连接 */</span></span><br><span class="line"><span class="comment">//创建socket</span></span><br><span class="line"><span class="keyword">int</span> client_socket = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (client_socket == <span class="number">-1</span>) &#123;</span><br><span class="line">  perror(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接client和server的通信道路</span></span><br><span class="line"><span class="keyword">int</span> connect_result = connect(client_socket, (struct sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(struct sockaddr_in));</span><br><span class="line"></span><br><span class="line"><span class="comment">//connect 成功之后，其实系统将你创建的socket绑定到一个系统分配的端口上，且其为全相关，包含服务器端的信息，可以用来和服务器端进行通信。</span></span><br><span class="line"><span class="keyword">char</span> recv_msg[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">char</span> reply_msg[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">if</span> (connect_result == <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    bzero(recv_msg, <span class="number">1024</span>);</span><br><span class="line">    bzero(reply_msg, <span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">long</span> byte_num = recv(client_socket, recv_msg, <span class="number">1024</span>, <span class="number">0</span>);</span><br><span class="line">    recv_msg[byte_num] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;server said:%s\n&quot;</span>,recv_msg);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client reply:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,reply_msg);</span><br><span class="line">    <span class="keyword">if</span> (send(client_socket, reply_msg, <span class="number">1024</span>, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">      perror(<span class="string">&quot;send error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="WIN"><a href="#WIN" class="headerlink" title="WIN"></a>WIN</h3><p>模仿Unix Socket技术实现</p><h4 id="操作流程-1"><a href="#操作流程-1" class="headerlink" title="操作流程"></a>操作流程</h4><img src="/2021/01/25/WebSocket/2.png" alt="截屏2021-01-31 下午2.57.07" style="zoom:45%;"> <h2 id="php"><a href="#php" class="headerlink" title="php"></a>php</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;h1 id=&quot;使用&quot;&gt;&lt;a href=&quot;#使用&quot; class=&quot;headerlink&quot; title=&quot;使用&quot;&gt;&lt;/a&gt;使用&lt;/h1&gt;&lt;p&gt;Web</summary>
      
    
    
    
    <category term="Course" scheme="https://jieyang-wei.github.io/categories/Course/"/>
    
    <category term="Network" scheme="https://jieyang-wei.github.io/categories/Course/Network/"/>
    
    
    <category term="socket" scheme="https://jieyang-wei.github.io/tags/socket/"/>
    
  </entry>
  
  <entry>
    <title>C++</title>
    <link href="https://jieyang-wei.github.io/2021/01/23/C++/"/>
    <id>https://jieyang-wei.github.io/2021/01/23/C++/</id>
    <published>2021-01-23T10:13:55.000Z</published>
    <updated>2021-04-19T06:42:27.335Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h1 id="语法教程"><a href="#语法教程" class="headerlink" title="语法教程"></a>语法教程</h1><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><h3 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h3><p><strong>bool</strong></p><p><strong>char</strong></p><p><strong>int</strong></p><p><strong>float</strong></p><p><strong>double</strong></p><p><strong>void</strong></p><p><strong>wchar_t</strong></p><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p><a class="link" href="https://www.cnblogs.com/wuruofeng/p/10412559.html">char,char*,string转换<i class="fas fa-external-link-alt"></i></a></p><h3 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h3><p>枚举类型</p><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ofstream outfile;</span><br><span class="line"><span class="comment">/* 打开文件 */</span></span><br><span class="line">outfile.open(<span class="string">&quot;file.txt&quot;</span>, ios::out | ios::trunc ); <span class="comment">//模式结合</span></span><br><span class="line"><span class="comment">/* 关闭文件*/</span></span><br><span class="line">outfile.close();</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, ios::openmode mode)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>filename：要打开的文件的名称和位置（绝对路径）</p><blockquote><p>相对路径的位置取得是可执行文件的位置，而不是代码文件所在位置</p><ul><li><strong>xcode</strong>：<code>/Users/username/Library/Developer/Xcode/DerivedData/区块链-cwiqijiormracofndmvocmukooxi/Build/Products/Debug</code></li></ul></blockquote></li><li><p>mode：文件的打开模式（早期c++用ios代替ios_base）</p><ul><li><strong>ios::app</strong>      追加模式。所有写入都追加到文件末尾。</li><li><strong>ios::ate</strong>       文件打开后定位到文件末尾</li><li><strong>ios::in</strong>          打开文件用于读取（ifstream默认）</li><li><strong>ios::out</strong>       打开文件用于写入（ofstream默认）</li><li><strong>ios::trunc</strong>   如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0</li></ul><blockquote><p>ios是C++的一个类，ios_base是有关输入输出流的类的公共基类，<strong>ios</strong>继承了basic_ios类，而basic_ios又继承了<strong>ios_base</strong>，所以说ios_base也是ios类的间接基类。</p><ul><li>其中ios_base类具有静态常量in、out、binary等（在VS中ios_base类还有一个叫_Iosb的基类，这些静态成员在_Iosb中，但是C++标准没有这种说法），</li><li>ios_base类也是basic_ostream、basic_istream等多个类的直接或间接基类。从这个意义上，写ostream::binary什么的可能也没什么问题，但是习惯上都用ios::in、ios::binary，或者ios_base::in、ios_base::binary之类的。</li><li>所以，综上，ios类继承了ios_base类的静态成员变量in、out、binary等，所以既可以用ios，也可以用ios_base。望采纳。</li></ul></blockquote></li></ul><h3 id="ostream"><a href="#ostream" class="headerlink" title="ostream"></a>ostream</h3><p>该数据类型表示输出文件流，用于创建文件并向文件写入信息。</p><h3 id="istream"><a href="#istream" class="headerlink" title="istream"></a>istream</h3><p>该数据类型表示输入文件流，用于从文件读取信息。</p><h3 id="fstream"><a href="#fstream" class="headerlink" title="fstream"></a>fstream</h3><p>该数据类型通常表示文件流，且同时具有 ofstream 和 ifstream 两种功能</p><h3 id="文件夹"><a href="#文件夹" class="headerlink" title="文件夹"></a>文件夹</h3><p><a class="link" href="https://blog.csdn.net/nuptwanglei/article/details/43051643">函数说明<i class="fas fa-external-link-alt"></i></a></p><p><strong>opendir</strong>（打开目录）</p><ul><li>相关函数：open，readdir，closedir，rewinddir，seekdir，telldir，scandir </li><li>表头文件：<code>#include&lt;dirent.h&gt; </code></li><li>定义函数：<code>DIR * opendir(const char * name); </code></li><li>函数说明：<ul><li>opendir()用来打开参数name指定的目录，并返回DIR*形态的目录流，和open()类似，接下来对目录的读取和搜索都要使用此返回值。 </li></ul></li><li>返回值：成功则返回 *<em>DIR**</em> 型态的目录流，打开失败则返回NULL。 </li><li>错误代码<ul><li>EACCESS   权限不足</li><li>EMFILE      已达到进程可同时打开的文件数上限</li><li>ENFILE       已达到系统可同时打开的文件数上限</li><li>ENOTDIR   参数name非真正的目录 </li><li>ENOENT    参数name 指定的目录不存在，或是参数name 为一空字符串</li><li>ENOMEM  核心内存不足。</li></ul></li></ul><p><strong>readdir（读取目录）</strong></p><ul><li><p>相关函数：open，opendir，closedir，rewinddir，seekdir，telldir，scandir </p></li><li><p>表头文件：<code>#include&lt;dirent.h&gt; </code></p></li><li><p>定义函数：<code>struct dirent * readdir(DIR * dir); </code></p></li><li><p>函数说明：</p><ul><li><p>readdir()返回参数dir目录流的下个目录进入点。 </p></li><li><pre><code class="c++">struct dirent&#123;  ino_t d_ino;   //此目录进入点的inode  ff_t d_off;    //目录文件开头至此目录进入点的位移，当前目录下为0  signed short int d_reclen;  //d_name的长度，不包含NULL字符  unsigned char d_type;       //d_name 所指的文件类型  //DT_REG 文件    DT_DIR 文件夹  har d_name[256];  //文件名&#125;;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>返回值：成功则返回下个目录进入点。有错误发生或读取到目录文件尾则返回NULL。</p></li><li><p>错误代码</p><ul><li>EBADF   参数dir为无效的目录流</li></ul></li></ul><p><strong>closedir（关闭目录）</strong></p><ul><li>相关函数：opendir</li><li>表头文件：<code>#include&lt;dirent.h&gt; </code></li><li>定义函数：<code>int closedir(DIR *dir);</code></li><li>函数说明：closedir()关闭参数dir所指的目录流。</li><li>返回值：关闭成功则返回0，失败返回-1，错误原因存于errno 中</li><li>错误代码<ul><li>EBADF   参数dir为无效的目录流</li></ul></li></ul><p><strong>示例</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getFiles</span><span class="params">(<span class="keyword">char</span> *path, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; files)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dirp</span>;</span></span><br><span class="line">    DIR* dir = opendir(path);</span><br><span class="line">    <span class="keyword">while</span> ((dirp = readdir(dir)) != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dirp-&gt;d_type == DT_REG) &#123;</span><br><span class="line">            <span class="comment">// 文件</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, dirp-&gt;d_name);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dirp-&gt;d_type == DT_DIR) &#123;</span><br><span class="line">            <span class="comment">// 文件夹</span></span><br><span class="line">            <span class="comment">// getFiles(dirp-&gt;d_name, files);  //迭代</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    closedir(dir);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p><a class="link" href="https://blog.csdn.net/touzani/article/details/1637776">教程<i class="fas fa-external-link-alt"></i></a></p><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h1 id="资源库"><a href="#资源库" class="headerlink" title="资源库"></a>资源库</h1><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><h2 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h2><h3 id="lt-time-h-gt"><a href="#lt-time-h-gt" class="headerlink" title="&lt;time.h&gt;"></a>&lt;time.h&gt;</h3><p><strong>struct timespec</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">time_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _TIMESPEC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _TIMESPEC</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span></span><br><span class="line"><span class="keyword">time_t</span> tv_sec;  <span class="comment">// seconds </span></span><br><span class="line"><span class="keyword">long</span> tv_nsec;   <span class="comment">// nanoseconds, 纳秒</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>一般由函数<code>int clock_gettime(clock id_t, struct timespec*)</code>获取特定时钟的时间</p><ul><li><p>常用clock有如下4种：</p><ul><li><strong>CLOCK_REALTIME</strong>   统当前时间，从1970年1.1日算起</li><li><strong>CLOCK_MONOTONIC</strong>   系统的启动时间，不能被设置</li><li><strong>CLOCK_PROCESS_CPUTIME_ID</strong>   本进程运行时间</li><li><strong>CLOCK_THREAD_CPUTIME_ID</strong>     本线程运行时间</li></ul></li><li><p>函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct tm* <span class="title">localtime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">time_t</span>* clock)</span></span>;  <span class="comment">//线程不安全</span></span><br><span class="line"><span class="function">struct tm* <span class="title">localtime_r</span><span class="params">(<span class="keyword">const</span> <span class="keyword">time_t</span>* timer, struct tm* result )</span></span>;<span class="comment">//线程安全</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">strftime</span><span class="params">(<span class="keyword">char</span>* ptr, <span class="keyword">size_t</span> maxsize, <span class="keyword">const</span> <span class="keyword">char</span>* format, <span class="keyword">const</span> struct tm* timeptr )</span></span>;</span><br></pre></td></tr></table></figure></li></ul><p><strong>struct timeval</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line"><span class="keyword">time_t</span> tv_sec;  <span class="comment">// seconds </span></span><br><span class="line"><span class="keyword">long</span> tv_usec;   <span class="comment">// microseconds </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timezone</span>&#123;</span> </span><br><span class="line"><span class="keyword">int</span> tz_minuteswest; <span class="comment">//miniutes west of Greenwich </span></span><br><span class="line"><span class="keyword">int</span> tz_dsttime; <span class="comment">//type of DST correction </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一般由函数<code>int gettimeofday(struct timeval* tv, struct timezone* tz)</code>获取系统的时间 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;h1 id=&quot;语法教程&quot;&gt;&lt;a href=&quot;#语法教程&quot; class=&quot;headerlink&quot; title=&quot;语法教程&quot;&gt;&lt;/a&gt;语法教程&lt;/h</summary>
      
    
    
    
    <category term="Notebook" scheme="https://jieyang-wei.github.io/categories/Notebook/"/>
    
    <category term="Programming language" scheme="https://jieyang-wei.github.io/categories/Notebook/Programming-language/"/>
    
    
    <category term="C++" scheme="https://jieyang-wei.github.io/tags/C/"/>
    
    <category term="编程语言" scheme="https://jieyang-wei.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>毕业设计</title>
    <link href="https://jieyang-wei.github.io/2021/01/04/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    <id>https://jieyang-wei.github.io/2021/01/04/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/</id>
    <published>2021-01-04T11:03:58.000Z</published>
    <updated>2021-04-18T15:55:10.359Z</updated>
    
    <content type="html"><![CDATA[<h1 id="例会"><a href="#例会" class="headerlink" title="例会"></a>例会</h1><h2 id="2021-1-4-A"><a href="#2021-1-4-A" class="headerlink" title="2021.1.4 - A"></a>2021.1.4 - A</h2><h3 id="A-Mixing-Scheme-Using-a-Decentralized-Signature-Protocol-for-Privacy-Protection-in-Bitcoin-Blockchain"><a href="#A-Mixing-Scheme-Using-a-Decentralized-Signature-Protocol-for-Privacy-Protection-in-Bitcoin-Blockchain" class="headerlink" title="A Mixing Scheme Using a Decentralized Signature Protocol for Privacy Protection in Bitcoin Blockchain"></a>A Mixing Scheme Using a Decentralized Signature Protocol for Privacy Protection in Bitcoin Blockchain</h3><p>BTC的匿名性保证 - 混币服务器</p><p>现有</p><ul><li><p><strong>Coinjoin</strong></p></li><li><p><strong>Coin Shuffle</strong>：Cut the connection between input address and output address</p></li><li><p><strong>Altcoin</strong></p></li><li><p><strong>Blind token</strong></p></li></ul><blockquote><p>现在的BTC系统，因为服务器节点远近问题，一个交易发布后会先被距离近的节点捕捉到，此时可以通过交易的时间未知等细节信息，定位到交易的ip地址，最后根据ip地址可以在线下找出交易双方的真实身份信息</p></blockquote><p>通过协商实现交易</p><h3 id="Differential-Privacy-Based-Blockchain-for-Industrial-Internet-of-Things"><a href="#Differential-Privacy-Based-Blockchain-for-Industrial-Internet-of-Things" class="headerlink" title="Differential Privacy-Based Blockchain for Industrial Internet-of-Things"></a>Differential Privacy-Based Blockchain for Industrial Internet-of-Things</h3><p>区块链边缘计算应用在物联网上的隐私保护</p><ul><li>边缘节点</li><li>拆分隐私处理</li></ul><h2 id="2021-1-11-A-B"><a href="#2021-1-11-A-B" class="headerlink" title="2021.1.11 - A + B"></a>2021.1.11 - A + B</h2><h3 id="自主可控区块链关键技术"><a href="#自主可控区块链关键技术" class="headerlink" title="自主可控区块链关键技术"></a>自主可控区块链关键技术</h3><p>区块链上升国家战略</p><p><strong>挑战</strong></p><ul><li>如何解决高效自主共识协议的一致性问题，缩短区块链网络中共识时间延时</li><li>数据自主存储的空间问题，在公有链环境下，比特币2019年已达到240G的存储空间，每年以50GB的增长</li><li>多链的跨链的自主交互问题，各种不同类型的区块链平台产生数据孤岛和价值孤岛问题</li></ul><p><strong>三大技术</strong></p><ol><li>数据保全 - 密码算法</li><li>共识算法<ol><li>PoW</li><li>新型共识机制 - 易构共识</li></ol></li><li>智能合约</li></ol><h3 id="预言机"><a href="#预言机" class="headerlink" title="预言机"></a>预言机</h3><p>4种推拉方式</p><h1 id="研读论文"><a href="#研读论文" class="headerlink" title="研读论文"></a>研读论文</h1><h2 id="1、Conflux共识机制"><a href="#1、Conflux共识机制" class="headerlink" title="1、Conflux共识机制"></a>1、Conflux共识机制</h2><p>Scaling Nakamoto Consensus to Thousands of Transactions per Second</p><p>最近arXiv上发现一篇论文（2018/8/2发表，”Scaling Nakamoto Consensus to Thousands of Transactions per Second”），作者来自清华大学，卡内基梅隆大学，以及多伦多大学，提出了<strong>Conflux共识机制</strong></p><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>本文提出了一个快速、可扩展和去中心化的区块链系统Conflux，它乐观地处理并发块而不丢弃任何as叉。conflux共识协议将块之间的关系表示为一个直接的非循环图，并在块的总顺序上达成共识。然后，Conflux从区块顺序确定地推导出transactiontotal顺序作为区块链分类帐。我们在Amazon EC2集群上评估了高达20k的全节点的Con-flux。Conflux在4.5-7.4分钟内实现了5.76GB/h的事务吞吐量。对于典型的比特币交易来说，其吞吐量相当于每秒6400笔交易。我们的结果还表明，<strong>当运行Conflux时，共识协议不再是吞吐量的瓶颈。相反，瓶颈在于单个节点的处理能力</strong></p><h2 id="2、区块链共识算法效能优化研究进展"><a href="#2、区块链共识算法效能优化研究进展" class="headerlink" title="2、区块链共识算法效能优化研究进展"></a>2、区块链共识算法效能优化研究进展</h2><h3 id="摘要-1"><a href="#摘要-1" class="headerlink" title="摘要"></a>摘要</h3><p>近年来，区块链及其相关技术发展迅速，区块链也迅速成为了学术界的热门领域。然而，<strong>区块链的共识算法在资源花销、能源耗费和性能上都饱受诟病，因此需要制定一个能衡量其执行效率的指标，以评价其设计是否优良</strong>。由于共识算法的资源花销、能源耗费以及性能之间相互关联且关系复杂，因此有必要从“效能”的角度对现有区块链的共识算法加以分析，并总结 研究思路。文中总结了区块链共识算法的效能优化研究进展。首先定义区块链共识算法的效能为“在正确性和有效性的前提 下计算的共识算法<strong>性能、所需资源和能源消耗</strong>”，并分析这3个影响因素的关联;然后从公有链与联盟链两方面对共识算法的效 能优化进行整理与总结;最后从多链区块链、多个区块链与 BaS这3个方面提出关于共识算法的资源共享问题，以供研究人员 参考。</p><h2 id="3、区块链共识机制综述"><a href="#3、区块链共识机制综述" class="headerlink" title="3、区块链共识机制综述"></a>3、区块链共识机制综述</h2><h3 id="摘要-2"><a href="#摘要-2" class="headerlink" title="摘要"></a>摘要</h3><p>区块链能够有效融合物联网、5G、大数据和人工智能等技术，在新型基础设施建设中具有重要作用。共识机制作为区块链的核心技术，能够保障区块链数据库的一致性和正确性，从而决定区块链的安全性、扩展性、吞吐量等相关性能。根据区块链共识机制的技术路线，将其细分为 3 类单一共识机制和 6 类混合共识机制。从原理实现角度，系 统描述共识机制的理论技术，归纳节点达成一致所需的运算操作并评价共识机制的优缺点。从工程应用角度，具体分 析共识机制的应用情况，介绍区块链项目并对比共识机制的关键性能。针对现有共识机制研究中存在的能耗与效率 问题给出相应的解决方案，并对其奖惩制度、网络分片与存储分片技术等下一步研究方向进行展望</p><h2 id="4、-区块链技术及应用研究综述"><a href="#4、-区块链技术及应用研究综述" class="headerlink" title="4、 区块链技术及应用研究综述"></a>4、 区块链技术及应用研究综述</h2><h3 id="摘要-3"><a href="#摘要-3" class="headerlink" title="摘要"></a>摘要</h3><p>针对区块链可构建信任和传递价值特性，从数据层面、财务层面、应用层面、体制 层面等多角度研究区块链技术及应用价值重构，对利用区块链技术在数字资产存证、保护 用户隐私、 数字资源流通、 <strong>跨部门信息系统互联与数据可信共享</strong>等应用场景研究进行综述，形成基于区块链的安全可信、稳定可靠、高效便捷的应用场景和模式，为区块链技术与各领域深度融合的技术路径创新与数据价值重构提供一定的借鉴参考。</p><p>共识机制解决全网节点之间数据验证同步和激励相融问题。 目前主流的共识机制有四种:PoW、 PoS，DPoS、PBFT。</p><ol><li>PoW 机制<ul><li>PoW 是最经典的共识机制. 基于给定难度值在 最快时间通过迭代计算得到一个随机数 Nonce 以 争夺记账权， 对获得优先记账权的节点给予一定激 励。 PoW 共识流程如图 4 所示。</li></ul></li><li>PoS 机制<ul><li>PoS 通过计算全网节点的持有币量和持币时间 来决定投票权和打包权。 拥有打包权的节点打包交 易后对全网广播， 拥有投票权的节点投票决定最终上链的区块， 根据每个节点持有币量和持币时间等 比例降低计算随机数的难度。</li></ul></li><li>DPoS 机制<ul><li>DPoS 是 PoS 的升级版， 由全网普通节点投票 选出一些代理节点进行交易验证和记账， 代理节点 完成共识后会获得一定数量的激励， 不合格的代理 节点会被投票替换。</li></ul></li><li>PBFT 算法<ul><li>PBFT 广泛使用于联盟链，是一种能容忍全网 1 / 3 节点出现错误或异常的分布式系统共识算法， 该算法依赖节点对同一信息的多次重复确认， 从而 达到全网共识。</li></ul></li></ol><p><strong>电子政务领域</strong>：</p><p>通过区块链技术将数据、信息上链，实现对数据的记录和追踪， 能缩短行政办公周期， 加快资金流动， 对于提升政府公共服务管理水平和政府办公效率具有重要的意义。 目前基于区块链的电子政务场 景主要集中在政务服务、综合监管、智慧法院、数字 身份等领域。</p><h2 id="5、物联网中区块链的轻量级共识机制"><a href="#5、物联网中区块链的轻量级共识机制" class="headerlink" title="5、物联网中区块链的轻量级共识机制"></a>5、物联网中区块链的轻量级共识机制</h2><p>A lightweight consensus mechanism for blockchain in IoT</p><h3 id="摘要-4"><a href="#摘要-4" class="headerlink" title="摘要"></a>摘要</h3><p>在物联网应用中，区块链消除了对单一可信权威的依赖，增强了潜在的可伸缩性和可靠性。区块链中使用的现有共识方法需要较高的能量消耗、具有可信权威的巨大计算能力或挖掘区块的证据。资源受限的物联网设备需要一种轻量级和低延迟的共识机制。与绝对共识方法相比，无信任概率共识方法允许每个节点都参与共识，增强了事务的鲁棒性和可靠性。对于物联网环境中的非合作区块链，我们提出了一种轻量级的耗时工作和运气(PoEWAL)一致性证明方法。PoEWAL消耗更少的能量，需要更少的计算能力和低延迟。我们利用康智奇库雅模拟器分析了PoEWAL在资源受限设备中的适用性。实验结果表明，在不同的难度水平下，能量消耗都很低，证明了PoEWAL的可行性。将PoEWAL与现有的概率共识方法如工作证明、权益证明、活动证明、algorand、权威证明等在能量、共识时间、网络延迟等方面进行比较，确认PoEWAL是适用于物联网区块链的共识方法。</p><h2 id="6、一种基于改进遗传算法的共识机制"><a href="#6、一种基于改进遗传算法的共识机制" class="headerlink" title="6、一种基于改进遗传算法的共识机制"></a>6、一种基于改进遗传算法的共识机制</h2><p>A Consensus Mechanism Based on an Improved Genetic Algorithm</p><h3 id="摘要-5"><a href="#摘要-5" class="headerlink" title="摘要"></a>摘要</h3><p><strong>区块链技术的一个重要特点是所有参与者共同维护事务数据，无需集成控制就可以实现相互信任关系，这依赖于分布式共识算法</strong>。实用拜占庭容错算法(PBFT)是一种基于状态机复制的容错算法，它解决了拜占庭错误，即节点的恶意行为。在PBFT中，所有参与节点分为主节点和备份节点。当这个主节点提交错误或失败时，它将再次选择一个主节点进行消息通信。遗传算法(GA)是受自然生物遗传进化准则“自然选择，生存拟合检验”启发而提出的一种计算机模拟研究方法。遗传算法实际上是一种寻找最优解的方法。据此，在PBFT算法中选择最佳主节点，以提高一致性效率。<strong>共识算法是区块链技术中去中心化特性的保证</strong>。PBFT算法是一种常用的共识算法。但该算法存在如下问题:当主节点发生故障时，必须重新选择该节点，导致协商效率降低。提出了一种基于改进遗传算法的一致性机制，利用改进的遗传算法来选择主节点。根据遗传算法选择最佳的主节点，使其与其他备份节点的交易效率达到最高。改进的一致性算法可以有效地减少系统延迟，提高一致性效率。</p><h2 id="7、pbft启发的区块链共识和Neo-dBFT增强的挑战"><a href="#7、pbft启发的区块链共识和Neo-dBFT增强的挑战" class="headerlink" title="7、pbft启发的区块链共识和Neo dBFT增强的挑战"></a>7、pbft启发的区块链共识和Neo dBFT增强的挑战</h2><p>Challenges of PBFT-Inspired Consensus for Blockchain and Enhancements over Neo dBFT</p><h3 id="摘要-6"><a href="#摘要-6" class="headerlink" title="摘要"></a>摘要</h3><p><strong>共识机制是处理谈判和协议的核心特征</strong>。区块链技术已经引入了不同类型的共识机制，从繁重的计算任务到错综复杂的数学证明协议。本文从实际的拜占庭容错(PBFT)中得到启发，提出了Neo区块链的先驱代理拜占庭容错(dBFT)协议。除了介绍它的历史，本研究描述了证明和说教的例子，以及新颖的设计和扩展Neo dBFT与多个区块的建议。最后，我们讨论了在处理强大的拜占庭对手时所面临的挑战，并针对当前的弱同步问题和增强系统抗攻击的鲁棒性提出了PBFT启发的解决方案。<strong>主要贡献</strong>:概述了pbft启发的区块链共识的历史，强调了其目前在文献、挑战和假设方面的重要性。在分布式共识领域做出贡献，提出了Neo dBFT (dBFT 2.0+、dBFT 3.0和dBFT 3.0+)的新扩展，对创新共识机制有新的见解。</p><h2 id="8、区块链原理及关键技术"><a href="#8、区块链原理及关键技术" class="headerlink" title="8、区块链原理及关键技术"></a>8、区块链原理及关键技术</h2><h3 id="摘要-7"><a href="#摘要-7" class="headerlink" title="摘要"></a>摘要</h3><p>区块链是综合运用密码学、分布式数据库、P2P 通信、智能合约等的技术，在一个去中心化、去信任网络中，利用加密算法在链式数据结构中验证和存储数据。区块链技术是一项具有普适性的底层技术架构，它通过共识机制在分布式节点上生成和同步数据，借助可编程脚本实现合约条款的自动执行和数据操作。对区块链进行系统梳理并对其关键技术元素进行解构，在此前提下，从体系结构和实现协议入手分析了区块链系统的基础架构，以区块链技术的应用发展为脉络，主要结合比特币、以太坊和超级账本应用场景，对其技术原理、 实现路径、应用现状和存在的挑战进行了阐述。力求为读者在系统学习区块链技术的基础上致力于更深入的 研究提供帮助和借鉴。</p><h2 id="9、区块链技术发展综述及其政务领域应用研究"><a href="#9、区块链技术发展综述及其政务领域应用研究" class="headerlink" title="9、区块链技术发展综述及其政务领域应用研究"></a>9、区块链技术发展综述及其政务领域应用研究</h2><h3 id="摘要-8"><a href="#摘要-8" class="headerlink" title="摘要"></a>摘要</h3><p>区块链是密码技术应用发展的重要里程碑,其技术特点及优势颠覆了传统管理思维与治理模式,有助于推动信任模式与管理机制的重构与优化,为建立新型的政府数据治理体系提供经验与启示.全面评述了区块链技术的起源、演进、发展和兴起历程,审视其核心思想与设计理念,对其核心技术、要素规则、基础架构分别作了比较与概括;从用例设计角度阐述了区块链技术在机关公文运转、信息资源目录、网上政务服务等政务领域典型场景的应用;总结了区块链技术在政务领域应用的愿景、问题与原因,并提出一些方向性的思考与展望</p><h2 id="————-New-———"><a href="#————-New-———" class="headerlink" title="———— New ———-"></a>———— New ———-</h2><h2 id="跨链技术"><a href="#跨链技术" class="headerlink" title="跨链技术"></a>跨链技术</h2><p><a class="link" href="https://zhuanlan.zhihu.com/p/37448916">https://zhuanlan.zhihu.com/p/37448916<i class="fas fa-external-link-alt"></i></a></p><ul><li>同构链和异构链</li></ul><h2 id="1、一种基于USBKey的区块链云存储方法-梁宵"><a href="#1、一种基于USBKey的区块链云存储方法-梁宵" class="headerlink" title="1、一种基于USBKey的区块链云存储方法_梁宵"></a>1、一种基于USBKey的区块链云存储方法_梁宵</h2><p>将共享数据拆分成多分，分别存放在多个云端，同时将拆分索引加密后上链</p><p>使得数据的存储位置信息可靠、可信</p><p>节点只需要请求链上的数据索引，即可根据索引目录获得云端数据</p><p>使用USBKey的一系列加密算法保证整个过程中数据的安全性</p><h2 id="2、基于区块链的可信数据交换技术与应用-梁伟"><a href="#2、基于区块链的可信数据交换技术与应用-梁伟" class="headerlink" title="2、基于区块链的可信数据交换技术与应用_梁伟"></a>2、基于区块链的可信数据交换技术与应用_梁伟</h2><p>将数据加密后的密文上链，客户端只能得到加密后的数据，客户端再通过数据双方协商的加解密格式对加密后的据进行解密，便可得到原始数据</p><p>使得原始数据在链上是不可见的</p><h2 id="3、跨区块链的数据访问"><a href="#3、跨区块链的数据访问" class="headerlink" title="3、跨区块链的数据访问"></a>3、跨区块链的数据访问</h2><p>跨区块链的数据访问方法、装置、系统及计算机可读介质与流程</p><p><a class="link" href="http://mip.xjishu.com/zhuanli/62/201810091905.html">http://mip.xjishu.com/zhuanli/62/201810091905.html<i class="fas fa-external-link-alt"></i></a></p><h2 id="4、Achain-跨链技术实现区块链价值信息交"><a href="#4、Achain-跨链技术实现区块链价值信息交" class="headerlink" title="4、Achain:跨链技术实现区块链价值信息交"></a>4、Achain:跨链技术实现区块链价值信息交</h2><p><a class="link" href="https://www.sohu.com/a/243006457_100190787">https://www.sohu.com/a/243006457_100190787<i class="fas fa-external-link-alt"></i></a></p><p>以太坊创始人V神最早在R3联盟发言时表明目前主流的跨链技术包括：<strong>公证人机制</strong>（Notary schemes）；<strong>侧链/中继</strong>（Sidechains/relays）；<strong>哈希锁定</strong>（Hash-locking）；<strong>分布式私钥控制</strong>（Distributed private key control）</p><p>Achain最重要的：VEP（Value Exchange Protocol）是不同区块链网络之间链接的标准协议</p><p>假设我们把一个区块链网络当做节点，多个区块链网络之间形成连接，那么我们也需要一个新的共识机制。诚然区块链的可靠性体现在分布式的账本和分布式共识，很多人认为既然区块链已经做到公开透明，信息交互的跨链不需要其他的共识机制。</p><p>但大家往往忽略了其中最重要的一点：不同网络的平等性、可信度、利益诉求让网络协作变得困难，其次在区块链的运作模式中总会有坏节点存在。<strong>在有矛盾、有冲突需要讨论的地方，就需要一套新的共识，一套新的预定规则，这就如同现实世界中跨组织写作的法律、契约等约束。</strong></p><h2 id="5、An-Achieving-Data-Exchange-Cross-Chain-Alliance-Protocol"><a href="#5、An-Achieving-Data-Exchange-Cross-Chain-Alliance-Protocol" class="headerlink" title="5、An Achieving Data Exchange Cross-Chain Alliance Protocol"></a>5、An Achieving Data Exchange Cross-Chain Alliance Protocol</h2><ul><li>为区块链之间建立和通信跨链联盟提供了一种方法和系统</li><li>根据通信需求，为每个节点建立跨链联盟，建立跨链联盟智能合约，并配置跨链联盟中每个节点的身份证书和交易证书，从而实现跨链联盟的建立，即<strong>跨链联盟</strong><ol><li>获取多个区块链中各通信节点的通信需求</li><li>根据通信需求，为不同区块链上属于通信需求的每个节点建立跨链联盟，并为每个节点配置身份证书和交易证书。</li><li>根据通信需求，为跨链联盟建立跨链智能合约</li></ol></li></ul><ul><li>建立<strong>跨链联盟</strong>的方法包括：获取多个区块链中各通信节点的通信需求，各节点建立跨链联盟，配置身份证书和交易证书，建立跨链智能合约。</li><li>区块链<strong>跨链通信</strong>方法包括：利用上述建立的跨链联盟中的每个区块链获取通信请求，并为每个节点建立节点智能合约;如果发起了通信请求，首先对通信请求进行背书策略验证，然后对通信请求进行全序列签名验证和数据一致性验证，验证通信请求后，根据跨链智能合约实现节点间通信。</li></ul><h2 id="6、Cross-blockchain-protocol-for-public-registries"><a href="#6、Cross-blockchain-protocol-for-public-registries" class="headerlink" title="6、Cross-blockchain protocol for public registries"></a>6、Cross-blockchain protocol for public registries</h2><h2 id="7、A-Novel-Cross-Chain-Mechanism-for-Blockchains"><a href="#7、A-Novel-Cross-Chain-Mechanism-for-Blockchains" class="headerlink" title="7、A Novel Cross-Chain Mechanism for Blockchains"></a>7、A Novel Cross-Chain Mechanism for Blockchains</h2><p>主要是跨链的数据隐私保护模型</p><ul><li>提出了一种新型的跨链机制，通过添加到应用程序中的插件提供不同区块链之间的互连。</li><li>我们引入了膜的概念，便于描述交叉链的机理。</li></ul><p>提出一个区块链是一个网络膜（新概念），快链交互就是跨膜交互，给出一种机制帮助完成跨链</p><h2 id="8、SynergyChain"><a href="#8、SynergyChain" class="headerlink" title="8、SynergyChain"></a>8、SynergyChain</h2><p>一个基于多链的数据共享框架，具有分层访问控制（存储层，合约层，应用层）</p><ul><li>跨链数据可靠共享 - 符合区块链防篡改特点</li><li>细粒度访问控制 - 保护敏感数据</li></ul><p>access request smart contracts - 访问请求智能合约</p><p>storage smart  contract - 存储智能合约</p><p>access control contract - 访问控制合约</p><ol><li><p>介绍</p></li><li><p>背景和动机</p></li><li><p>系统设计的初步概念</p><ol><li>共识：DPoS</li><li>Merkel tree：</li><li>智能合约：</li></ol></li><li><p>协同链系统的结构层和各层所涉及的主要功能模块</p><ul><li>分层：将数据共享操作与数据请求者和数据持有者隔离开来</li></ul><ol><li>存储层：accessrequest contracts, data upload contracts, data storage contracts,and access control contracts</li><li></li></ol></li><li><p>使用智能合约的分层访问控制的详细设计</p></li><li><p>性能评估</p></li><li><p>相关工作</p></li><li><p>工作总结</p></li></ol><h2 id="10、曹建农：区块链为大数据交换和共享提供解决方案"><a href="#10、曹建农：区块链为大数据交换和共享提供解决方案" class="headerlink" title="10、曹建农：区块链为大数据交换和共享提供解决方案"></a>10、曹建农：区块链为大数据交换和共享提供解决方案</h2><p><a class="link" href="https://www.chinaz.com/blockchain/2019/0527/1019351.shtml">华为区块链奠基者曹建农：区块链为大数据交换和共享提供解决方案<i class="fas fa-external-link-alt"></i></a></p><p>问题：</p><ol><li>怎么让用户控制数据灵活共享</li><li>不同方法查找数据;</li><li>如何减少延迟; </li><li>怎么解决公平性</li></ol><h1 id="弃-政务链上交易共识算法研究与应用"><a href="#弃-政务链上交易共识算法研究与应用" class="headerlink" title="(弃)政务链上交易共识算法研究与应用"></a>(弃)政务链上交易共识算法研究与应用</h1><h2 id="开题"><a href="#开题" class="headerlink" title="开题"></a>开题</h2><h3 id="1、任务书"><a href="#1、任务书" class="headerlink" title="1、任务书"></a>1、任务书</h3><h4 id="进度安排"><a href="#进度安排" class="headerlink" title="进度安排"></a>进度安排</h4><h4 id="任务目的与要求"><a href="#任务目的与要求" class="headerlink" title="任务目的与要求"></a>任务目的与要求</h4><h3 id="2、开题报告"><a href="#2、开题报告" class="headerlink" title="2、开题报告"></a>2、开题报告</h3><p>选择近五年的论文，或者是学术史上经典的论文参考</p><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>随着新基建技术的发展，区块链技术也得到日益广泛的应用。在现如今的网络大环境下，区块链凭着自己的去中心化、不可篡改等特点，在政务领域中逐步开始应用，而其中节点之间的共识算法成为政务链体系研究中的热门议题。<br>在政务链体系中各节点之间达成共识的特殊性，一个节点项目的产生，往往需要经过链上多方节点核实，各个独立的而有相互不可分割的部门都需要自动、高效地处理这一过程，从而达到共识。本课题的主要任务是针对政务链上节点共识的要求，设计出一款安全，可靠，高效的共识算法。</p><p>针对政务领域中节点之间的达成共识往往需要经过链上多方节点核实，但实时性要求较高，达成分歧较大的痛点问题；如何根据政务链应用的业务求，设计一款安全、高效的共识算法，使得各个独立而又相互不可分割的部门能自动、高效地处理这一过程，从而实现业务应用的有效执行</p><h4 id="现状和发展趋势"><a href="#现状和发展趋势" class="headerlink" title="现状和发展趋势"></a>现状和发展趋势</h4><p>共识机制是特殊节点的投票，在很短的时间内完成对交易的验证和确认；对一笔交易，如果利益不相干的若干个节点能够达成共识，我们就可以认为全网对此也能够达成共识。再通俗一点来讲，如果中国一名微博大V、美国一名虚拟币玩家、一名非洲留学生和一名欧洲旅行者互不相识，但他们都一致认为你是个好人，那么基本上就可以断定你这人还不坏。（摘自百度百科）</p><p>从本质上讲，公有、私有和联盟链并不矛盾，它们只是使用了不同的技术：</p><ul><li>精心设计的公有链在防审计性方面往往更具优势，但代价是速度和吞吐量较低。这些是对交易结算（或智能合约）提供安全性保证的最佳选择。</li><li>私有链可以优先考虑系统的速度，因为它无需像公共区块链那样担心核心故障。理想情况下，将私有链部署在个人或组织可控且信息保密的情况下。</li><li>联盟链可减轻私有链中交易对手的风险（通过消除集中控制），并且较少的节点数通常可使它们能够比公共链更有效率的运行。联盟链适合于彼此之间需要相互沟通的单位组织。</li></ul><h4 id="重难点和拟采用途径"><a href="#重难点和拟采用途径" class="headerlink" title="重难点和拟采用途径"></a>重难点和拟采用途径</h4><p>数图公链 -&gt; 政务联盟链</p><p>节点机</p><p>两个指针</p><p>交易所-效率高</p><p>达成共识-</p><p>服务于应用</p><p>模版</p><p>政务场景下达成共识设计</p><p><strong>项目招标：</strong></p><ul><li><p><strong>区块链底层基础平台</strong></p><ul><li>共识系统</li></ul></li><li><p><strong>区块链能力增强系统</strong></p><ul><li>高性能共识算法：针对现有共识系统吞吐量低下、交易确认时间长、应用场景受限等问题，突破区块链在交易共识过程中的性能瓶颈，提高全网交易吞吐量</li></ul></li></ul><h1 id="New-云链数据交换技术的研究与应用"><a href="#New-云链数据交换技术的研究与应用" class="headerlink" title="(New)云链数据交换技术的研究与应用"></a>(New)云链数据交换技术的研究与应用</h1><ul><li>没有算法深度，要加点东西</li><li>模型</li><li>目录检索 - 算法</li><li></li></ul><h2 id="开题-1"><a href="#开题-1" class="headerlink" title="开题"></a>开题</h2><p>提出、参考已有方法、自己解决的方法问题</p><p>复现别人的（跨链比较好找）</p><p>模型主要就是 - 数据存取</p><p>现有的区块链相关的数据交换都是通过区块链结构来完成可信数据交换，侧重点在于数据的可信度及隐私保护</p><p>本课题要讨论的则是一种使得链上(联盟链)数据可以安全交换的模型</p><p>设计一种前置机（智能合约）的东西，隔离政务内外网，隔离原始数据和链数据</p><p>如果存储数据索引，则可以攻击原始数据库</p><ul><li>所以根据链上数据不可篡改原则，考虑将数据索引和加密数据验证一同存储在链上，这样在取得数据后，还需要获得节点进行数据验证，以确保数据的准确性</li></ul><p>1、云链数据交换中，子链的前置节点机，存储的目录、索引，经常使用的数据（最近未使用替换算法），需要保障读数据的隐私保护（RSA，加密算法）；</p><p>2、基于政务业务的<strong>自组织政务链</strong>的智能合约，实时响应相关的业务需求；</p><p>主链：公信力（前置机如果只放在子链上，则没有公信力）</p><p>存日志信息</p><p>区块链特性：不可篡改、可追溯、去中心化</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>政务链：主侧链</p><p>业务给予web程序，链上只考虑数据流通和交换，考虑链上数据的不可篡改性，将数据操作存储在链上</p><p>真实的数据存储在云端，通过前置机与各节点间进行交换</p><p>通过智能合约的模式，使得原始数据不可见的，只返回业务执行结果</p><ul><li>需要证明结果确实是此数据跑出来的</li></ul><p>既节点1想要访问节点2管理的数据，需要？</p><p>数据库的分布，需要维护数据的索引，</p><p>主链上的节点维护自己的CA，提供给节点所属侧链</p><p>主链上再维护一个给主链节点提供的CA</p><h3 id="权限访问"><a href="#权限访问" class="headerlink" title="权限访问"></a>权限访问</h3><p>目前的权限访问模型分文两种：</p><ol><li>基于角色的访问控制（RBAC）：构建起来更加简单，缺点在于无法做到对资源细粒度地授权（都是授权某一类资源而不是授权某一个具体的资源）</li><li>基于属性的访问控制（ABAC）：构建相对比较复杂，学习成本比较高，优点在于细粒度和根据上下文动态执行。<ul><li>ABAC 属性通常来说分为四类：用户属性（如用户年龄），环境属性（如当前时间），操作属性（如读取）和对象属性（如一篇文章，又称资源属性），所以理论上能够实现非常灵活的权限控制。</li></ul></li></ol><h2 id="论文撰写"><a href="#论文撰写" class="headerlink" title="论文撰写"></a>论文撰写</h2><h2 id="材料"><a href="#材料" class="headerlink" title="材料"></a>材料</h2><p><a class="link" href="https://www.jianshu.com/p/7d0a9b211de7">SmartBlock 2018区块链论文合集<i class="fas fa-external-link-alt"></i></a></p><h3 id="异构链"><a href="#异构链" class="headerlink" title="异构链"></a>异构链</h3><p>方法：</p><ul><li>侧链/中继（Sidechains/relays）；<ul><li>cosmos、EOS</li></ul></li><li>哈希锁定（Hash-locking）；</li><li>分布式私钥控制（Distributed private key control）</li></ul><p>例子：</p><ul><li><p>SynergyChain</p></li><li><p>conflux：shuttleflow</p></li><li><p>纸贵：zig-ledger</p></li></ul><h3 id="同构链"><a href="#同构链" class="headerlink" title="同构链"></a>同构链</h3><h3 id="联盟和公有的跨链"><a href="#联盟和公有的跨链" class="headerlink" title="联盟和公有的跨链"></a>联盟和公有的跨链</h3><p>实现资产的互联和数据互联。</p><h2 id="开会"><a href="#开会" class="headerlink" title="开会"></a>开会</h2><p>核心竞争力</p><p>业务联盟链 - 数据交换体系</p><p>主子侧链</p><ul><li>临时虚拟链 - 自组织的智能合约</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p><strong>网络</strong></p><p>data-network：</p><ul><li>三个组织，每个组织一个admin的peer0和数据交换节点（前置机节点）frontend</li></ul><p>domain：gov.com</p><p>network：datanet</p><p>channel：datachannel</p><p>chaincode：dataexchange</p><p>contract：data-isolation/data-share</p><ul><li>file：data、datalist、datacontract</li><li>可以分为两部分：封闭式和开放式</li></ul><p>数据的使用</p><p>（封闭）</p><ul><li>数据验证 - 身份证<ul><li>是否正确</li><li>是否存在</li></ul></li></ul><p>（不封闭）</p><ul><li>数据验证</li><li>验证+带数据回来</li><li>仅是数据回来</li><li>是否回写系统</li></ul><p><strong>节点</strong></p><p>【domain：gov.com】</p><p>Org1:</p><ul><li>ca：7054</li></ul><p>Org2:</p><ul><li>ca：8054</li></ul><p>Org3:</p><ul><li>ca：6054</li></ul><p>Orderer：</p><h1 id="数据资产生命周期管理"><a href="#数据资产生命周期管理" class="headerlink" title="数据资产生命周期管理"></a>数据资产生命周期管理</h1><p><a class="link" href="https://mp.weixin.qq.com/s/4KIZPTgUu_bioT5Nx6-OBw">https://mp.weixin.qq.com/s/4KIZPTgUu_bioT5Nx6-OBw<i class="fas fa-external-link-alt"></i></a></p><ul><li>数据资产：入、存、用、出，形成生命周期闭环<ul><li>“用”这个期间是真正产生价值的周期，其他周期都是成本，数据因使用而生值，用处越多价值越大。在“用”这个期间要特别强调“数据复用”这个阶段，时下比较流行的数据中台架构，最大的一个价值就是数据复用和服务复用，这对于节省成本，提高效率非常重要。未来企业或组织在评估一个数据产品值不值得开发很重要的一个指标应该看能不能复用</li></ul></li><li>数据的使用是：增、删、改、查</li></ul><p><a class="link" href="https://www.zhihu.com/question/393978073/answer/1214162559">https://www.zhihu.com/question/393978073/answer/1214162559<i class="fas fa-external-link-alt"></i></a></p><h2 id="CSA模型"><a href="#CSA模型" class="headerlink" title="CSA模型"></a>CSA模型</h2><p>云安全联盟（CSA）是管理安全云计算环境的世界领先组织。CSA为云环境中的数据安全提出了一个数据生命周期模型。提供的数据模型有六个阶段，分别是<strong>创建、存储、使用、共享、存档和销毁</strong>，如图2所示。因此，这个模型解决了云计算环境中的一个特殊问题，安全性。</p><img src="/2021/01/04/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/v2-c1dc6c940cb72894ae4cc2f22640b798_1440w.jpg" alt="v2-c1dc6c940cb72894ae4cc2f22640b798_1440w" style="zoom:90%;"><p>结论：此模型涵盖的内容并不全面，因为它是为云计算模型中的数据安全而设计的。因此，并未考虑数据质量、数据处理和数据分析等概念</p><h2 id="DataOne模型"><a href="#DataOne模型" class="headerlink" title="DataOne模型"></a>DataOne模型</h2><p>地球数据观测网是由美国国家科学基金会（NSF）资助的一个名为“数据一号”的组织。他们的数据模型旨在为生物和环境科学研究提供数据保存和再利用。拟议的数据生命周期包括<strong>收集、保证、描述、存放、保存、发现、集成和分析</strong>，如图3所示。因此，该模型可以用于存储和检索长期使用的信息。</p><p>结论：该模型是专门为数据保存和复用而开发的，不能看作是一个综合模型。此外，对数据安全也没有任何关注。</p><h2 id="DDI模型"><a href="#DDI模型" class="headerlink" title="DDI模型"></a>DDI模型</h2><p>数据文件倡议（DDI）是大学间政治和社会研究联合会（ICPSR）的一个项目。DDI试图为社会科学数据资源的描述生成元数据规范。所提供的模型包括八个元素，它们是<strong>研究概念、数据收集、数据处理、数据存档、数据分发、数据发现、数据分析和重新调整用途</strong>，如图5所示</p><p>结论：这几乎是一个全面的模型，因为它成功地解决了数据生命周期中从收集到使用的大多数步骤。但是，似乎没有对数据质量和数据安全有任何关注。</p><h2 id="DigitalNZ模型"><a href="#DigitalNZ模型" class="headerlink" title="DigitalNZ模型"></a>DigitalNZ模型</h2><p>DigitalNZ来自数字新西兰。他们的目标是为用户收集和增加数字内容的数量，而数据模型是为存档和使用数字信息而设计的。该模型包括<strong>选择、创建、描述、管理、保存、发现、使用和复用</strong>等步骤，如图5所示。该模型旨在管理数据利益相关者之间的数字信息交换。</p><img src="/2021/01/04/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/v2-ffdb86c9dca9f2e07f3ef94b01618745_1440w.jpg" alt="v2-ffdb86c9dca9f2e07f3ef94b01618745_1440w" style="zoom:60%;"><p>结论：此模型的设计只关注存档和使用目的，因此不能将其视为一个全面的模型。此外，该模型不提供数据分析、数据集成、数据安全和数据质量。</p><h2 id="一般科学模型"><a href="#一般科学模型" class="headerlink" title="一般科学模型"></a>一般科学模型</h2><p>通用科学模型由科学机构提供，用于管理科学数字数据。此模型可用于管理用于存档或处理数据的数据收集方法。</p><p>通用科学数据模型将<strong>计划、收集、集成和转换、发布、发现和通知以及存档或丢弃</strong>作为生命周期的六个阶段。这个模型，如图7所示，可以用数据管理计划使用的特定技术来预测下一组数据采集。</p><p>结论：此模型不是整个数据生命周期的综合模型，因为它是专门为数据存档和处理而设计的。该模型不关心数据分析、数据安全和数据质量。</p><h2 id="北京邮电大学模型"><a href="#北京邮电大学模型" class="headerlink" title="北京邮电大学模型"></a>北京邮电大学模型</h2><p>该模型隶属于北京邮电大学的一个研究小组。此模型用于云计算环境中的数据安全。图13所示的基于图的模型有五个阶段，分别是<strong>创建、存储、使用和共享、存档和销毁</strong>。该模型适用于云环境中的安全性。</p><img src="/2021/01/04/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/v2-dc4aaf3ce605c155dd7a317d071e8af2_1440w.jpg" alt="v2-dc4aaf3ce605c155dd7a317d071e8af2_1440w" style="zoom:80%;"><p>结论：这个模型不能被认为是一个全面的模型，因为它的设计只支持云中的数据安全。此外，它不包括数据质量、数据分析和数据发布等阶段。</p><h1 id="数字孪生趋势，概念，技术及应用"><a href="#数字孪生趋势，概念，技术及应用" class="headerlink" title="数字孪生趋势，概念，技术及应用"></a>数字孪生趋势，概念，技术及应用</h1><p>数字孪生，是充分利用物理模型、传感器更新、运行历史等数据，集成多学科、多物理量、多尺度、多概率的仿真过程，在虚拟空间中完成映射，从而反映相对应的实体装备的全生命周期过程。</p><ul><li>一个实体的信息化虚拟孪生“克隆”体</li><li>对比于纸质图，他是本体的对象的动态仿真</li><li>最早在《PLM的概念性设想》中提出</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;例会&quot;&gt;&lt;a href=&quot;#例会&quot; class=&quot;headerlink&quot; title=&quot;例会&quot;&gt;&lt;/a&gt;例会&lt;/h1&gt;&lt;h2 id=&quot;2021-1-4-A&quot;&gt;&lt;a href=&quot;#2021-1-4-A&quot; class=&quot;headerlink&quot; title=&quot;2021.</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>计算机基础</title>
    <link href="https://jieyang-wei.github.io/2020/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    <id>https://jieyang-wei.github.io/2020/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/</id>
    <published>2020-12-23T01:18:40.000Z</published>
    <updated>2021-04-19T06:41:38.607Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机发展"><a href="#计算机发展" class="headerlink" title="计算机发展"></a>计算机发展</h1><p>专用计算机：凯撒密码徽章，算盘</p><p>1946：宾夕法尼亚研究的第一台电子计算机</p><p>求 pai</p><p>密码学：</p><h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><p>二进制编辑器：file info</p><p>Bmp：位图文件，没有压缩的原始文件</p><ul><li>jpg：是压缩之后的</li><li>文件前缀是BM(424d)，可以用二进编辑器打开</li><li>格式：（找到文档规范就能找到）<ul><li>源信息：BM 文件大小 空字节 … 宽 高 … </li><li>数据信息</li></ul></li></ul><p>文件类型：</p><ul><li>私有文件，不能对外交换信息</li><li>通用数据格式文件<ul><li>找到数据规范，就可以解析这个文件</li><li>去掉文件头，别人就打不开了</li><li>bmp，jpg，mp3等</li></ul></li></ul><p>vim -b  filename</p><p>:!xxde</p><h1 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h1><p>dapp：完全分布式的</p><p>中心服务器，单点故障</p><p>混合架构：查询/目录服务器</p><p><strong>完全分布式的</strong>：种子</p><ul><li>共享文件</li><li>种子会记录那些人的电脑里会有这些文件，<ul><li>雷达：主动搜索资源</li><li>种子：定向下载资源</li></ul></li><li>发布种子的人的网络地址，和发布的人对文件分片的每一篇的uri</li><li>唯一的uri标示一个唯一的资源，但可能很多个机器里都有<ul><li>bt://202.103.5.8:8909/asdas:00</li><li>bt://202.103.5.8:8909/asdas:01</li></ul></li><li>种子主要解决第一次连接的问题，一旦第一个连接了，就能知道还有其他那些可以连了</li><li>BT很特殊，不仅有ip等还有文件资源</li></ul><p> 广播：树/图/线/双向链/交叉链等</p><ul><li>线性：<strong>可控性</strong>强，效率低</li><li>非结构化的：可控性差</li><li><strong>结构化</strong>：基于hash，树的之类的</li></ul><h1 id="软件开发"><a href="#软件开发" class="headerlink" title="软件开发"></a>软件开发</h1><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p><strong>CLI</strong>：Command-Line interface - 命令行界面</p><p><strong>GUI</strong>：Graphical User Interface - 用户图形界面</p><h2 id="SDK"><a href="#SDK" class="headerlink" title="SDK"></a>SDK</h2><p>Software Development Kit - 软件开发工具包</p><ul><li>辅助开发某一类软件的相关文档、范例和工具的集合都可以叫做SDK。</li></ul><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><ul><li>我把软件A里你需要的功能打包好，写成一个函数。你按照我说的流程，把这个函数放在软件B里，就能直接用我的功能了！</li><li>软件A -&gt; 配置环境 -&gt; 构建函数 -&gt; 安装jar包 -&gt; 软件B中使用</li></ul><blockquote><p>如果把SDK想象成一个虚拟的程序包，在这个程序包中有一份做好的软件功能，这份程序包几乎是全封闭的，只有一个小小接口可以联通外界，这个接口就是API。</p></blockquote><h1 id="软件管理"><a href="#软件管理" class="headerlink" title="软件管理"></a>软件管理</h1><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><ul><li>一个开源的应用容器引擎，基于 Go 语言并遵从Apache2.0协议开源。</li><li>可以让开发者将应用和依赖包打包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</li><li>容器完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 App），更重要的是容器性能开销极低。</li></ul><p>Docker 包括三个基本概念:</p><ul><li><strong>镜像（Image）</strong>：相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。比如说nginx,mysql,redis等软件可以做成一个镜像。</li><li><strong>容器（Container）</strong>：容器可以被创建、启动、停止、删除、暂停等。</li><li><strong>仓库（Repository）</strong>：一个代码控制中心，用来保存镜像。DockerHub 是一个由 Docker 公司运行和管理的基于云的存储库。它是一个在线存储库，Docker 镜像可以由其他用户发布和使用。有两种库：公共存储库和私有存储库。如果你是一家公司，你可以在你自己的组织内拥有一个私有存储库，而公共镜像可以被任何人使用。</li></ul><p>刚开始使用，尽可能的会使用，了解其解决什么痛点，随着我们使用的深入，逐步了解其原理和结构是如何实现的。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol><li><p>使用Homebrew - for Mac</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Homebrew v2.x</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> brew cask install --appdir=<span class="string">&quot;/Applications&quot;</span> docker</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Homebrew v3.x:</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> brew install --cask --appdir=<span class="string">&quot;/Applications&quot;</span> docker</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> open it</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> open /Applications/Docker.app</span></span><br></pre></td></tr></table></figure></li><li><p>官方下载Docker Desktop for Mac</p></li><li><p>镜像下载dmg文件</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">http</span>://<span class="selector-tag">mirrors</span><span class="selector-class">.aliyun</span><span class="selector-class">.com</span>/<span class="selector-tag">docker-toolbox</span>/<span class="selector-tag">mac</span>/<span class="selector-tag">docker-for-mac</span>/</span><br></pre></td></tr></table></figure></li></ol><p>版本查看</p><h3 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h3><p>docker镜像在国外，为了后续下载加速，配置文件将镜像换成国内的</p><ul><li>在<code>/etc/docker/daemon.json</code>文件中配置或者如下图所示在软件中配置</li><li><code>&#123;&quot;registry-mirrors&quot;:[&quot;https://reg-mirror.qiniu.com/&quot;]&#125;</code>（可以在网上查找其他国内镜像源）</li></ul><img src="/2020/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/截屏2021-03-07 下午9.55.31.png" alt="截屏2021-03-07 下午9.55.31" style="zoom:60%;"><p>镜像源是否成功替换：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker info</span></span><br><span class="line"> Registry Mirrors:</span><br><span class="line">  https://reg-mirror.qiniu.com/</span><br></pre></td></tr></table></figure><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><h4 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h4><ol><li><strong>login</strong></li></ol><ol start="2"><li><strong>pull</strong></li></ol><ol start="3"><li><strong>push</strong></li></ol><h4 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h4><ol><li>启动容器</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在运行的容器中执行命令</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker <span class="built_in">exec</span> [OPTIONS] CONTAINER COMMAND [ARG...]</span></span><br></pre></td></tr></table></figure><ul><li><strong>OPTION</strong>：<ul><li><strong>–privilege</strong>：给命令加附加特权</li><li><strong>-d</strong>：分离模式: 在后台运行</li><li><strong>-i</strong>：即使没有附加也保持STDIN 打开</li><li><strong>-t</strong>：分配一个伪终端</li><li><strong>-e</strong>：设置环境变量</li></ul></li><li><strong>COMMAND</strong>：将在容器的默认目录中运行。<ul><li>如果底层映像的Dockerfile中有一个使用WORKDIR指令指定的自定义目录，则将使用该目录。</li></ul></li></ul><h2 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a>Homebrew</h2><p>Mac OS下的强大的软件包管理工具</p><p><strong>下载</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew install name</span></span><br></pre></td></tr></table></figure><p><strong>更新</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew update</span></span><br></pre></td></tr></table></figure><p><strong>操作</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew --version   <span class="comment">#版本查看</span></span></span><br></pre></td></tr></table></figure><p><strong>加速</strong></p><ul><li><p>因为brew的镜像在国外，所以使用时下载更新速率都十分的缓慢</p></li><li><p>故可以将镜像源修改成国内的（下面为<a class="link" href="https://mirrors.tuna.tsinghua.edu.cn/help/homebrew/">清华镜像<i class="fas fa-external-link-alt"></i></a>）</p></li><li><p>更换：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/Homebrew</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git -C <span class="string">&quot;<span class="subst">$(brew --repo)</span>&quot;</span> remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git -C <span class="string">&quot;<span class="subst">$(brew --repo homebrew/core)</span>&quot;</span> remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git -C <span class="string">&quot;<span class="subst">$(brew --repo homebrew/cask)</span>&quot;</span> remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-cask.git</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> brew update</span></span><br></pre></td></tr></table></figure></li><li><p>复原：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/Homebrew</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git -C <span class="string">&quot;<span class="subst">$(brew --repo)</span>&quot;</span> remote set-url origin https://github.com/Homebrew/brew.git</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git -C <span class="string">&quot;<span class="subst">$(brew --repo homebrew/core)</span>&quot;</span> remote set-url origin https://github.com/Homebrew/homebrew-core.git</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git -C <span class="string">&quot;<span class="subst">$(brew --repo homebrew/cask)</span>&quot;</span> remote set-url origin https://github.com/Homebrew/homebrew-cask.git</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.5之后没有cask，下面的不一定要执行</span></span><br><span class="line">----------------------------</span><br><span class="line"><span class="meta">$</span><span class="bash"> git -C <span class="string">&quot;<span class="subst">$(brew --repo homebrew/cask-fonts)</span>&quot;</span> remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-cask-fonts.git</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git -C <span class="string">&quot;<span class="subst">$(brew --repo homebrew/cask-drivers)</span>&quot;</span> remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-cask-drivers.git</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git -C <span class="string">&quot;<span class="subst">$(brew --repo homebrew/cask-versions)</span>&quot;</span> remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-cask-versions.git</span></span><br><span class="line">----------------------------</span><br><span class="line"><span class="meta">$</span><span class="bash"> brew update-reset</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 更换上游后需重新设置 git 仓库 HEAD：</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="apt-get"><a href="#apt-get" class="headerlink" title="apt-get"></a>apt-get</h2><p>Linux下的包管理工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get install &lt;package&gt;</span><br></pre></td></tr></table></figure><h2 id="cURL"><a href="#cURL" class="headerlink" title="cURL"></a>cURL</h2><p>是常用的命令行工具，用来请求 Web 服务器。它的名字就是客户端（client）的 URL 工具的意思。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl https://www.example.com</span></span><br></pre></td></tr></table></figure><ul><li>上面命令向<code>www.example.com</code>发出 GET 请求，服务器返回的内容会在命令行输出。</li></ul><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p><strong>-o</strong></p><p>将服务器的回应保存成文件，等同于<code>wget</code>命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -o example.html https://www.example.com</span></span><br></pre></td></tr></table></figure><ul><li>上面命令将<code>www.example.com</code>保存成<code>example.html</code>。</li></ul><p><strong>-O</strong></p><p>将服务器回应保存成文件，并将 URL 的最后部分当作文件名。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -O https://www.example.com/foo/bar.html</span></span><br></pre></td></tr></table></figure><ul><li>上面命令将将服务器的回应保存成文件，文件名为<code>bar.html</code>。</li></ul><p><strong>-s</strong></p><p>参数将不输出错误和进度信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -s https://www.example.com</span></span><br></pre></td></tr></table></figure><ul><li><p>上面命令一旦发生错误，不会显示错误信息。不发生错误的话，会正常显示运行结果。</p></li><li><p>如果想让 curl 不产生任何输出，可以使用下面的命令。</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -s -o /dev/null https://google.com</span></span><br></pre></td></tr></table></figure><p><strong>-S</strong></p><p>参数指定只输出错误信息，通常与<code>-s</code>一起使用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -s -o /dev/null https://google.com</span></span><br></pre></td></tr></table></figure><ul><li>此处有错</li></ul><p><strong>-L</strong></p><p>参数会让 HTTP 请求跟随服务器的重定向。curl 默认不跟随重定向。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -L -d <span class="string">&#x27;tweet=hi&#x27;</span> https://api.twitter.com/tweet</span></span><br></pre></td></tr></table></figure><h1 id="隐私保护"><a href="#隐私保护" class="headerlink" title="隐私保护"></a>隐私保护</h1><p>零知识证明</p><ul><li>证明知道答案，但却不泄漏答案的内容</li><li>阿里巴巴的洞</li></ul><p>安全多方计算技术</p><ul><li>无可信任第三方的情况下，安全地完成计算任务</li><li>应用：门限签名、电子拍卖等</li></ul><p>共享数据上链及存证</p><p>共享数据授权和使用</p><p>同态加密</p><p>可信硬件</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算机发展&quot;&gt;&lt;a href=&quot;#计算机发展&quot; class=&quot;headerlink&quot; title=&quot;计算机发展&quot;&gt;&lt;/a&gt;计算机发展&lt;/h1&gt;&lt;p&gt;专用计算机：凯撒密码徽章，算盘&lt;/p&gt;
&lt;p&gt;1946：宾夕法尼亚研究的第一台电子计算机&lt;/p&gt;
&lt;p&gt;求 pai&lt;</summary>
      
    
    
    
    <category term="Notebook" scheme="https://jieyang-wei.github.io/categories/Notebook/"/>
    
    <category term="Theory" scheme="https://jieyang-wei.github.io/categories/Notebook/Theory/"/>
    
    
    <category term="理论知识" scheme="https://jieyang-wei.github.io/tags/%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>nodejs</title>
    <link href="https://jieyang-wei.github.io/2020/12/18/nodejs/"/>
    <id>https://jieyang-wei.github.io/2020/12/18/nodejs/</id>
    <published>2020-12-18T09:56:37.000Z</published>
    <updated>2021-04-19T06:43:49.215Z</updated>
    
    <content type="html"><![CDATA[<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><h2 id="NVM"><a href="#NVM" class="headerlink" title="NVM"></a>NVM</h2><p>nodejs的版本管理工具</p><p><code>nvm ls</code></p><img src="/2020/12/18/nodejs/截屏2021-03-23 上午10.54.30.png" alt="截屏2021-03-23 上午10.54.30" style="zoom:50%;"><ul><li>列出电脑下所有的nodejs版本，并指出当前版本</li></ul><p><code>nvm use 10.15.0</code></p><ul><li>切换当前使用的nodejs版本</li></ul><p><code>nvm install 10.15.0</code></p><ul><li>下载并使用版本10.15.0</li></ul><h2 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h2><p>nodejs的包管理工具</p><ul><li><p><a class="link" href="https://www.cnblogs.com/datiangou/p/10172994.html">package.json<i class="fas fa-external-link-alt"></i></a></p></li><li><p><a class="link" href="https://docs.npmjs.com/cli/v6/configuring-npm/package-json">官方文档<i class="fas fa-external-link-alt"></i></a></p></li></ul><p><code>npm init</code></p><ul><li>可以初始化一个package.json文件。在初始化的过程中，会叫用户输入name, version等等信息，当然，你都可以忽略。一路点回车，就生成了下面这样一个初始化的package.json。</li></ul><p><code>package.json</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;test&quot;</span>, <span class="comment">// 假如项目叫做test</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;this is my test&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;index.js&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;amp;&amp;amp; exit 1&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;author&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;license&quot;</span>: <span class="string">&quot;ISC&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>name</strong>: 这个很好理解，就是package的名称。不过需要注意的是，name有长度限制(虽然一般都不会超)，而且name不能以 【点】 或者 【下划线】开头，name中不能有大写字母。这个是每一个package必须的。在业务代码中，通过<code>require($&#123;name&#125;)</code>就可以引入对应的程序包了。</li><li><strong>version</strong>: package的版本。对于业务项目来说，这个往往不太重要，但是如果你要发布自己的项目，这个就显得十分重要了。name和version共同决定了唯一一份代码。npm是用[<a class="link" href="https://docs.npmjs.com/misc/semver.html">npm-semver]<i class="fas fa-external-link-alt"></i></a>来解析版本号的。我们一般见到的都是<code>大版本.次要版本.小版本</code>这种版本号，比如<code>16.1.0</code>。版本号的规则、含义其实蛮多的，可以参考<a class="link" href="https://segmentfault.com/a/1190000011368506">这篇文章<i class="fas fa-external-link-alt"></i></a>。</li><li><strong>desription</strong>：包的描述。开发组件库时必需，简明的向库的使用者介绍这个库是干嘛的。对于公司的业务项目，这个配置项一般无所谓。</li><li><strong>keywords</strong>：关键词。一个字符串数组，对这个npm包的介绍。组件库必需，便于使用者在npm中搜索。对于公司业务项目，这个配置一般无所谓。</li><li>homepage： 项目主页。对于开发组件库来说挺有用的。</li><li>bugs：开发者的联系方式，代码库的issues地址等。如果代码使用者发现了bug，可以通过这个配置项找到提bug的地方。</li><li><strong>license</strong>：开源协议。对于开源组件库，这个十分重要。之前react还因为这事儿没少被社区嫌弃。开源协议略微复杂，用<a class="link" href="http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html">阮一峰<i class="fas fa-external-link-alt"></i></a>前辈的一张图来说明一下吧。注：图里少了ISC, ISC和BSD差不多</li></ul><img src="/2020/12/18/nodejs/截屏2020-12-22 下午7.11.30.png" alt="截屏2020-12-22 下午7.11.30" style="zoom: 33%;"><ul><li><p>author：项目的作者。可以为字符串，对象。</p></li><li><p>contributors：项目的贡献者。author的数组。</p></li><li><p><strong>main</strong>：代码入口。这个十分重要，特别是对于组件库。当你想在node_modules中修改你使用的某个组件库的代码时，首先在node_modules中找到这个组件库，第一眼就是要看这个main，找到组件库的入口文件。在这个入口文件中再去修改代码吧。</p></li><li><p><strong>scripts</strong>：指定了运行脚本命令的npm命令行缩写。十分重要。</p><ul><li>在命令行输入：<code>npm run dev</code> , 对应的命令就会被执行。这里有一个地方需要注意，当执行<code>npm run xxx </code>的时候，<code>node_modules/.bin/</code>目录会在运行时被加入系统的PATH变量。</li><li>上面的例子，当我们在命令行输入：<code>npm run build</code>时，其实真正执行的命令是<code>node_modules/.bin/webpack</code>而不是<code>webpack</code>。所以，当你的webpack并未全局安装时，直接在命令行输入：<code>webpack</code>是会报错的。因为你的webapck是安装在<code>node_modules/.bin/</code>下面的。</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;dev&quot;: &quot;NODE_ENV=dev webpack-dev-server --progress --hot --host 0.0.0.0 --port 8089&quot;,</span><br><span class="line">    &quot;test&quot;: &quot;NODE_ENV=test webpack --config webpack.test.config.js --progress&quot;,</span><br><span class="line">    &quot;online&quot;: &quot;NODE_ENV=production webpack --config webpack.online.config.js --progress&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;webpack&quot;,</span><br><span class="line">    &quot;node&quot;: &quot;node server.js&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>directories：对整个代码结构的描述。告诉代码包使用者可以在哪里找到对应的文件。</p></li><li><p>files：数组。表示代码包下载安装完成时包括的所有文件。</p></li><li><p><strong>repository</strong>：对于组件库很有用。让组件库使用者找到你的代码库地址。这个配置项会直接在组件库的npm首页生效。例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;repository&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;git&quot;,</span><br><span class="line">    &quot;url&quot;: &quot;git+https:&#x2F;&#x2F;github.com&#x2F;CoyPan&#x2F;react-scroll-to-show-cb.git&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><p>config：用于添加命令行的环境变量。具体用法见<a class="link" href="https://docs.npmjs.com/misc/config">这里<i class="fas fa-external-link-alt"></i></a>。</p></li><li><p><strong>dependencies</strong>：项目的依赖。通过<code>npm install --save</code>安装的包会出现在这里。</p><ul><li>注意，<strong>不要把测试工具、代码转换器或者打包工具</strong>等放在这里。当你在命令行里面使用<code>npm install react --save</code>时，react就会出现在dependencies。默认是安装最新的版本。如果想安装某个特定的版本，可以<code>npm install react@15.6.2</code>。</li></ul></li></ul><hr><p>以下的dependencies，格式都是合法的，</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&quot;dependencies&quot; : &#123; </span><br><span class="line">    &quot;foo&quot; : &quot;1.0.0 - 2.9999.9999&quot;,</span><br><span class="line">    &quot;bar&quot; : &quot;&amp;gt;=1.0.2 &amp;lt;2.1.2&quot;,</span><br><span class="line">    &quot;baz&quot; : &quot;&amp;gt;1.0.2 &amp;lt;=2.3.4&quot;,</span><br><span class="line">    &quot;boo&quot; : &quot;2.0.1&quot;,    // 指定了就是2.0.1版本</span><br><span class="line">    &quot;qux&quot; : &quot;&amp;lt;1.0.0 || &amp;gt;=2.3.1 &amp;lt;2.4.5 || &amp;gt;=2.5.2 &amp;lt;3.0.0&quot;,</span><br><span class="line">    &quot;asd&quot; : &quot;http://asdf.com/asdf.tar.gz&quot;,</span><br><span class="line">    &quot;til&quot; : &quot;~1.2.2&quot;,   // 安装版本号不低于1.2.2的1.2.x的最新版本</span><br><span class="line">  <span class="comment">// 例如:1.2.3， 1.2.4等等。1.2.1 ，1.3.x 等就不行了</span></span><br><span class="line">    &quot;elf&quot; : &quot;^1.2.3&quot;,   // 安装版本号不低于1.2.2的1.x.x的最新版本</span><br><span class="line">  <span class="comment">// 例如: 1.2.7，1.7.8等,1.2.1 ，2.0.0 等就不行了。</span></span><br><span class="line">    <span class="comment">// 注意，如果配置是^0.x.x，则和~0.x.x的效果一样。  </span></span><br><span class="line">    &quot;two&quot; : &quot;2.x&quot;,</span><br><span class="line">    &quot;thr&quot; : &quot;3.3.x&quot;,</span><br><span class="line">    &quot;lat&quot; : &quot;latest&quot;,   // 安装最新版本</span><br><span class="line">    &quot;dyl&quot; : &quot;file:../dyl&quot;,</span><br><span class="line">  <span class="comment">//&quot;foo&quot;: &quot;git+ssh://git@github.com:foo/foo.git#v1.0.1&quot;   // 还可以这样</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>foo组件的地址为<code>git+ssh://&#123;foo代码库的ssh地址&#125;#v&#123;foo的版本号&#125;</code><ul><li>好处：组内的许多项目都有同一个功能，把这个功能抽出来做成组件是很自然的想法。但是每个项目都有自己的代码库，公司也没有内部的npm库，组件应该放在哪里呢？可以专门为组件新建一个代码仓库，将组件放在这里开发、迭代。这样，各个项目都可以引用该组件：只需要在dependencies中将组件配置成上述的形式。至于组件的版本，可以通过<code>git tag</code>来控制。</li></ul></li><li>dependencies还有其他的配置方式，具体在<a class="link" href="https://docs.npmjs.com/files/package.json.html#dependencies">这里<i class="fas fa-external-link-alt"></i></a>查看。</li></ul><hr><ul><li><strong>devDependencies</strong>：项目的依赖。通过<code>npm run install --save-dev</code>安装的包会出现在这里。主要是在<strong>开发过程</strong>中依赖的一些工具。用法与dependencies相似。</li><li>bundledDependencies：数组，打包时的依赖。如果配置了bundledDependencies，在项目中执行 <code>npm pack</code>将项目打包时，最后生成的<code>.tgz</code>包中，会包含bundledDependencies中配置的依赖。bundledDependencies中的依赖必须在devDependencies或者dependencies中声明过。</li><li>peerDependencies: 指定当前组件的依赖以其版本。如果组件使用者在项目中安装了其他版本的同一依赖，会提示报错。</li><li>engines：指定项目所依赖的node环境、npm版本等。</li><li>private：如果设为true，无法通过<code>npm publish</code>发布代码。</li><li>bin：用来指定各个内部命令对应的可执行文件的路径。具体用法这里不多讲了。详情可以点击<a class="link" href="https://docs.npmjs.com/files/package.json.html#bin">这里<i class="fas fa-external-link-alt"></i></a>。</li></ul><p><code>npm install</code></p><ul><li>根据配置文件<code>package.json</code>来安装环境</li><li>会在当前路径下自动创建文件夹<code>node_modules</code>，里面放所有下载的依赖包</li></ul><p><code>npm install name --save</code></p><ul><li>下载包name，同时加载到配置文件<code>package.json</code>的依赖<code>&quot;dependencies&quot;</code>里面</li></ul><h1 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123</span>; <span class="comment">// 整数123</span></span><br><span class="line"><span class="number">0.456</span>; <span class="comment">// 浮点数0.456</span></span><br><span class="line"><span class="number">1.2345e3</span>; <span class="comment">// 科学计数法表示1.2345x1000，等同于1234.5</span></span><br><span class="line">-<span class="number">99</span>; <span class="comment">// 负数</span></span><br><span class="line"><span class="literal">NaN</span>; <span class="comment">// NaN表示Not a Number，当无法计算结果时用NaN表示</span></span><br><span class="line"><span class="literal">Infinity</span>; <span class="comment">// Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity</span></span><br></pre></td></tr></table></figure><ul><li>JavaScript不区分整数和浮点数，统一用Number表示，以上都是合法的Number类型</li><li>Number的四则运算同数学</li><li><strong>注意</strong>：<ul><li><code>NaN</code>这个特殊的Number与所有其他值都不相等，包括它自己：<ul><li>NaN === NaN        //false</li><li>isNaN(NaN);          //true</li></ul></li></ul></li></ul><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>大小写转换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&#x27;User&#x27;</span>;</span><br><span class="line">lowStr = str.toLowerCase(); <span class="comment">// &#x27;user&#x27;</span></span><br><span class="line">upStr = str.toUpperCase();  <span class="comment">// &#x27;USER&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>比较运算符</strong></p><ul><li><code>==</code>：它会<strong>自动转换数据类型</strong>再比较，很多时候，会得到非常诡异的结果；</li><li><code>===</code>：它<strong>不会</strong>自动转换数据类型，如果数据类型不一致，返回<code>false</code>，如果一致，再比较。<ul><li>由于JavaScript这个设计缺陷，<em>不要</em>使用<code>==</code>比较，始终坚持使用<code>===</code>比较。</li></ul></li></ul><p><strong>null和undefined：</strong></p><ul><li><code>null</code>表示一个“空”的值，它和<code>0</code>以及空字符串<code>&#39;&#39;</code>不同，<code>0</code>是一个数值，<code>&#39;&#39;</code>表示长度为0的字符串，而<code>null</code>表示“空”。</li><li>在其他语言中，也有类似JavaScript的<code>null</code>的表示，例如Java也用<code>null</code>，Swift用<code>nil</code>，Python用<code>None</code>表示。但是，在JavaScript中，还有一个和<code>null</code>类似的<code>undefined</code>，它表示“未定义”。</li><li>JavaScript的设计者希望用<code>null</code>表示一个空的值，而<code>undefined</code>表示值未定义。事实证明，这并没有什么卵用，区分两者的意义不大。</li><li>大多数情况下，我们都应该用<code>null</code>。<code>undefined</code>仅仅在判断函数参数是否传递的情况下有用。</li></ul><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p><strong>strict模式</strong></p><ul><li>JavaScript在设计之初，为了方便初学者学习，并不强制要求用<code>var</code>申明变量。这个设计错误带来了严重的后果：如果一个变量没有通过<code>var</code>申明就被使用，那么该变量就自动被申明为全局变量</li><li>为了修补JavaScript这一严重设计缺陷，ECMA在后续规范中推出了<code>strict模式</code>，在<code>strict模式</code>下运行的JavaScript代码，强制通过<code>var</code>申明变量，未使用<code>var</code>申明变量就使用的，将导致运行错误。</li></ul><h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><h5 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h5><h5 id="Iterable"><a href="#Iterable" class="headerlink" title="Iterable"></a>Iterable</h5><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul><li>变量名是大小写英文、数字、<code>$</code>和<code>_</code>的组合，且不能用数字开头。</li><li>变量名也不能是JavaScript的关键字，如<code>if</code>、<code>while</code>等。</li><li>申明一个变量用<code>var</code>语句</li></ul><p><strong>变量输出</strong></p><ul><li>console.log(x)</li><li>alert(x) –html弹窗</li></ul><p><strong>环境变量 process.env</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http_port = process.env.HTTP_PORT || <span class="number">3001</span>   <span class="comment">//默认设置为3001</span></span><br><span class="line"><span class="keyword">var</span> p2p_port = process.env.P2P_PORT || <span class="number">6001</span></span><br><span class="line"><span class="keyword">var</span> initialPeers = process.env.PEERS ? process.env.PEERS.split(<span class="string">&#x27;,&#x27;</span>) : []</span><br></pre></td></tr></table></figure><ul><li><p><strong>process</strong>：是一个 global （全局变量），提供有关信息，控制当前 Node.js 进程。<br>作为一个对象，它对于 Node.js 应用程序始终是可用的，故无需使用 require()。</p><ul><li>process（进程）其实就是存在nodejs中的一个全局变量，所有模块都可以调用。</li></ul></li><li><p>终端设置变量值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//win</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">set</span> HTTP_PORT=3002</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">set</span> P2P_PORT=6002</span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">set</span> PEERS=ws://localhost:6001</span></span><br><span class="line"></span><br><span class="line">//ios</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> HTTP_PORT=3002</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> P2P_PORT=6002</span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> PEERS=ws://localhost:6001</span></span><br><span class="line"></span><br><span class="line">//启动</span><br><span class="line"><span class="meta">$</span><span class="bash"> node file.js</span> </span><br></pre></td></tr></table></figure><ul><li>ios</li></ul></li></ul><h2 id="标准对象"><a href="#标准对象" class="headerlink" title="标准对象"></a>标准对象</h2><ul><li>在JavaScript的世界里，一切都是对象。</li><li>但是某些对象还是和其他对象不太一样。为了区分对象的类型，我们用<code>typeof</code>操作符获取对象的类型，它总是返回一个字符串</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">123</span>; <span class="comment">// &#x27;number&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span>; <span class="comment">// &#x27;number&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;str&#x27;</span>; <span class="comment">// &#x27;string&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>; <span class="comment">// &#x27;boolean&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>; <span class="comment">// &#x27;undefined&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Math</span>.abs; <span class="comment">// &#x27;function&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>; <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> []; <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;; <span class="comment">// &#x27;object&#x27;</span></span><br></pre></td></tr></table></figure><ul><li><code>number</code>、<code>string</code>、<code>boolean</code>、<code>function</code>和<code>undefined</code>有别于其他类型。</li><li><strong>特别注意</strong>：<code>null</code>的类型是<code>object</code>，<code>Array</code>的类型也是<code>object</code>，如果我们用<code>typeof</code>将无法区分出<code>null</code>、<code>Array</code>和通常意义上的object——<code>&#123;&#125;</code>。</li></ul><p><strong>包装对象</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>); <span class="comment">// 123,生成了新的包装类型</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>); <span class="comment">// true,生成了新的包装类型</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;str&#x27;</span>); <span class="comment">// &#x27;str&#x27;,生成了新的包装类型</span></span><br></pre></td></tr></table></figure><ul><li>类型为<code>object</code></li></ul><p>总结一下，有这么几条规则需要遵守：</p><ul><li><p>不要使用<code>new Number()</code>、<code>new Boolean()</code>、<code>new String()</code>创建包装对象；</p><ul><li>如果没写<code>new</code>，<code>Number()</code>、<code>Boolean</code>和<code>String()</code>被当做普通函数，把任何类型的数据转换为<code>number</code>、<code>boolean</code>和<code>string</code>类型（注意不是其包装类型）</li></ul></li><li><p>用<code>parseInt()</code>或<code>parseFloat()</code>来转换任意类型到<code>number</code>；</p></li><li><p>用<code>String()</code>来转换任意类型到<code>string</code>，或者直接调用某个对象的<code>toString()</code>方法；</p><ul><li><p><code>null</code>和<code>undefined</code>就没有<code>toString()</code>方法；Object一些情况下也不能使用</p></li><li><p><code>number</code>对象调用<code>toString()</code>报<strong>SyntaxError：</strong></p></li><li><pre><code class="javascript">123.toString();    // SyntaxError123..toString();   // &#39;123&#39;, 注意是两个点！(123).toString();  // &#39;123&#39;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 通常不必把任意类型转换为&#96;boolean&#96;再判断，因为可以直接写&#96;if (myVar) &#123;...&#125;&#96;；</span><br><span class="line"></span><br><span class="line">- &#96;typeof&#96;操作符可以判断出&#96;number&#96;、&#96;boolean&#96;、&#96;string&#96;、&#96;function&#96;和&#96;undefined&#96;；</span><br><span class="line"></span><br><span class="line">- 判断&#96;Array&#96;要使用&#96;Array.isArray(arr)&#96;；</span><br><span class="line"></span><br><span class="line">- 判断&#96;null&#96;请使用&#96;myVar &#x3D;&#x3D;&#x3D; null&#96;；</span><br><span class="line"></span><br><span class="line">- 判断某个全局变量是否存在用&#96;typeof window.myVar &#x3D;&#x3D;&#x3D; &#39;undefined&#39;&#96;；</span><br><span class="line"></span><br><span class="line">- 函数内部判断某个变量是否存在用&#96;typeof myVar &#x3D;&#x3D;&#x3D; &#39;undefined&#39;&#96;。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### Date</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### RegExp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### JSON</span><br><span class="line"></span><br><span class="line">* JSON实际上是JavaScript的一个子集。</span><br><span class="line">* JSON字符集必须是UTF-8</span><br><span class="line">* 为了统一解析JSON的字符串规定必须用双引号&#96;&quot;&quot;&#96;，Object的键也必须用双引号&#96;&quot;&quot;&#96;。</span><br><span class="line">* 在JSON中，一共就这么几种数据类型：</span><br><span class="line">  1. **number**：和JavaScript的&#96;number&#96;完全一致；</span><br><span class="line">  2. **boolean**：就是JavaScript的&#96;true&#96;或&#96;false&#96;；</span><br><span class="line">  3. **string**：就是JavaScript的&#96;string&#96;；</span><br><span class="line">  4. **nul**l：就是JavaScript的&#96;null&#96;；</span><br><span class="line">  5. **array**：就是JavaScript的&#96;Array&#96;表示方式——&#96;[]&#96;；</span><br><span class="line">  6. **object**：就是JavaScript的&#96;&#123; ... &#125;&#96;表示方式。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**序列化:** 对象 -&gt; JSON</span><br><span class="line"></span><br><span class="line">* &#96;JSON.stringfy(var, null, &#39; &#39;)&#96;：将nodejs对象输出成标准JSON格式</span><br><span class="line"></span><br><span class="line">  * 第二个参数用于控制如何筛选对象的键值，如果我们只想输出指定的属性，可以传入&#96;Array&#96;</span><br><span class="line"></span><br><span class="line">    * &#96;JSON.stringify(xiaoming, [&#39;name&#39;, &#39;skills&#39;], &#39;&#39;);  &#96;</span><br><span class="line">    * 只输出对象 xiaoming 的 name 和 skills 属性</span><br><span class="line"></span><br><span class="line">  * 第二个参数还能是一个函数，这样对象的每个键值对都会被函数先处理，</span><br><span class="line"></span><br><span class="line">    * &#96;&#96;&#96;javascript</span><br><span class="line">      function convert(key, value) &#123;</span><br><span class="line">          if (typeof value &#x3D;&#x3D;&#x3D; &#39;string&#39;) &#123;</span><br><span class="line">              return value.toUpperCase();</span><br><span class="line">          &#125;</span><br><span class="line">          return value;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      JSON.stringfy(xiaoming, convert, &#39;  &#39;);</span><br></pre></td></tr></table></figure></code></pre></li></ul><ul><li>第三个参数控制按缩进输出</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    age: <span class="number">14</span>,</span><br><span class="line">    gender: <span class="literal">true</span>,</span><br><span class="line">    height: <span class="number">1.65</span>,</span><br><span class="line">    grade: <span class="literal">null</span>,</span><br><span class="line">    <span class="string">&#x27;middle-school&#x27;</span>: <span class="string">&#x27;\&quot;W3C\&quot; Middle School&#x27;</span>,</span><br><span class="line">    skills: [<span class="string">&#x27;JavaScript&#x27;</span>, <span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;Lisp&#x27;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="built_in">JSON</span>.stringify(xiaoming);</span><br><span class="line"><span class="built_in">console</span>.log(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;小明&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">14</span>,<span class="string">&quot;gender&quot;</span>:<span class="literal">true</span>,<span class="string">&quot;height&quot;</span>:<span class="number">1.65</span>,<span class="string">&quot;grade&quot;</span>:<span class="literal">null</span>,<span class="string">&quot;middle-school&quot;</span>:<span class="string">&quot;\&quot;W3C\&quot; Middle School&quot;</span>,<span class="string">&quot;skills&quot;</span>:[<span class="string">&quot;JavaScript&quot;</span>,<span class="string">&quot;Java&quot;</span>,<span class="string">&quot;Python&quot;</span>,<span class="string">&quot;Lisp&quot;</span>]&#125;</span><br></pre></td></tr></table></figure><ul><li>如果我们还想要精确控制如何序列化小明，可以给<code>xiaoming</code>定义一个<code>toJSON()</code>的方法，直接返回JSON应该序列化的数据：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    age: <span class="number">14</span>,</span><br><span class="line">    gender: <span class="literal">true</span>,</span><br><span class="line">    height: <span class="number">1.65</span>,</span><br><span class="line">    grade: <span class="literal">null</span>,</span><br><span class="line">    <span class="string">&#x27;middle-school&#x27;</span>: <span class="string">&#x27;\&quot;W3C\&quot; Middle School&#x27;</span>,</span><br><span class="line">    skills: [<span class="string">&#x27;JavaScript&#x27;</span>, <span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;Lisp&#x27;</span>],</span><br><span class="line">    toJSON: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="comment">// 只输出name和age，并且改变了key：</span></span><br><span class="line">            <span class="string">&#x27;Name&#x27;</span>: <span class="built_in">this</span>.name,</span><br><span class="line">            <span class="string">&#x27;Age&#x27;</span>: <span class="built_in">this</span>.age</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify(xiaoming); <span class="comment">// &#x27;&#123;&quot;Name&quot;:&quot;小明&quot;,&quot;Age&quot;:14&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>反序列化:</strong> JSON -&gt; 对象</p><ul><li><code>JSON.parse()</code>：把JSON变成一个JavaScript对象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;[1,2,3,true]&#x27;</span>); <span class="comment">// [1, 2, 3, true]</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;&#123;&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:14&#125;&#x27;</span>); <span class="comment">// Object &#123;name: &#x27;小明&#x27;, age: 14&#125;</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;true&#x27;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;123.45&#x27;</span>); <span class="comment">// 123.45</span></span><br></pre></td></tr></table></figure><ul><li><code>JSON.parse()</code>还可以接收一个函数，用来转换解析出的属性：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">JSON</span>.parse(<span class="string">&#x27;&#123;&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:14&#125;&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key === <span class="string">&#x27;name&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value + <span class="string">&#x27;同学&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj)); <span class="comment">// &#123;name: &#x27;小明同学&#x27;, age: 14&#125;</span></span><br></pre></td></tr></table></figure><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>构造</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.type = <span class="string">&#x27;class&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;this is a func&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>();  <span class="comment">// 调用 father 的类构造函数</span></span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;this is a son func&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> Son(<span class="string">&#x27;cindy&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="use-strict"><a href="#use-strict" class="headerlink" title="use strict"></a>use strict</h2><ul><li>在第一行加上 <code>&#39;use strict&#39;</code> 表示启用严格模式<ul><li>ES6 的模块自动采用严格模式，不管你有没有在模块头部加上<code>&quot;use strict&quot;;</code>。</li></ul></li><li>主要限制：<ul><li>变量必须声明后再使用</li><li>函数的参数不能有同名属性，否则报错</li><li>不能使用<code>with</code>语句</li><li>不能对只读属性赋值，否则报错</li><li>不能使用前缀0表示八进制数，否则报错</li><li>不能删除不可删除的属性，否则报错</li><li>不能删除变量<code>delete prop</code>，会报错，只能删除属性<code>delete global[prop]</code></li><li><code>eval</code>不会在它的外层作用域引入变量</li><li><code>eval</code>和<code>arguments</code>不能被重新赋值</li><li><code>arguments</code>不会自动反映函数参数的变化</li><li>不能使用<code>arguments.callee</code></li><li>不能使用<code>arguments.caller</code></li><li>禁止<code>this</code>指向全局对象</li><li>不能使用<code>fn.caller</code>和<code>fn.arguments</code>获取函数调用的堆栈</li><li>增加了保留字（比如<code>protected</code>、<code>static</code>和<code>interface</code>）</li></ul></li></ul><h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><h2 id="module"><a href="#module" class="headerlink" title="module"></a>module</h2><p>用来提供nodejs的模块化功能</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* a.js */</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;My name is Lemmy Kilmister&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="built_in">exports</span> = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;My name is Lemmy Kilmister&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* b.js */</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">&#x27;a.js&#x27;</span>);</span><br><span class="line">a(); <span class="comment">// My name is Lemmy Kilmister</span></span><br></pre></td></tr></table></figure><ul><li>所有的<strong>exports</strong>收集到的属性和方法，都赋值给了**<code>Module.exports</code><strong>。当然，这有个前提，就是</strong><code>Module.exports</code><strong>本身不具备任何属性和方法。如果，</strong><code>Module.exports</code><strong>已经具备一些属性和方法，那么</strong>exports**收集来的信息将被忽略.</li></ul><h3 id="module-exports"><a href="#module-exports" class="headerlink" title="module.exports"></a>module.exports</h3><p><strong>模块规范</strong></p><ul><li><code>CommonJS</code>模块规范和<code>ES6</code>模块规范完全是两种不同的概念。</li><li><a class="link" href="http://javascript.ruanyifeng.com/nodejs/module.html">CommonJS规范<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" href="http://es6.ruanyifeng.com/#docs/module">ES6 Module 的语法<i class="fas fa-external-link-alt"></i></a></li></ul><p><strong>CommonJS</strong></p><ul><li><strong>Node</strong>应用由模块组成，采用CommonJS模块规范。</li><li>根据这个规范，每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。</li><li>CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。</li></ul><ul><li>下面代码通过module.exports输出变量x和函数addX。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> addX = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value + x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports.x = x;</span><br><span class="line"><span class="built_in">module</span>.exports.addX = addX;</span><br></pre></td></tr></table></figure><ul><li>require方法用于加载模块。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> example = <span class="built_in">require</span>(<span class="string">&#x27;./example.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(example.x); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(example.addX(<span class="number">1</span>)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><ul><li><strong>exports 与 module.exports</strong><ul><li>为了方便，Node为每个模块提供一个exports变量，指向module.exports。这等同在每个模块头部，有一行这样的命令。</li><li><code>var exports = module.exports;</code></li><li>于是我们可以直接在 exports 对象上添加方法，表示对外输出的接口，如同在module.exports 上添加一样。注意，不能直接将exports变量指向一个值，因为这样等于切断了exports与module.exports的联系。</li></ul></li></ul><p><strong>ES6</strong></p><ul><li>不同于CommonJS，ES6使用 export 和 import 来导出、导入模块。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// profile.js</span></span><br><span class="line"><span class="keyword">var</span> firstName = <span class="string">&#x27;Michael&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> lastName = <span class="string">&#x27;Jackson&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> year = <span class="number">1958</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;firstName, lastName, year&#125;;</span><br></pre></td></tr></table></figure><ul><li>需要特别注意的是，export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;m&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法三</span></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;n <span class="keyword">as</span> m&#125;;</span><br></pre></td></tr></table></figure><p><strong>export default</strong></p><ul><li>使用export default命令，为模块指定默认输出。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// export-default.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="fs"><a href="#fs" class="headerlink" title="fs"></a>fs</h2><ul><li>文件系统模块，负责读写文件</li><li>和所有其它JavaScript模块不同的是，<code>fs</code>模块同时提供了异步和同步的方法。、</li></ul><p><strong>异步读文件</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">&#x27;sample.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>异步读取时，传入的回调函数接收两个参数，当正常读取时，<code>err</code>参数为<code>null</code>，<code>data</code>参数为读取到的String。当读取发生错误时，<code>err</code>参数代表一个错误对象，<code>data</code>为<code>undefined</code>。</li><li>这也是Node.js<strong>标准的</strong>回调函数：第一个参数代表错误信息，第二个参数代表结果。后面我们还会经常编写这种回调函数。</li></ul><p>读取图片</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">&#x27;sample.png&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">        <span class="built_in">console</span>.log(data.length + <span class="string">&#x27; bytes&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>当读取二进制文件时，不传入文件编码时，回调函数的<code>data</code>参数将返回一个<code>Buffer</code>对象。在Node.js中，<code>Buffer</code>对象就是一个包含零个或任意个字节的数组（注意和Array不同）。<ul><li><code>Buffer</code>对象可以和String作转换，例如，把一个<code>Buffer</code>对象转换成String：</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Buffer -&gt; String</span></span><br><span class="line"><span class="keyword">var</span> text = data.toString(<span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(text);</span><br></pre></td></tr></table></figure><ul><li>或者把一个String转换成<code>Buffer</code>：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String -&gt; Buffer</span></span><br><span class="line"><span class="keyword">var</span> buf = Buffer.from(text, <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(buf);</span><br></pre></td></tr></table></figure><p><strong>同步读文件</strong></p><ul><li>同步读取的函数和异步函数相比，多了一个<code>Sync</code>后缀，并且不接收回调函数，函数直接返回结果。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data = fs.readFileSync(<span class="string">&#x27;sample.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(data);</span><br></pre></td></tr></table></figure><ul><li>如果同步读取文件发生错误，则需要用<code>try...catch</code>捕获该错误：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data = fs.readFileSync(<span class="string">&#x27;sample.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="comment">// 出错了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="path"><a href="#path" class="headerlink" title="path"></a>path</h2><p><code>path</code> 模块的默认操作会因 Node.js 应用程序运行所在的操作系统而异。 具体来说，当在 Windows 操作系统上运行时， <code>path</code> 模块会假定正被使用的是 Windows 风格的路径。</p><h3 id="path-dirname"><a href="#path-dirname" class="headerlink" title="path.dirname()"></a>path.dirname()</h3><h3 id="path-join-…paths"><a href="#path-join-…paths" class="headerlink" title="path.join([…paths])"></a>path.join([…paths])</h3><p><code>path.join()</code> 方法会将所有给定的 <code>path</code> 片段连接到一起（使用平台特定的分隔符作为定界符），然后规范化生成的路径。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line">path.join(<span class="string">&#x27;/目录1&#x27;</span>, <span class="string">&#x27;目录2&#x27;</span>, <span class="string">&#x27;目录3/目录4&#x27;</span>, <span class="string">&#x27;目录5&#x27;</span>, <span class="string">&#x27;..&#x27;</span>);</span><br><span class="line"><span class="comment">// 返回: &#x27;/目录1/目录2/目录3/目录4&#x27;</span></span><br><span class="line"></span><br><span class="line">path.join(<span class="string">&#x27;目录1&#x27;</span>, &#123;&#125;, <span class="string">&#x27;目录2&#x27;</span>);</span><br><span class="line"><span class="comment">// 抛出 &#x27;TypeError: Path must be a string. Received &#123;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>参数<ul><li>**[…paths]**：路径片段的序列。</li><li>返回：string</li></ul></li><li>如果任何的路径片段不是字符串，则抛出 <a href="http://nodejs.cn/api/errors.html#errors_class_typeerror"><code>TypeError</code></a>。</li><li>长度为零的 <code>path</code> 片段会被忽略。 如果连接后的路径字符串为长度为零的字符串，则返回 <code>&#39;.&#39;</code>，表示当前工作目录。</li></ul><h3 id="path-resolve-…paths"><a href="#path-resolve-…paths" class="headerlink" title="path.resolve([…paths])"></a>path.resolve([…paths])</h3><p><code>path.resolve()</code> 方法会将路径或路径片段的序列解析为绝对路径。</p><p>给定的路径序列会从右到左进行处理，后面的每个 <code>path</code> 会被追加到前面，直到构造出<strong>绝对路径</strong>。 </p><ul><li>例如，给定的路径片段序列：[/目录1、/目录2、目录3]，调用 <code>path.resolve(&#39;/目录1&#39;, &#39;/目录2&#39;, &#39;目录3&#39;)</code> 会返回 <code>/目录2/目录3</code>，因为 <code>&#39;目录3&#39;</code> 不是绝对路径，但 <code>&#39;/目录2&#39; + &#39;/&#39; + &#39;目录3&#39;</code> 是。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line">path.resolve(<span class="string">&#x27;/目录1/目录2&#x27;</span>, <span class="string">&#x27;./目录3&#x27;</span>);</span><br><span class="line"><span class="comment">// 返回: &#x27;/目录1/目录2/目录3&#x27;</span></span><br><span class="line"></span><br><span class="line">path.resolve(__dirname, <span class="string">&#x27;/目录3/目录4/&#x27;</span>);</span><br><span class="line"><span class="comment">// 返回: &#x27;当前目录路径/目录3/目录4&#x27;</span></span><br><span class="line"></span><br><span class="line">path.resolve(<span class="string">&#x27;目录1&#x27;</span>, <span class="string">&#x27;目录2/目录3/&#x27;</span>, <span class="string">&#x27;../目录4/文件.gif&#x27;</span>);</span><br><span class="line"><span class="comment">// 如果当前工作目录是 /目录A/目录B，</span></span><br><span class="line"><span class="comment">// 则返回 &#x27;/目录A/目录B/目录1/目录2/目录4/文件.gif&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>参数：<ul><li>**[…paths]**：路径片段的序列。</li><li>返回：string</li></ul></li><li>如果在处理完所有给定的 <code>path</code> 片段之后还未生成绝对路径，则会使用当前工作目录。</li><li>生成的路径会被规范化，并且尾部的斜杠会被删除（除非路径被解析为根目录）。</li><li>零长度的 <code>path</code> 片段会被忽略。</li><li>如果没有传入 <code>path</code> 片段，则 <code>path.resolve()</code> 会返回<strong>当前工作目录</strong>的绝对路径。</li></ul><h3 id="path-relate-from-to"><a href="#path-relate-from-to" class="headerlink" title="path.relate(from, to)"></a>path.relate(from, to)</h3><p><code>path.relative()</code> 方法根据当前工作目录返回 <code>from</code> 到 <code>to</code> 的相对路径。</p><ul><li><p>如果 <code>from</code> 和 <code>to</code> 各自解析到相同的路径（分别调用 <code>path.resolve()</code> 之后），则返回零长度的字符串。</p></li><li><p>如果将零长度的字符串传入 <code>from</code> 或 <code>to</code>，则使用当前工作目录代替该零长度的字符串。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* POSIX上 */</span></span><br><span class="line">path.relative(<span class="string">&#x27;/data/orandea/test/aaa&#x27;</span>, <span class="string">&#x27;/data/orandea/impl/bbb&#x27;</span>);</span><br><span class="line"><span class="comment">// 返回: &#x27;../../impl/bbb&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Windows上 */</span></span><br><span class="line">path.relative(<span class="string">&#x27;C:\\orandea\\test\\aaa&#x27;</span>, <span class="string">&#x27;C:\\orandea\\impl\\bbb&#x27;</span>);</span><br><span class="line"><span class="comment">// 返回: &#x27;..\\..\\impl\\bbb&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>参数：<ul><li><strong>from</strong>：string</li><li><strong>to</strong>：string</li><li>返回：string</li></ul></li><li>如果 <code>from</code> 或 <code>to</code> 不是字符串，则抛出 <a href="http://nodejs.cn/api/errors.html#errors_class_typeerror"><code>TypeError</code></a>。</li></ul><h2 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h2><h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入http模块:</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建http server，并传入回调函数:</span></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(req.method == <span class="string">&quot;GET&quot;</span>)&#123;</span><br><span class="line">        doGet(req, res)</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(req.method == <span class="string">&quot;POST&quot;</span>)&#123;</span><br><span class="line">        doPost(req, res)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        res.end();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 让服务器监听8080端口:</span></span><br><span class="line">server.listen(<span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doGet</span>(<span class="params">request, response</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 回调函数接收request和response对象,</span></span><br><span class="line">    <span class="comment">// 获得HTTP请求的method和url:</span></span><br><span class="line">    <span class="built_in">console</span>.log(request.method + <span class="string">&#x27;: &#x27;</span> + request.url);</span><br><span class="line">    <span class="comment">// 解析请求的Url，返回一个标准的对象</span></span><br><span class="line">    <span class="keyword">var</span> params = url.parse(request.url, <span class="literal">true</span>);   </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 向http请求返回一个表单</span></span><br><span class="line">    <span class="comment">// 协议头，将HTTP响应200写入response, 同时设置Content-Type: text/html:</span></span><br><span class="line">    response.writeHead(<span class="number">200</span>, &#123;<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/html&#x27;</span>&#125;);</span><br><span class="line">    response.write(<span class="string">&#x27;&lt;html&gt;&#x27;</span>);</span><br><span class="line">    response.write(<span class="string">&#x27;&lt;head&gt;&#x27;</span>);</span><br><span class="line">    response.write(<span class="string">&#x27;&lt;meta charset=&quot;utf-8&quot;&gt;&#x27;</span>);</span><br><span class="line">    response.write(<span class="string">&#x27;&lt;title&gt;&#x27;</span>);</span><br><span class="line">    response.write(<span class="string">&#x27;&lt;/title&gt;&#x27;</span>);</span><br><span class="line">    response.write(<span class="string">&#x27;&lt;/head&gt;&#x27;</span>);</span><br><span class="line">    response.write(<span class="string">&#x27;&lt;body&gt;&#x27;</span>);</span><br><span class="line">    response.write(<span class="string">&#x27;&lt;form method=&quot;post&quot;&gt;&#x27;</span>);  <span class="comment">//表单post输出传入下面的函数</span></span><br><span class="line">    response.write(<span class="string">&#x27;username:&lt;input name=&quot;username&quot;&gt;&#x27;</span>);</span><br><span class="line">    response.write(<span class="string">&#x27;password:&lt;input name=&quot;password&quot;&gt;&lt;input type=&quot;submit&quot;&gt;&#x27;</span>);</span><br><span class="line">    response.write(<span class="string">&#x27;&lt;/form&gt;&#x27;</span>);</span><br><span class="line">    response.write(<span class="string">&#x27;&lt;/body&gt;&#x27;</span>);</span><br><span class="line">    response.write(<span class="string">&#x27;&lt;/html&gt;&#x27;</span>);</span><br><span class="line">    <span class="comment">// 将HTTP响应的HTML内容写入response:</span></span><br><span class="line">    response.end()</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doPost</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> formDate = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 通过req的data事件监听函数，每当接受到请求体的数据，就累加到formDate变量中</span></span><br><span class="line">    req.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        formDate += data;</span><br><span class="line">        <span class="built_in">console</span>.log(data); </span><br><span class="line"><span class="comment">//&lt;Buffer 75 73 65 72 6e 61 6d 65 3d 25 45 39 25 41 44 25 38 46 25 45 36 25 42 34 25 38 31 25 45 36 25 39 44 25 41 38 26 70 61 73 73 77 6f 72 64 3d 34 35 36 37&gt;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 在end事件触发后，通过querystring.parse将formDate解析为真正的POST请求格式，然后向客户端返回。</span></span><br><span class="line">    req.on(<span class="string">&#x27;end&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> body = querystring.parse(formDate);</span><br><span class="line">    res.end(util.inspect(body));</span><br><span class="line">      <span class="comment">// [Object: null prototype] &#123; username: &#x27;wjy&#x27;, password: &#x27;456&#x27; &#125;</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Server is running at http://127.0.0.1:8080/&#x27;</span>);</span><br></pre></td></tr></table></figure><ul><li><code>request</code>：封装了HTTP请求，我们调用<code>request</code>对象的属性和方法就可以拿到所有HTTP请求的信息；<ul><li>{‘Content-Type’: ‘text/html’}：设置类型为html页面</li><li><strong>方法</strong><ul><li><code>req.on(&#39;data&#39;, function(data)&#123;&#125;)</code>：data为一个buffer数据，需要将所有数据包的字节都存储起来，再来分析</li><li><code>req.on(&#39;end&#39;, function(data)&#123;  res.end();  &#125;)</code>：在出发结束的函数后，再在他的function里面结束相应<code>res.end();</code></li></ul></li></ul></li><li><code>response</code>：封装了HTTP响应，我们操作<code>response</code>对象的方法，就可以把HTTP响应返回给浏览器。<ul><li><strong>方法</strong><ul><li><code>response.writeHead()</code>：设置http协议头，给浏览器看的</li><li><code>response.write()</code>：仅发送数据</li><li><code>response.end()</code>：发送并结束请求，必须有，可以发送空</li></ul></li></ul></li></ul><p><strong>编码模式</strong></p><ul><li>浏览器默认<code>urlencode</code>字符集编码，不支持中文<ul><li>接收浏览器的请求数据res，在nodejs中输出是中文适配的</li><li>但是如果直接将中文传到浏览器输出将会出现乱码，所以设置html页面属性meta为<code>utf-8</code></li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">res.write(<span class="string">&#x27;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;/&gt;&lt;/head&gt;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">------ urlcode 加解码 ------</span><br><span class="line"><span class="built_in">encodeURI</span>(<span class="string">&quot;魏洁杨&quot;</span>);    <span class="comment">// %E9%AD%8F%E6%B4%81%E6%9D%A8</span></span><br><span class="line"><span class="built_in">decodeURI</span>(<span class="string">&quot;%E9%AD%8F%E6%B4%81%E6%9D%A8&quot;</span>)   <span class="comment">//魏洁杨</span></span><br></pre></td></tr></table></figure><p><strong>请求内容</strong></p><ul><li>GET：<ul><li>由于GET请求直接被嵌入在路径中，URL是完整的请求路径，包括了?后面的部分，因此你可以手动解析后面的内容作为GET请求的参数。</li><li>下面 url 模块中的 <code>parse</code>函数提供了这个功能。</li></ul></li><li>POST：<ul><li>POST 请求的内容全部的都在请求体中，http.ServerRequest 并没有一个属性内容为请求体，原因是等待请求体传输可能是一件耗时的工作。</li><li>比如上传文件，而很多时候我们可能并不需要理会请求体的内容，恶意的POST请求会大大消耗服务器的资源，所以 node.js 默认是不会解析请求体的，当你需要的时候，需要手动来做。</li><li>下面的querystring和util模块提供了相应的处理</li></ul></li></ul><h2 id="url"><a href="#url" class="headerlink" title="url"></a>url</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(url.parse(<span class="string">&#x27;http://user:pass@host.com:8080/path/to/file?query=string#hash&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出 */</span></span><br><span class="line">Url &#123;</span><br><span class="line">  protocol: <span class="string">&#x27;http:&#x27;</span>,</span><br><span class="line">  slashes: <span class="literal">true</span>,</span><br><span class="line">  auth: <span class="string">&#x27;user:pass&#x27;</span>,</span><br><span class="line">  host: <span class="string">&#x27;host.com:8080&#x27;</span>,</span><br><span class="line">  port: <span class="string">&#x27;8080&#x27;</span>,</span><br><span class="line">  hostname: <span class="string">&#x27;host.com&#x27;</span>,</span><br><span class="line">  hash: <span class="string">&#x27;#hash&#x27;</span>,</span><br><span class="line">  search: <span class="string">&#x27;?query=string&#x27;</span>,</span><br><span class="line">  query: <span class="string">&#x27;query=string&#x27;</span>,</span><br><span class="line">  pathname: <span class="string">&#x27;/path/to/file&#x27;</span>,</span><br><span class="line">  path: <span class="string">&#x27;/path/to/file?query=string&#x27;</span>,</span><br><span class="line">  href: <span class="string">&#x27;http://user:pass@host.com:8080/path/to/file?query=string#hash&#x27;</span> &#125;</span><br></pre></td></tr></table></figure><h2 id="querystring"><a href="#querystring" class="headerlink" title="querystring"></a>querystring</h2><p>模块提供用于解析和格式化 URL 查询字符串的实用工具</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123; unescapeBuffer: [Function],</span></span><br><span class="line"><span class="comment">  unescape: [Function: qsUnescape],</span></span><br><span class="line"><span class="comment">  escape: [Function],</span></span><br><span class="line"><span class="comment">  encode: [Function],</span></span><br><span class="line"><span class="comment">  stringify: [Function],</span></span><br><span class="line"><span class="comment">  decode: [Function],</span></span><br><span class="line"><span class="comment">  parse: [Function] &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">console</span>.log(querystring);</span><br></pre></td></tr></table></figure><p><strong>序列化：url -&gt; 对象</strong></p><p><code>querystring.parse(str[, sep[, eq[, options]]])</code></p><ul><li><p>把一个URL查询字符串(str)解析成一个<strong>键值对的集合</strong></p></li><li><p>参数</p><ul><li><p><strong>str</strong>：要解析的 URL 查询字符串</p></li><li><p><strong>sep</strong>：用于在查询字符串中分隔键值对的子字符串。<strong>默认值:</strong> <code>&#39;&amp;&#39;</code></p></li><li><p><strong>eq</strong>：用于在查询字符串中分隔键和值的子字符串。<strong>默认值:</strong> <code>&#39;=&#39;</code>。</p></li><li><p><strong>Options</strong>：</p><ul><li><code>decodeURIComponent</code> <a href="http://url.nodejs.cn/ceTQa6"><Function></Function></a> 当解码查询字符串中的百分比编码字符时使用的函数。<strong>默认值:</strong> <code>querystring.unescape()</code>。</li><li><code>maxKeys</code> <a href="http://url.nodejs.cn/SXbo1v"><number></number></a> 指定要解析的键的最大数量。指定 <code>0</code> 可移除键的计数限制。<strong>默认值:</strong> <code>1000</code>。</li><li>注：默认情况下，会假定查询字符串中的百分比编码字符使用 UTF-8 编码。 如果使用其他的字符编码，则需要指定其他的 <code>decodeURIComponent</code> 选项</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;foo=bar&amp;abc=xyz&amp;abc=123&quot;</span></span><br><span class="line"><span class="keyword">var</span> body = querystring.parse(str)</span><br><span class="line"><span class="comment">//body = &#x27;&#123; foo: &#x27;bar&#x27;, abc: [ &#x27;xyz&#x27;, &#x27;123&#x27; ] &#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">querystring.parse(<span class="string">&#x27;w=%D6%D0%CE%C4&amp;foo=bar&#x27;</span>, <span class="literal">null</span>, <span class="literal">null</span>,</span><br><span class="line">                  &#123; <span class="attr">decodeURIComponent</span>: gbkDecodeURIComponent &#125;);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>注意：本方法返回的对象不继承自 JavaScript 的 Object。 这意味着典型的 Object 方法如 <code>obj.toString()</code>、<code>obj.hasOwnProperty()</code>等没有被定义且无法使用</p></li></ul><p><strong>反序列化：对象 -&gt; url</strong></p><p><code>querystring.stringify(obj[, sep][, eq][, options])</code></p><ul><li><p>通过遍历对象的自有属性，从一个给定的obj产生一个URL查询字符串</p></li><li><p>参数：</p><ul><li><p><strong>obj</strong>：要序列化为 URL 查询字符串的对象。</p></li><li><p><strong>sep</strong>：用于在查询字符串中分隔键值对的子字符串。<strong>默认值:</strong> <code>&#39;&amp;&#39;</code></p></li><li><p><strong>eq</strong>：用于在查询字符串中分隔键和值的子字符串。<strong>默认值:</strong> <code>&#39;=&#39;</code></p></li><li><p><strong>options</strong>：</p><ul><li><code>decodeURIComponent</code> <a href="http://url.nodejs.cn/ceTQa6"><Function></Function></a> 当解码查询字符串中的百分比编码字符时使用的函数。<strong>默认值:</strong> <code>querystring.unescape()</code>。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">querystring.stringify(&#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>: [<span class="string">&#x27;qux&#x27;</span>, <span class="string">&#x27;quux&#x27;</span>], <span class="attr">corge</span>: <span class="string">&#x27;&#x27;</span> &#125;);</span><br><span class="line"><span class="comment">// 返回 &#x27;foo=bar&amp;baz=qux&amp;baz=quux&amp;corge=&#x27;</span></span><br><span class="line"></span><br><span class="line">querystring.stringify(&#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>: <span class="string">&#x27;qux&#x27;</span> &#125;, <span class="string">&#x27;;&#x27;</span>, <span class="string">&#x27;:&#x27;</span>);</span><br><span class="line"><span class="comment">// 返回 &#x27;foo:bar;baz:qux&#x27;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>编码</strong></p><p><code>querystring.escape(str)</code></p><p><code>querystring.unescape(str)</code></p><ul><li><p>给定的 <code>str</code> 上执行 URL 百分比编码字符的解码</p></li><li><p><code>querystring.unescape()</code> 方法由 <code>querystring.parse()</code> 使用，通常不会被直接地使用。 它的导出主要是为了允许应用程序代码在需要时通过将 <code>querystring.unescape</code> 赋值给替代函数来提供替换的解码实现。</p><p>默认情况下， <code>querystring.unescape()</code> 方法将会尝试使用 JavaScript 内置的 <code>decodeURIComponent()</code> 方法进行解码。 如果失败，则将会使用更保险的不会因格式错误的 URL 而抛出异常的同类方法。</p></li></ul><h2 id="body-parser"><a href="#body-parser" class="headerlink" title="body-parser"></a>body-parser</h2><h2 id="socket-io"><a href="#socket-io" class="headerlink" title="socket.io"></a>socket.io</h2><h2 id="crypto"><a href="#crypto" class="headerlink" title="crypto"></a>crypto</h2><p><code>crypto.createHash(algorithm, key[, options])</code></p><h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><h3 id="silly-datetime"><a href="#silly-datetime" class="headerlink" title="silly-datetime"></a>silly-datetime</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sd = <span class="built_in">require</span>(<span class="string">&#x27;silly-datetime&#x27;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* silly-datetime 当前时间格式化 */</span></span><br><span class="line"><span class="built_in">console</span>.log(sd.format(<span class="keyword">new</span> <span class="built_in">Date</span>(), <span class="string">&#x27;YYYY-MM-DD HH:mm&#x27;</span>));</span><br><span class="line"><span class="comment">// 2021-04-18 12:18</span></span><br><span class="line"><span class="built_in">console</span>.log(sd.format(<span class="keyword">new</span> <span class="built_in">Date</span>(), <span class="string">&#x27;YYYY-MM-DD HH:mm:ss&#x27;</span>));</span><br><span class="line"><span class="comment">// 2021-04-18 12:18:04</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 通过时间戳拼接 格式化时间 */</span></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>((<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime())</span><br><span class="line">    Y = date.getFullYear() + <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    M = (date.getMonth()+<span class="number">1</span> &lt; <span class="number">10</span> ? <span class="string">&#x27;0&#x27;</span>+(date.getMonth()+<span class="number">1</span>) : date.getMonth()+<span class="number">1</span>) + <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">        D = (date.getDate() &lt; <span class="number">10</span> ? <span class="string">&#x27;0&#x27;</span>+date.getDate() : date.getDate()) + <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        h = (date.getHours() &lt; <span class="number">10</span> ? <span class="string">&#x27;0&#x27;</span>+date.getHours() : date.getHours()) + <span class="string">&#x27;:&#x27;</span>;</span><br><span class="line">        m = (date.getMinutes() &lt; <span class="number">10</span> ? <span class="string">&#x27;0&#x27;</span>+date.getMinutes() : date.getMinutes()) + <span class="string">&#x27;:&#x27;</span>;</span><br><span class="line">        s = (date.getSeconds() &lt; <span class="number">10</span> ? <span class="string">&#x27;0&#x27;</span>+date.getSeconds() : date.getSeconds());</span><br><span class="line"><span class="built_in">console</span>.log(Y+M+D+h+m+s);</span><br><span class="line"><span class="comment">// 2021-04-18 12:18:04</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取当前时间戳 */</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime());</span><br><span class="line"><span class="comment">// 1618719753004</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="keyword">new</span> <span class="built_in">Date</span>()).valueOf());</span><br><span class="line"><span class="comment">// 1618719753007</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Date</span>.parse(<span class="keyword">new</span> <span class="built_in">Date</span>()));</span><br><span class="line"><span class="comment">// 1618719753000</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 将指定时间转化成时间戳 */</span></span><br><span class="line"><span class="keyword">var</span> newDate = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&#x27;2021-04-18 12:25:13&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(newDate.getTime());</span><br><span class="line"><span class="comment">// 1618719913000</span></span><br></pre></td></tr></table></figure><h3 id="moment"><a href="#moment" class="headerlink" title="moment"></a>moment</h3><ol><li>日期格式化</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moment = <span class="built_in">require</span>(<span class="string">&#x27;moment&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(moment().format(<span class="string">&#x27;MMMM Do YYYY, h:mm:ss a&#x27;</span>));</span><br><span class="line"><span class="comment">// April 18th 2021, 12:29:11 pm</span></span><br><span class="line"><span class="built_in">console</span>.log(moment().format(<span class="string">&#x27;dddd&#x27;</span>));</span><br><span class="line"><span class="comment">// Sunday</span></span><br><span class="line"><span class="built_in">console</span>.log(moment().format(<span class="string">&quot;MMM Do YY&quot;</span>));</span><br><span class="line"><span class="comment">// Apr 18th 21</span></span><br><span class="line"><span class="built_in">console</span>.log(moment().format(<span class="string">&#x27;YYYY [escaped] YYYY&#x27;</span>));</span><br><span class="line"><span class="comment">// 2021 escaped 2021</span></span><br><span class="line"><span class="built_in">console</span>.log(moment().format());</span><br><span class="line"><span class="comment">// 2021-04-18T12:29:11+08:00</span></span><br></pre></td></tr></table></figure><ol start="2"><li>相对时间</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 当前时间 */</span></span><br><span class="line"><span class="built_in">console</span>.log(moment().format()); <span class="comment">// 2021-04-18T12:32:11+08:00</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 相对时间 */</span></span><br><span class="line"><span class="built_in">console</span>.log(moment(<span class="string">&quot;20111031&quot;</span>, <span class="string">&quot;YYYYMMDD&quot;</span>).fromNow());</span><br><span class="line"><span class="comment">// 9 years ago</span></span><br><span class="line"><span class="built_in">console</span>.log(moment(<span class="string">&quot;20120620&quot;</span>, <span class="string">&quot;YYYYMMDD&quot;</span>).fromNow());</span><br><span class="line"><span class="comment">// 9 years ago</span></span><br><span class="line"><span class="built_in">console</span>.log(moment().startOf(<span class="string">&#x27;day&#x27;</span>).fromNow());</span><br><span class="line"><span class="comment">// 13 hours ago</span></span><br><span class="line"><span class="built_in">console</span>.log(moment().endOf(<span class="string">&#x27;day&#x27;</span>).fromNow());</span><br><span class="line"><span class="comment">// in 11 hours</span></span><br><span class="line"><span class="built_in">console</span>.log(moment().startOf(<span class="string">&#x27;hour&#x27;</span>).fromNow());</span><br><span class="line"><span class="comment">// 31 minutes ago</span></span><br></pre></td></tr></table></figure><ol start="3"><li>日历时</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 当前时间 */</span></span><br><span class="line"><span class="built_in">console</span>.log(moment().format()); <span class="comment">// 2021-04-18T12:35:03+08:00</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 日历时间 */</span></span><br><span class="line"><span class="built_in">console</span>.log(moment().subtract(<span class="number">10</span>, <span class="string">&#x27;days&#x27;</span>).calendar());</span><br><span class="line"><span class="comment">// 04/08/2021</span></span><br><span class="line"><span class="built_in">console</span>.log(moment().subtract(<span class="number">6</span>, <span class="string">&#x27;days&#x27;</span>).calendar());</span><br><span class="line"><span class="comment">// Last Monday at 12:35 PM</span></span><br><span class="line"><span class="built_in">console</span>.log(moment().subtract(<span class="number">3</span>, <span class="string">&#x27;days&#x27;</span>).calendar());</span><br><span class="line"><span class="comment">// Last Thursday at 12:35 PM</span></span><br><span class="line"><span class="built_in">console</span>.log(moment().subtract(<span class="number">1</span>, <span class="string">&#x27;days&#x27;</span>).calendar());</span><br><span class="line"><span class="comment">// Yesterday at 12:35 PM</span></span><br><span class="line"><span class="built_in">console</span>.log(moment().calendar());</span><br><span class="line"><span class="comment">// Today at 12:35 PM</span></span><br><span class="line"><span class="built_in">console</span>.log(moment().add(<span class="number">1</span>, <span class="string">&#x27;days&#x27;</span>).calendar());</span><br><span class="line"><span class="comment">// Tomorrow at 12:35 PM</span></span><br><span class="line"><span class="built_in">console</span>.log(moment().add(<span class="number">3</span>, <span class="string">&#x27;days&#x27;</span>).calendar());</span><br><span class="line"><span class="comment">// Wednesday at 12:35 PM</span></span><br><span class="line"><span class="built_in">console</span>.log(moment().add(<span class="number">10</span>, <span class="string">&#x27;days&#x27;</span>).calendar());</span><br><span class="line"><span class="comment">// Wednesday at 12:35 PM</span></span><br></pre></td></tr></table></figure><p>其他更多的函数参考：<a class="link" href="http://momentjs.cn/docs/">http://momentjs.cn/docs/<i class="fas fa-external-link-alt"></i></a></p><ol start="4"><li>示例<br>计算俩日期相差多少天</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前时间</span></span><br><span class="line"><span class="keyword">let</span> m1 = moment();</span><br><span class="line"><span class="comment">// 获取需要对比的时间</span></span><br><span class="line"><span class="keyword">let</span> m2 = moment(time);</span><br><span class="line"><span class="comment">// 计算相差多少天 day可以是second minute</span></span><br><span class="line">day = m2.diff(m1, <span class="string">&#x27;day&#x27;</span>);</span><br></pre></td></tr></table></figure><p>当前日期往后加几天</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moment().add(<span class="number">30</span>, <span class="string">&quot;days&quot;</span>).format(<span class="string">&#x27;YYYY-MM-DD HH:mm:ss&#x27;</span>)</span><br></pre></td></tr></table></figure><p>指定日期往后加几天</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moment(<span class="string">&quot;传入时间戳&quot;</span>).add(<span class="number">30</span>, <span class="string">&quot;days&quot;</span>).format(<span class="string">&#x27;YYYY-MM-DD HH:mm:ss&#x27;</span>)</span><br></pre></td></tr></table></figure><ol start="5"><li>clone</li></ol><p>所有的 moment 都是可变的。 如果想要克隆 moment，则可以隐式或显式地操作。</p><p>在 moment 上调用 moment() 将会克隆它。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = moment([<span class="number">2012</span>]);</span><br><span class="line"><span class="keyword">var</span> b = a.clone();</span><br><span class="line">a.year(<span class="number">2000</span>);</span><br><span class="line">b.year(); <span class="comment">// 2021</span></span><br></pre></td></tr></table></figure><h1 id="同步异步"><a href="#同步异步" class="headerlink" title="同步异步"></a>同步异步</h1><h2 id="async-await"><a href="#async-await" class="headerlink" title="async-await"></a>async-await</h2><p>Async/await的主要益处是可以避免回调地狱（callback hell），且以最接近同步代码的方式编写异步代码。</p><p><strong>基本概念</strong></p><ul><li>promise 对象：<ul><li>有三种状态：成功(Fulfilled)、失败(Rejected)、等待(Pending)</li><li>不配合&lt;async, await&gt;时，使用 <code>.then()</code> 和 <code>.catch()</code> 处理<strong>成功</strong>和<strong>失败</strong>情况是目前的常规方案。</li></ul></li><li>async 表示这是一个async函数，await只能用在这个函数里面。async 对象也是一个 promise 对象。</li><li>await 表示在这里等待 promise 返回结果了，再继续执行。</li><li>await 后面跟着的应该是一个 promise 对象（当然，其他返回值也没关系，不过那样就没有意义了…）</li><li>很多库的接口返回 promise 对象，await 后赋值给一个变量后使用其 resolve 的值。<a class="link" href="http://mongoosejs.com/docs/api.html#query_Query-exec">例如<i class="fas fa-external-link-alt"></i></a></li><li>注意三点，promise 对象的状态，promise 对象上的方法(then,catch),promise 对象返回的值。</li><li>promise 是当时为了解决回调地狱的解决方案，也是当前处理异步操作最流行和广泛使用的方案，async 和 await 最为当前的终极方案两只之间还有一些过渡方案。</li></ul><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> showArticle = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">PostModel.incPv(postId, <span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">resolve(result);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);<span class="comment">// pv 加 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> post = <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">PostModel.getPostById(postId, <span class="function"><span class="keyword">function</span> (<span class="params">article</span>) </span>&#123;</span><br><span class="line">resolve(article);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);<span class="comment">// 获取文章信息，相当于 post = article</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    userModel.getUserById(post.author,<span class="function"><span class="keyword">function</span> (<span class="params">author</span>) </span>&#123;</span><br><span class="line">      post.author=author;</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;);<span class="comment">//获取文章作者</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> comments = <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    CommentModel.getComments(post._id, <span class="function"><span class="keyword">function</span> (<span class="params">comment</span>) </span>&#123;</span><br><span class="line">      resolve(comment);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);<span class="comment">// 获取该文章所有留言</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; comments.length; i++)&#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      userModel.getUserById(comments[i].author,<span class="function"><span class="keyword">function</span> (<span class="params">author</span>) </span>&#123;</span><br><span class="line">        comments[i].author=author;</span><br><span class="line">        resolve();</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;);<span class="comment">//获取文章留言作者</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (!post) &#123;</span><br><span class="line">    req.session.error = <span class="string">&#x27;该文章不存在&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> res.redirect(<span class="string">&#x27;/post&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  res.render(<span class="string">&#x27;post&#x27;</span>,&#123;<span class="attr">post</span>: post, <span class="attr">comments</span>: comments&#125;);</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">showArticle();</span><br></pre></td></tr></table></figure><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><h2 id="实现延时"><a href="#实现延时" class="headerlink" title="实现延时"></a>实现延时</h2><p><a class="link" href="https://zhuanlan.zhihu.com/p/163292394">https://zhuanlan.zhihu.com/p/163292394<i class="fas fa-external-link-alt"></i></a></p><ol><li>使用 <code>setTimeout</code> 函数</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wait</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(), ms));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> wait(<span class="number">3000</span>); <span class="comment">//延时3秒</span></span><br></pre></td></tr></table></figure><ol start="2"><li>使用for和 <code>Date</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数实现，参数 delay 单位 毫秒 ；</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> t = <span class="built_in">Date</span>.now(); <span class="built_in">Date</span>.now() - t &lt;= delay;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方法，同步执行，阻塞后续程序的执行；</span></span><br><span class="line">sleep(<span class="number">5000</span>);</span><br></pre></td></tr></table></figure><ol start="3"><li>在nodejs平台调用Linux系统自带的 <code>sleep</code> 函数</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数实现，参数单位 秒 ；</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wait</span>(<span class="params">second</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// execSync 属于同步方法；异步方式请根据需要自行查询 node.js 的 child_process 相关方法；</span></span><br><span class="line">    <span class="keyword">let</span> ChildProcess_ExecSync = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>).execSync;</span><br><span class="line">    ChildProcess_ExecSync(<span class="string">&#x27;sleep &#x27;</span> + second);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方法；休眠 60 秒，即 1 分钟；</span></span><br><span class="line">wait( <span class="number">60</span> );</span><br></pre></td></tr></table></figure><h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><h2 id="express"><a href="#express" class="headerlink" title="express"></a>express</h2><ul><li>基于nodejs平台的web应用开发框架</li><li><a class="link" href="https://www.cnblogs.com/yiliweichinasoft/p/3851791.html">https://www.cnblogs.com/yiliweichinasoft/p/3851791.html<i class="fas fa-external-link-alt"></i></a></li></ul><p><strong>server.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">&#x27;body-parser&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = express();</span><br><span class="line">server.listen(<span class="number">8088</span>); <span class="comment">// server 后端监听的端口</span></span><br><span class="line"></span><br><span class="line">server.use(bodyParser.urlencoded(&#123;&#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* localhost:8088/try [get类型请求，post类型将会到 server.post()]</span></span><br><span class="line"><span class="comment"> * try后面跟的参数，将会存储为对象 req.params.id</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">server.get(<span class="string">&#x27;/try/:id&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;try&#x27;</span>);</span><br><span class="line">    res.send(<span class="string">`1111 <span class="subst">$&#123;req.params.id&#125;</span>`</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// localhost:8088/try/wjy 将会输出：</span></span><br><span class="line"><span class="comment">// try</span></span><br><span class="line"><span class="comment">// 1111 wjy</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* router 路径管理 */</span></span><br><span class="line">server.use(<span class="string">&#x27;/login&#x27;</span>, <span class="built_in">require</span>(<span class="string">&#x27;./router/login.js&#x27;</span>)());</span><br><span class="line"><span class="comment">// 访问 &#x27;localhost:8088/login&#x27; 将会定位到文件夹 router 下的 login.js文件</span></span><br><span class="line"></span><br><span class="line">server.use(<span class="string">&#x27;/home&#x27;</span>, <span class="built_in">require</span>(<span class="string">&#x27;./router/home&#x27;</span>)());</span><br><span class="line"><span class="comment">// 访问 &#x27;localhost:8088/home&#x27; 将会定位到整个文件夹 home 下</span></span><br></pre></td></tr></table></figure><p><strong>router/login.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadUser</span>(<span class="params">req, res, next</span>) </span>&#123;            </span><br><span class="line">  <span class="comment">// You would fetch your user from the db            </span></span><br><span class="line">  <span class="keyword">var</span> user = users[req.params.id];            </span><br><span class="line">  <span class="keyword">if</span> (user) &#123;            </span><br><span class="line">    req.user = user;            </span><br><span class="line">    next();            </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;            </span><br><span class="line">    next(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Failed to load user &#x27;</span> + req.params.id));            </span><br><span class="line">  &#125;            </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">andRestrictToSelf</span>(<span class="params">req, res, next</span>) </span>&#123;            </span><br><span class="line">  req.authenticatedUser.id == req.user.id            </span><br><span class="line">    ? next()            </span><br><span class="line">    : next(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Unauthorized&#x27;</span>));            </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> responseData;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> router = express.Router();</span><br><span class="line">router.use(<span class="string">&#x27;/&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>)</span>&#123;</span><br><span class="line">    responseData = &#123;  <span class="comment">// 返回值标准化</span></span><br><span class="line">        code: <span class="string">&#x27;&#x27;</span>,     <span class="comment">// 状态吗</span></span><br><span class="line">        message: <span class="string">&#x27;&#x27;</span>   <span class="comment">// 一般为json类型</span></span><br><span class="line">    &#125;</span><br><span class="line">    next(); <span class="comment">// 将会接着执行下面的函数</span></span><br><span class="line">&#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 同时处理多个函数 */</span></span><br><span class="line">router.get(<span class="string">&#x27;/user/:id/edit&#x27;</span>, loadUser, andRestrictToSelf, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;            </span><br><span class="line">  res.send(<span class="string">&#x27;Editing user &#x27;</span> + req.user.name);            </span><br><span class="line">&#125;);</span><br><span class="line">  </span><br><span class="line"><span class="keyword">return</span> router;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当用户访问：<code>/user/gainover/edit</code> 时，首先会调用第一个处理函数loadUser，判断用户是否存在于users中，如果不存在，通过 <code>next(new Error(msg)); </code> 的方式抛出异常，否则，执行next()，而next此时实际就是指向 andRestrictToSelf 函数，然后判断当前登录的id和被编辑的id是否等同，如果等同，则继续 <code>next()</code>，从而执行 <code>res.send( ...);</code></li></ul><h2 id="koa"><a href="#koa" class="headerlink" title="koa"></a>koa</h2><h2 id="Fabric"><a href="#Fabric" class="headerlink" title="Fabric"></a>Fabric</h2><p>（指路fabric篇）</p><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><h2 id="多人实时聊天服务器"><a href="#多人实时聊天服务器" class="headerlink" title="多人实时聊天服务器"></a>多人实时聊天服务器</h2><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p><code>npm install socket.io --save</code>    </p><ul><li><p>网络上的程序实现双向的数据链接，这个链接的一端成为socket。</p><p> 1.Socket是一个持久链接。</p><p> 2.Socket是双向通信的。</p></li></ul><p><strong>Socket VS ajax轮询</strong></p><ul><li>ajax轮询 ， 是利用客户端来发送请求，每隔几秒发送一个http请求，服务器压力大。</li><li>Socket不会，一旦链接不会断开，可以实现实时通信。 比如微信的朋友圈更新提示。即时聊天通讯。</li></ul><h2 id="p2p"><a href="#p2p" class="headerlink" title="p2p"></a>p2p</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;工具&quot;&gt;&lt;a href=&quot;#工具&quot; class=&quot;headerlink&quot; title=&quot;工具&quot;&gt;&lt;/a&gt;工具&lt;/h1&gt;&lt;h2 id=&quot;NVM&quot;&gt;&lt;a href=&quot;#NVM&quot; class=&quot;headerlink&quot; title=&quot;NVM&quot;&gt;&lt;/a&gt;NVM&lt;/h2&gt;&lt;p</summary>
      
    
    
    
    <category term="Notebook" scheme="https://jieyang-wei.github.io/categories/Notebook/"/>
    
    <category term="Programming language" scheme="https://jieyang-wei.github.io/categories/Notebook/Programming-language/"/>
    
    
    <category term="编程语言" scheme="https://jieyang-wei.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="nodejs" scheme="https://jieyang-wei.github.io/tags/nodejs/"/>
    
  </entry>
  
</feed>
